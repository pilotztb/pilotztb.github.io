<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Deepfake中的transformer应用</title>
    <url>/posts/b018e611.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>Deepfake基础知识</title>
    <url>/posts/1cd3f9de.html</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<h2 id="deepfake伪造">Deepfake伪造</h2>
<h3 id="图像生成">图像生成</h3>
<h4 id="dcgan">DCGan</h4>
<p>核心原理就是在鉴别器中采用L2损失函数替代原本的对数损失函数，一定程度上提高了GAN
模型稳定性和图像伪造的效果</p>
<h4 id="progan">ProGAN</h4>
<p>同时在生成器网络和鉴别器网络中稳定地增加网络层：训练时，以低像素图像为起始数据，通过不断在模型中添加网络层对图像细节进行完善</p>
<h4 id="singan">SinGAN</h4>
<p>以在一张图像或者一张包含噪声的图作为输入的情况下，生成新图像</p>
<h3 id="图像篡改">图像篡改</h3>
<h4 id="deepfake">Deepfake</h4>
<p>采用两对编码器-解码器网络，但在训练时两个编码器共享参数，分别训练两个解码器。测试时将原脸A输入编码器，再连接B的解码器，解码即可完成将B的脸换为A
的脸</p>
<h4 id="faceswap-gan">Faceswap-gan</h4>
<p>在Faceswap 的基础上引入对抗损失函数和感知损失，并与GAN
结合达到了人脸交换的目的</p>
<h4 id="face2face">Face2Face</h4>
<p>根据图像的光度一致性原理对原视频和目标视频的表情进行追踪，然后通过目标检索的方法对面部属性进行精准匹配，
最后将数据进行扭曲后完成交换元素的无缝衔接</p>
<h2 id="deepfake-检测研究">Deepfake 检测研究</h2>
<h3 id="一个端到端的deepfake-检测系统">一个端到端的Deepfake
检测系统</h3>
<p>引入了<strong>强化</strong>学习的思想，先用其他数据集在InceptionV3
网络上进行预训练，然后用预训练过的模型对Deepfake
数据集进行训练和测试，该方法很大程度上在提高了模型检测效率和检测效果</p>
<h3
id="此外基于xception-网络注意力机制模块以及transformer-模型的深度伪造检测方法也可达到较高的准确率">此外，基于Xception
网络、注意力机制模块以及Transformer
模型的深度伪造检测方法也可达到较高的准确率</h3>
<h3
id="采用多个网络来提取图像不同角度的特征联合检测图像真伪">采用多个网络来提取图像不同角度的特征联合检测图像真伪</h3>
<h3 id="多流网络检测算法">多流网络检测算法</h3>
<p>将人脸分割成多块，分别发送到不同的Resnet18，最后连接一个全连接（Fully
Connected layer，FC）层输出检测结果</p>
<h3 id="双流检测方法">双流检测方法</h3>
<p>使用卷积神经网络学习图像边界特征并结合图像所具有的隐写噪声的特点，综合鉴别图像的真伪性</p>
<h3
id="研究一种预处理方法以提高deepfake-检测性能">研究一种预处理方法以提高Deepfake
检测性能。</h3>
<h4
id="提取图像像素域中三个颜色通道上的共生矩阵作为模型输入基于深度cnn-框架进行训练测试">提取图像像素域中三个颜色通道上的共生矩阵作为模型输入，基于深度CNN
框架进行训练测试</h4>
<h4
id="采用离散傅里叶变换获得每张图像的功率谱特征然后对其求平均得到图像的频谱图最后使用简单分类器完成伪造图像取证">采用离散傅里叶变换获得每张图像的功率谱特征，然后对其求平均得到图像的频谱图，最后使用简单分类器完成伪造图像取证</h4>
<h4
id="利用haar-小波变换对视频中提取的帧做预处理通过真伪图像的边缘差异进行deepfake-检测">利用Haar
小波变换对视频中提取的帧做预处理，通过真伪图像的边缘差异进行Deepfake
检测。</h4>
<h3 id="基于生物特征">基于生物特征</h3>
<h2 id="本实验">本实验</h2>
<p>研究基于自编码器的Deepfake 检测方法</p>
<p>提取了图像在空间域的高频信息图作为模型输入，并且在编码器网络中引入“Squeeze-and-Excitation”网络块，加强模型的特征提取能力，从而提高鉴别真伪图像的准确率。</p>
<p>采用双流网络结构分别提取图像空间域的高频特征和图像频谱图特征，并对提取的特征进行融合，使得模型在能够综合图像空间域和频域的特征做出决策，提高模型的整体检测效果。</p>
<p>通过消融实验证明提取图像高频信息、添加注意力机制和多模特征融合对于Deepfake
检测的有效性</p>
<h1 id="相关理论">相关理论</h1>
<h2 id="自动编码器">自动编码器</h2>
<p>可以通过自编码器，将大量图像数据输入编码器，提取主要特征，然后通过解码器对原图进行恢复</p>
<p>在特征信息越少的情况下，重构信息越准确，那么表示自编码器的性能越好。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122133625915.png" /></p>
<h2 id="注意力机制">注意力机制</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122133757419.png" /></p>
<h2 id="多模特征融合">多模特征融合</h2>
<p>通过融合图像的全局特征(颜色直方图)和局部特征(Bag-OfFeature
模型)的表示图像，然后，将融合后的特征作为分类器的输入数据，使得
识别率得到显著提高。</p>
<p>早期融合方法只需要对单一模型进行训练</p>
<p>晚期的融合方法是对各模块单独训练首先根据输入的模态生成与之相对应的模型，然后设计一种融合机制对不同模型得到的结果进行集成，常用的融合机制有投票选举法，平均方法，基于信道噪声和信号方差的加权方法以及设计并训练一个融合模型等。</p>
<h2 id="deepfake-算法">Deepfake 算法</h2>
<h3 id="一种是基于生成对抗网络gan">一种是基于生成对抗网络GAN</h3>
<p>由一个生成器网络（Generator，G）和一个鉴别器网络
(Discrimistor，D)组成</p>
<p>首先，生成器可将潜在空间中的噪声生成图像，然后将其和真实图像混合输入鉴别器进行分类</p>
<p>鉴别器网络本质是一个二分类模型，主要作用就是鉴别真实图像和伪造图像</p>
<p>训练时，生成器和判别器迭代优化，不断更新模型参数，直到达到纳什平衡</p>
<h3 id="一种是基于自动编码器网络">一种是基于自动编码器网络</h3>
<p>Deepfake
核心就是一个经过特殊训练的自编码器，用监督学习训练一个神经网络提取人脸的表情特征，然后通过训练后的神经网络还原成其他人的脸</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122134258140.png" /></p>
<p>“如上图，在训练时，需要两组编码器-解码器网络，两个编码器网络共享一个编码器权重，而分别对应不同的解码器，这样编码器能
同时对A 和B
两人的共有面部特征进行提取(主要为表情特征)，而解码器能对其进行重构，恢复各自脸部图片。”</p>
<p>大白话：公用一个编码器，对应不同解码器</p>
<p>在图像生成时，如果需要将图片中A 的脸替换为B 的脸，可将数据集A
作为输入，得到表情特征，然后输入到解码器B 中 进行解码，即可得到具有A
表情的B 人脸。</p>
<h1
id="基于自编码器的深度伪造图像检测">基于自编码器的深度伪造图像检测</h1>
<h2 id="主要思路">主要思路</h2>
<p>首先提取图像高频信息</p>
<p>紧接着通过自编码器网络提取图像深层特征，并且在编码器网络中引入“Squeeze-and-Excitation”网络块以提取更多有效特征；</p>
<p>最后采用三层全连接网络做分类。</p>
<h2 id="补充">补充</h2>
<h3 id="什么是图像的高频信息">什么是图像的高频信息？</h3>
<p>图像的高频信息就是图像边缘变化明显的地方，图像的低频信息就是图像的内部变化缓慢的地方</p>
<p>用高斯滤波计算出低频信息后，用原图-低频就得到高频，就向下图那个像拓印的图</p>
<p>计算低频信息的方法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123102946170.png" /></p>
<h2 id="模型框架">模型框架</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122134638328.png" /></p>
<h2 id="预处理阶段">预处理阶段</h2>
<p>高斯滤波是一种线性的平滑滤波，在计算过程中，卷积核的大小是固定的，以计算像素位置为原点，周围的点用正态分布函数分配对应权重，最后通过计算加权平均值即可得到最终值</p>
<p>所以在预处理过程中，<strong>先用高斯滤波获取输入图像低频信息图，然后将原图像与低频信息图做差以保留高频信息</strong></p>
<h2 id="自编码器网络">自编码器网络</h2>
<p>本文编码器中引用了Squeeze-and-Excitation（SE-Block），其核心思想是：网络根据损失函
数学习获得通道特征的权重值，根据其对任务的有效性分配一定的权重</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122135313488.png" /></p>
<p>在特征提取阶段，采用一个自编码器网络对高频信息图进行特征提取，同时，在编码器中添加“Squeeze-and-Excitation”模块，该模块
能够根据不同通道特征对检测任务的重要性进行合理提取，保证特征提取的有效性；</p>
<p>在图像分类阶段，本文分类器由三个全连接层组成。在检测过程中，由编码器直接对图像高频信息图编码后输入全连接层，即可输出图像的真伪</p>
<h1
id="基于多模特征融合的深度伪造图像检测">基于多模特征融合的深度伪造图像检测</h1>
<p>首先对图像进行预处理，保留图像高频信息，并且对通过傅里叶变换获取图像的频谱图；接着通过双流网络来提取预处理图像的特征并进行融合；最后将融合后的特征图作为分类器（三层全连接）的输入进行分类。</p>
<h2 id="模型框架-1">模型框架</h2>
<p>采用双流自动编码器网络结构作为主干网络。</p>
<p>通过融合图像在空间域和频域的特征进行Deepfake
检测预处理阶段，分别采用高斯滤波和傅里叶变换提取图像的高频信息图和图像的频谱图</p>
<p>在特征提取和融合阶段，首先，通过两个编码器分别提取图像在空间域和频域的特征，然后
对编码器提取的特征图进行融合，最后添加最大池化层对融合特征降采样</p>
<p>在图像分类阶段，采用三层全连接网络结构。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122140350046.png" /></p>
<h2 id="预处理">预处理</h2>
<p>与在空间域中提取的特征图相比，图像的某些特征在频域中更为突出，特别是图像的重复性和频率特征可以通过傅里叶变换来分析</p>
<p>在图像空间域一般很难检测出图像的全局纹理信息，但在图像的频域内检测相对容易，而Deepfake
图像往往在纹理上存在一定的缺陷</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122142004817.png" /></p>
<p>图像傅里叶变换过程</p>
<p>1.将原图转换为灰度图； 2.进行傅里叶变换；
3.将图像变换的源点移动到频域矩阵中心； 4.对傅里叶变换结果进行对数变换；
5.对中心化后的结果进行对数变换。</p>
<p>图像傅里叶变换后，其高频信息聚集在中间，低频信息分布在四角。</p>
<p>为了把能量集中起来以方便滤波器的使用，利用二维傅里叶变换的平移性质对频谱进行中心化。所以要对频谱中心化后的效果，就是低频在中间，高频在四周，</p>
<p>最后将中心化后的图像作为自动编码器网络的输入</p>
<h2 id="特征提取与融合">特征提取与融合</h2>
<p>采用双流网络结构进行特征提取</p>
<p>首先，预处理得到的高频图和频谱图作为模型输入；</p>
<p>其次，一个自编码器用来提取像素域高频图特征，</p>
<p>另一个自编码器用来提取频谱图特征，并且对提取的空间域和频域特征进行融合；最后，融合特征经过一层最大池化层后输入分类器。</p>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>理论基础</category>
      </categories>
  </entry>
  <entry>
    <title>GANprintR论文阅读</title>
    <url>/posts/bc3980f0.html</url>
    <content><![CDATA[<h1 id="abstract">Abstract</h1>
<p>1 提出利用自编码器移除GAN指纹</p>
<p>2 创建了一个新数据集、</p>
<h1 id="introduction">Introduction</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/db8bd2513df8ed711a4a707eae81d12.jpg"
alt="db8bd2513df8ed711a4a707eae81d12" />
<figcaption
aria-hidden="true">db8bd2513df8ed711a4a707eae81d12</figcaption>
</figure>
<p>FAR:False Acceptance Rate"，即误接受率,在二元分类问题中，"False
Acceptance"
意味着将一个负例（非目标类别）错误地分类为正例（目标类别)</p>
<p>FRR:False Rejection
Rate"，即误拒绝率,表示在应该被接受的情况下，系统错误地拒绝的比率。</p>
<p>DET Curve:在 DET Curve 上，横轴通常表示 FAR（False Acceptance
Rate），纵轴表示 FRR（False Rejection
Rate）。曲线上的每个点对应于系统在不同的阈值下的性能。</p>
<p># Related Work</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/61600cdd836ce17fc87c792a6b81551.jpg" /></p>
<h1 id="proposed-approch">Proposed Approch</h1>
<h2 id="gan指纹是什么">GAN指纹是什么</h2>
<p>GAN指纹指图像中GAN's architect，就是所有与真实图像不相关的东西</p>
<h2 id="如何消除">如何消除</h2>
<p>先在真实图像上训练一个卷积神经网络，然后将GAN图像传入，output的就是去除GAN指纹的图像</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1d3e51f96e99ba43706ba6eb072ae5a.jpg" /></p>
<h1 id="experiment-setup">Experiment Setup</h1>
<h2 id="预处理">预处理</h2>
<p>通过68个人脸数据点中的眼睛确定人脸位置并且最大程度裁剪掉背景保留人脸</p>
<h2 id="检测器的选择">检测器的选择</h2>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>FaceXray论文阅读</title>
    <url>/posts/f01673d4.html</url>
    <content><![CDATA[<h1 id="face-x-ray实验">Face X-ray实验</h1>
<h1 id="流程图及公式">1 流程图及公式</h1>
<h2 id="流程图">1 流程图</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108210731.png" /></p>
<h2 id="公式1-混合">2 公式1 混合</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108210822.png" /></p>
<h2 id="点积不是矩阵乘法">2.1 点积不是矩阵乘法</h2>
<h2 id="if是前脸">2.2 IF是前脸</h2>
<h2 id="ib是背景">2.3 IB是背景</h2>
<h2 id="m-是划定被操纵区域的面具每个像素点的值被限制在01">2.4 M
是划定被操纵区域的面具，每个像素点的值被限制在0~1</h2>
<h2 id="混合前要colortransfor">2.5 混合前要colortransfor！</h2>
<h2 id="公式2">3 公式2</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108211101.png"
alt="微信截图_20231108211101" />
<figcaption aria-hidden="true">微信截图_20231108211101</figcaption>
</figure>
<h1 id="具体实验步骤">具体实验步骤</h1>
<p>使用HRNet网络</p>
<p>将来自所有四种不同分辨率的表示拼接到相同大小的 64x64</p>
<p>经过一个输出通道为 1x1 卷积层</p>
<p>一个输出大小为 256x256 的双线性上采样层</p>
<p>一个 sigmoid 函数。</p>
<p>训练过程</p>
<p>batch_size设置为32</p>
<p>总迭代轮数设置为200,000</p>
<p>热启动</p>
<p>前50,000次迭代用ImgNet训练HRNet（可以直接找现成的权重）</p>
<p>后150,000微调，用bi数据集</p>
<p>学习率一开始设置成0.002，使用Adam优化器，在最后的 50,000
次迭代中线性衰减为 0。</p>
<p>For the fully convolutional neural network NNb in our framework, we
adopt the recent ad- vanced neural network architecture, i.e., HRNet
[42, 43], and then concatenate representations from all four different
resolutions to the same size 64 ⇥ 64, followed by a 1 ⇥ 1 convolutional
layer with one output channel, a bilinear up- sampling layer with 256 ⇥
256 output size and a sigmoid function. In the training process, the
batch size is set to 32 and the total number of iterations is set to
200, 000. To ease the training process of our framework, we warm start
the re- maining layers with fixed ImageNet pre-trained HRNet for the
first 50, 000 iterations and then finetune all layers to- gether for the
rest 150, 000 iterations. The learning rate is set as 0.0002 using Adam
[20] optimizer at first and then is linearly decayed to 0 for the last
50, 000 iterations.</p>
<h1 id="具体步骤">2 具体步骤</h1>
<h1 id="json文件读取">json文件读取</h1>
<p>首先要产生BI数据集</p>
<p>将数据集保存到json文件中，json文件是以字典形式存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pre_computed_landmarks.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    self.landmarks_record_dic = json.load(f)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.landmarks_record_dic.items():</span><br><span class="line">        landmarks_record_dic[k] = np.array(v)</span><br></pre></td></tr></table></figure>
<h1 id="图片读取与存取">图片读取与存取</h1>
<h2 id="利用skimage中io读取图片">利用skimage中io读取图片</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line">face_img = io.imread(background_face_path)</span><br></pre></td></tr></table></figure>
<p><code>skimage.io.imread</code> 返回的 NumPy 数组的默认格式是
HWC（Height, Width,
Channels），即图像的高度、宽度和通道信息，通道顺序是RGB</p>
<p>以张量形式读取图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_image</span><br></pre></td></tr></table></figure>
<h1 id="图片对象与数组对象的转换">图片对象与数组对象的转换</h1>
<h2 id="numpy">numpy</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">face_img = np.array(face_img)</span><br></pre></td></tr></table></figure>
<h2 id="pil">PIL</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment"># 将数组对象读取成图片</span></span><br><span class="line">face_img = Image.fromarray(face_img)</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<h1
id="增加图片多样性或者叫图片增广">增加图片多样性（或者叫图片增广）</h1>
<h2 id="上采样">上采样</h2>
<h3 id="最近邻插值">最近邻插值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img.resize((aug_size, aug_size), Image.NEAREST)</span><br></pre></td></tr></table></figure>
<h3 id="双线性插值">双线性插值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img.resize((aug_size, aug_size), Image.BILINEAR)</span><br></pre></td></tr></table></figure>
<h2 id="图片压缩">图片压缩</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随意生成压缩尺寸 使用 OpenCV 中的 cv2.IMWRITE_JPEG_QUALITY 常量来指定 JPEG 图像的编码质量参数，并将其与具体的质量值 quality 组成一个列表 encode_param。</span></span><br><span class="line">encode_param = [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), quality]</span><br><span class="line"><span class="comment"># 使用 OpenCV 的 cv2.imencode 函数将图像编码为指定格式（这里是 PNG 格式）。函数的参数包括要保存的图像格式、图像数据和编码参数。结果是一个包含两个元素的元组，其中第一个元素表示是否成功编码，第二个元素是包含编码后的二进制数据的 NumPy 数组。</span></span><br><span class="line">face_img_encode = cv2.imencode(<span class="string">&#x27;.png&#x27;</span>, face_img, encode_param)[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 使用 OpenCV 的 cv2.imdecode 函数，该函数接受两个参数：编码后的二进制数据（face_img_encode）和读取图像的标志（这里是 cv2.IMREAD_COLOR，表示以彩色图像的方式读取）。</span></span><br><span class="line">face_img = cv2.imdecode(face_img_encode, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="图片裁剪就是切片">图片裁剪：就是切片</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img[<span class="number">60</span>:<span class="number">317</span>, <span class="number">30</span>:<span class="number">287</span>, :]</span><br><span class="line">mask = mask[<span class="number">60</span>:<span class="number">317</span>, <span class="number">30</span>:<span class="number">287</span>, :]</span><br></pre></td></tr></table></figure>
<h2 id="图像反转">图像反转</h2>
<h3 id="水平翻转">水平翻转</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = np.flip(face_img, <span class="number">1</span>)</span><br><span class="line">mask = np.flip(mask, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="垂直翻转">垂直翻转</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = np.flip(face_img, <span class="number">0</span>)</span><br><span class="line">mask = np.flip(mask, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1
id="定义计算人脸图片的68个数据点也可以封装成一个类">定义计算人脸图片的68个数据点（也可以封装成一个类）</h1>
<p>核心</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读入图片，一般用cv2的库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> dlib</span><br><span class="line">img = cv2.imread(img_path)</span><br><span class="line"><span class="comment"># 加载模型文件</span></span><br><span class="line">predictor = dlib.shape_predictor(<span class="string">&#x27;shape_predictor_68_face_landmarks.dat&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义人脸检测器</span></span><br><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line"><span class="comment"># 检测人脸, 其中1可以理解位定义的计算开销,用faces是因为可能检测到不止一个脸</span></span><br><span class="line">faces = detector(img, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 遍历每一个检测到的人脸</span></span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> faces:</span><br><span class="line">    <span class="comment"># 获得68个人脸数据点</span></span><br><span class="line">    landmarks = predictor(img, face)</span><br></pre></td></tr></table></figure>
<p>如果想将读取的68个人脸数据点保存成如下格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;000_0000.png&quot;: [[56, 143], [57, 168], [61, 192], [67, 216], [76, 238], [93, 257], [112, 273], [133, 288], [156, 291], [178, 287], [198, 271], [219, 256], [236, 237], [246, 216], [250, 192], [252, 167], [252, 142], [69, 131], [84, 123], [102, 123], [119, 126], [137, 132], [178, 130], [195, 122], [213, 119], [230, 119], [244, 126], [158, 149], [158, 168], [158, 186], [159, 205], [140, 211], [148, 214], [158, 219], [168, 214], [176, 210], [91, 150], [102, 143], [116, 144], [127, 154], [115, 156], [101, 156], [188, 152], [199, 142], [213, 141], [224, 148], [214, 153], [201, 154], [117, 232], [134, 229], [148, 228], [158, 231], [168, 228], [181, 229], [195, 232], [182, 246], [169, 253], [158, 254], [147, 254], [132, 247], [125, 234], [147, 238], [158, 239], [168, 237], [188, 234], [168, 237], [158, 239], [147, 238]], &quot;001_0000.png&quot;: [[56, 143], [57, 168], [61, 192], [67, 216], [76, 238], [93, 257], [112, 273], [133, 288], [156, 291], [178, 287], [198, 271], [219, 256], [236, 237], [246, 216], [250, 192], [252, 167], [252, 142], [69, 131], [84, 123], [102, 123], [119, 126], [137, 132], [178, 130], [195, 122], [213, 119], [230, 119], [244, 126], [158, 149], [158, 168], [158, 186], [159, 205], [140, 211], [148, 214], [158, 219], [168, 214], [176, 210], [91, 150], [102, 143], [116, 144], [127, 154], [115, 156], [101, 156], [188, 152], [199, 142], [213, 141], [224, 148], [214, 153], [201, 154], [117, 232], [134, 229], [148, 228], [158, 231], [168, 228], [181, 229], [195, 232], [182, 246], [169, 253], [158, 254], [147, 254], [132, 247], [125, 234], [147, 238], [158, 239], [168, 237], [188, 234], [168, 237], [158, 239], [147, 238]]&#125;</span><br><span class="line">结构</span><br><span class="line">(字典)&#123;&quot;图片路径&quot;:[[x, y](每个点坐标),[]](68个数据点), &quot;&quot;:[[],[],……], …… &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">landmarks_dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, face <span class="keyword">in</span> <span class="built_in">enumerate</span>(faces):</span><br><span class="line">    landmarks = predictor(img, face)</span><br><span class="line">    <span class="comment"># 提前声明二维列表</span></span><br><span class="line">    landmarks_list = [[i.x, i.y] <span class="keyword">for</span> i <span class="keyword">in</span> landmarks.parts()]</span><br><span class="line">    landmark_dic[<span class="string">&quot;pic_path&quot;</span>] = landmarks_list</span><br></pre></td></tr></table></figure>
<h1 id="定义生成bi数据集的类">定义生成BI数据集的类</h1>
<h2 id="初始化">初始化</h2>
<h3 id="读取json文件到内存字典中">读取json文件到内存字典中</h3>
<p>json文件中key是图片路径，value是68个数据点</p>
<p>如何计算：</p>
<h3 id="定义只包含图片路径的列表">定义只包含图片路径的列表</h3>
<h3 id="定义生成遮罩时的仿射变换">定义生成遮罩时的仿射变换</h3>
<h2
id="生成一个数据点包括backgroundfaceforegroundface类型fake-or-real-mask">生成一个“数据点”，包括backgroundface，foregroundface，类型（fake
or real）， mask</h2>
<h3
id="从图片路径列表中随机选择一个图片的路径">从图片路径列表中随机选择一个图片的路径</h3>
<h3 id="按50随机生成图片类型fake-or-real">按50%随机生成图片类型（fake or
real）</h3>
<h3
id="如果是fake生成混合后的图片并利用公式2将得到的mask转换成facexray">如果是fake，生成混合后的图片并利用公式2将得到的mask转换成FaceXray</h3>
<h4
id="根据给定的backgroundface路径读取图片对象和对应的68个数据点">根据给定的backgroundface路径读取图片对象和对应的68个数据点</h4>
<h4
id="在数据集中搜索相似的脸作为前脸">在数据集中搜索相似的脸作为前脸</h4>
<p>先随机选取1000个图片路径，并且剔除和backgroundface来自同一个视频（数据集里保存在同一个文件夹下的）</p>
<p>通过计算两张图片的68个数据点的欧氏距离来判断相似度，找到欧式距离最小的那个作为frontface</p>
<h4
id="根据backgroundface和其landmark生成4种mask">根据backgroundface和其landmark生成4种mask</h4>
<p>将mask进行仿射变换，随机腐蚀和膨胀来增强mask的多样性<a
href="https://blog.csdn.net/alw_123/article/details/83868878">可以参考这篇文章</a></p>
<h4
id="混合前对foregroundface进行颜色变换以适应backgroundface">混合前对foregroundface进行颜色变换以适应backgroundface</h4>
<h4
id="将maskforegroundface和backgroundface混合">将mask，foregroundface和backgroundface混合</h4>
<h3
id="如果是real直接读取图片并且生成mask的灰度图">如果是real，直接读取图片，并且生成mask的灰度图</h3>
<p>注：所有图片的大小都是317 * 717</p>
<p>最终生成bi数据集的结构</p>
<p>影响：MyGetBIDataset 271行save_bi_dataset</p>
<p>bi_dataset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| —— true</span><br><span class="line">|   | —— face</span><br><span class="line">|   |   | —— 1.png</span><br><span class="line">|   |   | —— 2.png</span><br><span class="line">|	| —— mask</span><br><span class="line">|   |   | —— 1.png</span><br><span class="line">|   |   | —— 2.png</span><br><span class="line">|   | —— fake</span><br></pre></td></tr></table></figure>
<p>获得当时数据集最后格式的方法：切片+解包</p>
<p>比如对于your/file/000/background_face.jpg，要获取000/background_face.jpg，用如下写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">background_face_path = <span class="string">&quot;your/file/000/background_face.jpg&quot;</span></span><br><span class="line"><span class="comment"># 拆分路径为目录和文件名</span></span><br><span class="line">final_two = os.path.join(*<span class="built_in">list</span>(background_face_path.split(<span class="string">&#x27;/&#x27;</span>))[-<span class="number">2</span>::])</span><br><span class="line"><span class="built_in">print</span>(final_two)</span><br></pre></td></tr></table></figure>
<p>命名的时候用是第几张图片命名</p>
<p>如何优雅地用一行代码计算一个文件夹里所有文件的数量</p>
<p>利用列表推导式和匿名函数实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count_files = <span class="keyword">lambda</span> folder_path : <span class="built_in">len</span>([f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(foler_path) <span class="keyword">if</span> os.path.isfile(os.path.join(folder_path, f))])</span><br></pre></td></tr></table></figure>
<p>computer_landmarksbug修复</p>
<p>用try-except</p>
<p>直接往文件里面写</p>
<p>处理错误</p>
<p>定义保存错误信息的文件位置</p>
<p>配置错误函数</p>
<p>将错误写入错误函数指向的文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.basicConfig(filename=<span class="string">&quot;ErrorLogs&quot;</span>, level=logging.ERROR)</span><br><span class="line">    <span class="comment"># logging.basicConfig: 这是一个配置基础日志系统的函数，用于配置日志记录的基本设置。在这里，它指定了将日志写入文件，而不是默认的控制台输出 </span></span><br><span class="line">    <span class="comment"># filename=GETBIERRORLOG: 这部分指定了日志文件的路径和名称。 GETBIERRORLOG 是一个变量，它应该在这一行代码之前定义，并包含了日志文件的完整路径。</span></span><br><span class="line">    <span class="comment"># level=logging.ERROR: 这设置了日志记录的级别。在这里，设置为ERROR，表示只记录错误级别的日志消息，包括错误和更严重的消息。这有助于筛选并专注于捕捉代码中的潜在问题。</span></span><br><span class="line">    logging.error(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 将错误信息写入上面配置的错误函数指向的文件</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1
id="定义数据集dataset封装成一个类">定义数据集dataset（封装成一个类）</h1>
<p>需要写入h5文件</p>
<p>h5文件里面要包含些什么？</p>
<h1 id="hrnet网络的使用">HRNet网络的使用</h1>
<p>HRNet网络介绍</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240128070003428.png" /></p>
<p>从官方下载HRNet的网络</p>
<p>其中加载预训练模型的位置</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240128063426079.png" /></p>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">common params for NETWORK</span><br></pre></td></tr></table></figure>
<p>default作用说明里有这句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义模型配置,_C.MODEL:</span><br></pre></td></tr></table></figure>
<p>在default搜索_C.MODEL,发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.PRETRAINED = &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>修改为之前下载的预训练函数位置</p>
<p>default.py中输出种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.NUM_CLASSES = 2</span><br></pre></td></tr></table></figure>
<p>default.py中修改传入的图片大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.IMAGE_SIZE</span><br></pre></td></tr></table></figure>
<p>修改传入的图片种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.DATA_FORMAT = &#x27;png&#x27;</span><br></pre></td></tr></table></figure>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATASET related params</span><br></pre></td></tr></table></figure>
<p>传入的图片种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.DATA_FORMAT = &#x27;png&#x27;</span><br></pre></td></tr></table></figure>
<p>数据集根路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.ROOT = &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># train</span><br></pre></td></tr></table></figure>
<p>迭代轮数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.END_EPOCH = 150000</span><br></pre></td></tr></table></figure></p>
<p>batch_size设置为32</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.LR = 0.002</span><br></pre></td></tr></table></figure>
<p>总迭代轮数设置为200,000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.END_EPOCH = 200000</span><br></pre></td></tr></table></figure>
<p>学习率一开始设置成0.002</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.LR = 0.002</span><br></pre></td></tr></table></figure>
<p>使用Adam优化器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.OPTIMIZER = &#x27;adam&#x27;</span><br></pre></td></tr></table></figure>
<p>在最后的 50,000 次迭代中线性衰减为 0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>在tools/train.py中找到data_loader</p>
<p>lib/core/function.py中定义了训练函数</p>
<p>我还是有点懵，这到底怎么传文件啊</p>
<p>我现在就是按它哪个要求修改了分类的参数，但还是迷糊</p>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>论文笔记：Beyond the Prior Forgery Knowledge Mining</title>
    <url>/posts/fdcdf70e.html</url>
    <content><![CDATA[<h1 id="abstract">Abstract</h1>
<h2 id="以前方法存在的问题">以前方法存在的问题：</h2>
<p>都只是为了捕获特定的伪造线索，比如噪声(noise patterns),
混合边界(blending boundaries)和频率(frequency
artifacts),导致容易陷入局部最优，从而降低鲁棒性和泛化能力</p>
<h2 id="创新点">创新点</h2>
<p>提出CFM框架，原文which can be flexibly assembled with various
backbones to boost their generalization and robustness
performance，那么是一种模块吗？</p>
<h3
id="cfm框架组成先把原文放在这看后面怎么说">CFM框架组成(先把原文放在这，看后面怎么说)</h3>
<h4
id="首先构建了一个细粒度的三元组并通过先验知识不可知的数据增强来抑制特定的伪造痕迹">首先构建了一个细粒度的三元组，并通过先验知识不可知的数据增强来抑制特定的伪造痕迹</h4>
<p>Specifically, we first build a fine-grained triplet and suppress
specific forgery traces through prior knowledge-agnostic data
augmentation</p>
<h4
id="随后我们提出了一个细粒度的关系学习原型通过实例和局部相似感知损失来挖掘伪造中的关键信息">随后，我们提出了一个细粒度的关系学习原型，通过实例和局部相似感知损失来挖掘伪造中的关键信息</h4>
<p>Subsequently, we propose a fine-grained relation learning prototype
to mine critical information in forgeries through instance and local
similarity-aware losses</p>
<h4
id="此外我们设计了一种新颖的渐进式学习控制器来引导模型专注于主要特征组件使其能够以从粗到精的方式学习关键伪造特征">此外，我们设计了一种新颖的渐进式学习控制器来引导模型专注于主要特征组件，使其能够以从粗到精的方式学习关键伪造特征</h4>
<p>Moreover, we design a novel progressive learning controller to guide
the model to focus on principal feature components, enabling it to learn
critical forgery features in a coarse-to-fine manner</p>
<h1 id="introduction">INTRODUCTION</h1>
<h2 id="研究背景">研究背景：</h2>
<p>以常见的4种伪造手段Deepfakes , Face2Face ,FaceSwap and
NeuralTextures为代表的深度伪造技术不断发展，并且越来越多现成的伪造软件被开发被人利用，导致了严重的金融欺诈，假新闻和身份假冒。</p>
<h2 id="早期检测">早期检测</h2>
<p>生物信息，比如眨眼，头部位置不一致和面部扭曲伪影，效果差</p>
<p>基于深度学习的检测，泛化性差</p>
<p>基于深度学习与捕获先验已知的特征，对图像失真的鲁棒性差</p>
<h2 id="目标">目标</h2>
<p>抗过拟合的同时挖掘出尽可能多的伪造线索</p>
<h2 id="实现">实现</h2>
<h3 id="数据集准备">数据集准备</h3>
<p>利用先验知识不可知的数据增强来防止模型陷入局部最优，并驱动模型学习更广义的伪造知识;</p>
<h3 id="学习框架">学习框架</h3>
<p>引入细粒度三元关系学习方案，使模型能够学习更多的固有特征表示</p>
<h3 id="正则化方案">正则化方案</h3>
<p>用PLC正则化</p>
<h3 id="目标函数">目标函数</h3>
<p>实例相似度感知损失和局部相似度感知损失来同时学习全局关键特征和局部细微伪影</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240214092733347.png"
alt="基于EfficientNet-B4的不同线索提取器的注意图" />
<figcaption
aria-hidden="true">基于EfficientNet-B4的不同线索提取器的注意图</figcaption>
</figure>
<p>上图每个部分图像第一列是不同形式伪造的图片</p>
<p>提取特征的主干网络都是EfficientNet-B4(可以换成线性transformer试试)</p>
<p>第二列是用普通卷积层提取出的基本伪造特征</p>
<p>第三列是用低频提取出的噪声线索</p>
<p>第四列是用本文提出的CFM框架提取出的关键伪造线索</p>
<p>a部分的图像并没有经过任何变换，b部分的图像经过了下采样，c部分的图像加入了高斯噪声，对比可以看出根据基础线索（估计即使边界）和根据频率线索的检测都受到了干扰</p>
<h1 id="related-work">RELATED WORK</h1>
<h2 id="a.-prior-knowledge-based-face-forgery-detection">A. Prior
Knowledge-Based Face Forgery Detection</h2>
<p>缺点：抗扰动性差</p>
<h2 id="b.-face-forgery-detection-via-representation-learning">B. Face
Forgery Detection via Representation Learning</h2>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>网页开发基础知识</title>
    <url>/posts/d417c152.html</url>
    <content><![CDATA[<h1 id="html常用的标签">html常用的标签</h1>
<h1 id="注释标签文字标签和段落标签">注释标签、文字标签和段落标签</h1>
<h2 id="注释标签">注释标签</h2>
<p>原文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Welcome to my website!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>加上注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Welcome to my website!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt; --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="文字标签">文字标签</h2>
<h3 id="格式-fontfont">格式 &lt;font&gt;……&lt;/font&gt;</h3>
<h3 id="常用属性">常用属性</h3>
<h4 id="color">color</h4>
<p>1.使用英文单词表示 red black blue green</p>
<p>2.rgb(十六进制,0~9 a~f) 每两位代表一种颜色 red green blue
常用的十六进制颜色: 语法格式:#后面跟上随机6个位数</p>
<p>#ffffff 白色 #000000 黑色 #abcdef 天蓝色 #ff0000 红色</p>
<h4 id="size">size</h4>
<p>size:取值范围1~7之间
如果超出了最大值使用默认最大值7size:取值范围1~7之间
如果超出了最大值使用默认最大值7</p>
<p>举个例子</p>
<p>&lt;font color="red"
size="4"&gt;宣示—习近平发出新时代改革开放强音&lt;/font&gt;</p>
<p>效果如下</p>
<p><font color="red"  size="4">宣示—习近平发出新时代改革开放强音</font></p>
<h2 id="段落标签">段落标签</h2>
<h3 id="格式-pp">格式 &lt;p&gt;……&lt;/p&gt;</h3>
<p>作用:设置文本的样式(外观)
语法格式:style='属性名:属性值;属性名2:属性值2..'</p>
<p>font-size:修改文字的大小 fonts-size:20px 单位像素
background-color:设置文本的背景颜色</p>
<p>width:设置宽度的属性<br />
1.使用像素 800px 2.使用百分比: 80% height:设置高度的属性</p>
<p>举个例子</p>
<p>&lt;p style="color:white;background:
red;width:80%;height:200px;"&gt;新浪科技讯
北京时间12月21日早间消息，本周四，苹果宣布约翰·詹南德雷亚（John
Giannandrea）进入公司执行团队。不久之前，苹果刚刚任命詹南德雷亚担任AI、机器学习战略高级副总裁。晋升之后，詹南德雷亚直接向苹果CEO库克汇报工作。&lt;/p&gt;</p>
<p>效果如下</p>
<p style="color:white;background: red;width:80%;height:200px;">
新浪科技讯
北京时间12月21日早间消息，本周四，苹果宣布约翰·詹南德雷亚（John
Giannandrea）进入公司执行团队。不久之前，苹果刚刚任命詹南德雷亚担任AI、机器学习战略高级副总裁。晋升之后，詹南德雷亚直接向苹果CEO库克汇报工作。
</p>
<h2 id="和字体相关的其他标签">和字体相关的其他标签</h2>
<h3 id="加粗">加粗</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加粗--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗2<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--加粗-->
<p>
段落
</p>
<p><b>加粗</b> <strong>加粗2</strong></p>
<h3 id="下划线">下划线</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下划线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--下划线-->
<p><u>下划线</u></p>
<h3 id="删除线">删除线</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">s</span>&gt;</span></span><br><span class="line">市场价:<span class="tag">&lt;<span class="name">s</span>&gt;</span>999<span class="tag">&lt;/<span class="name">s</span>&gt;</span>现价:99</span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--删除线-->
<p><s>删除线</s> 市场价:<s>999</s>现价:99</p>
<h3 id="换行">换行</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">这一举动表明苹果高度重要AI。库克在声明中说：“在苹果，约翰做得很好，<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">很高兴能看到他加入我们的执行团队。机器学习与AI对于苹果的未来至关重</span><br></pre></td></tr></table></figure>
<!--换行-->
<p>一举动表明苹果高度重要AI。库克在声明中说：“在苹果，约翰做得很好，<br/>很高兴能看到他加入我们的执行团队。机器学习与AI对于苹果的未来至关重</p>
<h3 id="上标和下标">上标和下标</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>上标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">正常显示的文字</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>下标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<p>
<sup>上标</sup> 正常显示的文字 <sub>下标</sub>
</p>
<h3 id="斜体">斜体</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--斜体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体2<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--斜体-->
<p><i>斜体</i> <em>斜体2</em></p>
<h3 id="缩进">缩进</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--缩进--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>詹南德雷亚在谷歌工作8年，4月份加入苹果。在谷歌工作时，他曾经是搜索、机器智能与研发主管。跳到苹果之后，詹南德雷亚对Siri、Core Ml负责。</span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果 <!--缩进--></p>
<blockquote>
詹南德雷亚在谷歌工作8年，4月份加入苹果。在谷歌工作时，他曾经是搜索、机器智能与研发主管。跳到苹果之后，詹南德雷亚对Siri、Core
Ml负责。
</blockquote>
<h1 id="标题标签和字符实体">标题标签和字符实体</h1>
<h2
id="标题标签hnhn-注意n的取值范围为16的整数">标题标签：&lt;hn&gt;&lt;/hn&gt;
注意：n的取值范围为1~6的整数</h2>
<p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<h1>
标题1
</h1>
<h2>
标题2
</h2>
<h3>
标题3
</h3>
<h4>
标题4
</h4>
<h5>
标题5
</h5>
<h6>
标题6
</h6>
<h2 id="字符实体">字符实体</h2>
<h3 id="特殊字符">特殊字符</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&amp;lt ---&gt; &lt;</span><br><span class="line">&amp;gt ---&gt; &gt;</span><br></pre></td></tr></table></figure>
<h3 id="版权">版权</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--版权--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span>北京清华出版社<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--版权-->
<p>
©北京清华出版社
</p>
<h3 id="空格">空格</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--空格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>一名在美中国公民被控窃取商业机密,美方称涉案达18亿<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--空格-->
<p>
    一名在美中国公民被控窃取商业机密,美方称涉案达18亿
</p>
<h3 id="双引号">双引号</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--双引号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;quot;</span>华为回应部分国际银行断交:公司经营稳健,业务运转正常<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--双引号-->
<p>
"华为回应部分国际银行断交:公司经营稳健,业务运转正常"
</p>
<h3 id="和号">和号</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--和号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>11人跨省全链条制贩毒网络团伙<span class="symbol">&amp;amp;</span>被摧毁,头目是前知名歌手<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--和号-->
<p>
11人跨省全链条制贩毒网络团伙&amp;被摧毁,头目是前知名歌手
</p>
<h1 id="图像标签和路径">图像标签和路径</h1>
<h2 id="图像标签">图像标签</h2>
<h3 id="格式img">格式&lt;img……/&gt;</h3>
<h3 id="作用显示网页上面的图片">作用：显示网页上面的图片</h3>
<h3 id="常用属性-1">常用属性</h3>
<p>1.src:图片的路径 2.width:设置图片的宽度 3.height:设置图片的高度
4.alt:图片的替换文本,如果图片资源加载不出来,显示文本
5.title:鼠标悬浮标题</p>
<p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接设置网页上显示图片,使用图片默认宽高--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic.jpg&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用width和height--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic4.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--图片替换文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic33.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;圣诞节快乐&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--鼠标悬浮标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic2.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;美女与野兽&quot;</span> <span class="attr">width</span>=<span class="string">&#x27;200px&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;200px&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>python基本数据结构，条件语句，循环语句</title>
    <url>/posts/2865530f.html</url>
    <content><![CDATA[<h1
id="exercise1print取消换行和格式化字符串">exercise1：print取消换行和格式化字符串</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   编写代码完成一个名片显示,要求使用取消换行和格式化操作符</span><br><span class="line">   </span><br><span class="line">   ================</span><br><span class="line">   姓名：张三</span><br><span class="line">   QQ:1234567</span><br><span class="line">   手机号：1234567</span><br><span class="line">   公司地址：北京市</span><br><span class="line">   =================</span><br></pre></td></tr></table></figure>
<h2 id="answer">Answer</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;================&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">qq = <span class="string">&quot;1234567&quot;</span></span><br><span class="line">phone = <span class="string">&quot;1234567&quot;</span></span><br><span class="line">address = <span class="string">&quot;北京市&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;QQ:<span class="subst">&#123;qq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;手机号:<span class="subst">&#123;phone&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;公司地址：<span class="subst">&#123;address&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;================&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="输出效果">输出效果</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114160151131.png"
alt="image-20240114160151131" />
<figcaption aria-hidden="true">image-20240114160151131</figcaption>
</figure>
<h1 id="基本数据结构">基本数据结构</h1>
<h2 id="list">list</h2>
<h3 id="定义">定义</h3>
<h4 id="相当于其他语言的数组">相当于其他语言的数组</h4>
<h4 id="可以存储不同类型的多个值">可以存储<span
style="color:red">不同类型</span>的多个值</h4>
<h3 id="append">append</h3>
<h2 id="字典">字典</h2>
<h2 id="元祖">元祖</h2>
<h2 id="集合">集合</h2>
<h3 id="创建方式">创建方式</h3>
<h4 id="set函数">set()函数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res = set([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h4 id="创建">{}创建</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">res2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="逻辑运算符and-or-not">逻辑运算符：and, or, not</h1>
<h1 id="exercise2键盘输入与if语句1">exercise2：键盘输入与if语句1</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   要求，从键盘获取自己的年龄，判断是否大于等于18，如果条件成立输出成年了,反之,未成年</span><br></pre></td></tr></table></figure>
<h2 id="answer-1">Answer</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(age) &gt;= <span class="number">18</span>:	<span class="comment">#注意需要强转</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成年了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114162357070.png"
alt="image-20240114162357070" />
<figcaption aria-hidden="true">image-20240114162357070</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114162414785.png"
alt="image-20240114162414785" />
<figcaption aria-hidden="true">image-20240114162414785</figcaption>
</figure>
<h1 id="exercise3键盘输入与if语句2">exercise3：键盘输入与if语句2</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">#if...elif案例</span><br><span class="line">#根据考试的成绩，判断学生的等级</span><br><span class="line">#案例:通过键盘录入的方式获取学生的成绩</span><br></pre></td></tr></table></figure>
<h2 id="answer-2">Answer</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">score = <span class="built_in">input</span>(<span class="string">&quot;请输入学生成绩&quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(score)</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">90</span> <span class="keyword">and</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">80</span> <span class="keyword">and</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">70</span> <span class="keyword">and</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="输出-1">输出</h2>
<figure>
<img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\image-20240114162831600.png"
alt="image-20240114162831600" />
<figcaption aria-hidden="true">image-20240114162831600</figcaption>
</figure>
<h1 id="循环语句">循环语句</h1>
<h2 id="while...else">while...else</h2>
<h3 id="逻辑">逻辑：</h3>
<p>在条件语句（判断表达式）为false，执行else中的语句2</p>
<h2 id="for...else">for...else</h2>
<h2 id="enumerate枚举函数">enumerate()枚举函数</h2>
<h3 id="定义-1">定义</h3>
<h4
id="将一个可遍历的数据对象字符串列表元祖组合为一个索引序列可以同时获取下标和元素值">将一个可遍历的数据对象(字符串,列表,元祖)组合为一个索引序列,可以同时获取下标和元素值</h4>
<h4
id="enumarate序列起始下标-不指定起始下标默认从0开始指定下标使用最新的后面的自动增长">enumarate(序列,起始下标)
不指定起始下标,默认从0开始,指定下标使用最新的,后面的自动增长</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x, y in <span class="title function_">enumerate</span><span class="params">(name, <span class="number">5</span>)</span>:	#x表示对应下标，y表示对应下标的值</span><br><span class="line">    print(x, y)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 h</span><br><span class="line">6 e</span><br><span class="line">7 l</span><br><span class="line">8 l</span><br><span class="line">9 o</span><br><span class="line">10  </span><br><span class="line">11 w</span><br><span class="line">12 o</span><br><span class="line">13 r</span><br><span class="line">14 l</span><br><span class="line">15 d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>python数据类型常见操作</title>
    <url>/posts/1f6e1eb2.html</url>
    <content><![CDATA[<h1 id="三种与类型有关的运算id-type-isinstance">三种与类型有关的运算id,
type, isinstance</h1>
<h2 id="id变量名-获取变量内存地址">id(变量名) 获取变量内存地址</h2>
<h2 id="type变量名获取变量类型">type(变量名)获取变量类型</h2>
<h2
id="isinstance变量名预测的数据类型获取变量类型">isinstance(变量名,预测的数据类型)获取变量类型</h2>
<p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(isintance(string, <span class="built_in">str</span>))</span><br><span class="line">lis = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lis, <span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115202423457.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115202434956.png" /></p>
<p>type(变量名)获取变量的数据类型,它不会认为子类和父类是相同的数据类型
isinstance(变量名,预测的数据类型)预测变量是什么类型,它会认为子类和父类是相同</p>
<span id="more"></span>
<h1 id="number常用的模块">Number常用的模块</h1>
<h2 id="mathimport-math">math（import math)</h2>
<h3 id="求绝对值">求绝对值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(math.fabs(-<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="向上取整-math.ceil3.1">向上取整 math.ceil(3.1)</h3>
<h3 id="向下取整-math.floor3.9">向下取整 math.floor(3.9)</h3>
<h3 id="求平方-math.pow2-3">求平方 math.pow(2, 3)</h3>
<h3
id="同时求整数部分和小数部分-math.modf12.999">同时求整数部分和小数部分
math.modf(12.999)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(math.modf(<span class="number">12.9999</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115203322220.png" /></p>
<h3 id="求正弦-math.sin3">求正弦 math.sin(3)</h3>
<h2 id="randomimport-random">random(import random)</h2>
<h3 id="生成0-1-之间随机数-random.random">生成0 ~1 之间随机数
random.random()</h3>
<h3
id="生成指定范围的随机数左闭右开-random.randrange1-100">生成指定范围的随机数(左闭右开)
random.randrange(1, 100)</h3>
<h3
id="生成指定范围的一个整数左闭右闭-random.randint0-10">生成指定范围的一个整数(左闭右闭)
random.randint(0, 10)</h3>
<h3 id="返回随机一个元素-random.choice">返回随机一个元素
random.choice()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小芳&quot;</span>]</span><br><span class="line">name = random.choice(lis)</span><br></pre></td></tr></table></figure>
<h3 id="随机打乱序列里面元素">随机打乱序列里面元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="string">&#x27;一个水杯&#x27;</span>,<span class="string">&#x27;一台电脑&#x27;</span>,<span class="string">&#x27;一支笔&#x27;</span>,<span class="string">&#x27;一副眼镜&#x27;</span>,<span class="string">&#x27;一件风衣&#x27;</span>]</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>
<h3 id="随机获取部分元素">随机获取部分元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">res = random.sample(<span class="built_in">str</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(r,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2
id="切片语法格式开始值结束值步长">切片(语法格式:[开始值:结束值:步长])</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从最后一个开始从后两个两个往前</span></span><br><span class="line">name = <span class="string">&#x27;lishi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115211210214.png" /></p>
<h2 id="查">查</h2>
<h3
id="find检测子字符串是否包含在母字符串中如果是返回开始元素的索引值否则返回-1">find：检测子字符串是否包含在母字符串中，如果是返回开始元素的索引值，否则返回-1</h3>
<h3
id="index跟find方法一样只不过如果str不在mystr中直接报错">index：跟find方法一样，只不过如果str不在myStr中，直接报错</h3>
<h3
id="count返回子字符串在start和end的母字符串中出现的次数">count：返回子字符串在start和end的母字符串中出现的次数</h3>
<h3
id="isalpha判断一个字符串是不是全是字母">isalpha：判断一个字符串是不是全是字母</h3>
<h3
id="isdigit判断一个字符串是不是全是数字">isdigit：判断一个字符串是不是全是数字</h3>
<h2 id="改">改</h2>
<h3
id="replace把母字符串中str1旧元素替换为str2新元素如果指定了count则替换不超过count次">replace：把母字符串中str1(旧元素)替换为str2(新元素)，如果指定了count，则替换不超过count次</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212050487.png" /></p>
<p>但是string并没有修改</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212158499.png" /></p>
<h3
id="split-分割以str为分隔符切片母字符串-返回的是列表分割后的每一个元素作为列表中的元素string">split：
分割，以str为分隔符切片母字符串,
返回的是列表（分割后的每一个元素作为列表中的元素（String）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;hello, world, python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string.split(<span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212508540.png" /></p>
<h3
id="join用指定字符将列表中元素连接成一个字符串其中指定字符串加在列表中元素后面">join：用指定字符将列表中元素连接成一个字符串，其中指定字符串加在列表中元素后面</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115220547267.png" /></p>
<h3 id="获得字母的ascii码">获得字母的ASCII码</h3>
<h4
id="ord用来返回一个字母的ascii码">ord()用来返回一个字母的ASCII码</h4>
<h4 id="chr相当于逆运算">chr()相当于逆运算</h4>
<h3 id="空格">空格</h3>
<h5 id="lstrip删除字符串左空格">.lstrip()删除字符串左空格</h5>
<h5 id="rstrip删除字符串右空格">.rstrip()删除字符串右空格</h5>
<h5 id="strip删除两端空格">.strip()删除两端空格</h5>
<h4 id="对齐">对齐</h4>
<h5
id="ljustwidth左对齐并用空格填充到长度为width">.ljust(width)：左对齐并用空格填充到长度为width</h5>
<h5
id="rjustwidth右对齐并用空格填充到长度为width">.rjust(width)：右对齐并用空格填充到长度为width</h5>
<h5
id="centerwidth居中并用空格填充到长度为width">.center(width)：居中并用空格填充到长度为width</h5>
<h1 id="列表">列表</h1>
<h2 id="增">增</h2>
<h3 id="append在末尾插入">append(在末尾插入)</h3>
<h3
id="insert在指定位置插入这个指定位置是插入后这个元素在新列表中的位置">insert(在指定位置插入，这个指定位置是插入后这个元素在新列表中的位置)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240120134509890.png" /></p>
<h2 id="删">删</h2>
<h3 id="del根据下标删除">del(根据下标删除)</h3>
<h3 id="pop删除最后一个元素">pop(删除最后一个元素)</h3>
<h3 id="remove根据元素的值删除">remove根据元素的值删除</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">international = [<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;韩国&#x27;</span>,<span class="string">&#x27;日本&#x27;</span>,<span class="string">&#x27;美国&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> international[<span class="number">2</span>]</span><br><span class="line">international.pop()</span><br><span class="line">international.remove(<span class="string">&#x27;韩国&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(international)</span><br></pre></td></tr></table></figure>
<h2 id="查-1">查</h2>
<h3 id="in判断一个元素在不在列表中">in(判断一个元素在不在列表中)</h3>
<h3
id="count计算一个元素在列表中个数">count(计算一个元素在列表中个数)</h3>
<h3 id="index得到列表中一个元素下标">index(得到列表中一个元素下标)</h3>
<h2 id="改直接通过下标修改">改：直接通过下标修改</h2>
<h2
id="求一个列表中最大值和最小值maxlist和minlist">求一个列表中最大值和最小值：max(list)和min(list)</h2>
<h2 id="exercise1">exercise1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   一个学校，有3个办公室，现在有8个老师[&#x27;张学友&#x27;,&#x27;刘德华&#x27;,&#x27;黎明&#x27;,&#x27;郭富城&#x27;,&#x27;王菲&#x27;,&#x27;张柏芝&#x27;,&#x27;张韶涵&#x27;,&#x27;杨颖&#x27;]等待分配工位，请编写程序，完成随机分配</span><br><span class="line">要求：</span><br><span class="line">   办公室的编号，人数  具体是谁</span><br></pre></td></tr></table></figure>
<p>Answer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">name = [<span class="string">&#x27;张学友&#x27;</span>,<span class="string">&#x27;刘德华&#x27;</span>,<span class="string">&#x27;黎明&#x27;</span>,<span class="string">&#x27;郭富城&#x27;</span>,<span class="string">&#x27;王菲&#x27;</span>,<span class="string">&#x27;张柏芝&#x27;</span>,<span class="string">&#x27;张韶涵&#x27;</span>,<span class="string">&#x27;杨颖&#x27;</span>]</span><br><span class="line">room = [[], [], []]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    indexPeople = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(name) - <span class="number">1</span>)</span><br><span class="line">    indexRoom = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    room[indexRoom].append(name[indexPeople])</span><br><span class="line">    <span class="keyword">del</span> name[indexPeople]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;办公室编号: <span class="subst">&#123;i&#125;</span>\t 人员组成: &quot;</span>, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(room[i])):</span><br><span class="line">        <span class="built_in">print</span>(room[i][j], end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115222037480.png" /></p>
<h1 id="元组">元组</h1>
<h1 id="字典">字典</h1>
<h2 id="创建">创建</h2>
<h3 id="直接用创建空字典">直接用{}创建空字典</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找">查找</h2>
<h3
id="通过键查询值直接将键作为下标">通过键查询值：直接将键作为“下标”</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115222904851.png" /></p>
<h3 id="get函数">get函数</h3>
<p>不确定字典中是否存在某一个键而又想获取它的值，可以使用get(),设置默认值，如果不存在就返回默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_info = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三丰&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">30</span>,<span class="string">&#x27;no&#x27;</span>:<span class="number">110</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_info.get(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;不存在&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115223257313.png" /></p>
<h2 id="修改">修改</h2>
<h3
id="修改元素的值直接通过查找到的键来修改">修改元素的值：直接通过查找到的键来修改</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典变量名[对应键名] = 新的值</span></span><br><span class="line">stu_info = &#123;<span class="string">&#x27;no&#x27;</span>:<span class="number">110</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line">stu_info[<span class="string">&#x27;age&#x27;</span>] = <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3
id="添加元素变量名键-数据如果对应的键不存在会自动创建">添加元素：变量名["键"]
= 数据(如果对应的键不存在会自动创建)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_info[<span class="string">&#x27;mobile&#x27;</span>] = <span class="number">13248301214</span></span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<h3
id="删除指定键的元素或整个字典del">删除指定键的元素或整个字典：del</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> dic	<span class="comment"># 整个字典从内存中释放</span></span><br></pre></td></tr></table></figure>
<h3 id="清空整个字典">清空整个字典</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic.clear()	<span class="comment"># 字典内容被清空，字典依然存在</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历">遍历</h2>
<h3 id="获取字典中键值对的数量len">获取字典中键值对的数量：len</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(dic) </span><br></pre></td></tr></table></figure>
<h3
id="keys获取字典中由键组成的列表">.keys()：获取字典中由键组成的列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allKeys = dic.keys()</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> allKeys:</span><br><span class="line">    <span class="built_in">print</span>(elem, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="values获取字典中由值组成的列表">.values()：获取字典中由值组成的列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allValues = dic.values()</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> allValues:</span><br><span class="line">    <span class="built_in">print</span>(elem, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="items返回一个包含所有键-值元祖的列表">items()：返回一个包含所有(键
值)元祖的列表</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115223520574.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
<h1 id="集合">集合</h1>
<h2 id="创建-1">创建</h2>
<h3 id="set-函数创建-里面可以是字典列表元组">set( )函数创建，(
)里面可以是字典，列表，元组</h3>
<h3 id="大括号创建">大括号创建</h3>
<h2 id="集合运算">集合运算</h2>
<h3 id="交">交 &amp;</h3>
<h3 id="并">并 |</h3>
<h3 id="差--">差 -</h3>
<h1 id="生成器">生成器</h1>
<h2 id="创建-2">创建</h2>
<h3 id="列表推导式">列表推导式、</h3>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_list = [expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>expression</code>: 定义列表元素的表达式。</li>
<li><code>item</code>: 迭代变量，表示来自 iterable 的当前元素。</li>
<li><code>iterable</code>: 可迭代对象，例如列表、元组、字符串等。</li>
<li><code>condition</code>（可选）: 过滤条件，用于筛选元素。</li>
</ul>
<p>expression中的变量和item中一致i，expression表示的是最终的返回值</p>
<p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122193656603.png" /></p>
<h3 id="生成器-1">生成器</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(generator)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122193922577.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122194006578.png" /></p>
<p>生成器每次返回的是一个算法,每使用一次next函数就可以获取一个元素值,
直到最后一个元素值,</p>
<p>也可以直接用for</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<h2 id="yield">yield</h2>
<p>举例：构造斐波那契数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">febo</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">generator = febo(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p>yield关键字类似于return关键字,每次迭代遇到yield返回后面的一个元素,
下次再迭代时候,从上一次yield结束位置后面继续执行</p>
<h1 id="迭代器">迭代器</h1>
<h2 id="迭代对象">迭代对象</h2>
<p>一类：str list tuple dict set 二类：生成器</p>
<p>这些可以直接作用与for循环的对象的统称 ----》迭代对象 ： Iterable</p>
<h2 id="迭代器-1">迭代器</h2>
<p>可以被next()函数调用并且不断的返回下一个值的对象----》迭代器
Iterator</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>有序遍历文件夹</title>
    <url>/posts/41f2a6b9.html</url>
    <content><![CDATA[<p>按数字从小到大遍历文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> root, _, images <span class="keyword">in</span> tqdm(<span class="built_in">sorted</span>(os.walk(src_path)))</span><br></pre></td></tr></table></figure>
<p>按数字从小到大遍历文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="built_in">sorted</span>(images, key=<span class="keyword">lambda</span> x : <span class="built_in">int</span>(os.path.splitext(x)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>sorted()中</p>
<p>images作用：待排序的列表</p>
<p>key表示sorted中用于排序的规则</p>
<p>匿名函数：lambda x : int(os.path.splitext(x)[0])</p>
]]></content>
      <categories>
        <category>python</category>
        <category>有用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>第一周和第二周作业</title>
    <url>/posts/a41b37e2.html</url>
    <content><![CDATA[<h1 id="第一周作业">第一周作业</h1>
<h2 id="exercise1考察随机数的获取">exercise1：考察随机数的获取</h2>
<p>循环实现班级随机抽奖,假设有10排,每排10个同学,输出结果如下:
第7排,1列同学中奖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">循环实现班级随机抽奖,假设有10排,每排10个同学,输出结果如下:</span></span><br><span class="line"><span class="string">第7排,1列同学中奖</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">row = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">col = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;row&#125;</span>, <span class="subst">&#123;col&#125;</span>列同学中奖&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="第二周作业">第二周作业</h1>
<h2 id="exercise1考察列表中常用操作">exercise1：考察列表中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">编程实现对一个元素全为数字的列表，求最大值、最小值.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">99</span>,<span class="number">23</span>,-<span class="number">1</span>,<span class="number">199</span>,<span class="number">888</span>]</span><br><span class="line"><span class="built_in">list</span>.sort()</span><br><span class="line">maxNum = <span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line">minNum = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;max = <span class="subst">&#123;maxNum&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;minNum&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;max = <span class="subst">&#123;<span class="built_in">max</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;<span class="built_in">min</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise2join的用法">exercise2：join的用法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">完成一个路径的组装</span></span><br><span class="line"><span class="string">先提示用户多次输入路径，最后显示一个完整的路径，比如/home/python/ftp/share</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">strList = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    substr = <span class="built_in">input</span>(<span class="string">&quot;请输入文件夹名称&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(substr != <span class="string">&#x27;exit&#x27;</span>):</span><br><span class="line">        strList.append(substr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">char = <span class="string">&#x27;/&#x27;</span></span><br><span class="line">path = char.join(strList)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span> + path)</span><br></pre></td></tr></table></figure>
<h2
id="exercise3考察字符串中常用操作">exercise3：考察字符串中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 3.统计用户通过键盘输入的字母，数字，空格的个数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">countAlp = <span class="number">0</span></span><br><span class="line">countNum = <span class="number">0</span></span><br><span class="line">countBlank = <span class="number">0</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一段话&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i].isalpha():</span><br><span class="line">        countAlp += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>[i].isnumeric():</span><br><span class="line">        countNum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">        countBlank += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;alphabet is <span class="subst">&#123;countAlp&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;number is <span class="subst">&#123;countNum&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;blank is <span class="subst">&#123;countBlank&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise4考察字典中常用操作">exercise4：考察字典中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 5.编写程序，完成以下要求：</span></span><br><span class="line"><span class="string">#	统计字符串中，各个字符的个数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一段话：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    dic[char] = <span class="built_in">str</span>.count(char)</span><br><span class="line"></span><br><span class="line">items = dic.items()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> items:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>:<span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise5">exercise5：</h2>
<h3 id="生成指定范围随机数">生成指定范围随机数</h3>
<h3 id="字符串的拼接">字符串的拼接</h3>
<p>字符串拼接就必须全部转换成字符串</p>
<h3 id="获得字母的ascii码">获得字母的ASCII码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 6.随机生成一个六位数的验证码（包含数字和字符）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">string = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    choose_num_or_char = random.randrange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> choose_num_or_char == <span class="number">0</span>: <span class="comment"># 生成数字</span></span><br><span class="line">        add = random.randrange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        string += <span class="built_in">str</span>(add)</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># 生成字母</span></span><br><span class="line">        add = random.randrange(<span class="number">1</span>, <span class="number">26</span>)</span><br><span class="line">        add = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + add - <span class="number">1</span>)</span><br><span class="line">        string += add</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure>
<h2 id="exercise6">exercise6：</h2>
<h3 id="字符串空格的操作">字符串空格的操作</h3>
<h3 id="字符串起始位置的查询">字符串起始位置的查询</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#7.查找列表元素，移除每个元素的空格，</span></span><br><span class="line"><span class="string">并查找以a 或A开头 并且以c 结尾的所有元素。</span></span><br><span class="line"><span class="string">li = [&quot;alex&quot;, &quot; aric&quot;, &quot;Alex&quot;, &quot;Tony&quot;, &quot;rain&quot;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">li = [<span class="string">&quot;alex&quot;</span>, <span class="string">&quot; aric&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Tony&quot;</span>, <span class="string">&quot;rain&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">target = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> li:</span><br><span class="line">    item = item.strip()</span><br><span class="line">    <span class="keyword">if</span> (item.startswith(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">or</span> item.startswith(<span class="string">&#x27;A&#x27;</span>)) <span class="keyword">and</span> item.endswith(<span class="string">&#x27;c&#x27;</span>):</span><br><span class="line">        target.append(item)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(target)</span><br></pre></td></tr></table></figure>
<h2 id="exercise7">exercise7</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">9. 分页显示内容</span></span><br><span class="line"><span class="string">a. 通过for循环创建301条数据，数据类型不限，如：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user1　　　email-1　　　pwd1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user2　　　email-2　　　pwd2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.........</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">b.提示用户 请输入要查看的页码，当用户输入指定页码时，显示指定数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　- 每页显示10条数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　- 用户输入页码是非十进制数字，则提示输入内容格式错误</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRandomStr</span>(<span class="params">length</span>):</span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        choose_num_or_char = random.randrange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> choose_num_or_char == <span class="number">0</span>: <span class="comment"># 生成数字</span></span><br><span class="line">            add = random.randrange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            string += <span class="built_in">str</span>(add)</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 生成字母</span></span><br><span class="line">            add = random.randrange(<span class="number">1</span>, <span class="number">26</span>)</span><br><span class="line">            add = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + add - <span class="number">1</span>)</span><br><span class="line">            string += add</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line">records = []</span><br><span class="line">record_per_page = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">301</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">        records.append(record_per_page)</span><br><span class="line">        record_per_page = []</span><br><span class="line">    information = &#123;&#125;</span><br><span class="line">    information[<span class="string">&quot;user&quot;</span>] = getRandomStr(<span class="number">6</span>)</span><br><span class="line">    information[<span class="string">&quot;email&quot;</span>] = getRandomStr(<span class="number">10</span>) + <span class="string">&quot;@163.com&quot;</span></span><br><span class="line">    information[<span class="string">&quot;pwd&quot;</span>] = getRandomStr(<span class="number">12</span>)</span><br><span class="line">    record_per_page.append(information)</span><br><span class="line">records.append(record_per_page)</span><br><span class="line">yema = <span class="built_in">input</span>(<span class="string">&quot;请输入查询页码&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> yema.isdigit() == <span class="literal">True</span>:</span><br><span class="line">    yema = <span class="built_in">int</span>(yema)</span><br><span class="line">    <span class="keyword">for</span> people <span class="keyword">in</span> records[yema]:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> people.items():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>--<span class="subst">&#123;value&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入有误&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码在第一次写在 record_per_page = [] 写成了
record_per_page.clear()</p>
<p>虽然都是清空列表，但第一种写法是将record_per_page指向一个新对象，而第二种写法没有</p>
<p>所以第二种写法导致的问题就会出现改一个跟着改了几个</p>
<p>问题简化就是下面这种情况</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/408b5898-aff7-4fd9-bbcb-2c3186083ed6.gif" /></p>
<p>修改inner的同时out也被改变</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>调试</title>
    <url>/posts/aaf56f78.html</url>
    <content><![CDATA[<h1 id="调试">调试</h1>
<h2 id="断言assert">断言assert</h2>
<p>格式：assert expression 等价于： if not expression: raise
AssertError</p>
<h2 id="logging">logging</h2>
<p>导入模块</p>
<p>添加配置</p>
<p>写入的信息的类别</p>
<p>debug,info,warnning,error
如果指定info,debug不再起作用,如果指定wranning,debug,info不起作用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">导入logging模块</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加一个配置</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="comment">#控制台打印的日志级别</span></span><br><span class="line">                    filename=<span class="string">&#x27;./log/new.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;a&#x27;</span>,<span class="comment">##模式，有w和a，w就是写模式，每次都会重新写日志，覆盖之前的日志</span></span><br><span class="line">                    <span class="comment">#a是追加模式，默认如果不写的话，就是追加模式</span></span><br><span class="line">                    <span class="built_in">format</span>=</span><br><span class="line">                    <span class="string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span></span><br><span class="line">                    <span class="comment">#日志格式</span></span><br><span class="line">                    )</span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">logging.info(<span class="string">&#x27;n=%d&#x27;</span>%n)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>/n)</span><br></pre></td></tr></table></figure>
<h2 id="pdb">pdb</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">命令           用途</span><br><span class="line"><span class="keyword">break</span> 或则 b  设置断点</span><br><span class="line"><span class="keyword">continue</span>/c    继续执行程序，或者跳到下一个断点</span><br><span class="line"><span class="built_in">next</span>/n       执行下一行</span><br><span class="line">step/s       进入函数</span><br><span class="line"><span class="built_in">list</span>/l      查看当前的代码段</span><br><span class="line"><span class="keyword">return</span>/r    执行代码直到从当前函数的返回</span><br><span class="line">exit/q       终止，退出</span><br><span class="line">p/!          打印变量的值    p c</span><br><span class="line"><span class="built_in">help</span>/h       帮助</span><br></pre></td></tr></table></figure>
<h1 id="单元测试">单元测试</h1>
<p>导入unittest模块</p>
<h2 id="测试函数">测试函数</h2>
<h2 id="测试类">测试类</h2>
<h1 id="文档测试">文档测试</h1>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-作业</title>
    <url>/posts/581bdacc.html</url>
    <content><![CDATA[<h1
id="exercise1写一个函数求三个数的平均值要求分别使用默认参数和不定长参数">exercise1:写一个函数求三个数的平均值(要求分别使用默认参数和不定长参数)</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用不定长参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args) / <span class="built_in">len</span>(args)</span><br></pre></td></tr></table></figure>
<h1 id="exercise2偏函数">exercise2：偏函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">键盘录入一个数字,使用偏函数计算这个数字表示n周（一周7天）的总天数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 从functools中导包</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="comment"># 定义原始函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">days_per_week, n</span>):</span><br><span class="line">    <span class="keyword">return</span> n * days_per_week</span><br><span class="line"><span class="comment"># 利用partial装饰原始函数，就是新建了一个函数</span></span><br><span class="line">count_days = partial(count, <span class="number">7</span>)</span><br><span class="line">days = count_days(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(days)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-模块文件操作</title>
    <url>/posts/ea79def.html</url>
    <content><![CDATA[<h1 id="文件操作">文件操作</h1>
<span id="more"></span>
<h2 id="从文件中读取">从文件中读取</h2>
<p>text.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="read">read</h3>
<h4 id="不加限制就是全部读取文件">不加限制就是全部读取文件</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="读取指定长度">读取指定长度</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(f.read(2))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">he</span><br></pre></td></tr></table></figure>
<p>注：read移动的是文件指针，一开始写成这样结果发现后面什么都没有读到，因为文件指针已经读到末尾了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;全部读取\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#f.seek(0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;读取前两个字符\n<span class="subst">&#123;f.read(<span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#f.seek(0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;读取前10个字符\n<span class="subst">&#123;f.read(<span class="number">10</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全部读取</span><br><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br><span class="line">读取前两个字符</span><br><span class="line"></span><br><span class="line">读取前10个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要将文件指针复位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;text.txt&quot;, &quot;r&quot;)</span><br><span class="line">print(f&quot;全部读取\n&#123;f.read()&#125;&quot;)</span><br><span class="line">f.seek(0)</span><br><span class="line">print(f&quot;读取前两个字符\n&#123;f.read(2)&#125;&quot;)</span><br><span class="line">f.seek(0)</span><br><span class="line">print(f&quot;读取前10个字符\n&#123;f.read(10)&#125;&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全部读取</span><br><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br><span class="line">读取前两个字符</span><br><span class="line">he</span><br><span class="line">读取前10个字符</span><br><span class="line">hello worl</span><br></pre></td></tr></table></figure>
<h4 id="用for循环就会一行一行读">用for循环就会一行一行读</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for循环</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">python  java c c++</span><br><span class="line"></span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line"></span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结:如果读取多次,下次读取是从上次读取结束的位置开始读取</p>
<h3 id="readline">readline</h3>
<h4 id="一行一行读">一行一行读</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readline()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h4
id="如果限制字符数就读取一行中限制字符数">如果限制字符数就读取一行中限制字符数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readline(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hel</span><br></pre></td></tr></table></figure>
<h4
id="for循环逐个打印文件中一行中字符">for循环逐个打印文件中一行中字符</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> f.readline():</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line"> </span><br><span class="line">w</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">l</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<h3 id="readlines">readlines()</h3>
<h4
id="不加限制就是读取文件中全部行将每一行作为列表中一个元素最终保存到一个列表里">不加限制就是读取文件中全部行，将每一行作为列表中一个元素，最终保存到一个列表里</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;hello world\n&#x27;, &#x27;python  java c c++\n&#x27;, &#x27;for f serj eoifjwefj;asf\n&#x27;, &#x27;aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq\n&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="读取xlsx文件">读取xlsx文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readExcel</span>(<span class="params">file_path</span>):</span><br><span class="line">    wb = openpyxl.load_workbook(file_path)</span><br><span class="line">    sheet = wb.active</span><br><span class="line">    <span class="comment"># sheet = wb.active 这行代码的作用是获取 Excel 工作簿（Workbook）中的活动工作表（Sheet）。在一个 Excel 文件中，可以包含多个工作表，而 active 方法用于获取当前活动的工作表，即当前被选中的工作表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> sheet.iter_rows():</span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">            <span class="built_in">print</span>(cell.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(readExcel(<span class="string">r&quot;D:\HuaweiMoveData\Users\piolet\Desktop\寒假每天任务记录.xlsx&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日期 正式工作时间 蓝桥杯（5：30-11：30）目标4） 科研（13：00-18：00， 19：00-20：00，目标6h） 数模（21：00-23：00，目标2） 开小差次数 手机使用时间 总工作时间 None </span><br><span class="line">1.13 05:28:00 4 None None 1 2h28min None None </span><br><span class="line">1.14 05:30:00 4,明天从</span><br><span class="line">https://blog.csdn.net/weixin_43914593/article/details/133969568开始做 3，明天继续看https://zh.d2l.ai/chapter_linear-networks/softmax-regression.html#equation-eq-softmax-y-and-o留下来的一点小尾巴，然后要从https://zh.d2l.ai/chapter_linear-networks/softmax-regression-concise.html#sec-softmax-concise和https://zh.d2l.ai/chapter_multilayer-perceptrons/mlp-concise.html开始看，争取一天看完动手深度学习 None 1 2h23min 7 None </span><br><span class="line">1.15 05:36:00 3 4 2 1 2h41min 9 None </span><br><span class="line">1.16 05:35:00 5 3 1 2 2和4min 9 None </span><br><span class="line">1.17 05:45:00 0 8 0 0 2h40min 8 None </span><br><span class="line">1.18 05:32:00 5 4.5 1.5 1 1h55min 11 None </span><br><span class="line">1.19 05:25:00 1 5 0 6 5h 6 None </span><br><span class="line">1.2 06:40:00 维护博客3h 0 3 0 5h 6 None </span><br><span class="line">1.21 05:39:00 6 0 0 5 6h8min 6 None </span><br><span class="line">1.22 05:22:00 5 4 2 4 2h30min 11 None </span><br><span class="line">日期 正式工作时间 科研（5：30-11：30，目标4） 蓝桥杯（13：30-6：30，目标4） 数模（19：00-20：00，21：00-23：00，目标3） 开小差次数 手机使用时间 总工作时间 运动次数 </span><br><span class="line">1.23 05:30:00 4 4 2 5 None None 2 </span><br><span class="line">None</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="写入xlsx文件">写入xlsx文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writeExcel</span>(<span class="params">path, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param path: 写入数据的文件路径</span></span><br><span class="line"><span class="string">    :param data: 要写入到文件里数据</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    wb = openpyxl.Workbook()</span><br><span class="line">    sheet = wb.active</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">        sheet.append(row)</span><br><span class="line"></span><br><span class="line">    wb.save(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">path = <span class="string">&#x27;D:\\yaoming.xlsx&#x27;</span></span><br><span class="line">writeExcel(path, [[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>], [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>], [<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应用---制作文件的备份">应用---制作文件的备份</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任务描述：</span><br><span class="line">输入文件名字，然后程序自动完成对该文件的备份操作：</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">input---&gt;string</span></span><br><span class="line"><span class="string">打开需要备份的文件</span></span><br><span class="line"><span class="string">            存在</span></span><br><span class="line"><span class="string">                读取打开需要备份文件数据</span></span><br><span class="line"><span class="string">                关闭需要备份文件</span></span><br><span class="line"><span class="string">            不存在</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实现备份</span></span><br><span class="line"><span class="string">1.定义备份文件的规则</span></span><br><span class="line"><span class="string">2.将备份文件数据写入到新文件里面</span></span><br><span class="line"><span class="string">3.关闭新文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">path</span>): <span class="comment">#path需要备份文件路径</span></span><br><span class="line">    <span class="comment">#打开需要备份的文件</span></span><br><span class="line">    oldFileName = <span class="built_in">input</span>(<span class="string">&#x27;请输入你要备份文件的名称:&#x27;</span>)</span><br><span class="line">    <span class="comment">#打开文件</span></span><br><span class="line">    fileName = <span class="built_in">open</span>(oldFileName,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="comment">#判断文件是否打开</span></span><br><span class="line">    <span class="keyword">if</span> fileName:</span><br><span class="line">        <span class="comment">#获取备份的文件名</span></span><br><span class="line">        copyFile = oldFileName.rfind(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        name = oldFileName[<span class="number">0</span>:copyFile]</span><br><span class="line">        <span class="comment">#splitText获取文件名和扩展名</span></span><br><span class="line">        fileFlag = os.path.splitext(path)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义新文件备份规则</span></span><br><span class="line">        newFileName = name+<span class="string">&#x27;-副本&#x27;</span>+fileFlag</span><br><span class="line">        <span class="comment">#打开新文件</span></span><br><span class="line">        newFile = <span class="built_in">open</span>(newFileName,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#读取旧文件数据,一行行往新文件里面写入</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fileName.readlines():</span><br><span class="line">            newFile.write(line)</span><br><span class="line">        <span class="comment">#关闭文件</span></span><br><span class="line">        fileName.close()</span><br><span class="line">        newFile.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没有文件打开&#x27;</span>)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">copy(<span class="string">&#x27;text.txt&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="文件的定位读写">文件的定位读写</h3>
<h4 id="获取当前读写文件的位置">获取当前读写文件的位置</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;text.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.read(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取的数据是:&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line">position = f.tell()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取的位置是:&#x27;</span>,position)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取的数据是: b&#x27;hel&#x27;</span><br><span class="line">读取的位置是: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="定位到某一个位置">定位到某一个位置</h4>
<h4 id="定位到某一个位置-1">定位到某一个位置</h4>
<h2 id="文件的重命名">文件的重命名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;毕业论文.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="文件的删除">文件的删除</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.remove(<span class="string">&quot;待删除文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="文件夹操作">文件夹操作</h1>
<h2 id="创建">创建</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&quot;新文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取当前的目录">获取当前的目录</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&quot;./&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="删除文件夹">删除文件夹</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rmdir(<span class="string">&quot;待删除文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2
id="应用----批量修改文件名重命名">应用----批量修改文件名（重命名）</h2>
<h1 id="stringio和bytesio">StringIO和BytesIO</h1>
<h2 id="stringio">StringIO</h2>
<h2 id="bytesio">BytesIO</h2>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-函数</title>
    <url>/posts/984d2642.html</url>
    <content><![CDATA[<h1 id="函数的参数传递">函数的参数传递</h1>
<h2 id="不可变对象">不可变对象</h2>
<p>number, string, turple</p>
<p>函数传参如果传递的是这种类型，无法在函数内改变传入的参数的值</p>
<h2 id="可变对象">可变对象</h2>
<p>list, dict, set</p>
<p>函数传参如果传递的是这种类型，可以在函数内改变传入的参数的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a</span>):  <span class="comment"># a形参</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;inside <span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;outside <span class="subst">&#123;<span class="built_in">id</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br><span class="line">fun(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;inside <span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;outside <span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line">add(num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;now num: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122205506418.png" /></p>
<p>在 Python 中，整数是不可变的（immutable），所以在 <code>add</code>
函数中，执行 <code>num += 10</code>
时，实际上是创建了一个新的整数对象，并将 <code>num</code>
重新指向这个新对象。这并不会影响到函数外部的 <code>num</code> 变量</p>
<h1 id="关键字参数args">关键字参数:**args</h1>
<p>允许函数调用时参数顺序和定义时不一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_stu_info</span>(<span class="params">name,age,**args</span>):</span><br><span class="line">    <span class="comment">#print(&#x27;姓名是:%s,年龄是:%d&#x27;%(name,age))</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">get_stu_info(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">29</span>,sex=<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">get_stu_info(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">29</span>,sex=<span class="string">&#x27;男&#x27;</span>,height=<span class="number">178</span>,weight=<span class="number">80</span>,hobby=<span class="string">&#x27;唱歌&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122210136207.png" /></p>
<h1 id="默认参数">默认参数</h1>
<p>调用函数时，缺省参数的值如果没有传入，<strong>则会被认为是默认值</strong></p>
<h1 id="不定长参数">不定长参数</h1>
<p>加了一个*号的变量args会存放所有未命名的变量参数，----》元祖
加了**号，存放所有命名的变量参数----》字典</p>
<p>加了一个*号的变量args会存放所有未命名的变量参数，----》元祖
加了**号，存放所有命名的变量参数----》字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c,*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;args=&#x27;</span>,args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kwargs=&#x27;</span>,kwargs)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;key=&#x27;</span>,key,<span class="string">&#x27;value=&#x27;</span>,value)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">fun(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,name=<span class="string">&#x27;鹿晗&#x27;</span>,age=<span class="number">20</span>,height=<span class="number">180</span>)</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a= 1</span><br><span class="line">b= 3</span><br><span class="line">c= 5</span><br><span class="line">args= (6,)</span><br><span class="line">kwargs= &#123;&#x27;name&#x27;: &#x27;鹿晗&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 180&#125;</span><br></pre></td></tr></table></figure>
<p>先后顺序方面一般先*再**</p>
<h1 id="匿名函数">匿名函数</h1>
<h2 id="定义">定义：</h2>
<p>不使用def这样语句来定义函数 使用lambda来创建一个匿名函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lambda</code>: 关键字，表示定义一个匿名函数。</li>
<li><code>arguments</code>:
参数列表，类似于函数的参数，但不能包含默认值、可变参数等。</li>
<li><code>expression</code>: 单一的表达式，函数的返回值。</li>
</ul>
<h2 id="应用">应用</h2>
<h3 id="作为参数进行传递">作为参数进行传递</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b,opt</span>): <span class="comment">#opt当做参数传递</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(opt(<span class="number">1</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">test(<span class="number">10</span>,<span class="number">100</span>,<span class="keyword">lambda</span> x,y:x+y)</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">100</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="作为内置函数的参数">作为内置函数的参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;laowang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">35</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据名称进行排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;排序之前的数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照名称进行排序&quot;</span>)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> y: y[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据年龄进行排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照年龄排序&quot;</span>)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> c: c[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br></pre></td></tr></table></figure>
<p>sort 函数接受一个关键字参数 key，这个参数是一个函数或 lambda
表达式，用于指定排序的依据。</p>
<p>lambda y: y['name'] 是一个匿名函数，接受一个字典 y，返回该字典中键为
'name' 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序之前的数据:</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;]</span><br><span class="line">按照名称进行排序</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;]</span><br><span class="line">按照年龄排序</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;]</span><br></pre></td></tr></table></figure>
<h1 id="偏函数">偏函数</h1>
<p>函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。</p>
<p>可以有效冻结一些预先定义好的参数,对函数参数做缓存,后面想使用再解冻
类似斐波那契数列,知道了前面的几个数,就能推导出后面的数字
比如定义了一个函数,传了2个参数,现在调用可能只会用到部分参数,可以将它冻结起来
后面想使用时候随时解冻</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">plus = partial(add,<span class="number">100</span>) <span class="comment">#提前获知第一个参数的值</span></span><br><span class="line">res = plus(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>使用了 Python 中的 <code>functools.partial</code>
函数来创建一个偏函数</p>
<p>定义了一个原始函数 <code>add(a, b)</code>，用于计算两个数之和。</p>
<p>使用 <code>functools.partial</code> 创建了一个新的函数
<code>plus</code>，通过 <code>partial(add, 100)</code>，将原始函数
<code>add</code> 的第一个参数 <code>a</code> 固定为
<code>100</code>，这样，<code>plus</code> 函数实际上就是
<code>add</code> 函数的一个变体，其中第一个参数已经被固定为
<code>100</code>。</p>
<p>调用 <code>plus(9)</code>，相当于调用
<code>add(100, 9)</code>，得到结果 <code>109</code>。</p>
<h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2
id="如何在函数里修改全局变量global-全局变量名">如何在函数里修改全局变量：global
全局变量名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="comment"># x = 100</span></span><br><span class="line">    <span class="comment"># print(x)</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;before function:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;after function:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before function:10</span><br><span class="line">after function:1010</span><br></pre></td></tr></table></figure>
<p>当不可变的数据类型作为全局变量，需要用global声明，进行修改
可变的数据类型 不一定</p>
<h2
id="如何在函数里使用外层变量nonlocal-外层变量名">如何在函数里使用外层变量:nonlocal
外层变量名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nonlocal:使用函数的外层变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;before test2, num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num *= <span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;in test2,num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;after test2,num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> test2()</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h1 id="装饰器">装饰器</h1>
<h2 id="定义-1">定义:</h2>
<p><strong>本质上就是一个python函数</strong>，他可以让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。</p>
<p>这么做目的是：首先把函数传递到装饰器里面,先验证权限,验证通过,再调用传递进来函数</p>
<h2 id="基本格式">基本格式</h2>
<p><span class="citation" data-cites="函数名">@函数名</span></p>
<p>举例说明</p>
<p>定义一种装饰器函数如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">fun</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="comment"># 验证1</span></span><br><span class="line">        <span class="comment"># 验证2</span></span><br><span class="line">        <span class="comment"># 验证3</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        fun()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<p>定义带装饰器的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>直接调用装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接调用装饰器&quot;</span>)</span><br><span class="line">f = w1(f1)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1</span><br></pre></td></tr></table></figure>
<p>使用被语法糖修饰的带装饰器的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1</span><br></pre></td></tr></table></figure>
<p>举例运用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义了一个装饰器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBold</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;b&gt;&#x27;</span>+fn()+<span class="string">&#x27;&lt;/b&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="comment">#定义一个带装饰器的函数</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello-world-1&#x27;</span></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(test1())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;hello-world-1&lt;/b&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第五周作业</title>
    <url>/posts/74265ed1.html</url>
    <content><![CDATA[<h1
id="exercise1修改类属性值的两种方式并写出具体的代码">exercise1：修改类属性值的两种方式？并写出具体的代码</h1>
<h2 id="类属性">类属性：</h2>
<p>和java相似的是，就是这一类公共的属性，修改这一个其他是这个类（不是同一个对象的）都会变</p>
<p>不同点在于java中类属性是用static修饰的，就是类属性和普通属性之间由严格的界定，而python没有</p>
<h2 id="方法">方法</h2>
<ol type="1">
<li>直接通过类名修改类属性的值。</li>
<li>通过实例对象修改类属性的值（这种方式会在实例中创建同名的实例属性，并覆盖类属性）。</li>
</ol>
<p>比如下面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_attr = <span class="string">&quot;I am a class attribute&quot;</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类名修改类属性的值</span></span><br><span class="line">MyClass.class_attr = <span class="string">&quot;Modified class attribute&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出修改后的类属性值</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attr)  <span class="comment"># 输出：&quot;Modified class attribute&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过实例对象修改类属性的值</span></span><br><span class="line">obj.class_attr = <span class="string">&quot;New class attribute value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出实例对象的属性值</span></span><br><span class="line"><span class="built_in">print</span>(obj.class_attr)  <span class="comment"># 输出：&quot;New class attribute value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类属性的值</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attr)  <span class="comment"># 输出：&quot;Modified class attribute&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="exercise2">exercise2</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.定义学生类student,在该类中使用构造函数实现对学生信息(姓名、年龄、性别)</span><br><span class="line">的初始化，然后针对类的各个属性建立相应的方法来获取属性的值</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.定义学生类student,在该类中使用构造函数实现对学生信息(姓名、年龄、性别)</span></span><br><span class="line"><span class="string">的初始化，然后针对类的各个属性建立相应的方法来获取属性的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>():</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    sex = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sex</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sex</span><br><span class="line"></span><br><span class="line">studentA = student(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(studentA.get_name())</span><br><span class="line"><span class="built_in">print</span>(studentA.get_age())</span><br><span class="line"><span class="built_in">print</span>(studentA.get_sex())</span><br></pre></td></tr></table></figure>
<h1 id="exercise3">exercise3</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.定义一个学生类。有下面的类属性:</span><br><span class="line">1 姓名</span><br><span class="line">2 年龄</span><br><span class="line">3 成绩（语文,数学,英语)[每课成绩的类型为整数]</span><br><span class="line">类方法：</span><br><span class="line">1 获取学生的姓名：get_name() 返回类型:str</span><br><span class="line">2 获取学生的年龄：get_age() 返回类型:int</span><br><span class="line">3 返回3门科目中最高的分数。get_course() 返回类型:int</span><br><span class="line">写好类以后,可以创建对象测试下：</span><br><span class="line">stu = Student(&#x27;zhangming&#x27;,20,[69,88,100])</span><br><span class="line">返回结果：</span><br><span class="line">zhangming</span><br><span class="line">20</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="代码-1">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">3.定义一个学生类。有下面的类属性:</span></span><br><span class="line"><span class="string">1 姓名</span></span><br><span class="line"><span class="string">2 年龄</span></span><br><span class="line"><span class="string">3 成绩（语文,数学,英语)[每课成绩的类型为整数]</span></span><br><span class="line"><span class="string">类方法：</span></span><br><span class="line"><span class="string">1 获取学生的姓名：get_name() 返回类型:str</span></span><br><span class="line"><span class="string">2 获取学生的年龄：get_age() 返回类型:int</span></span><br><span class="line"><span class="string">3 返回3门科目中最高的分数。get_course() 返回类型:int</span></span><br><span class="line"><span class="string">写好类以后,可以创建对象测试下：</span></span><br><span class="line"><span class="string">stu = Student(&#x27;zhangming&#x27;,20,[69,88,100])</span></span><br><span class="line"><span class="string">返回结果：</span></span><br><span class="line"><span class="string">zhangming</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">100</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, scores</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.scores = scores</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建学生对象并测试</span></span><br><span class="line">stu = Student(<span class="string">&#x27;zhangming&#x27;</span>, <span class="number">20</span>, [<span class="number">69</span>, <span class="number">88</span>, <span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span>(stu.get_name())</span><br><span class="line"><span class="built_in">print</span>(stu.get_age())</span><br><span class="line"><span class="built_in">print</span>(stu.get_course())</span><br></pre></td></tr></table></figure>
<h1 id="exercise4">exercise4</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.练习：</span><br><span class="line">    有一个学校,人数为0,入职的老师和学生,人数增加1,老师要显示姓名和工号,</span><br><span class="line">   学生要显示姓名和成绩,老师和学生入职后都需要做自我介绍</span><br></pre></td></tr></table></figure>
<h2 id="知识点">知识点</h2>
<p>继承：teacher和student继承自people</p>
<p>通过修改__str__方法来打印信息</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">4.练习：</span></span><br><span class="line"><span class="string">    有一个学校,人数为0,入职的老师和学生,人数增加1,老师要显示姓名和工号,</span></span><br><span class="line"><span class="string">	学生要显示姓名和成绩,老师和学生入职后都需要做自我介绍</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduction</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;大家好，我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(teacher, self).__init__(name, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        msg = <span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>  工号：<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span>, scores</span>):</span><br><span class="line">        self.scores = scores</span><br><span class="line">        <span class="built_in">super</span>(student, self).__init__(name, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        msg = <span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>  学号：<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>  成绩：<span class="subst">&#123;self.scores&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">school</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.total_num = <span class="number">0</span></span><br><span class="line">        self.teachers = []</span><br><span class="line">        self.students = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_teachers</span>(<span class="params">self, teacher</span>):</span><br><span class="line">        self.teachers.append(teacher)</span><br><span class="line">        self.total_num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(teacher)</span><br><span class="line">        teacher.introduction()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_student</span>(<span class="params">self, student</span>):</span><br><span class="line">        self.students.append(student)</span><br><span class="line">        self.total_num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(student)</span><br><span class="line">        student.introduction()</span><br><span class="line"></span><br><span class="line">jinan_university = school()</span><br><span class="line">teacherA = teacher(<span class="string">&quot;xiazhihua&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">studentA = student(<span class="string">&quot;ztb&quot;</span>, <span class="string">&quot;123&quot;</span>, [<span class="number">89</span>, <span class="number">89</span>, <span class="number">89</span>])</span><br><span class="line">jinan_university.add_teachers(teacherA)</span><br><span class="line">jinan_university.add_student(studentA)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第四周-作业</title>
    <url>/posts/1cb8774b.html</url>
    <content><![CDATA[<h1 id="exercise6装饰器的使用">exercise6:装饰器的使用</h1>
<p>user-credentials.txt内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;xiaoming&quot;, &quot;password&quot;:&quot;123&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaowang&quot;, &quot;password&quot;:&quot;321&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaofang&quot;, &quot;password&quot;:&quot;432&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaobai&quot;, &quot;password&quot;:&quot;111&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_user_credentials</span>(<span class="params">file_path</span>):</span><br><span class="line">    credentials = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            user_info = json.loads(line.strip())</span><br><span class="line">            credentials.append(user_info)</span><br><span class="line">    <span class="keyword">return</span> credentials</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authentication_required</span>(<span class="params">func</span>):</span><br><span class="line">    authenticated = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> authenticated</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> authenticated:</span><br><span class="line">            username = <span class="built_in">input</span>(<span class="string">&quot;Enter your username: &quot;</span>)</span><br><span class="line">            password = <span class="built_in">input</span>(<span class="string">&quot;Enter your password: &quot;</span>)</span><br><span class="line">            user_credentials = read_user_credentials(<span class="string">&quot;user_credentials.txt&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> user_info <span class="keyword">in</span> user_credentials:</span><br><span class="line">                <span class="keyword">if</span> user_info.get(<span class="string">&#x27;name&#x27;</span>) == username <span class="keyword">and</span> user_info.get(<span class="string">&#x27;password&#x27;</span>) == password:</span><br><span class="line">                    authenticated = <span class="literal">True</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Authentication successful!&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Authentication failed. Please try again.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is function 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is function 2.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    function1()</span><br><span class="line">    function1()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter your username: xiaoming</span><br><span class="line">Enter your password: 123</span><br><span class="line">Authentication successful!</span><br><span class="line">This is function 1.</span><br><span class="line">This is function 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第六周-面向对象、函数高阶用法</title>
    <url>/posts/40aa2ee.html</url>
    <content><![CDATA[<h1 id="多态">多态</h1>
<p>python的多态与java的多态类似。比如一种常见的使用形式就是在函数传参的时候传递的可以是父类和继承该父类的多种子类。然而python比java更灵活</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">   多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）</span><br><span class="line">   </span><br><span class="line">例如:</span><br><span class="line">	序列有多种形态:字符串，列表，元祖</span><br><span class="line">	动物有多种形态:人，猪，狗</span><br><span class="line">	</span><br><span class="line">多态和多态性的区别:</span><br><span class="line">    多态：同一种事物的多种形态，动物分为人类，猪类（在定义角度） </span><br><span class="line">    多态性：一种调用方式，不同的执行效果（多态性）</span><br><span class="line">   </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">面向对象的三大特征:封装,继承,多态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">封装:又称为信息的隐藏,类的实现和使用时分开的,类提供了外部访问的方法,调用者不需要关注</span></span><br><span class="line"><span class="string">类里面的具体实现,会调用即可</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生活中封装:买手机会用就可以</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">继承:一个类继承另外一个类,被继承的类称为父类或者基类,继承的类称为子类或者派生类,</span></span><br><span class="line"><span class="string">子类可以共享父类里面受保护,公有属性和方法,子类不能共享父类私有属性和方法</span></span><br><span class="line"><span class="string">继承可以减少代码的书写,提高代码的可维护性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多态:同一种事物有多种形态</span></span><br><span class="line"><span class="string">多态性:同一种调用方式,返回不同的结果</span></span><br><span class="line"><span class="string">多态的前提:继承和重写</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#多态:一种事物有多种表现形式</span></span><br><span class="line"><span class="comment">#定义一个父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Person,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello,i am Person&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Pig,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;aoao,i am Pig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Dog,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wangwang,i am Dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化不同子类创建对象</span></span><br><span class="line">Per = Person()</span><br><span class="line">Pi = Pig()</span><br><span class="line">Do = Dog()</span><br><span class="line"><span class="comment"># Per.sayHello()</span></span><br><span class="line"><span class="comment"># Pi.sayHello()</span></span><br><span class="line"><span class="comment"># Do.sayHello()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多态性:同一种调用方式,返回不同的结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">o</span>):  <span class="comment">#python是动态语言,o是多态性的体现,这里不需要指定类型,参数的类型由调用者传的值决定</span></span><br><span class="line">    o.sayHello()</span><br><span class="line"></span><br><span class="line">func(Per)</span><br><span class="line">func(Pi)</span><br><span class="line">func(Do)</span><br><span class="line"></span><br><span class="line"><span class="comment">#多态的好处</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>): <span class="comment">#继承父类Animal重新定义子类Cat</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;mimi,i am Cat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个Cat的对象ca</span></span><br><span class="line">ca = Cat()</span><br><span class="line">func(ca)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多态的好处:</span></span><br><span class="line"><span class="string">1.提高代码在外部调用灵活性</span></span><br><span class="line"><span class="string">2.提高代码的扩展性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="类属性和实例属性">类属性和实例属性</h1>
<h2 id="类属性">类属性</h2>
<h3 id="定义在类中定义的属性">定义：在类中定义的属性</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">    在类中定义的属性（公有和私有）</span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义一个人类，设置姓名和年龄属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;xiaoming&#x27;</span>  <span class="comment">#公有类属性</span></span><br><span class="line">    __age = <span class="number">12</span>          <span class="comment">#私有类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象p</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.name)  <span class="comment">#实例对象访问类的公有属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.name)  <span class="comment">#类对象访问类的公有属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__age)   <span class="comment">#实例对象访问类的私有属性   not ok</span></span><br><span class="line"><span class="built_in">print</span>(Person.__age) <span class="comment">##类对象访问类的私有属性 not ok </span></span><br></pre></td></tr></table></figure>
<h2 id="实例属性">实例属性</h2>
<h3
id="定义定义在init初始化方法中的属性">定义：定义在init初始化方法中的属性</h3>
<p>举个例子，什么是实例属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个人类，设置姓名，年龄和地址等属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    address = <span class="string">&#x27;上海市&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name  <span class="comment">#实例属性</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象pe</span></span><br><span class="line">pe = Person(<span class="string">&#x27;张三&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment"># print(pe.address)  #通过实例对象访问类属性</span></span><br><span class="line"><span class="comment"># print(pe.name)  #通过实例对象访问实例属性</span></span><br><span class="line"><span class="comment"># print(pe.age)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Person.address)    <span class="comment">#类在定义的时候已经产生了,类属性直接属于类</span></span><br><span class="line"><span class="built_in">print</span>(Person.name)  <span class="comment">#当实例化类创建对象,对属性赋值 实例属性才会产生内存里面 类访问不到实例属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="实例属性和类属性的关系同名的情况下实例属性会覆盖类属性">实例属性和类属性的关系：同名的情况下，实例属性会覆盖类属性</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.country = <span class="string">&#x27;上海市&#x27;</span> <span class="comment">#实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象p</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.country)  <span class="comment">#通过实例对象访问属性 输出“上海市”</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment">#类对象访问属性 输出“china”</span></span><br><span class="line"><span class="comment">#通过实例属性修改类属性的值</span></span><br><span class="line">p.country = <span class="string">&#x27;chinese&#x27;</span>  <span class="comment">#实例属性会屏蔽类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.country) <span class="comment"># 输出“chinese”</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment"># 输出“china”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> p.country  <span class="comment">#删除实例对象</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(p.country) <span class="comment"># 输出“china”，是类对象，不是实例对象</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment"># 输出“china”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类里面定义同名的实例属性和类属性,实例对象修改类属性,实例属性会屏蔽同名类属性</span></span><br><span class="line"><span class="comment">#实例属性优先级高于类属性</span></span><br></pre></td></tr></table></figure>
<h1 id="静态方法和类方法">静态方法和类方法</h1>
<h2 id="类方法">类方法</h2>
<h3 id="定义">定义</h3>
<p>概述: 类对象所拥有的方法，需要使用到修饰器 <span class="citation"
data-cites="classmethod">@classmethod</span>----&gt;类方法
对于类方法，第一个参数必须是类对象，一般以cls表示作为第一个参数（当然可以用其他的名字，但是不建议修改）</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 定义一个人类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCountry</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.country</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setCountry</span>(<span class="params">cls, country</span>):</span><br><span class="line">        cls.country = country</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Person对象</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.getCountry())  <span class="comment"># 通过实例对象访问类方法 输出“china”</span></span><br><span class="line"><span class="built_in">print</span>(Person.getCountry())  <span class="comment"># 通过类对象访问类方法 输出“china”</span></span><br><span class="line"></span><br><span class="line">p.setCountry(<span class="string">&#x27;chinese&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.getCountry()) <span class="comment"># 输出&quot;chinese&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Person.getCountry()) <span class="comment"># 输出“chinese”    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:类方法可以修改类属性</span></span><br></pre></td></tr></table></figure>
<h2 id="静态方法">静态方法</h2>
<h3
id="定义通过修饰器staticmethod来进行修饰不需要传参数">定义：通过修饰器@staticmethod来进行修饰，不需要传参数</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">   需要通过修饰器@<span class="built_in">staticmethod</span>来进行修饰，不需要传参数  </span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCountry</span>():</span><br><span class="line">        <span class="keyword">return</span> Person.country</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.getCountry())  <span class="comment">#通过实例对象访问静态方法</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>类方法:声明方法之前,需要使用到修饰器 <span class="citation"
data-cites="classmethod">@classmethod</span>,里面第一个参数类对象cls,类对象访问的是类属性或者类方法
实例方法:隐含传递的参数是self,对象本身,self访问的可能是实例属性,也有可能是类属性,类方法,静态方法
静态方法:声明方法之前,需要使用到修饰器@staticmethod，不需要加任何参数,访问的是类属性的引用,只能通过类对象调用</p>
<h1 id="slots__">__slots__</h1>
<h2 id="定义限制实例属性">定义：限制实例属性</h2>
<p>语法格式:<strong>slots</strong> = ('属性1','属性2')</p>
<p>__slots__属性限制添加属性只对当前类的实例对象起作用,对类属性,继承的子类实例对象不起作用的</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">动态语言：可以在运行的过程中，修改代码</span><br><span class="line">静态语言：编译时已经确定的代码，运行的时候不能修改</span><br><span class="line"></span><br><span class="line">如果我们想要限制实例属性？</span><br><span class="line">    允许对Person实例中添加name和age属性，</span><br><span class="line">    python允许定义<span class="keyword">class</span>的时候，定义一个特殊的变量----&gt;__slots__，限制<span class="keyword">class</span>能够添加的属性</span><br><span class="line">    </span><br><span class="line">语法格式:__slots__ = (<span class="string">&#x27;属性1&#x27;</span>,<span class="string">&#x27;属性2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#定义一个人类，只允许添加姓名和年龄属性    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">#限制当前类添加的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Student类创建对象stu</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="comment">#往对象里面添加属性</span></span><br><span class="line">stu.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">stu.sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu.name)</span><br><span class="line"><span class="built_in">print</span>(stu.sex)</span><br><span class="line"><span class="comment">#增加一个新的属性</span></span><br><span class="line"><span class="comment"># stu.weight = &#x27;80kg&#x27;  #报错,类中限制添加属性没有weight</span></span><br><span class="line"><span class="comment"># print(stu.weight)</span></span><br><span class="line">Student.weight = <span class="string">&#x27;50kg&#x27;</span> <span class="comment"># 添加类属性</span></span><br><span class="line"><span class="built_in">print</span>(stu.weight)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类demo,继承Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">d = Demo()</span><br><span class="line">d.height = <span class="string">&#x27;180&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.height)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意:__slots__属性限制添加属性只对当前类的实例对象起作用,对类属性,继承的子类实例对象不起作用的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="property"><span class="citation"
data-cites="property">@property</span></h1>
<h2
id="私有属性添加getter和setter方法">私有属性添加getter和setter方法</h2>
<p>python中和java类似的是私有属性不能直接修改，需要调用专门的方法才能修改；但python相对于java做出了优化，通过property函数创建一个特性（property），将
<code>getMoney</code> 方法作为获取属性值的方法，<code>setMoney</code>
方法作为设置属性值的方法。这样就可以像访问普通属性一样来访问
<code>Money</code> 类中的 <code>money</code> 属性</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个money类，设置一个私有的__money属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义对属性设置的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMoney</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value,<span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(value,<span class="built_in">float</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error:金额只能是整形或者浮点型&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义方法获取属性值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMoney</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加实例属性</span></span><br><span class="line">    money = <span class="built_in">property</span>(getMoney,setMoney)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Money类创建对象mo</span></span><br><span class="line">mo = Money()</span><br><span class="line"><span class="comment"># print(mo.__money)  #实例对象不能访问类的私有属性</span></span><br><span class="line">mo.setMoney(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(mo.getMoney()) <span class="comment"># 输出100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这两行代码看似是直接修改了对象的私有属性，实际上是先调用了getMoney和setMoney方法</span></span><br><span class="line">mo.money = <span class="number">500</span></span><br><span class="line"><span class="built_in">print</span>(mo.money) <span class="comment"># 输出500</span></span><br></pre></td></tr></table></figure>
<h2
id="使用property取代getter和setter方法">使用property取代getter和setter方法</h2>
<p>取代set/get------》修饰器-----》<span class="citation"
data-cites="property">@property</span> <span class="citation"
data-cites="property">@property</span>---&gt;属性函数，可以对属性赋值时候做必要的检查，并保证代码的清晰简短
作用： 1.将方法转化为只读
2.重新实现一个属性的设置和读取方法，可做边界判定</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):  <span class="comment">#相当于获取元素值方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line"><span class="meta">    @money.setter   </span><span class="comment">#money是上面取值的方法名  赋值的方法</span></span><br><span class="line">    <span class="comment"># @money.setter是一个装饰器，用于指定一个方法作为属性的设置方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value,<span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(value,<span class="built_in">float</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error:不是整形也不是浮点型&#x27;</span>)</span><br><span class="line">    <span class="comment"># 上面两个方法同名，第一个用来获取元素，第二个用来设置元素的值，然后在外界看起来虽然是私有属性的money和实例属性并无区别</span></span><br><span class="line"><span class="comment">#通过Money创建对象m</span></span><br><span class="line">m = Money()</span><br><span class="line"><span class="built_in">print</span>(m.money)</span><br><span class="line">m.money = <span class="number">16888</span></span><br><span class="line"><span class="built_in">print</span>(m.money)</span><br></pre></td></tr></table></figure>
<h1 id="发送邮件">发送邮件</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入邮件库</span></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="comment">#导入邮箱文本</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置邮箱服务器 qq/126/163/gmail/yahoo/阿里云</span></span><br><span class="line">SMTPServer = <span class="string">&#x27;smtp.163.com&#x27;</span></span><br><span class="line"><span class="comment">#设置发送邮箱的地址</span></span><br><span class="line">sender = <span class="string">&#x27;ztb0016@163.com&#x27;</span></span><br><span class="line"><span class="comment">#设置发送邮箱的通行码，不是密码</span></span><br><span class="line">password = <span class="string">&#x27;GTTULMLHIKOZSXIZ&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置发送的内容</span></span><br><span class="line">message = <span class="string">&#x27;你是一个好人123333...&#x27;</span></span><br><span class="line"><span class="comment">#转换成人能够看懂的格式</span></span><br><span class="line">msg = MIMEText(message)</span><br><span class="line"><span class="comment">#设置发送邮件的主题</span></span><br><span class="line">msg[<span class="string">&#x27;subject&#x27;</span>] = <span class="string">&#x27;来自一位帅哥的表白33333&#x27;</span></span><br><span class="line"><span class="comment">#发送者</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置邮箱服务器， 25表示的是端口</span></span><br><span class="line">emailServer = smtplib.SMTP(SMTPServer,<span class="number">25</span>)</span><br><span class="line"><span class="comment">#登录邮箱</span></span><br><span class="line">emailServer.login(sender,password)</span><br><span class="line"><span class="comment">#发送邮件的内容</span></span><br><span class="line">emailServer.sendmail(sender,[<span class="string">&#x27;piolet0016@gmail.com&#x27;</span>],msg.as_string())</span><br><span class="line"><span class="comment">#关闭邮箱</span></span><br><span class="line">emailServer.quit()</span><br></pre></td></tr></table></figure>
<h1 id="用列表模拟栈">用列表模拟栈</h1>
<p>append模拟入栈</p>
<p>pop模拟出栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">栈---&gt;有名堆栈</span></span><br><span class="line"><span class="string">原理:先进后出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">装子弹</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#使用列表模拟堆栈</span></span><br><span class="line"><span class="comment">#入栈</span></span><br><span class="line"><span class="comment"># stack = []</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;A&#x27;)</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;B&#x27;)</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;C&#x27;)</span></span><br><span class="line"><span class="comment"># print(stack)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #出栈</span></span><br><span class="line"><span class="comment"># stack.pop()</span></span><br><span class="line"><span class="comment"># print(stack)</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAllFileDir</span>(<span class="params">path</span>):</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="comment">#入栈</span></span><br><span class="line">    stack.append(path)</span><br><span class="line">    <span class="comment">#处理栈,当栈为空的时候结束操作</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#出栈</span></span><br><span class="line">        outDir = stack.pop()</span><br><span class="line">        <span class="comment">#获取当前目录所有文件</span></span><br><span class="line">        filelist = os.listdir(outDir)</span><br><span class="line">        <span class="comment">#判断哪些是目录,继续入栈,如果是文件直接打印</span></span><br><span class="line">        <span class="keyword">for</span> fileName <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment">#判断文件是否是路径(用绝对路径)</span></span><br><span class="line">            fileAbsPath = os.path.join(outDir,fileName)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(fileAbsPath):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;目录:&#x27;</span>,fileName)</span><br><span class="line">                <span class="comment">#入栈</span></span><br><span class="line">                stack.append(fileAbsPath)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;文本文件:&#x27;</span>,fileName)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getAllFileDir(<span class="string">&#x27;C:\python课程大纲\python课程大纲&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="专门模拟队列的">专门模拟队列的</h1>
<p>定义一个队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">queue = collections.deque()</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queue.append(path)</span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outDir = queus.popLeft()</span><br></pre></td></tr></table></figure>
<p>具体事例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">队列原理:先进先出</span></span><br><span class="line"><span class="string">#银行办理业务排队</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">collections</span></span><br><span class="line"><span class="string">deque()  创建一个队列</span></span><br><span class="line"><span class="string">append() 队列添加元素</span></span><br><span class="line"><span class="string">popLeft() 从队列里面删除元素</span></span><br><span class="line"><span class="string">len() 获取长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">listdir()获取当前目录下所有的文件</span></span><br><span class="line"><span class="string">isdir()判断是否是目录</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAllFileDir</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="comment">#创建一个队列</span></span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    <span class="comment">#入队</span></span><br><span class="line">    queue.append(path)</span><br><span class="line">    <span class="comment">#处理队列,如果队列为空结束操作</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#出队</span></span><br><span class="line">        outDir = queue.popleft()</span><br><span class="line">        <span class="comment">#获取当前目录下所有的文件</span></span><br><span class="line">        filelist = os.listdir(outDir)</span><br><span class="line">        <span class="comment">#判断哪些是目录,入队,如果是文件直接打印</span></span><br><span class="line">        <span class="keyword">for</span> fileName <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment">#判断是否是路径(用绝对路径)</span></span><br><span class="line">            fileAbsPath = os.path.join(outDir,fileName)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(fileAbsPath):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;目录:&#x27;</span>,fileName)</span><br><span class="line">                <span class="comment">#入队</span></span><br><span class="line">                queue.append(fileAbsPath)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;文本文件:&#x27;</span>,fileName)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getAllFileDir(<span class="string">&#x27;C:\python课程大纲\python课程大纲&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="高阶函数">高阶函数</h1>
<h2 id="map">map</h2>
<h3
id="定义根据提供的函数对指定的序列做映射">定义：根据提供的函数对指定的序列做映射</h3>
<h3 id="格式">格式</h3>
<p>map(function,iterable)
function---》函数，两个参数---》返回值是一个新的列表
iterable---》一个或者多个序列</p>
<p>python2:返回列表 python3:返回的是迭代器</p>
<h3 id="举例">举例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#案例1:计算列表各个元素的平方</span></span><br><span class="line"><span class="comment">#定义一个求平方的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">map</span>(square,li)  <span class="comment">#将li列表里面每个元素先作为square函数参数,获取每个元素平方,再执行map函数</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment">#输出&lt;map object at 0x000002C8C4875CC0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(res))   <span class="comment">#输出(1, 4, 9, 16)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))  <span class="comment">#输出[]</span></span><br><span class="line"><span class="comment">#案例2：将单个字符转换为对应的字面量整数</span></span><br><span class="line">li2 = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chrToInt</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>&#125;[<span class="built_in">str</span>]</span><br><span class="line">res2 = <span class="built_in">map</span>(chrToInt,li2)</span><br><span class="line"><span class="comment"># print(list(res2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例3：将整数元素的序列，转换为字符串类型</span></span><br><span class="line"><span class="comment">#[1,2,3,4]---&gt;[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span></span><br><span class="line">res3 = <span class="built_in">map</span>(<span class="built_in">str</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(res3))</span><br></pre></td></tr></table></figure>
<h2 id="reduce">reduce</h2>
<h3
id="定义reduce函数会对参数中的元素进行累积">定义：reduce()函数会对参数中的元素进行累积</h3>
<p>函数将一个数据集合(列表，元组)中的所有数据进行下列操作：用传给 reduce
中的函数 function（有两个参数）先对集合中的第 1、2
个元素进行操作，得到的结果再与第三个数据用 function
函数运算，最后得到一个结果。</p>
<h3 id="格式-1">格式：</h3>
<p>reduce(function,iterable,[initializer]) function:函数，有两个参数
iterable：可迭代的对象 initializer：可选，初始化参数</p>
<h3 id="举例-1">举例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment">#案例1:两个数的求和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">res = reduce(add,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2:获取每一个词出现的次数（空格）</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hello python hello php python aa ss aa&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">if</span> y <span class="keyword">in</span> x:</span><br><span class="line">        x[y] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[y] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">res3 = reduce(func,<span class="built_in">list</span>,&#123;&#125;)</span><br><span class="line"><span class="comment"># reduce 函数的工作流程是：</span></span><br><span class="line"><span class="comment"># 将初始值 &#123;&#125; 和列表中的第一个元素传递给函数 func 进行处理，得到一个新的结果。</span></span><br><span class="line"><span class="comment"># 将上一步的结果和列表中的下一个元素传递给函数 func 进行处理，得到另一个新的结果。</span></span><br><span class="line"><span class="comment"># 不断重复上述过程，直到列表中的所有元素都被处理完毕。</span></span><br><span class="line"><span class="comment"># 返回最终的结果，即字典，其中存储了每个单词的出现次数。</span></span><br><span class="line"><span class="built_in">print</span>(res3)</span><br></pre></td></tr></table></figure>
<h2 id="filter">filter</h2>
<h3 id="定义-1">定义</h3>
<p>filter()函数：用于过滤序列，过滤掉不符合条件的元素，返回由符合条件的元素组成的新列表</p>
<h3 id="格式-2">格式</h3>
<p>filter(function,iterable) function:函数 判断函数
iterable：序列，序列的每一个元素作为参数传递到函数进行判断，返回True,False,最后将返回True的元素存放到一个新的列表中</p>
<h3 id="返回值">返回值</h3>
<p>Pyhton2返回列表 Python3返回迭代器对象</p>
<h3 id="举个例子">举个例子</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例1:筛选指定的元素</span></span><br><span class="line">list01 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#案例1:将偶数筛选出来,奇数删除</span></span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">res = <span class="built_in">filter</span>(even,list01)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2:将没有爱好的信息过滤掉</span></span><br><span class="line">list02 = [[<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;爱好&#x27;</span>],[<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;无&#x27;</span>],[<span class="string">&#x27;laowang&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;写代码&#x27;</span>],[<span class="string">&#x27;xiaogang&#x27;</span>,<span class="number">29</span>,<span class="string">&#x27;无&#x27;</span>]]</span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v == <span class="string">&#x27;无&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> list02:</span><br><span class="line">    res2 = <span class="built_in">filter</span>(test,line)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res2))</span><br><span class="line"><span class="comment">#使用匿名函数</span></span><br><span class="line">res4 = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x.isdigit(),L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res4))</span><br></pre></td></tr></table></figure>
<h2 id="sorted">sorted</h2>
<h3 id="定义-2">定义</h3>
<p>sorted()函数对所有的可迭代的对象进行排序的操作 sort:
方法返回的是对已经存在的列表进行操作
sorted:返回值为一个新的list，而不是在原来的基础上进行的操作。</p>
<h3 id="格式-3">格式</h3>
<p>sorted(iterable[, cmp[, key[, reverse]]]) iterable:可迭代的对象 cmp
---》比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
key
---》主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
reverse ---》 排序规则，reverse = True 降序 ， reverse = False
升序（默认）。</p>
<h3 id="举个例子-1">举个例子</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">99</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">111</span>]</span><br><span class="line">lst.sort()</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line">res = <span class="built_in">sorted</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#key接受一个内置函数进行排序</span></span><br><span class="line">lst2 = [-<span class="number">3</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">111</span>,-<span class="number">200</span>]</span><br><span class="line">lst2.sort()</span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br><span class="line">res2 = <span class="built_in">sorted</span>(lst2,key=<span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第四周-面向对象</title>
    <url>/posts/2cc950a3.html</url>
    <content><![CDATA[<h1 id="定义一个类">定义一个类</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):	<span class="comment">#objectobject 是所有类的基类，也称为顶级类或根类。在定义类时，如果没有明确指定继承的父类，则默认继承自 object 类，可以省略</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):	<span class="comment"># self 是一个惯用的命名约定，用来表示对象自身。在类的方法定义中，self 参数指向类的实例，也就是调用该方法的对象本身。通过 self，可以在方法内部访问和操作对象的属性和方法。是 Python 中定义类方法的标准做法，不可省略</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self</span>):</span><br></pre></td></tr></table></figure>
<h1 id="类中几种常见方法">类中几种常见方法</h1>
<h2
id="init__方法类似与java类的构造函数">__init__方法（类似与java类的构造函数）</h2>
<h2
id="del方法删除对象时自动调用在对一个对象引用次数为0才算彻底删除">del()方法：删除对象时自动调用，在对一个对象引用次数为0才算彻底删除</h2>
<p>举个例子</p>
<p>定义一个动物的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法  创建对象时候自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;__init__方法被调用&#x27;)</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会跑&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个析构方法  删除对象的时候自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;__del__方法被调用&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s对象被干掉&#x27;</span>%(self.name))</span><br></pre></td></tr></table></figure>
<p>然后实例化一个猫的对象，并且多次引用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cat = Animal(<span class="string">&#x27;波斯猫&#x27;</span>)</span><br><span class="line">cat2 = cat</span><br><span class="line">cat3 = cat</span><br></pre></td></tr></table></figure>
<p>发现创建了多个cat对象</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220170553004.png" /></p>
<p>如果只删除一个，另外两个还存在</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220170715549.png" /></p>
<h2
id="魔法方法python中的一种特殊方法它们以双下划线开头和结尾例如-__init____str____add__-等这些方法在特定的情况下会被python解释器自动调用而不需要我们显式地调用它们">魔法方法：Python中的一种特殊方法，它们以双下划线开头和结尾，例如
<code>__init__</code>、<code>__str__</code>、<code>__add__</code>
等。这些方法在特定的情况下会被Python解释器自动调用，而不需要我们显式地调用它们。</h2>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法  创建对象的时候被自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,newColor,newWheelNum</span>):</span><br><span class="line">        self.color = newColor</span><br><span class="line">        self.wheelNum = newWheelNum</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个析构方法  删除对象的时候被自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s对象被删除&#x27;</span>%(self.color))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个魔方方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># msg = &#x27;%s-%d&#x27;%(self.color,self.wheelNum)</span></span><br><span class="line">        <span class="comment"># return msg</span></span><br><span class="line">        <span class="keyword">return</span> self.color</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个对象laosi</span></span><br><span class="line">laosi = Car(<span class="string">&#x27;红色&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 通过print打印对象的时候,如果类中定义__str__方法,自动调用,一般方便查看类中属性值</span></span><br><span class="line"><span class="built_in">print</span>(laosi)</span><br><span class="line"><span class="comment"># 后面做开发的时候,想直接返回对象中属性值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#总结:如果类的属性比较多,可以重写__str__()方法打印属性,方便阅读,无需手动调用,当使用print打印对象的时候,自动调用</span></span><br></pre></td></tr></table></figure>
<p>定义一个魔法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.color</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220172039437.png" /></p>
<p>如果类的属性比较多,可以重写__str__()方法打印属性,方便阅读,无需手动调用,当使用print打印对象的时候,自动调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    msg = <span class="string">&#x27;%s-%d&#x27;</span>%(self.color,self.wheelNum)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220172155163.png" /></p>
<h2 id="str和repr">str()和repr()</h2>
<h3
id="str_用于将数值转化为人阅读的形式调用print的时候自动调用">_<strong>str</strong>_()用于将数值转化为人阅读的形式，调用print的时候自动调用</h3>
<h3
id="repr__用于转化为解释器读取的形式">__repr__()用于转化为解释器读取的形式</h3>
<p>注：在没有__str__的时候，认为str == repr</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前的时间</span></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(now)</span><br><span class="line"><span class="comment"># output 2024-02-05 22:12:48.663497</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(now))</span><br><span class="line"><span class="comment"># output &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(now))  <span class="comment">#转换成字符串</span></span><br><span class="line"><span class="comment"># output: 2024-02-05 22:12:48.663497</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(now)))</span><br><span class="line"><span class="comment"># output: &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(now))</span><br><span class="line"><span class="comment"># output: datetime.datetime(2024, 2, 5, 22, 12, 48, 663497)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(now)))  <span class="comment">#eval参数是字符串表达式 repr(now)当成整体作为参数执行 再返回repr之后的结果</span></span><br><span class="line"><span class="comment"># output: 2024-02-05 22:12:48.663497</span></span><br></pre></td></tr></table></figure>
<p>总结: repr返回的是字符串,一般用来获取对象</p>
<p>obj == eval(repr(obj)) 这个公式是成立的</p>
<h1 id="继承">继承</h1>
<h2 id="定义">定义</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    attribute1, attribute2</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):	<span class="comment"># 表示B继承A</span></span><br></pre></td></tr></table></figure>
<p>如果有两个类,一个父类,一个子类,定义了同名的方法,如果实例化子类对象调用方法的时候先从子类查找
，再一级一级往上查找</p>
<h2 id="初始化">初始化</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人都需要吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我会汉语&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义子类Student继承父类Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,name,age,sex</span>):</span><br><span class="line">        self.no = no</span><br><span class="line">        <span class="comment"># 调用父类同名方法</span></span><br><span class="line">        <span class="comment"># 1.父类类名.父类方法</span></span><br><span class="line">        <span class="comment"># Person.__init__(self,name,age,sex)  直接调用父类的初始化方法，并将 self（当前实例）以及需要传递的参数传递给它。</span></span><br><span class="line">        <span class="comment"># 2.super()</span></span><br><span class="line">        <span class="comment"># super().__init__(name,age,sex) 使用 super() 函数获取父类的引用，并调用其初始化方法，无需手动传递 self，它会自动传递。</span></span><br><span class="line">        <span class="built_in">super</span>(Student, self).__init__(name,age,sex)</span><br><span class="line">        <span class="comment"># 调用父类 Person 的 __init__ 方法，以便在创建 Student 对象时对父类属性进行初始化。</span></span><br></pre></td></tr></table></figure>
<h1 id="访问限制">访问限制</h1>
<h2
id="私有就是按java中私有属性的来理解">私有，就是按java中私有属性的来理解</h2>
<p>__双下划线后面跟属性名</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,money</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法对属性设置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="comment">#数据过滤</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(value) &lt;= <span class="number">4</span>:</span><br><span class="line">            self.__name = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;名称的长度不能大于4个字符&#x27;</span>)</span><br><span class="line">    <span class="comment">#定义普通方法获取属性值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我的名字是:%s,我有%s存款&#x27;</span>%(self.__name,self._money))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义公有方法获取私有属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        self.__sayHello()</span><br></pre></td></tr></table></figure>
<h2 id="半公开_单下划线后面跟属性名">半公开：_单下划线后面跟属性名</h2>
<h2 id="公开直接属性名">公开：直接属性名</h2>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟环境</title>
    <url>/posts/48543190.html</url>
    <content><![CDATA[<p>conda管理环境下pip的安装路径</p>
<p>默认conda下用pip安装的路径都会在一个地方</p>
<p><a
href="https://blog.csdn.net/mukvintt/article/details/80908951">参考文章</a></p>
<p>另外关于vir管理问题就比较迷惑了</p>
<p>我将C:3个G的文件移动到其他盘就报错，必须把它移会来</p>
<p>报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OSError: [WinError 649] 创建操作失败，因为名称含有至少一个装入点</span><br></pre></td></tr></table></figure>
<p>正常pip的虚拟环境就配置在venv里面</p>
<p>比如安装numpy后</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126232333231.png" /></p>
<p>哦原来如此，上面提到的放的是缓存，可以删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip cache purge</span><br></pre></td></tr></table></figure>
<p>修改pip安装包的位置</p>
<p>/home/ztb/.conda/envs/FaceXray_env2/lib/python3.6/site.py</p>
]]></content>
  </entry>
  <entry>
    <title>调试</title>
    <url>/posts/aaf56f78.html</url>
    <content><![CDATA[<h1 id="调试">调试</h1>
<h2 id="断言assert">断言assert</h2>
<p>等价于： if not expression: raise AssertError</p>
<h2 id="logging">logging</h2>
<h3 id="导入">导入</h3>
<h3 id="配置">配置</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(</span><br><span class="line">    filename</span><br><span class="line">    filenode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="种类">种类</h3>
<p>debug，error， info，warning</p>
<h2 id="pdb">pdb</h2>
<p>可以在终端调试代码</p>
<h1 id="单元测试">单元测试</h1>
<p>概述： 单元测试：
用来对一个函数，一个类或者一个模块来进行一个正确性的校验工作</p>
<p>结果： 1.单元测试通过：说明测试的函数功能正常
2.单元测试不通过：函数有BUG，测试条件输入有误</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>接口与继承</title>
    <url>/posts/d3f99f79.html</url>
    <content><![CDATA[<h1 id="接口">接口</h1>
<span id="more"></span>
<p><strong>接口就像是一种约定</strong>，我们约定某些英雄是物理系英雄，那么他们就一定能够进行物理攻击。</p>
<h2 id="创建接口">创建接口</h2>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface AD &#123;</span><br><span class="line">        //物理伤害</span><br><span class="line">    public void physicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口">实现接口</h2>
<p><strong>实现某个接口，就相当于承诺了某种约定</strong></p>
<p>所以，<strong>实现</strong>了<strong>AD</strong>这个接口，就<strong>必须</strong>提供AD接口中声明的方法<strong>physicAttack()</strong>
<strong>实现</strong>在语法上使用关键字 <strong>implements</strong></p>
<h2 id="默认方法">默认方法</h2>
<h3 id="定义">定义</h3>
<p>接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface Mortal &#123;</span><br><span class="line">    public void die();</span><br><span class="line"> </span><br><span class="line">    default public void revive() &#123;</span><br><span class="line">        System.out.println(&quot;本英雄复活了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么会有默认方法">为什么会有默认方法</h3>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
<h1 id="对象转型">对象转型</h1>
<h2 id="引用类型与对象类型">引用类型与对象类型</h2>
<p>在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad
对象是有类型的， 是ADHero 引用也是有类型的，是ADHero
通常情况下，引用类型和对象类型是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向上转型">向上转型</h2>
<h3 id="子类转父类">子类转父类</h3>
<p>一个很简单的判别办法
<font color = "red"><strong>把右边的当做左边来用</strong>，看说得通不</font></p>
<p>所有的<strong>子类转换为父类</strong>，都是说得通的</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;   </span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        Hero h = new Hero();//h引用的类型是Hero</span><br><span class="line">        ADHero ad = new ADHero();//ad引用的类型是ADHero</span><br><span class="line">        h = ad; //把ADHero当做Hero使用，一定可以         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类转换接口">类转换接口</h3>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">          </span><br><span class="line">        AD adi = ad;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从语义上来讲，把一个ADHero当做AD来使用，而AD接口只有一个physicAttack方法，这就意味着转换后就有可能要调用physicAttack方法，而ADHero一定是有physicAttack方法的，所以转换是能成功的。</p>
<h2 id="向下转型">向下转型</h2>
<h3 id="父类转子类">父类转子类</h3>
<p>父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。
强制转换的意思就是 转换有风险，风险自担。</p>
<h3 id="接口转实现类">接口转实现类</h3>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">     </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">         </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">            </span><br><span class="line">        AD adi = ad;	//ad引用指向ADHero， 而adi引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功</span><br><span class="line">   </span><br><span class="line">        ADHero adHero = (ADHero) adi;	//adi实际上是指向一个ADHero的，所以能够转换成功</span><br><span class="line">            </span><br><span class="line">        ADAPHero adapHero = (ADAPHero) adi;	// adi引用所指向的对象是一个ADHero，要转换为ADAPHero就会失败。</span><br><span class="line">        adapHero.magicAttack();</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口要先向下转型成为一个类，这个接口实际上已经只想一个类(应该不全，有空看看文章)</p>
<p>所以继承并实现这个接口的类才有可能让接口向下转型，与这个接口没有继承关系的类一定不能</p>
<h2 id="instanceof">instanceof</h2>
<p>判断一个引用所指向的对象</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">        APHero ap = new APHero();</span><br><span class="line">         </span><br><span class="line">        Hero h1= ad;</span><br><span class="line">        Hero h2= ap;</span><br><span class="line">         </span><br><span class="line">        //判断引用h1指向的对象，是否是ADHero类型</span><br><span class="line">        System.out.println(h1 instanceof ADHero);</span><br><span class="line">         </span><br><span class="line">        //判断引用h2指向的对象，是否是APHero类型</span><br><span class="line">        System.out.println(h2 instanceof APHero);</span><br><span class="line">         </span><br><span class="line">        //判断引用h1指向的对象，是否是Hero的子类型</span><br><span class="line">        System.out.println(h1 instanceof Hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态">多态</h1>
<h2 id="操作符的多态">操作符的多态</h2>
<p>如果+号两侧都是整型，那么<strong>+代表 数字相加</strong>
如果+号两侧，任意一个是字符串，那么<strong>+代表字符串连接</strong></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        int i = 5;</span><br><span class="line">        int j = 6;</span><br><span class="line">        int k = i+j; //如果+号两侧都是整型，那么+代表 数字相加</span><br><span class="line">         </span><br><span class="line">        System.out.println(k);</span><br><span class="line">         </span><br><span class="line">        int a = 5;</span><br><span class="line">        String b = &quot;5&quot;;</span><br><span class="line">         </span><br><span class="line">        String c = a+b; //如果+号两侧，任意一个是字符串，那么+代表字符串连接</span><br><span class="line">        System.out.println(c);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的多态">类的多态</h2>
<p>同一个类型，调用同一个方法，却能呈现不同的状态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Item i1= new LifePotion();	// i1实际上指向LifePotion这种对象</span><br><span class="line">Item i2 = new MagicPotion();	//i2实际上指向MagicPotion这种对象</span><br><span class="line">System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;);	//i1调用LifePotion对象中方法</span><br><span class="line">i1.effect();</span><br><span class="line">System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);		//i2调用MagicPotion对象中effect方法</span><br><span class="line">i2.effect();</span><br></pre></td></tr></table></figure>
<h3 id="类的多态条件">类的多态条件</h3>
<ol type="1">
<li>父类（接口）引用指向子类对象</li>
<li>调用的方法有重写</li>
</ol>
<h2 id="使用多态与不使用多态区别">使用多态与不使用多态区别</h2>
<p>不使用多态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void useLifePotion(LifePotion lp)&#123;</span><br><span class="line">    lp.effect();</span><br><span class="line">&#125;</span><br><span class="line">public void useMagicPotion(MagicPotion mp)&#123;</span><br><span class="line">    mp.effect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useLifePotion(LifePotion lp)&#123;</span><br><span class="line">        lp.effect();</span><br><span class="line">    &#125;</span><br><span class="line">    public void useMagicPotion(MagicPotion mp)&#123;</span><br><span class="line">        mp.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp =new LifePotion();</span><br><span class="line">        MagicPotion mp =new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useLifePotion(lp);</span><br><span class="line">        garen.useMagicPotion(mp);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用多态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void useItem(Item i)&#123;</span><br><span class="line">    i.effect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp =new LifePotion();</span><br><span class="line">        MagicPotion mp =new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useItem(lp);</span><br><span class="line">        garen.useItem(mp);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exercise</p>
<ol type="1">
<li>设计一个接口</li>
</ol>
<p>接口叫做Mortal,其中有一个方法叫做die</p>
<ol start="2" type="1">
<li>实现接口</li>
</ol>
<p>分别让ADHero,APHero,ADAPHero这三个类，实现Mortal接口，不同的类实现die方法的时候，都打印出不一样的字符串</p>
<ol start="3" type="1">
<li><p>为Hero类，添加一个方法,在这个方法中调用 m的die方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void kill(Mortal m)</span><br></pre></td></tr></table></figure></li>
<li><p>在主方法中 首先实例化出一个Hero对象:盖伦
然后实例化出3个对象，分别是ADHero,APHero,ADAPHero的实例 然后让盖伦 kill
这3个对象</p></li>
</ol>
<p>answer</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void kill(Mortal m) &#123;</span><br><span class="line">    m.die();</span><br><span class="line">&#125;</span><br><span class="line">    ADHero shibing1 = new ADHero();</span><br><span class="line">    APHero shibing2 = new APHero();</span><br><span class="line">    ADAPHero shibing3 = new ADAPHero();</span><br><span class="line">    garen.kill(shibing1);</span><br><span class="line">    garen.kill(shibing2);</span><br><span class="line">    garen.kill(shibing3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面在尝试的时候发现只能在声明shibing的时候必须用对应的类或者声明成接口类型Mortal，如果声明成Hero类型会报错。个人理解原因是Hero与Mortal之间没有继承关系</p>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void kill(Mortal m) &#123;</span><br><span class="line">        m.die();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line"></span><br><span class="line">        Mortal shibing1 = new ADHero();</span><br><span class="line">        Mortal shibing2 = new APHero();</span><br><span class="line">        Mortal shibing3 = new ADAPHero();</span><br><span class="line">        garen.kill(shibing1);</span><br><span class="line">        garen.kill(shibing2);</span><br><span class="line">        garen.kill(shibing3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="隐藏">隐藏</h1>
<p>与重写类似，方法的<strong>重写是</strong>子类覆盖父类的<strong>对象方法</strong></p>
<p><strong>隐藏</strong>，就是子类覆盖父类的<strong>类方法</strong></p>
<p><font color = "red">子类中的静态方法覆盖率父类中的静态方法</font></p>
<p>举例：</p>
<p>父类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    //类方法，静态方法</span><br><span class="line">    //通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;hero battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //隐藏父类的battleWin方法</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;ad hero battle win&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exercise:</p>
<p>Hero h =new ADHero();</p>
<p>h.battleWin(); //battleWin是一个类方法 h是父类类型的引用
但是指向一个子类对象 h.battleWin();
会调用父类的方法？还是子类的方法？</p>
<p>answer:</p>
<p><font color = "red">静态方法与类直接关联，而不是与实例对象关联</font>。所以声明为Hero的类，就调用Hero的类方法</p>
<h1 id="super关键字">super关键字</h1>
<h2 id="父类显式提供无参构造方法">父类显式提供无参构造方法</h2>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Hero()&#123;</span><br><span class="line">    System.out.println(&quot;Hero的构造方法 &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; //姓名</span><br><span class="line">        </span><br><span class="line">    float hp; //血量</span><br><span class="line">        </span><br><span class="line">    float armor; //护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化子类，父类的构造方法一定会被调用</p>
<p>实例化一个ADHero(), 其构造方法会被调用
其<strong>父类的构造方法也会被调用</strong>
并且是父类构造方法<strong>先调用</strong> 子类构造方法会默认调用父类的
无参的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ADHero()&#123;</span><br><span class="line">     </span><br><span class="line">    System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">new ADHero();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完整代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero()&#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hero的构造方法 </span><br><span class="line">AD Hero的构造方法</span><br></pre></td></tr></table></figure>
<h2 id="父类显式提供两个构造方法">父类显式提供两个构造方法</h2>
<p>分别是无参的构造方法和带一个参数的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Hero()&#123;</span><br><span class="line">    System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public Hero(String name)&#123;</span><br><span class="line">    System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; //姓名</span><br><span class="line">        </span><br><span class="line">    float hp; //血量</span><br><span class="line">        </span><br><span class="line">    float armor; //护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类显式调用父类带参构造方法</p>
<p>使用关键字<strong>super</strong> 显式调用父类带参的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ADHero(String name)&#123;</span><br><span class="line">    super(name);</span><br><span class="line">    System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ADHero(&quot;德莱文&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用父类属性</p>
<h1 id="objext类">Objext类</h1>
<p>Object类是所有类的父类</p>
<h2 id="tostring">toString()</h2>
<p>toString()的意思是返回当前对象的<strong>字符串表达</strong></p>
<p>举例说明</p>
<p>直接调用原式版本的toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">//    public String toString()&#123;</span><br><span class="line">//        return name;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero h = new Hero();</span><br><span class="line">        h.name = &quot;盖伦&quot;;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        //直接打印对象就是打印该对象的toString()返回值</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero h = new Hero();</span><br><span class="line">        h.name = &quot;盖伦&quot;;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        //直接打印对象就是打印该对象的toString()返回值</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize()</h2>
<p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。</p>
<p>举例</p>
<h2 id="equals">equals()</h2>
<p>equals() 用于判断两个对象的内容是否相同</p>
<p>原始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">//    public boolean equals(Object o)&#123;</span><br><span class="line">//        if(o instanceof Hero)&#123;</span><br><span class="line">//            Hero h = (Hero) o;</span><br><span class="line">//            return this.hp == h.hp;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return false;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1.equals(h2));</span><br><span class="line">        System.out.println(h1.equals(h3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>改写：</p>
<p>假设，当两个英雄的hp相同的时候，我们就认为这两个英雄相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h = (Hero) o;</span><br><span class="line">            return this.hp == h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1.equals(h2));</span><br><span class="line">        System.out.println(h1.equals(h3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section">==</h2>
<p>这不是Object的方法，但是用于判断两个对象是否相同
<strong>更准确的讲</strong>，用于判断两个引用，是否指向了同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h = (Hero) o;</span><br><span class="line">            return this.hp == h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1==h2);</span><br><span class="line">        System.out.println(h1==h3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<h1 id="final">final</h1>
<h2 id="final修饰类">final修饰类</h2>
<p>当Hero被修饰成final的时候，表示Hero不能够被继承
其子类会出现编译错误</p>
<h2 id="final修饰方法">final修饰方法</h2>
<p>父类中被final修饰的方法不能在子类中重写</p>
<h2 id="final修饰基本类型变量">final修饰基本类型变量</h2>
<p>final修饰基本类型变量，表示该变量只有一次赋值机会</p>
<h2 id="final修饰引用">final修饰引用</h2>
<p>final修饰引用
h引用被修饰成final，表示该引用只有<strong>1</strong>次指向对象的机会</p>
<h1 id="抽象类">抽象类</h1>
<h2 id="定义-1">定义</h2>
<p>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</p>
<p>这样的方法就叫抽象方法，使用修饰符“abstract"</p>
<p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p>
<p><font color = "red">抽象类可以没有抽象方法，一旦一个类被声明为抽象类，就不能够被直接实例化</font></p>
<h2 id="与子类的关系">与子类的关系</h2>
<p>为Hero增加一个<strong>抽象方法
attack</strong>，并且把Hero声明为abstract的。继承Hero类后，这些<strong>子类就必须提供</strong>不一样的attack方法实现。</p>
<h2 id="抽象类和接口的区别">抽象类和接口的区别</h2>
<p>区别1：</p>
<ul>
<li><p>子类只能继承一个抽象类，不能继承多个</p></li>
<li><p>子类可以实现<strong>多个</strong>接口</p></li>
</ul>
<p>区别2：</p>
<ul>
<li>抽象类可以定义
public,protected,package,private、静态和非静态属性、final和非final属性</li>
<li>接口中声明的属性，即便没有显式的声明，也只能是public、静态和final</li>
</ul>
<h1 id="内部类">内部类</h1>
<h2 id="非静态内部类">非静态内部类</h2>
<h3 id="定义-2">定义：</h3>
<p>非静态内部类可以直接在一个类里面定义</p>
<h3 id="语法">语法</h3>
<p><strong>new 外部类().new 内部类()</strong></p>
<h3 id="使用">使用</h3>
<p>作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name<strong>的</strong></p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">class BattleScore &#123;</span><br><span class="line">    int kill;</span><br><span class="line">    int die;</span><br><span class="line">    int assit;</span><br><span class="line"> </span><br><span class="line">    public void legendary() &#123;</span><br><span class="line">        if (kill &gt;= 8)</span><br><span class="line">            System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        // 实例化内部类</span><br><span class="line">    // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    // 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">    BattleScore score = garen.new BattleScore();</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private String name; // 姓名</span><br><span class="line"> </span><br><span class="line">    float hp; // 血量</span><br><span class="line"> </span><br><span class="line">    float armor; // 护甲</span><br><span class="line"> </span><br><span class="line">    int moveSpeed; // 移动速度</span><br><span class="line"> </span><br><span class="line">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    // 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    class BattleScore &#123;</span><br><span class="line">        int kill;</span><br><span class="line">        int die;</span><br><span class="line">        int assit;</span><br><span class="line"> </span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;= 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen = new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">        // 实例化内部类</span><br><span class="line">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        // 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">        BattleScore score = garen.new BattleScore();</span><br><span class="line">        score.kill = 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类">静态内部类</h2>
<h3 id="定义-3">定义</h3>
<p>与非静态内部类不同，<strong>静态内部类</strong>水晶类的实例化
<strong>不需要一个外部类的实例为基础</strong>，可以直接实例化</p>
<h3 id="语法-1">语法</h3>
<p><strong>new 外部类.静态内部类();</strong></p>
<h3 id="使用-1">使用</h3>
<p>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong>
除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class EnemyCrystal&#123;</span><br><span class="line">    int hp=5000;</span><br><span class="line">     </span><br><span class="line">    //如果水晶的血量为0，则宣布胜利</span><br><span class="line">    public void checkIfVictory()&#123;</span><br><span class="line">        if(hp==0)&#123;</span><br><span class="line">            Hero.battleWin();</span><br><span class="line">             </span><br><span class="line">            //静态内部类不能直接访问外部类的对象属性</span><br><span class="line">            System.out.println(name + &quot; win this game&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        //实例化静态内部类</span><br><span class="line">    Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    private static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //敌方的水晶</span><br><span class="line">    static class EnemyCrystal&#123;</span><br><span class="line">        int hp=5000;</span><br><span class="line">         </span><br><span class="line">        //如果水晶的血量为0，则宣布胜利</span><br><span class="line">        public void checkIfVictory()&#123;</span><br><span class="line">            if(hp==0)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                //静态内部类不能直接访问外部类的对象属性</span><br><span class="line">                System.out.println(name + &quot; win this game&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //实例化静态内部类</span><br><span class="line">        Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名类">匿名类</h2>
<h3 id="定义-4">定义</h3>
<ol type="1">
<li>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练
通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</li>
<li>有的时候，为了快速使用，<font color = "red">直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。</font>
既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。
<font color = "red">这样的类，叫做匿名类</font></li>
<li>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</li>
</ol>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; //姓名</span><br><span class="line">          </span><br><span class="line">    float hp; //血量</span><br><span class="line">          </span><br><span class="line">    float armor; //护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh=new ADHero();</span><br><span class="line">        //通过打印adh，可以看到adh这个对象属于ADHero类</span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        Hero h = new Hero()&#123;</span><br><span class="line">            //当场实现attack方法</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本地类">本地类</h2>
<h3 id="定义-5">定义</h3>
<p>本地类可以理解为<font color = "red">有名字的匿名类</font>,可以直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//与匿名类的区别在于，本地类有了自定义的类名</span><br><span class="line">class SomeHero extends Hero&#123;</span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        System.out.println( name+ &quot; 新的进攻手段&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; //姓名</span><br><span class="line">          </span><br><span class="line">    float hp; //血量</span><br><span class="line">          </span><br><span class="line">    float armor; //护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        //与匿名类的区别在于，本地类有了自定义的类名</span><br><span class="line">        class SomeHero extends Hero&#123;</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println( name+ &quot; 新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        SomeHero h  =new SomeHero();</span><br><span class="line">        h.name =&quot;地卜师&quot;;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="uml图">UML图</h1>
<h2 id="类图">类图</h2>
<p><img src="https://stepimagewm.how2j.cn/2318.png" /></p>
<h2 id="接口图">接口图</h2>
<p><img src="https://stepimagewm.how2j.cn/2319.png" /></p>
<h2 id="继承关系">继承关系</h2>
<p><img src="https://stepimagewm.how2j.cn/2320.png" /></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>数字与字符串</title>
    <url>/posts/37035380.html</url>
    <content><![CDATA[<h1 id="装箱和拆箱">装箱和拆箱</h1>
<span id="more"></span>
<h2 id="封装类">封装类</h2>
<p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong>
比如int对应的类是Integer 这种类就叫做封装类</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">         </span><br><span class="line">        //把一个基本类型的变量,转换为Integer对象</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">        //把一个Integer对象，转换为一个基本类型的int</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="number类">Number类</h2>
<p>数字封装类有 Byte,Short,Integer,Long,Float,Double
这些类都是抽象类Number的子类</p>
<h2 id="基本类型转封装类">基本类型转封装类</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装类转基本类型">封装类转基本类型</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">        //封装类型转换成基本类型</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动装箱">自动装箱</h2>
<p>不需要调用构造方法，<strong>通过=符号自动</strong>把 基本类型 转换为
类类型 就叫装箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">        //自动转换就叫装箱</span><br><span class="line">        Integer it2 = i;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动拆箱">自动拆箱</h2>
<p>不需要调用Integer的intValue方法，通过=就自动转换成int类型，就叫拆箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">  </span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">          </span><br><span class="line">        //封装类型转换成基本类型</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">        //自动转换就叫拆箱</span><br><span class="line">        int i3 = it;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串转换">字符串转换</h1>
<h2 id="数字转字符串">数字转字符串</h2>
<p>先把基本类型装箱为类对象，然后调用类对象的静态方法toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">         </span><br><span class="line">        //方法1</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        //方法2</span><br><span class="line">        Integer it = i;</span><br><span class="line">        String str2 = it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转数字">字符串转数字</h2>
<p>调用类对象的静态方法parseInt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String str = &quot;999&quot;;</span><br><span class="line">         </span><br><span class="line">        int i= Integer.parseInt(str);</span><br><span class="line">         </span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学方法">数学方法</h1>
<h2 id="四舍五入-随机数开方次方π自然常数">四舍五入,
随机数，开方，次方，π，自然常数</h2>
<h3 id="四舍五入round">四舍五入round</h3>
<h3 id="随机数random">随机数random</h3>
<h3 id="开方sqrt">开方sqrt</h3>
<h3 id="次方pow">次方pow</h3>
<h3 id="π">π</h3>
<h3 id="自然常数e">自然常数e</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">5.4f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">5.5f</span>;</span><br><span class="line">        <span class="comment">//5.4四舍五入即5</span></span><br><span class="line">        System.out.println(Math.round(f1));</span><br><span class="line">        <span class="comment">//5.5四舍五入即6</span></span><br><span class="line">        System.out.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-1之间的随机浮点数（取不到1）</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-10之间的随机整数 （取不到10）</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)( Math.random()*<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//开方</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        <span class="comment">//次方（2的4次方）</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//π</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自然常数</span></span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="格式化输出">格式化输出</h1>
<h2 id="printf和format">printf和format</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String name =&quot;盖伦&quot;;</span><br><span class="line">        int kill = 8;</span><br><span class="line">        String title=&quot;超神&quot;;</span><br><span class="line">         </span><br><span class="line">        String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">        //使用printf格式化输出</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">        //使用format格式化输出</span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="总长度左对齐补0千位分隔符小数点位数本地化表达">总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2020</span>;</span><br><span class="line">        <span class="comment">//总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接打印数字</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,默认右对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,左对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%-8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,不够补0</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%08d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//千位分隔符</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%,8d%n&quot;</span>,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//小数点位数</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%.2f%n&quot;</span>,Math.PI);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//不同国家的千位分隔符</span></span><br><span class="line">        System.out.format(Locale.FRANCE,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.US,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.UK,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符">字符</h1>
<h2 id="常用方法">常用方法</h2>
<h3 id="是否是字母isletter">是否是字母isLetter</h3>
<h3 id="是否为数字isdigit">是否为数字isDigit</h3>
<h3 id="是否是空白iswhitespace">是否是空白isWhiteSpace</h3>
<h3 id="是否是大写isuppercase">是否是大写isUpperCase</h3>
<h3 id="是否是小写islowercase">是否是小写isLowerCase</h3>
<h3 id="转换为大写touppercase">转换为大写toUpperCase</h3>
<h3 id="转换为小写tolowercase">转换为小写toLowerCase</h3>
<h3 id="转换为字符串tostring">转换为字符串toString</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是否为字母</span></span><br><span class="line">        System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//判断是否为数字</span></span><br><span class="line">        System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>)); <span class="comment">//是否是空白</span></span><br><span class="line">        System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是大写</span></span><br><span class="line">        System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是小写</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//转换为大写</span></span><br><span class="line">        System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//转换为小写</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//不能够直接把一个字符转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> Character.toString(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//转换为字符串</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2 id="创建字符串">创建字符串</h2>
<h3
id="字面值就是用双引号括起来的值">字面值，就是用双引号括起来的值</h3>
<h3 id="通过字符数组创建">通过字符数组创建</h3>
<h3 id="通过拼接">通过+拼接</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">garen</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>; <span class="comment">//字面值,虚拟机碰到字面值就会创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;提莫&quot;</span>); <span class="comment">//创建了两个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;崔&#x27;</span>,<span class="string">&#x27;斯&#x27;</span>,<span class="string">&#x27;特&#x27;</span>&#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);<span class="comment">//  通过字符数组创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">hero3</span> <span class="operator">=</span> garen + teemo;<span class="comment">//  通过+加号进行字符串拼接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串不能被继承，不能被改变</p>
<h2 id="exercise">Exercise</h2>
<h3 id="ex.1随机字符串">ex.1:随机字符串</h3>
<p>碰到问题：</p>
<ol type="1">
<li><p>random如何获得指定范围内随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span>)(Math.random() * <span class="number">10</span>)</span><br><span class="line"><span class="comment">//(int)用来将double强转成int类型</span></span><br><span class="line"><span class="comment">//(Math.random() * 10)外括号一定要有，否则会先运算将Math.random()结果强转成int类型再乘10，就始终是0</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何获得随机的26个字母</p>
<p>先用random获得随机距离，从0到25，然后用(char)('a' +
distance)获得随机的字母</p></li>
<li><p>如何将int类型数字转换成char类型数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">char</span>)(<span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">random_5_length_string</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> flag_for_capacity;</span><br><span class="line">        <span class="type">char</span>[] charStrings = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag_for_digit_or_char</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            flag_for_digit_or_char = (<span class="type">int</span>)(Math.random() * <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// flag_for_digit_or_char如果是0就填数字</span></span><br><span class="line">            <span class="keyword">if</span>(flag_for_digit_or_char == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">                charStrings[i] = (<span class="type">char</span>)(number + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag_for_capacity = (<span class="type">int</span>)(Math.random() * <span class="number">2</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">26</span>);</span><br><span class="line">                charStrings[i] = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + distance);</span><br><span class="line">                <span class="comment">// flag_for_capacity 如果是0就大写</span></span><br><span class="line">                <span class="keyword">if</span>(flag_for_capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                    charStrings[i] = Character.toUpperCase(charStrings[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charStrings);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/340249a9.html</url>
    <content><![CDATA[<h1
id="system.arraycopysrc-srcpos-dest-destpos-length">System.arraycopy(src,
srcPos, dest, destPos, length)</h1>
<span id="more"></span>
<p>src:源数组</p>
<p>srcPos：复制源数组的起始位置</p>
<p>dest：目标数组</p>
<p>destPos：复制目标数组的起始位置</p>
<p>length：复制长度</p>
<p>举个例子：复制一个数组前3个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item: b) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span> <span class="number">62</span> <span class="number">68</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exercise</span><br><span class="line">首先准备两个数组，他俩的长度是5-10之间的随机数，并使用随机数初始化这两个数组</span><br><span class="line">([向数组填充随机数](https://how2j.cn/k/array/array-create/280.html#step2182)的办法，[参考这里](https://how2j.cn/k/array/array-create/280.html#step2182))</span><br><span class="line"></span><br><span class="line">然后准备第三个数组，第三个数组的长度是前两个的和</span><br><span class="line">通过System.arraycopy 把前两个数组合并到第三个数组中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>java中产生随机数：</p>
<p>Math.random():产生0-1的浮点数</p>
<p>Math.random()*100：产生0-100的浮点数</p>
<p>(Math.random() + 6) * 10:产生5-10的浮点数</p>
<p>anser</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">exercise</span></span><br><span class="line"><span class="comment">首先准备两个数组，他俩的长度是5-10之间的随机数，并使用随机数初始化这两个数组</span></span><br><span class="line"><span class="comment">([向数组填充随机数](https://how2j.cn/k/array/array-create/280.html#step2182)的办法，[参考这里](https://how2j.cn/k/array/array-create/280.html#step2182))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后准备第三个数组，第三个数组的长度是前两个的和</span></span><br><span class="line"><span class="comment">通过System.arraycopy 把前两个数组合并到第三个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mergeArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">6</span>) + <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">6</span>) + <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthC</span> <span class="operator">=</span> lengthA + lengthB;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[lengthA];</span><br><span class="line">        System.out.println(<span class="string">&quot;数组A：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthA; i++) &#123;</span><br><span class="line">            a[i] = (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[lengthB];</span><br><span class="line">        System.out.println(<span class="string">&quot;数组B：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthB; i++) &#123;</span><br><span class="line">            b[i] = (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[lengthC];</span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, c, <span class="number">0</span>, lengthA);</span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, c, lengthA, lengthB);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item : c) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二维数组">二维数组</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	   <span class="comment">//初始化二维数组，</span></span><br><span class="line">	   <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//有两个一维数组，每个一维数组的长度是3</span></span><br><span class="line">	   a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;  <span class="comment">//可以直接访问一维数组，因为已经分配了空间</span></span><br><span class="line">	     </span><br><span class="line">	   <span class="comment">//只分配了二维数组</span></span><br><span class="line">	   <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][]; <span class="comment">//有两个一维数组，每个一维数组的长度暂未分配</span></span><br><span class="line">	   b[<span class="number">0</span>]  =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//必须事先分配长度，才可以访问</span></span><br><span class="line">	   b[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//指定内容的同时，分配空间</span></span><br><span class="line">	   <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">	   &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二维数组要求每个空间都必须先new才能使用（就是往里面放东西）</p>
<p>二维数组不一定要等长</p>
<p>exercise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个5X5的二维数组。 然后使用随机数填充该二维数组。</span><br><span class="line">找出这个二维数组里，最大的那个值，并打印出其二维坐标</span><br></pre></td></tr></table></figure>
<p>answer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个5X5的二维数组。 然后使用随机数填充该二维数组。</span></span><br><span class="line"><span class="comment">找出这个二维数组里，最大的那个值，并打印出其二维坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maxNum</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">maxNum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">twoDimensionArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                a[i][j] = (<span class="type">int</span>)(Math.random() * <span class="number">6</span> +<span class="number">5</span>);</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">maxNum</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">maxNum</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j] &gt; max.val) &#123;</span><br><span class="line">                    max.val = a[i][j];</span><br><span class="line">                    max.x = i;</span><br><span class="line">                    max.y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最大：%d 横坐标：%d 纵坐标：%d&quot;</span>, max.val, max.x, max.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java.util.arrays类常用方法">java.util.Arrays类常用方法</h1>
<h2 id="数组复制">数组复制</h2>
<p>与<a
href="https://how2j.cn/k/array/array-copyarray/284.html#step575">使用System.arraycopy进行数组复制</a>类似的，
Arrays提供了一个copyOfRange方法进行数组复制。
不同的是System.arraycopy，需要事先准备好目标数组，并分配长度。
copyOfRange 只需要源数组就就可以了，就是目标数组不需要new</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyOfArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item : b) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组转换为字符串">数组转换为字符串</h2>
<p>通过Arrays.toString(a)</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arrayToString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a的类别是：&quot;</span> + a.getClass().getName());</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringA</span> <span class="operator">=</span> Arrays.toString(a);</span><br><span class="line">        System.out.println(stringA);</span><br><span class="line">        System.out.println(<span class="string">&quot;stringA的类型是：&quot;</span> + stringA.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的类别是：[I</span><br><span class="line">[<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>]</span><br><span class="line">stringA的类型是：java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<p>Arrays.sort(a)</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arraySort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line">[<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>]</span><br><span class="line">排序后：</span><br><span class="line">[<span class="number">9</span>, <span class="number">18</span>, <span class="number">62</span>, <span class="number">65</span>, <span class="number">68</span>, <span class="number">82</span>]</span><br></pre></td></tr></table></figure>
<h2 id="搜索">搜索</h2>
<p>查询元素出现的位置
需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序
如果数组中有多个相同的元素，查找结果是不确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字62出现的位置&quot;</span> + Arrays.binarySearch(a, <span class="number">62</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字<span class="number">62</span>出现的位置<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="比较两个数组是否相同">比较两个数组是否相同</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="填充">填充</h2>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fill</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(a, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>exercise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先定义一个5X8的二维数组，然后使用随机数填充满。</span><br><span class="line">借助Arrays的方法对二维数组进行排序。</span><br><span class="line">参考思路：</span><br><span class="line">先把二维数组使用System.arraycopy进行数组复制到一个一维数组</span><br><span class="line">然后使用sort进行排序</span><br><span class="line">最后再复制回到二维数组。</span><br></pre></td></tr></table></figure>
<p>answer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array.Arrays_method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用随机数构造二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                a[i][j] = (<span class="type">int</span>)(Math.random() * <span class="number">40</span>);</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本来是想利用Arrays.copyOfRange,但是Arrays.copyOfRange会对数组重新引用</span></span><br><span class="line">        <span class="comment">// 将二维数组中内容复制到一维数组里面</span></span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.arraycopy(a[i], <span class="number">0</span>, tmp, i * <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            System.out.print(tmp[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 对数组排序</span></span><br><span class="line">        Arrays.sort(tmp);</span><br><span class="line">        <span class="comment">// 将一维数组中内容复制到二维数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            a[i] = Arrays.copyOfRange(tmp, i * <span class="number">8</span>, (i + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝问题</title>
    <url>/posts/b273c765.html</url>
    <content><![CDATA[<p><a href="">刷蓝桥杯碰到的</a>，觉得有必要另写一篇文章</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] backUp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMatrix</span><span class="params">(Scanner scan)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			matrix[i] = scan.nextLine().toCharArray();</span><br><span class="line">			backUp[i] = Arrays.copyOf(matrix[i], matrix[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 上</span></span><br><span class="line">		<span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x - <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 左</span></span><br><span class="line">		<span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x, y - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 右</span></span><br><span class="line">		<span class="keyword">if</span>(y + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x, y + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(x + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x + <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 自个</span></span><br><span class="line">		flip(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 一共要有n次读取</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">// 读取每次的初始灯矩阵并保存备份</span></span><br><span class="line">			readMatrix(scan);</span><br><span class="line">			System.out.println(<span class="string">&quot;初始化矩阵为：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				System.out.println(matrix[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minChange</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">			<span class="comment">// 遍历 32 种可能性</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将第一行的按法调整成对应的5位二进制</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%5s&quot;</span>, Integer.toBinaryString(j)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">				System.out.format(<span class="string">&quot;第一行的开关状态为：%s\n&quot;</span>, tmpString);</span><br><span class="line">				<span class="comment">// 第一行的按完后的状态</span></span><br><span class="line">				System.out.print(<span class="string">&quot;第一行现在状态：&quot;</span>);</span><br><span class="line">				System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(tmpString.charAt(k) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						changeMatrix(<span class="number">0</span>, k);</span><br><span class="line">						System.out.format(<span class="string">&quot;按下开关%d, 第一行现在状态 &quot;</span>, k + <span class="number">1</span>);</span><br><span class="line">						System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;开关按完后第一行现在的状态：&quot;</span>);</span><br><span class="line">				System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; <span class="number">5</span>; b++) &#123;</span><br><span class="line">						<span class="comment">// 通过这一行确定下一行的开关，再根据这个开关看灯的亮暗</span></span><br><span class="line">						<span class="keyword">if</span>(matrix[a][b] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">							changeMatrix(a + <span class="number">1</span>, b);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.format(<span class="string">&quot;经过第%d行后的状态\n&quot;</span>, a+<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">5</span>; c++) &#123;</span><br><span class="line">						System.out.println(matrix[c]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 遍历第5行，看是不是都是1</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(matrix[<span class="number">4</span>][k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">					minChange = Math.min(count, minChange);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 将备份矩阵拷贝回原矩阵</span></span><br><span class="line">				matrix = Arrays.copyOf(backUp, backUp.length);	</span><br><span class="line">				System.out.println(<span class="string">&quot;backUp数组是：&quot;</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">					System.out.println(backUp[a]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(count &lt;= <span class="number">6</span>) System.out.println(count);</span><br><span class="line">			<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很逆天的一个问题</p>
<p>比如原数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br></pre></td></tr></table></figure>
<p>第一次将backUp数组拷贝回原数组时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backUp数组是：</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br></pre></td></tr></table></figure>
<p>第二次就做妖了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">00100</span><br></pre></td></tr></table></figure>
<p>出问题的代码是这里,将backUp拷贝回matrix时</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = Arrays.copyOf(backUp, backUp.length);	</span><br></pre></td></tr></table></figure>
<p>受影响的表现是修改matrix的时候，backUp也会被改变</p>
<p>改为下面后就正常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">	matrix[a] = Arrays.copyOf(backUp[a], backUp[a].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明确的是System.arraycopy和Arrays.copyOf，如果拷贝的对象是基本数据类型，则是深拷贝，而对于引用数据类型则是浅拷贝</p>
<p>拷贝对象是基本数据类型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126192504250.png" /></p>
<p>拷贝对象是引用数据类型,比如int[](虽然是二维数组之间的拷贝，但是拷贝对象是int[])</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126193150985.png" /></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/28239a8d.html</url>
    <content><![CDATA[<h1 id="面向对象">面向对象</h1>
<span id="more"></span>
<h2 id="继承">继承</h2>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Object_oriented.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> <span class="keyword">extends</span> <span class="title class_">Item</span>&#123;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">infinityEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>();</span><br><span class="line">        infinityEdge.damage = <span class="number">65</span>;</span><br><span class="line">        infinityEdge.name = <span class="string">&quot;无尽之刃&quot;</span>;</span><br><span class="line">        infinityEdge.price = <span class="number">3600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="方法重载方法名一样但是参数类型不一样">方法重载:方法名一样，但是参数类型不一样</h2>
<p>采用可变数量的参数 <strong>只需要设计一个方法</strong> public void
attack(Hero <strong>...</strong>heros) 即可代表上述所有的方法了
在方法里，使用操作数组的方式处理参数heros即可</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot; 进行了一次攻击 ，但是不确定打中谁了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可变数量的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero... heros)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">			System.out.println(name + <span class="string">&quot; 攻击了 &quot;</span> + heros[i].name);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ADHero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">		bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		h1.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		h2.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line"></span><br><span class="line">		bh.attack(h1);</span><br><span class="line">		bh.attack(h1, h2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<p>通过一个类创建一个对象，这个过程叫做<strong>实例化</strong></p>
<p>实例化是通过调用<strong>构造方法</strong>(又叫做<strong>构造器</strong>)实现的</p>
<h3 id="定义">定义：</h3>
<p>方法名和类名一样（包括大小写） <strong>没有返回类型</strong>
实例化一个对象的时候，必然调用构造方法</p>
<h3 id="隐式的构造方法">隐式的构造方法</h3>
<p>无参的构造方法，如果不写，就会默认提供一个</p>
<p>如果提供了一个有参的构造方法，同时又<strong>没有显式</strong>的提供一个无参的构造方法那么默认的无参的构造方法，就“木有了“</p>
<h3 id="构造方法的重载">构造方法的重载</h3>
<h2 id="this的使用">this的使用</h2>
<p>this这个关键字，相当于普通话里的“我” this即代表当前对象</p>
<h3 id="this代表当前对象">this代表当前对象</h3>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">	</span><br><span class="line">	String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印内存中的虚拟地址</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAddressInMemory</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印this看到的虚拟地址：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">		<span class="comment">//直接打印对象，会显示该对象在内存中的虚拟地址</span></span><br><span class="line">		<span class="comment">//格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;打印对象看到的虚拟地址：&quot;</span>+garen);</span><br><span class="line">		<span class="comment">//调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址</span></span><br><span class="line">		garen.showAddressInMemory();</span><br><span class="line">		</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印对象看到的虚拟地址：&quot;</span>+teemo);</span><br><span class="line">		teemo.showAddressInMemory();</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打印对象看到的虚拟地址：Object_oriented.reload.Hero@1b6d3586(和下面<span class="built_in">this</span>引用的一样)</span><br><span class="line">打印<span class="built_in">this</span>看到的虚拟地址：Object_oriented.reload.Hero@1b6d3586</span><br><span class="line">打印对象看到的虚拟地址：Object_oriented.reload.Hero@4554617c</span><br><span class="line">打印<span class="built_in">this</span>看到的虚拟地址：Object_oriented.reload.Hero@4554617c</span><br></pre></td></tr></table></figure>
<h3 id="通过this访问属性">通过this访问属性</h3>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName3</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//name代表的是参数name</span></span><br><span class="line">    <span class="comment">//this.name代表的是属性name</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">	</span><br><span class="line">	String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//参数名和属性名一样</span></span><br><span class="line">	<span class="comment">//在方法体中，只能访问到参数name</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName1</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了避免setName1中的问题，参数名不得不使用其他变量名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName2</span><span class="params">(String heroName)</span>&#123;</span><br><span class="line">		name = heroName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过this访问属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName3</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="comment">//name代表的是参数name</span></span><br><span class="line">		<span class="comment">//this.name代表的是属性name</span></span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span>  <span class="variable">h</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		</span><br><span class="line">		h.setName1(<span class="string">&quot;teemo&quot;</span>);</span><br><span class="line">		System.out.println(h.name);</span><br><span class="line">		</span><br><span class="line">		h.setName2(<span class="string">&quot;garen&quot;</span>);</span><br><span class="line">		System.out.println(h.name);		</span><br><span class="line">		</span><br><span class="line">		h.setName3(<span class="string">&quot;死歌&quot;</span>);</span><br><span class="line">		System.out.println(h.name);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">garen</span><br><span class="line">死歌</span><br></pre></td></tr></table></figure>
<h3 id="通过this调用其他的构造方法">通过this调用其他的构造方法</h3>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name);</span><br><span class="line">    System.out.println(<span class="string">&quot;两个参数的构造方法&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.hp = hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Object_oriented.reload;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line"></span><br><span class="line">    String name; //姓名</span><br><span class="line"></span><br><span class="line">    float hp; //血量</span><br><span class="line"></span><br><span class="line">    float armor; //护甲</span><br><span class="line"></span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line"></span><br><span class="line">    //带一个参数的构造方法</span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;一个参数的构造方法&quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //带两个参数的构造方法</span><br><span class="line">    public Hero(String name,float hp)&#123;</span><br><span class="line">        this(name);</span><br><span class="line">        System.out.println(&quot;两个参数的构造方法&quot;);</span><br><span class="line">        this.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo =  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">        System.out.println(teemo.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传参">传参</h2>
<h3 id="基本类型传参">基本类型传参</h3>
<p>基本类型传参 在方法内，无法修改方法外的基本类型参数</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">xueping</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提莫通过这个血瓶回血</span></span><br><span class="line"></span><br><span class="line">teemo.huixue(xueping);</span><br><span class="line"></span><br><span class="line">System.out.println(xueping);</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">       </span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">huixue</span><span class="params">(<span class="type">int</span> xp)</span>&#123;</span><br><span class="line">    	hp = hp + xp;</span><br><span class="line">    	<span class="comment">//回血完毕后，血瓶=0</span></span><br><span class="line">    	xp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">        <span class="comment">//血瓶，其值是100</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xueping</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提莫通过这个血瓶回血</span></span><br><span class="line">        </span><br><span class="line">        teemo.huixue(xueping);</span><br><span class="line">        </span><br><span class="line">        System.out.println(xueping);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">(按理说不应该是100，因为已经回血后按理说血瓶废了，说明方法没有修改方法外参数)</span><br></pre></td></tr></table></figure>
<h3 id="引用与">引用与=</h3>
<p>如果一个变量是基本类型 比如 int hp = 50; 我们就直接管hp叫变量
<strong>=表示赋值的意思</strong>。 如果一个变量是类类型 比如 Hero h =
new Hero(); 我们就管h叫做<strong>引用</strong>。
<strong>=不再是赋值的意思</strong> <strong>=表示指向的意思</strong> 比如
Hero h = new Hero(); 这句话的意思是 引用h，指向一个Hero对象</p>
<h3 id="类类型传参">类类型传参</h3>
<p>关键代码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322150201788.png" /></p>
<p>传递给方法里的如果是类类型那么就可以在方法内修改方法外的变量</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.hp = hp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 攻击一个英雄，并让他掉damage点血</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero hero, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">		hero.hp = hero.hp - damage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;提莫&quot;</span>, <span class="number">383</span>);</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>, <span class="number">616</span>);</span><br><span class="line">		garen.attack(teemo, <span class="number">100</span>);</span><br><span class="line">		System.out.println(teemo.hp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">283.0</span><br></pre></td></tr></table></figure>
<h2 id="四种访问修饰符">四种访问修饰符</h2>
<p>成员变量有四种修饰符 <strong>private</strong> 私有的
<strong>package</strong>/friendly/default 不写
<strong>protected</strong> 受保护的 <strong>public</strong> 公共的</p>
<h3 id="类之间的关系">类之间的关系</h3>
<p>类和类之间的关系有如下几种: 以Hero为例
<strong>自身：</strong>指的是Hero自己
<strong>同包子类：</strong>ADHero这个类是Hero的子类，并且和Hero处于<strong>同一个包下</strong>
<strong>不同包子类：</strong>Support这个类是Hero的子类，但是在<strong>另一个包下</strong>
<strong>同包类：</strong> GiantDragon
这个类和Hero是<strong>同一个包</strong>，但是彼此<strong>没有继承关系</strong>
<strong>其他类：</strong>Item这个类，<strong>在不同包</strong>，也没有继承关系的类</p>
<p><img src="https://stepimagewm.how2j.cn/605.png" /></p>
<h3 id="private-私有的">private 私有的</h3>
<p><font color = "red">只能自己用</font></p>
<p>自身：是可以访问的 同包子类：不能继承 不同包子类：不能继承
同包类：不能访问 其他包类：不能访问</p>
<h3 id="packagefriendlydefault-不写">package/friendly/default 不写</h3>
<p><font color = "red">只能在同一个包里用</font></p>
<p><img src="https://stepimagewm.how2j.cn/609.png" /></p>
<p>### protected 受保护的</p>
<p><font color = "red">同一个包里和是它的子类都能用</font></p>
<p><img src="https://stepimagewm.how2j.cn/610.png" /></p>
<h3 id="public-公共的">public 公共的</h3>
<p><font color = "red">谁都可以用</font></p>
<p><img src="https://stepimagewm.how2j.cn/611.png" /></p>
<h3 id="选择依据">选择依据</h3>
<ol type="1">
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ol>
<p>再就是<strong>作用范围最小原则</strong>
简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。
这样就能把数据尽量的封装起来，没有必要<strong>露出来的</strong>，就不用<strong>露出来</strong>了</p>
<h2 id="类属性静态属性">类属性、静态属性</h2>
<p>当一个属性被<strong>static</strong>修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong>
当一个属性被声明成类属性，那么<strong>所有的对象，都共享一个值</strong>
与对象属性对比： 不同对象的 对象属性 的值都可能不一样。 比如盖伦的hp 和
提莫的hp 是不一样的。
<font color = "red">但是所有对象的类属性的值，都是一样的</font></p>
<h3 id="类属性">类属性</h3>
<p><strong>类属性：</strong> 又叫做静态属性 <strong>对象属性：</strong>
又叫实例属性，非静态属性
<font color = "red">如果一个属性声明成类属性，那么所有的对象，都共享这么一个值</font></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String name; //实例属性，对象属性，非静态属性</span><br><span class="line">protected float hp;</span><br><span class="line">static String copyright;//类属性,静态属性</span><br></pre></td></tr></table></figure>
<h3 id="访问类属性">访问类属性</h3>
<ol type="1">
<li><p>对象.类属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">teemo.copyright</span><br></pre></td></tr></table></figure></li>
<li><p>类.类属性</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hero.copyright</span><br></pre></td></tr></table></figure>
<h2 id="类方法">类方法</h2>
<p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上
访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<h3 id="类方法-1">类方法</h3>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实例方法,对象方法，非静态方法</span><br><span class="line">//必须有对象才能够调用</span><br><span class="line">public void die()&#123;</span><br><span class="line">    hp = 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//类方法，静态方法</span><br><span class="line">//通过类就可以直接调用</span><br><span class="line">public static void battleWin()&#123;</span><br><span class="line">    System.out.println(&quot;battle win&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    //实例方法,对象方法，非静态方法</span><br><span class="line">    //必须有对象才能够调用</span><br><span class="line">    public void die()&#123;</span><br><span class="line">        hp = 0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //类方法，静态方法</span><br><span class="line">    //通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero garen =  new Hero();</span><br><span class="line">           garen.name = &quot;盖伦&quot;;</span><br><span class="line">           //必须有一个对象才能调用</span><br><span class="line">           garen.die();</span><br><span class="line">            </span><br><span class="line">           Hero teemo =  new Hero();</span><br><span class="line">           teemo.name = &quot;提莫&quot;;</span><br><span class="line">            </span><br><span class="line">           //无需对象，直接通过类调用</span><br><span class="line">           Hero.battleWin();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用类方法">调用类方法</h3>
<ol type="1">
<li><p>对象.类方法</p></li>
<li><p>类.类方法</p></li>
</ol>
<h2 id="属性初始化">属性初始化</h2>
<h3 id="对象属性初始化">对象属性初始化</h3>
<ol type="1">
<li>声明该属性的时候初始化</li>
<li>构造方法中初始化</li>
<li>初始化块</li>
</ol>
<p><font color = "red">初始化块中的代码会先执行，接着是构造方法中的代码，最后是在属性声明时直接赋值的代码。</font></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">	public String name = &quot;some hero&quot;; //声明该属性的时候初始化 </span><br><span class="line">	protected float hp;</span><br><span class="line">	float maxHP;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		maxHP = 200; //初始化块</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	public Hero()&#123;</span><br><span class="line">		hp = 100; //构造方法中初始化</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类属性初始化">类属性初始化</h3>
<ol type="1">
<li>声明该属性的时候初始化</li>
<li>静态初始化块</li>
</ol>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">	public String name; </span><br><span class="line">	protected float hp;</span><br><span class="line">	float maxHP;</span><br><span class="line">	</span><br><span class="line">	//物品栏的容量</span><br><span class="line">	public static int itemCapacity=8; //声明的时候 初始化</span><br><span class="line">	</span><br><span class="line">	static&#123;</span><br><span class="line">		itemCapacity = 6;//静态初始化块 初始化</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Hero()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(Hero.itemCapacity);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单例模式">单例模式</h2>
<p>单例模式又叫做
Singleton模式，<font color = "red">指的是一个类，在一个JVM里，只有一个实例存在。</font></p>
<h3 id="饿汉式单例模式">饿汉式单例模式</h3>
<ol type="1">
<li>通过<font color = "red">私有化其构造方法</font>，使得外部无法通过new
得到新的实例。</li>
<li><font color = "red">私有实例化一个对象</font></li>
<li><font color = "red">定义一个公共的类方法用于返回之前创建的对象</font></li>
</ol>
<p>关键：<font color = "red">无论如何都会创建一个实例</font></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line"> </span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span><br><span class="line"> </span><br><span class="line">    private static GiantDragon instance = new GiantDragon();</span><br><span class="line">     </span><br><span class="line">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式单例模式">懒汉式单例模式</h3>
<p>使用：</p>
<ol type="1">
<li><font color = "red">私有化构造方法</font></li>
<li>准备一个私有的类属性，<font color = "red">但是暂时只想NULL</font></li>
<li>定义一个<font color = "red">公共的类方法</font>，如果之前私有的类属性指向空，就实例化一个对象，否则就不用</li>
</ol>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line">  </span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class="line">    private static GiantDragon instance;</span><br><span class="line">      </span><br><span class="line">    //public static 方法，返回实例对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class="line">        if(null==instance)&#123;</span><br><span class="line">            instance = new GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        //返回 instance指向的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式三元素</p>
<ol type="1">
<li>构造方法私有化</li>
<li>静态属性指向实例</li>
<li>public static的 getInstance方法，返回第二步的静态属性</li>
</ol>
<h2 id="枚举类型">枚举类型</h2>
<h3 id="预先定义的常量">预先定义的常量</h3>
<p><strong>注：</strong>因为是常量，所以一般都是全大写</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        switch (season) &#123;</span><br><span class="line">        case SPRING:</span><br><span class="line">            System.out.println(&quot;春天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case SUMMER:</span><br><span class="line">            System.out.println(&quot;夏天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AUTUMN:</span><br><span class="line">            System.out.println(&quot;秋天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case WINTER:</span><br><span class="line">            System.out.println(&quot;冬天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历枚举">遍历枚举</h3>
<p>增强型for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Season s : Season.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/posts/a444b428.html</url>
    <content><![CDATA[<h1 id="排序">排序</h1>
<span id="more"></span>
<h2 id="插入排序">插入排序</h2>
<h3
id="直接插入排序不断从无序序列中挑选出元素插入有序序列">直接插入排序：不断从无序序列中挑选出元素插入有序序列</h3>
<h3
id="折半插入排序先折半查找出待插入位置再统一移动">折半插入排序：先折半查找出待插入位置，再统一移动</h3>
<h3
id="希尔排序每次取不同的步长按步长从原序列里挑出子序列直到最后步长为0">希尔排序：每次取不同的步长，按步长从原序列里挑出子序列，直到最后步长为0</h3>
<p>举例1：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231230195246.jpg" /></p>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序：</h3>
<h4
id="每轮排序结果确定1个位置可以从最后一个开始也可以从第一个开始">每轮排序结果确定1个位置，可以从最后一个开始，也可以从第一个开始</h4>
<h4
id="每轮排序过程中比较交换两个相邻的元素">每轮排序过程中比较交换两个相邻的元素</h4>
<h3
id="快排主要思想是分治pivot前都比它小pivot后都比它大再对左右子序列继续选pivot分解">快排：主要思想是分治，pivot前都比它小，pivot后都比它大，再对左右子序列继续选pivot，分解</h3>
<h4
id="一轮分治过程中high和low依次运行">一轮分治过程中，high和low依次运行</h4>
<h4
id="首先high运行当high所指元素小于pivot时high所指元素放到low指的地方认为每次停下来i的那个highlow指向的位置为空">首先high运行，当high所指元素小于pivot时，high所指元素放到low指的地方（认为每次停下来i的那个（high/low）指向的位置为空)</h4>
<h4
id="然后low开始运行当low所指元素大于pivot时low所指元素放到high所指位置">然后low开始运行，当low所指元素大于pivot时，low所指元素放到high所指位置</h4>
<h4
id="不断循环直到low-high将pivot放到i与j此时指向的位置">不断循环直到low
== high,将pivot放到i与j此时指向的位置</h4>
<h4
id="快排每次分治都有1个元素被放到最终位置">快排每次分治都有1个元素被放到最终位置</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Partition函数参数是待划分序列，开头位置（low指针指向的位置）结尾位置（high指针指向的位置），返回最终pivot的位置*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> high, <span class="type">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = data[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[high] &gt;= pivot) high--;</span><br><span class="line">        data[low] = data[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[low] &lt;= pivot) low++;</span><br><span class="line">        data[high] = data[low];    </span><br><span class="line">    &#125;   </span><br><span class="line">    data[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*QuickSort函数参数是待划分序列，开头位置（low指向位置），结尾位置（high指向位置）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotPosition = <span class="built_in">Partition</span>(data, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, low, pivotPosition - <span class="number">1</span>);    <span class="comment">//对左子表再快排</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(data, pivotPosition + <span class="number">1</span>, high);   <span class="comment">//对右子表再快排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例1：判断排序结果</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231122081638.jpg" />
1 写出最终排序结果 2
逐个选项选出已经放到应该排的位置的元素，因为针对每一个子列排序，都会有一个元素排到它应该排的位置，所以排第n趟的时候至少有n个元素已经放到正确位置
3
再看每个放到正确位置元素将原序列分成几段，因为如果每趟的pivot恰好放在端的地方，那么就是排第n趟的时候有n个元素归位，但如果分割了原序列，就是n+1</p>
<h2 id="选择排序">选择排序</h2>
<h3
id="简单选择排序每次确定一个元素位置比如确定最后一个就是最大元素比较范围从1n-1确定倒数第二个比较范围从1到n-1以此类推">简单选择排序：每次确定一个元素位置，比如确定最后一个，就是最大元素，比较范围从1~n-1，确定倒数第二个，比较范围从1到n-1……以此类推</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231230213447.jpg" /></p>
<h3 id="堆排序">堆排序</h3>
<h4 id="存储与结构">1 存储与结构</h4>
<h5 id="树形结构">1.1 树形结构</h5>
<p>堆的最常用结构是二叉树，且一般是完全二叉树</p>
<h5 id="存储结构">1.2 存储结构</h5>
<p>堆实际存储一般不用指针，而是使用数组，如下图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231124085512.jpg" /></p>
<h5 id="数组下标关系">1.3 数组下标关系</h5>
<h6 id="起始存储单元为1而不是0-0作为哨兵且也易于从子节点找到父节点">1.
起始存储单元为1，而不是0, 0作为哨兵，且也易于从子节点找到父节点</h6>
<h6
id="对于下标为i的节点父节点下标是i2向下取整反过来对于下标为i的节点左孩子下标是2-i右孩子是-2-i-1">2.
对于下标为i的节点，父节点下标是i/2向下取整，反过来，对于下标为i的节点，左孩子下标是2
* i，右孩子是 2 * i + 1</h6>
<h4 id="操作">2 操作</h4>
<h5 id="插入">2.1 插入</h5>
<p>以大顶堆为例</p>
<h6
id="先将待插入节点放到数组最后一位">先将<strong>待插入节点</strong>放到<strong>数组最后一位</strong></h6>
<h6
id="然后向上上滤寻找插入位置即与父节点比较如果比父节点大那么就把父节点下放-直到找到待插入节点应该插入的位置">然后<strong>向上上滤</strong>寻找插入位置，即与父节点比较，如果比父节点大，那么就把父节点<strong>下放</strong>
，直到找到待插入节点应该插入的位置</h6>
<p>但是注意到，如果插入的新节点比原堆中任意元素都大，那么到堆顶（下标为1）的时候又/=2得0，0不断/=2得0陷入死循环，所以如果已知堆中元素范围，可以将下标0设置为大于堆中可能元素，这样循环到0就一定会退出</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 1000000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> x, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = ++size;	<span class="comment">//因为要插入元素，所以大顶堆size + 1</span></span><br><span class="line">    <span class="keyword">for</span>(; data[i / <span class="number">2</span>] &lt; x; i /= <span class="number">2</span>) &#123;	<span class="comment">//向上寻找插入位置</span></span><br><span class="line">        data[i] = data[i / <span class="number">2</span>];			<span class="comment">//将父节点下放</span></span><br><span class="line">    &#125;	</span><br><span class="line">    data[i] = x;	<span class="comment">//将新节点插入到应该插入的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除">2.2 删除</h5>
<p>以大顶堆为例</p>
<h6 id="先弹出根节点">先弹出根节点</h6>
<h6
id="然后取数组中最后一个元素因为它在大顶堆中必然是叶子节点向下下滤寻找插入位置">然后取数组中最后一个元素（因为它在大顶堆中必然是叶子节点）<strong>向下下滤</strong>寻找插入位置</h6>
<h6
id="通过与当前层为根节点此时为空的左右子树中最大值比较如果左右子树中最大值比最后一个元素大就将左右子树中最大值上移接着从上移节点的位置此时为空继续向下比较否则将最后一个元素插入当前层为根节点">通过<strong>与当前层为根节点（此时为空）</strong>的<strong>左右子树中最大值</strong>比较，如果左右子树中最大值比最后一个元素大，就将左右子树中最大值上移，接着从上移节点的位置（此时为空）继续向下比较，否则将最后一个元素插入当前层为根节点</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231124095808.jpg" /></p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PopMax</span><span class="params">(MaxHeap maxHeap)</span> &#123;</span><br><span class="line">	<span class="type">int</span> maxData = maxHeap-&gt;Data[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x = maxHeap-&gt;Data[maxHeap-&gt;Size--];	<span class="comment">//选择原来大顶堆中最后一个存储的元素来下滤</span></span><br><span class="line">    <span class="type">int</span> parent = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= maxHeap-&gt;Size; parent = child) &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(child != maxHeap-&gt;Size &amp;&amp; maxHeap-&gt;Data[child] &lt; maxHeap-&gt;Data[child + <span class="number">1</span>]) &#123;</span><br><span class="line">			child = child + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; maxHeap-&gt;Data[child]) &#123;	<span class="comment">//将x与child比较，注意这时parent指向的位置为空, 如果小就将child提上来</span></span><br><span class="line">            maxHeap-&gt;Data[parent] = maxHeap-&gt;Data[child];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果x比child大就break出循环，注意不能在循环里赋值，具体还不清楚，但在循环里就把x赋给parent会报错</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxHeap-&gt;Data[parent] = x;</span><br><span class="line">    <span class="keyword">return</span> maxData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<h3 id="一-算法思想分治">一 算法思想：分治</h3>
<p>不过归并分治过程和快排有区别</p>
<p>快排是先对一个大序列(在一个大序列中找到pivot，利用pivot将大序列分割成左右两个小序列)操作，再分割成小序列</p>
<p>归并是先分割成小序列(先将大序列分割成小序列)
，再操作(对将小序列两个两个归并成一个大序列)</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231128090112.jpg" /></p>
<h4 id="分分割成小序列">1 “分”：分割成小序列</h4>
<h4 id="治小序列两个两个合并成大序列">2
治：小序列两个两个合并成大序列</h4>
<h5 id="开一个辅助数组b">2.1 开一个辅助数组B</h5>
<h5 id="将待排数组名义上两个但实际上存在一个里面存放到辅助数组里面">2.2
将待排数组(名义上两个，但实际上存在一个里面)存放到辅助数组里面</h5>
<h5
id="这时待排数组为空利用两个指针分别指示待归并的两个数组的起点在辅助数组上移动将其中大的重新拷贝回待排数组">2.3
这时待排数组为空，利用两个指针(分别指示待归并的两个数组的起点)在辅助数组上移动，将其中大的重新拷贝回待排数组</h5>
<h5
id="如果其中一个指针移动的位置超过了原来对应待归并的数组的范围将剩下一个数组里元素全部拷贝回待排数组">2.4
如果其中一个指针移动的位置超过了原来对应待归并的数组的范围，将剩下一个数组里元素全部拷贝回待排数组</h5>
<h3 id="二-代码">二 代码</h3>
<h4 id="merge用来合并两个序列">Merge()(用来合并两个序列)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Assistance[MAXNUM];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line">    <span class="comment">/*拷贝到辅助数组*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; high; i++) &#123;</span><br><span class="line">        Assistance[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p, q, r;</span><br><span class="line">    <span class="keyword">for</span>(p = low, q = mid + <span class="number">1</span>, r = low; p &lt;= mid &amp;&amp; q &lt;= high; ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Assistance[p] &gt; Assistance[q]) &#123;</span><br><span class="line">            data[r++] = Assistance[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[r++] = Assistance[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= mid) data[r++] = Assistance[p];</span><br><span class="line">    <span class="keyword">while</span>(q &lt;= high) data[r++] = Assistance[q]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="mergesort用来分割">MergeSort()(用来分割)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(data, low, mid);</span><br><span class="line">        MergeSort(data, mid + <span class="number">1</span>, low);</span><br><span class="line">        Merge(data, low, high, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序">基数排序</h2>
<h3 id="主要思想">主要思想</h3>
<h4
id="不基于比较和移动而基于关键字各位的大小">不基于比较和移动，而基于关键字各位的大小</h4>
<h4 id="分配">分配：</h4>
<h4 id="收集">收集：</h4>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231231071221.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231231071233.jpg" /></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构绪论</title>
    <url>/posts/b06cc6ec.html</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<h2 id="数据结构基本概念">数据结构基本概念</h2>
<h3
id="数据元素数据项数据元素包含数据项举例学生这个数据元素里会有姓名学号等数据项">数据元素、数据项：数据元素包含数据项，举例：学生这个数据元素里会有姓名、学号等数据项</h3>
<h3
id="数据对象数据对象是相同数据元素的集合">数据对象：数据对象是相同数据元素的集合</h3>
<h3 id="数据类型">数据类型</h3>
<h4
id="原子类型不可再分的最小数据类型">原子类型：不可再分的最小数据类型</h4>
<h4 id="结构类型可以再分">结构类型：可以再分</h4>
<h4
id="抽象数据类型可以从java中接口理解既要有属性也要有方法">抽象数据类型：可以从java中接口理解，既要有属性，也要有方法</h4>
<h3 id="数据">数据</h3>
<h4 id="记录各个数据元素的值">记录各个数据元素的值</h4>
<h4 id="记录数据元素之间关系">记录数据元素之间关系</h4>
<h3 id="数据结构三要素">数据结构三要素</h3>
<h4
id="逻辑结构描述的是数据之间的逻辑关系与怎么存储无关">逻辑结构：描述的是数据之间的逻辑关系，与怎么存储无关。</h4>
<h5 id="线性结构">线性结构</h5>
<h6 id="一般线性表">一般线性表</h6>
<h6 id="栈和队列">栈和队列</h6>
<h6 id="串">串</h6>
<h6 id="数组">数组</h6>
<h5 id="非线性结构">非线性结构</h5>
<h6 id="集合">集合</h6>
<h6 id="树">树</h6>
<h6 id="图">图</h6>
<h4
id="存储结构用计算机语言实现的逻辑结构">存储结构：用计算机语言实现的逻辑结构</h4>
<h5 id="顺序存储逻辑相邻物理相邻">顺序存储：逻辑相邻，物理相邻</h5>
<h5
id="链式存储逻辑相邻物理不一定相邻存储空间不一定相连但存储的地址一定相邻">链式存储：逻辑相邻，物理不一定相邻(存储空间不一定相连，但存储的地址一定相邻)</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217100037.jpg"
alt="微信图片_20231217100037" />
<figcaption aria-hidden="true">微信图片_20231217100037</figcaption>
</figure>
<h5
id="索引存储通过索引表去查经典的就是数组下标就是索引表">索引存储：通过索引表去查，经典的就是数组下标，就是索引表</h5>
<h5 id="散列存储经典的就是哈希">散列存储：经典的就是哈希</h5>
<h3 id="数据运算">数据运算</h3>
<h4
id="运算定义针对逻辑结构可以理解为java的抽象类里面定义的抽象方法">运算定义针对逻辑结构，可以理解为java的抽象类里面定义的抽象方法</h4>
<h4
id="运算实现针对存储结构可以理解为java继承抽象类的子类中对抽象类里面定义的抽象方法的具体实现">运算实现针对存储结构，可以理解为java继承抽象类的子类中对抽象类里面定义的抽象方法的具体实现=</h4>
<h3 id="题型">题型</h3>
<h4
id="判断一个结构是逻辑结构还是存储结构">判断一个结构是逻辑结构还是存储结构：</h4>
<h5 id="首先要熟悉基本数据结构的实现">首先要熟悉基本数据结构的实现</h5>
<h5
id="判断逻辑结构就是看给出的结构抽不抽象如果可以用多种存储方式实现就是抽象">判断逻辑结构就是看给出的结构抽不抽象，如果可以用多种存储方式实现就是抽象</h5>
<h5
id="判断存储结构就是看具不具体如果指定了存储方式就是具体">判断存储结构就是看具不具体，如果指定了存储方式就是具体</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217094819.jpg"
alt="微信图片_20231217094819" />
<figcaption aria-hidden="true">微信图片_20231217094819</figcaption>
</figure>
<h5
id="逻辑结构与存储结构之间关系逻辑结构是独立的但存储结构依赖于逻辑结构是逻辑结构在计算机上的实现">逻辑结构与存储结构之间关系：逻辑结构是独立的，但存储结构依赖于逻辑结构，是逻辑结构在计算机上的实现</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217095851.jpg"
alt="微信图片_20231217095851" /> ## 算法评价 ### 时间复杂度 ####
计算规则 ##### 加法：一个算法的时间复杂度由其中最耗时的决定 #####
乘法：嵌套的循环里时间复杂度相乘 #### 题型 ##### 嵌套循环的计算： ######
1 外层循环计算了多少次，在多少次终止 ###### 2 内存循环每次计算了多少次
###### 3 外层执行一次乘这次内层执行的次数后求和 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217101508.jpg"
alt="微信图片_20231217101508" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217102736.jpg"
alt="微信图片_20231217102736" />
<figcaption aria-hidden="true">微信图片_20231217102736</figcaption>
</figure>
<h5 id="递归的计算">递归的计算</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217103806.jpg"
alt="微信图片_20231217103806" />
<figcaption aria-hidden="true">微信图片_20231217103806</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217104339.jpg"
alt="微信图片_20231217104339" />
<figcaption aria-hidden="true">微信图片_20231217104339</figcaption>
</figure>
<h3 id="空间复杂度">空间复杂度</h3>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/posts/40f24371.html</url>
    <content><![CDATA[<h1 id="线性表">线性表</h1>
<h2 id="定义">定义：</h2>
<h3 id="类型相同的数据元素">类型相同的数据元素</h3>
<h3 id="长度有限">长度有限</h3>
<h3 id="逻辑结构">逻辑结构</h3>
<h3 id="题型一什么是线性表">题型一：什么是线性表</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217105307.jpg"
alt="微信图片_20231217105307" />
<figcaption aria-hidden="true">微信图片_20231217105307</figcaption>
</figure>
<h2 id="线性表的顺序表示又叫顺序表">线性表的顺序表示，又叫顺序表</h2>
<h3 id="定义-1">定义：</h3>
<h4 id="逻辑相邻物理也相邻">逻辑相邻，物理也相邻</h4>
<h4
id="与数组区别在于线性表是从下标1开始存储数组是从0开始">与数组区别在于线性表是从下标1开始存储，数组是从0开始</h4>
<p>举例：顺序存储线性表的特点：随机存取，含义是线性表可以直接访问指定地址元素，且时间复杂度为O(1)</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140802.jpg"
alt="微信图片_20231217140802" />
<figcaption aria-hidden="true">微信图片_20231217140802</figcaption>
</figure>
<h3 id="基本操作">基本操作</h3>
<h4
id="在第i个位置插入新元素e插入位置可以从1到l.length-1">在第i个位置插入新元素e(插入位置可以从1到L.length
+ 1)</h4>
<h5
id="主要思路从最后一个起到第i个将所有元素往后移动一位这样位置i就空出来可以放元素了">主要思路：从最后一个起到第i个将所有元素往后移动一位，这样位置i就空出来可以放元素了</h5>
<h5 id="平均次数fracn2"><span
class="math inline">\(平均次数：\frac{n}{2}\)</span></h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140039.jpg"
alt="微信图片_20231217140039" />
<figcaption aria-hidden="true">微信图片_20231217140039</figcaption>
</figure>
<h5 id="时间复杂度on"><span
class="math inline">\(时间复杂度O(n)\)</span></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;	<span class="comment">//判断插入位置是否合理，注意，插入的最后一个可以是在现在队尾的下一位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length; L &gt;= i; i++) &#123;	<span class="comment">//后移，注意，后移的范围是从当前队尾到插入位置</span></span><br><span class="line">        L.data[j + <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="删除第i个位置元素删除位置1到l.length">删除第i个位置元素，删除位置1到L.length</h4>
<h5
id="主要思路通过将从i-1个位置起元素一起向前移动一位覆盖前一位元素实现">主要思路：通过将从i
+ 1个位置起元素一起向前移动一位,覆盖前一位元素实现</h5>
<h5 id="移动节点平均次数fracn-12"><span
class="math inline">\(移动节点平均次数\frac{n-1}{2}\)</span></h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140458.jpg"
alt="微信图片_20231217140458" />
<figcaption aria-hidden="true">微信图片_20231217140458</figcaption>
</figure>
<h5 id="时间复杂度on-1"><span
class="math inline">\(时间复杂度O(n)\)</span></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype &amp;e)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j] = L.data[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="查找值是i的元素就是遍历整个数组查找">查找值是i的元素：就是遍历整个数组查找</h4>
<h2 id="线性表的链式表示">线性表的链式表示：</h2>
<h3 id="头节点和头指针">头节点和头指针</h3>
<h4
id="头节点叫头结点的就是虚拟头节点">头节点：叫头结点的就是虚拟头节点</h4>
<h4
id="头指针头指针始终指向第一个节点如果有头节点就指向头节点如果没有就指向链表的第一个节点">头指针：头指针始终指向第一个节点，如果有头节点就指向头节点，如果没有就指向链表的第一个节点</h4>
<h3 id="单链表">单链表</h3>
<h4 id="头插法">头插法</h4>
<h5 id="新节点的尾指针指向虚拟头节点的next">1
新节点的尾指针指向虚拟头节点的next</h5>
<h5 id="虚拟头节点的next再指向新节点">2
虚拟头节点的next再指向新节点</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newNode-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="尾插法">尾插法</h4>
<h5 id="定义一个额外的尾指针">1定义一个额外的尾指针</h5>
<h5 id="先把尾指针的next指向新节点">2 先把尾指针的next指向新节点</h5>
<h5 id="再移动尾指针指向新节点">3 再移动尾指针指向新节点</h5>
<h5 id="最后把尾指针的next放空">4最后把尾指针的next放空</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear-&gt;next = newNode;</span><br><span class="line">rear = newNode;</span><br></pre></td></tr></table></figure>
<h4
id="按序号查找注意节点序号从1开始因为链表也是线性表线性表就是从1开始-指针p一次往后移动1次移动i-1次最终指向的位置就是序号i的节点">按序号查找：注意节点序号从1开始(因为链表也是线性表，线性表就是从1开始)
，指针p一次往后移动1次，移动i-1次，最终指向的位置就是序号i的节点</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找">按值查找</h4>
<h4 id="在位置i插入节点">在位置i插入节点</h4>
<h5
id="先查找插入位置前驱节点利用前面写好的按序号查找方法">先查找插入位置前驱节点，利用前面写好的按序号查找方法</h5>
<h5
id="在将新节点的next指向原来序号i的节点序号i-1的next指向新节点">在将新节点的next指向原来序号i的节点，序号i-1的next指向新节点</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *before = GetElem(LinkList L, i<span class="number">-1</span>);</span><br><span class="line">newNode-&gt;next = before-&gt;next;</span><br><span class="line">before-&gt;next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="删除序号是i的节点">删除序号是i的节点</h4>
<h5
id="利用前面查找节点查找到节点i-1">利用前面查找节点查找到节点i-1</h5>
<h5 id="用临时指针指向节点i">用临时指针指向节点i</h5>
<h5 id="节点i-1的next直接指向i的next">节点i-1的next直接指向i的next</h5>
<h5 id="free掉节点i">free掉节点i</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *before = GetElem(LinkList L, i);</span><br><span class="line">LNode *tmp = before-&gt;next;</span><br><span class="line">before-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br></pre></td></tr></table></figure>
<h4 id="求表长">求表长</h4>
<h3 id="双链表">双链表</h3>
<h4
id="在指定节点p之后插入节点s顺序不唯一但一定要注意操作过程不能把原来的后继节点位置中途搞丢">在指定节点p之后插入节点s(顺序不唯一，但一定要注意操作过程不能把原来的后继节点位置中途搞丢)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先处理后半部分</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line"><span class="comment">//再处理前半部分</span></span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<h4 id="删除节点p的后继节点q">删除节点p的后继节点q</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;priror = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<h4
id="循环单链表尾节点的next不是null而指向头节点">循环单链表：尾节点的next不是NULL，而指向头节点</h4>
<p>举个例子</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217160038.jpg"
alt="微信图片_20231217160038" />
<figcaption aria-hidden="true">微信图片_20231217160038</figcaption>
</figure>
<p>删除后还要判断链表是否为空，如果为空(临时指针和尾指针指向同一个节点，就要修改尾指针)</p>
<p>####循环双链表</p>
<h3
id="静态链表结构体数组的数据域data里存数据指针域里存下一个节点的地址不过这个地址是结构体数组里unsigned-int类型的下标">静态链表：结构体数组的数据域data里存数据，指针域里存下一个节点的地址，不过这个地址是结构体数组里unsigned
int类型的下标</h3>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
  </entry>
  <entry>
    <title>第一章-命题逻辑的基本概念</title>
    <url>/posts/10c6a857.html</url>
    <content><![CDATA[<h1 id="命题与联结词">命题与联结词</h1>
<span id="more"></span>
<h2 id="命题"><strong>命题</strong></h2>
<p>判断结果惟一（非真即假）的陈述句</p>
<h3 id="命题的真值-判断的结果"><strong>命题的真值</strong>
<strong>判断的结果</strong></h3>
<h3 id="真值的取值-真与假"><strong>真值的取值</strong>
<strong>真与假</strong></h3>
<p>注意</p>
<p><strong>感叹句、祈使句、疑问句都不是命题</strong></p>
<p><strong>陈述句中的悖论，判断结果不惟一确定的不是命题</strong></p>
<p>举个例子</p>
<p><span class="math inline">\(\sqrt{2}是有理数\)</span>
是命题，但是是假命题</p>
<p>x + 5 &gt; 3 不是命题</p>
<p>2050年元旦下大雪 是命题，但是真假未知</p>
<h3
id="命题分类简单命题也称原子命题与复合命题">命题分类：简单命题（也称原子命题）与复合命题</h3>
<h4 id="简单命题符号化"><strong>简单命题符号化</strong></h4>
<p>用小写英文字母 <span class="math inline">\(p,q,r, …,p_i, q_i, r_i(i
&gt; 1)\)</span>表示简单命题</p>
<p>用1表示真，用0表示假</p>
<p>举个例子</p>
<p><span class="math inline">\(p:\sqrt{2}是有理数，
则p的真值为0\)</span></p>
<h2 id="联结词">联结词</h2>
<h3 id="否定lnot">否定：<span class="math inline">\(\lnot\)</span></h3>
<p>规定<span class="math inline">\(\lnot p\)</span>
为真当且仅当p为假</p>
<h3 id="合取-land"><strong>合取</strong>: <span
class="math inline">\(\land\)</span></h3>
<p>p与q要同时为真才为真</p>
<h3 id="析取lor">析取：<span class="math inline">\(\lor\)</span></h3>
<p>p与q之一为真即为真</p>
<h4 id="相同或">相同或</h4>
<p>举个例子</p>
<p>令p:2是素数,q:4是素数,<span class="math inline">\(p\lor
q\)</span></p>
<h4 id="排斥或">排斥或</h4>
<p>举个例子</p>
<p>p:王小红生于1975年,q:王小红生于1976年,</p>
<p><span class="math inline">\((p\land \lnot q)\lor (\lnot p \lor q)或p
\or q\)</span></p>
<h3 id="蕴含to">蕴含：<span class="math inline">\(\to\)</span></h3>
<p>如果p，则q，记作<span class="math inline">\(p \to q\)</span>，
p是前件，q是后件，规定<span class="math inline">\(p \to
q\)</span>为假当且仅当p为真q为假</p>
<p>注：</p>
<ol type="1">
<li><p><span class="math inline">\(p \to
q\)</span>的逻辑关系：<font color = "red">q为p的必要条件</font>,这个很重要，直接区分了只要……就和只有……才的区别</p></li>
<li><p>当p为假时，<span class="math inline">\(p\to
q\)</span>恒为真，称为空证明</p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9431cbcfcb225833f2a8472c4f728c9.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="等价联结词leftrightarrow">等价联结词:<span
class="math inline">\(\leftrightarrow\)</span></h3>
<h1 id="命题公式及其赋值"><strong>命题公式及其赋值</strong></h1>
<h2 id="命题变项与合式公式"><strong>命题变项与合式公式</strong></h2>
<h3 id="命题变项">命题变项</h3>
<p>命题常项：简单命题</p>
<p>命题变项（命题变元）：真值可以变化的陈述句</p>
<h3 id="合式公式的递归定义">合式公式的递归定义</h3>
<p>就是如果一个已经时合式公式，那么在基础上的运算产生的公式也是合式公式</p>
<h3 id="合式公式的层次">合式公式的层次</h3>
<p>(1)若公式A是单个命题变项，则称A为0层公式</p>
<ol start="2" type="1">
<li>A时n+1层的前提，在于得到A的公式中最大层数时n</li>
</ol>
<p>举个例子</p>
<p><span class="math inline">\(A = B \land
C\)</span>,其中B,C分别为层和j层公式，且n =max(i,j)</p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/82d3859feb3ba201b0d65a55243be82.jpg" /></p>
<h2
id="公式的赋值使这个公式为真的赋值称作成真赋值成假的就是成假赋值"><strong>公式的赋值</strong>：使这个公式为真的赋值称作成真赋值，成假的就是成假赋值</h2>
<p>注: 含n个命题变项的公式有<span
class="math inline">\(2^n\)</span>个赋值</p>
<h2 id="真值表从0列到2n---1">真值表：从0列到<span
class="math inline">\(2^n - 1\)</span></h2>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240226162335090.png" /></p>
<h3 id="公式的类型">公式的类型</h3>
<h3 id="重言式永真式">重言式(永真式)</h3>
<h3 id="矛盾式永假式">矛盾式(永假式)</h3>
<h3 id="可满足式">可满足式</h3>
<h2 id="公式和真值表用途">公式和真值表用途</h2>
<p>n个命题变项，可以构成无穷多个合式公式，这些公式的真值表有<span
class="math inline">\(2^{2^n}\)</span>个不同的情况，因为有n个命题变项，每个有2种选择，有<span
class="math inline">\(2^n\)</span>种，结果有2种选择</p>
<h1 id="section"></h1>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-命题逻辑的推理理论</title>
    <url>/posts/b34dc25f.html</url>
    <content><![CDATA[<h1 id="推理的形式结构">推理的形式结构</h1>
<span id="more"></span>
<h2 id="推理的正确与错误">推理的正确与错误</h2>
<p>设 A1, A2, ..., Ak, B 为命题公式。若对于每一组赋值，当 A1 ∧ A2 ∧ ...
∧ Ak 为假时，或者当 A1 ∧ A2 ∧ ... ∧ Ak 为真时，B 也为真，则称由前提 A1,
A2, ..., Ak 推出结论 B 的推理是有效的或正确的，并称 B 是有效结论。</p>
<h2 id="推理的形式结构-1">推理的形式结构</h2>
<ol type="1">
<li>{A1, A2, …, Ak} ⊢ B 若推理正确，记为 {A1, A2, ..., An} ⊢ B 记Γ =
{A1, A2, …, Ak}，则 Γ ⊢ B. 若推理正确，则 Γ ⊢ B.</li>
<li><span class="math inline">\((A1 ∧ A2 ∧ … ∧ Ak \rightarrow B)
若推理正确，记为 (A1 ∧ A2 ∧ … ∧ Ak \Rightarrow B)\)</span></li>
<li>前提：(A1, A2, ..., Ak) 结论：(B)</li>
</ol>
<h2 id="判断推理正确的方法">判断推理正确的方法</h2>
<ol type="1">
<li>真值表法</li>
<li>等值演算法</li>
<li>主析取范式法</li>
</ol>
<p>举例：</p>
<p>判断下面推理是否正确 (1) 若今天是1号, 则明天是5号. 今天是1号. 所以,
明天是5号.<br />
(2) 若今天是1号, 则明天是5号. 明天是5号. 所以, 今天是1号.</p>
<p>首先表示（1）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6a754e0ce024506e9bd01c6a5fb74f2.jpg" /></p>
<p>用等值演算法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5e7b6268e783c344436a60e51802d24.jpg" /></p>
<p>用主析取范式，以（2）为例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/77a01b599885f2e3178da79f3b105ae.jpg" /></p>
<h2 id="推理定律重点"><font color = "red">推理定律(重点)</font></h2>
<ol type="1">
<li><span class="math inline">\(A \Rightarrow (A \lor B)\)</span> 附加律
(如果命题A为真，那么命题A或B为真)</li>
<li><span class="math inline">\((A \land B) \Rightarrow A\)</span>
化简律</li>
<li><span class="math inline">\((A \Rightarrow B) \land A \Rightarrow
B\)</span> 假言推理</li>
<li><span class="math inline">\((A \Rightarrow B) \land \lnot B
\Rightarrow \lnot A\)</span> 拒取式<br />
</li>
<li><span class="math inline">\((A \lor B) \land \lnot B \Rightarrow
A\)</span> 析取三段论</li>
<li><span class="math inline">\((A \Rightarrow B) \land (B \Rightarrow
C) \Rightarrow (A \Rightarrow C)\)</span> 假言三段论</li>
<li><span class="math inline">\((A \Leftrightarrow B) \land (B
\Leftrightarrow C) \Rightarrow (A \Leftrightarrow C)\)</span>
等价三段论</li>
<li><span class="math inline">\((A \Rightarrow B) \land (C \Rightarrow
D) \land (A \lor C) \Rightarrow (B \lor D)\)</span> 构造性二难 <span
class="math inline">\((A \Rightarrow B) \land (\lnot A \Rightarrow B)
\Rightarrow B\)</span> 构造性二难(特殊形式)</li>
<li><span class="math inline">\((A \Rightarrow B) \land (C \Rightarrow
D) \land (\lnot B \lor \lnot D) \Rightarrow (\lnot A \lor \lnot
C)\)</span> 破坏性二难</li>
</ol>
<p>每个等值式可产生两个推理定律 如，由 <span class="math inline">\(A
\Leftrightarrow \lnot \lnot A\)</span> 可产生 <span
class="math inline">\(A \Rightarrow \lnot \lnot A\)</span> 和 <span
class="math inline">\(\lnot \lnot A \Rightarrow A\)</span></p>
<h1 id="自然推理系统p">自然推理系统P</h1>
<h2 id="形式系统的定义与分类">形式系统的定义与分类</h2>
<h2 id="自然推理系统p-1">自然推理系统P</h2>
<h3 id="字母表">字母表</h3>
<ol type="1">
<li>命题变项符号：p, q, r, …, pi, qi, ri, …</li>
<li>联结词符号：¬, ∧, ∨, →, ↔︎</li>
<li>括号与逗号：(, ), ，</li>
</ol>
<h3 id="合式公式同定义1.6">合式公式（同定义1.6）</h3>
<p>有限次地应用联结词和括号形成的命题符号串是合式公式</p>
<h3
id="推理规则重点中的重点"><font color = "red">推理规则(重点中的重点)</font></h3>
<ol type="1">
<li>前提引入规则</li>
<li>结论引入规则</li>
<li>置换规则（就是德摩根律）</li>
</ol>
<p>注：</p>
<p><font color = "red">假言推理在于蕴含式前提为真</font></p>
<p><font color = "red">拒取式规则在于蕴含式结论为假</font></p>
<p><font color = "red">假言三段论在于递推</font></p>
<p><font color = "red">析取三段论或的一方为假</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325150416218.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325150426381.png" /></p>
<h2
id="在p中构造证明直接证明法附加前提证明法归谬法">在P中构造证明:直接证明法、附加前提证明法、归谬法</h2>
<h3 id="直接证明法">直接证明法</h3>
<p>举例：</p>
<p>构造下面推理的证明： 若明天是星期一或星期三, 我明天就有课.
若我明天有课, 今天必备课. 我今天没备课. 所以, 明天不是星期一, 也不
是星期三.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/1d9392a9b4536441ba48c4005c0ce49.jpg" /></p>
<h3 id="附加前提证明法">附加前提证明法</h3>
<p>欲证 前提：(A1, A2, …, Ak) 结论：<span class="math inline">\(C
\Rightarrow B\)</span></p>
<p>等价地证明 前提：(A1, A2, …, Ak, C) 结论：B</p>
<p>理由： <span class="math inline">\((A1 \land A2 \land … \land Ak)
\Rightarrow (C \Rightarrow B)\)</span> <span
class="math inline">\(\equiv \lnot (A1 \land A2 \land … \land Ak) \lor
(\lnot C \lor B)\)</span> <span class="math inline">\(\equiv \lnot (A1
\land A2 \land … \land Ak \land C) \lor B\)</span> <span
class="math inline">\(\equiv (A1 \land A2 \land … \land Ak \land C)
\Rightarrow B\)</span></p>
<p><font color = "red">适用于结论为蕴涵式，本质就是将本来结论中的前提也作为条件</font></p>
<p>举例:构造下面推理的证明:</p>
<p>"2是素数或合数. 若2是素数, 则 () 是无理数. 若 () 是无理数,
则4不是素数. 所以, 如果4是素数, 则2是合数."</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5586ba2610cf6608c526036e805adb5.jpg" /></p>
<h3 id="归谬法反证法">归谬法（反证法）</h3>
<p>欲证 前提：(A1, A2, … , Ak)<br />
结论：(B)</p>
<p>做法 <font color = "red">在前提中加入<span class="math inline">\(lnot
B\)</span>，推出矛盾.</font></p>
<p>理由： <span class="math inline">\(A1\land A2\land …\land
Ak\Rightarrow B\)</span> <span class="math inline">\(\equiv
\lnot(A1\land A2\land …\land Ak)\lor B\)</span> <span
class="math inline">\(\equiv \lnot(A1\land A2\land …\land Ak\land\lnot
B)\)</span> <span class="math inline">\(\equiv \lnot(A1\land A2\land
…\land Ak\land\lnot B)\lor 0\)</span> <span class="math inline">\(\equiv
A1\land A2\land …\land Ak\land\lnot B\Rightarrow 0\)</span></p>
<p>举例：</p>
<p>前提：<span class="math inline">\(\lnot(p\land q))\lor r\)</span>,
<span class="math inline">\(r\Rightarrow s\)</span>, <span
class="math inline">\(\lnot s\)</span>, <span
class="math inline">\(p\)</span><br />
结论：<span class="math inline">\(\lnot q\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c8cc52970162529ec6abfc6e1d19155.jpg" /></p>
<h1 id="消解证明法">消解证明法</h1>
<p>基本做法：
1.<font color = "red">把前提中的公式,结论的否定都化成等值的合取范式</font>
2.<font color = "red">列出所有合取范式的所有简单析取式作为前提</font>
3.用消解规则构造证明.
4.<font color = "red">如果得到空式(就是矛盾），则证明推理是正确的.</font></p>
<p>举例</p>
<p>前提：<span class="math inline">\(q\Rightarrow p\)</span>, <span
class="math inline">\(q\Leftrightarrow s\)</span>, <span
class="math inline">\(s\Leftrightarrow t\)</span>, <span
class="math inline">\(t\land r\)</span><br />
结论：<span class="math inline">\(p\land q\land s\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9451f03b4db5480042cc1f2b2ba5d82.jpg" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-命题逻辑等值演算</title>
    <url>/posts/d8837e86.html</url>
    <content><![CDATA[<h1 id="等值式与基本的等值式">等值式与基本的等值式</h1>
<span id="more"></span>
<h2 id="等值式定义">等值式定义</h2>
<p>如果A<span
class="math inline">\(\leftrightarrow\)</span>B是永真式(重言式)，则称A与B等值</p>
<p>注：</p>
<ol type="1">
<li>哑元</li>
</ol>
<p>举例</p>
<ol type="1">
<li>判断两个公式是否等值</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/729b4593eee6390e616eb31c6f4911c.jpg" /></p>
<h2 id="基本等值式">基本等值式</h2>
<h3 id="双重否定律-a-a">双重否定律: ¬(¬A) ↔︎ A</h3>
<h3 id="幂等律-a-a-a-a-a-a">幂等律: A ∨ A ↔︎ A, A ∧ A ↔︎ A</h3>
<h3 id="交换律-a-b-b-a-a-b-b-a">交换律: A ∨ B ↔︎ B ∨ A, A ∧ B ↔︎ B ∧
A</h3>
<h3 id="结合律-a-b-c-a-b-c-a-b-c-a-b-c">结合律: (A ∨ B) ∨ C ↔︎ A ∨ (B ∨
C), (A ∧ B) ∧ C ↔︎ A ∧ (B ∧ C)</h3>
<h3 id="分配律-a-b-c-a-b-a-c-a-b-c-a-b-a-c">分配律: A ∨ (B ∧ C) ↔︎ (A ∨
B) ∧ (A ∨ C), A ∧ (B ∨ C) ↔︎ (A ∧ B) ∨ (A ∧ C)</h3>
<h3 id="德摩根律-a-b-a-b-a-b-a-b"><font color = "red">德摩根律</font>:
¬(A ∨ B) ↔︎ (¬A) ∧ (¬B), ¬(A ∧ B) ↔︎ (¬A) ∨ (¬B)</h3>
<h3 id="吸收律-a-a-b-a-a-a-b-a"><font color = "red">吸收律:</font> A ∨
(A ∧ B) ↔︎ A, A ∧ (A ∨ B) ↔︎ A</h3>
<h3 id="零律-a-1-1-a-0-0">零律: A ∨ 1 ↔︎ 1, A ∧ 0 ↔︎ 0</h3>
<h3 id="同一律-a-0-a-a-1-a">同一律: A ∨ 0 ↔︎ A, A ∧ 1 ↔︎ A</h3>
<h3 id="排中律-a-a-1">排中律: A ∨ ¬A ↔︎ 1</h3>
<h3 id="矛盾律-a-a-0">矛盾律: A ∧ ¬A ↔︎ 0</h3>
<h3 id="蕴涵等值式-a-b-a-b"><font color = "red">蕴涵等值式</font>: A → B
↔︎ ¬A ∨ B</h3>
<h3 id="等价等值式-a-b-a-b-b-a">等价等值式: A ↔︎ B ↔︎ (A → B) ∧ (B →
A)</h3>
<h3 id="假言易位-a-b-b-a"><font color = "red">假言易位</font>: A → B ↔︎
¬B → ¬A</h3>
<h3 id="等价否定等值式-a-b-a-b">等价否定等值式: A ↔︎ B ↔︎ ¬A ↔︎ ¬B</h3>
<h3 id="归谬论-a-b-a-b-a"><font color = "red">归谬论</font>: (A → B) ∧
(A → ¬B) ↔︎ ¬A</h3>
<h1 id="等值演算与置换规则">等值演算与置换规则</h1>
<h2 id="置换规则">置换规则</h2>
<p><span class="math inline">\(如果 \Phi(A) 是包含公式 A 的命题公式，
\Phi(B) 是将公式 B 替换为 \Phi(A) 中所有的 A 后得到的命题公式，则若 B
\leftrightarrow A ，则 \Phi(B) \leftrightarrow \Phi(A)。\)</span></p>
<p>等值演算应用举例</p>
<ol type="1">
<li><p>证明两个公式等值</p>
<p>比如证明$p (q r) (p q) r $</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/e2a76a38f993148b2fbf3817eaecb5d.jpg" /></p></li>
</ol>
<p>​ 注：用等值演算不能直接证明两个公式不等值</p>
<p>​ 证明两个公式不等值的方法：</p>
<p>​ 举个例子：$p (q r) 与 (p q) r $</p>
<p>​ ①真值表</p>
<p>​ ②观察:000左真右假</p>
<p>​ ③先用等值化简再观察</p>
<ol start="2" type="1">
<li><p>判断公式类型</p>
<p><span class="math inline">\(q \land \neg (p \rightarrow
q)\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/949c2cc74f5622a9fac0fc88879c8ca.jpg" /></p></li>
</ol>
<h1
id="析取范式与合取范式主析取范式与主合取范式">析取范式与合取范式，主析取范式与主合取范式</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="文字">文字</h3>
<p>命题变项及其否定的总称</p>
<h3 id="简单析取式">简单析取式</h3>
<h3
id="由有限个文字构成的析取式一些例子包括">由有限个文字构成的析取式。一些例子包括：</h3>
<ul>
<li>p</li>
<li><span class="math inline">\(\neg q\)</span></li>
<li><span class="math inline">\(p \lor \neg q\)</span></li>
<li><span class="math inline">\(p \lor q \lor r\)</span></li>
<li>...</li>
</ul>
<h3 id="简单合取式">简单合取式</h3>
<p>由有限个文字构成的合取式。一些例子包括：</p>
<ul>
<li>p</li>
<li>$ q $</li>
<li>$ p q $</li>
<li>$ p q r $</li>
<li>...</li>
</ul>
<h3 id="析取范式">析取范式</h3>
<p>是由有限个简单合取式组成的析取式。以下是一些例子：</p>
<p><span class="math inline">\(p, \quad \neg p \land q, \quad p \lor
\neg q, \quad (p \land \neg q) \lor (\neg p \land q \land \neg r) \lor
(q \land r)\)</span></p>
<h3 id="合取范式">合取范式</h3>
<p>由有限个简单析取式组成的合取式。以下是一个例子：</p>
<p><span class="math inline">\(p, \quad p \lor \neg q, \quad \neg p
\land q, \quad (p \lor q) \land \neg p \land (p \lor \neg q \lor \neg
r)\)</span></p>
<h3 id="范式">范式</h3>
<p>析取范式与合取范式的总称</p>
<h2 id="范式的性质">范式的性质</h2>
<h3 id="简单范式">简单范式</h3>
<ol type="1">
<li><p>一个简单析取式是重言式当且仅当它同时含有某个命题变项和它的否定式</p></li>
<li><p>一个简单合取式是矛盾式当且仅当它同时含有某个命题变项和它的否定式</p></li>
</ol>
<h3 id="复合范式">复合范式</h3>
<ol type="1">
<li><p>一个析取范式是矛盾式当且仅当它每个简单合取式都是矛盾式</p></li>
<li><p>一个合取范式是重言式当且仅当它的每个简单析取式都是重言式</p></li>
</ol>
<p>注：单个文字既是简单析取式，又是简单合取式</p>
<h3 id="范式存在定理">范式存在定理</h3>
<p>任何命题公式都存在与之等值的析取范式与合取范式</p>
<h2 id="求公式的范式">求公式的范式</h2>
<h3 id="消去a中的to-leftrightarrow">消去A中的<span
class="math inline">\(\to\)</span> , <span
class="math inline">\(\leftrightarrow\)</span></h3>
<h3 id="否定连接词lnot內移或消去">否定连接词<span
class="math inline">\(\lnot\)</span>內移或消去</h3>
<h3 id="分配律">分配律</h3>
<p>举个例子</p>
<p>(p→¬q)→r</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d8bde4ae81b9643ff4d2ca7207fc200.jpg" /></p>
<h2 id="极小项与极大项">极小项与极大项</h2>
<h3 id="定义">定义：</h3>
<p>在含有n个命题变项的简单合取式（简单析取式）中，若每个命题变项均以文字的形式在其中出现且仅出现一次，而且第k个文字出现在左起第k位上（1≤k≤n），称这样的简单合取式（简单析取式）为极小项（极大项）。</p>
<p>①每个命题变项均以文字的形式在其中出现且仅出现一次</p>
<p>②第k个文字出现在左起第k位上（1≤k≤n）</p>
<p>③简单合取<span class="math inline">\(\land\)</span>,成真赋值<span
class="math inline">\(\to\)</span>极小项，简单析取<span
class="math inline">\(\lor\)</span>，成假赋值<span
class="math inline">\(\to\)</span>极大项</p>
<p>注：</p>
<ol type="1">
<li><p>n个命题变项有<span
class="math inline">\(2^n\)</span>个极小项和<span
class="math inline">\(2^n\)</span>个极大项</p></li>
<li><p>这些极小项（极大项）均互不等值。</p></li>
<li><p>用<span
class="math inline">\(m_i\)</span>表示第i个极小项，其中i是该极小项成真赋值的十进制表示。用<span
class="math inline">\(M_i\)</span>表示第i个极大项，其中i是该极大项成假赋值的十进制表示。<span
class="math inline">\(m_i\)</span>（<span
class="math inline">\(M_i\)</span>）称为极小项（极大项）的名称。</p></li>
</ol>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304163125914.png" /></p>
<h2 id="主析取范式与主合取范式">主析取范式与主合取范式</h2>
<h3 id="主析取范式">主析取范式</h3>
<p>由极小项构成的析取范式</p>
<h3 id="主合取范式">主合取范式</h3>
<p>由极大项构成的合取范式</p>
<p>例如，n=3，命题变项为 p, q, r 时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(¬p ∧ ¬q ∧ r) ∨ (¬p ∧ q ∧ r) </span><br><span class="line">   ⇔ m1 ∨ m3 ——主析取范式</span><br><span class="line"></span><br><span class="line">(p ∨ q ∨ ¬r) ∧ (¬p ∨ ¬q ∨ ¬r) </span><br><span class="line">   ⇔ M1 ∧ M7——主合取范式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="求公式主析取范式的步骤"><font color = "red">求公式主析取范式的步骤:</font></h3>
<p>设公式A含命题变项p1,p2,…,pn。</p>
<ol type="1">
<li>求A的<font color = "red">析取范式A' = B1 ∨ B2 ∨ … ∨
Bs</font>，其中Bj是简单合取式 j=1,2, … ,s。</li>
</ol>
<p>(2)确保<font color = "red">每项简单合取式含有n个不同命题变项</font>。<font color = "red">若某个Bj既不含pi，又不含¬pi，则将Bj展开成：
Bj ⇔ Bj ∧ (pi ∨ ¬pi) ⇔ (Bj ∧ pi) ∨ (Bj ∧ ¬pi)</font>
。重复这个过程，直到所有简单合取式都是长度为n的极小项为止。</p>
<ol start="3" type="1">
<li><p><font color = "red">消去重复出现的极小项</font>，即用mi代替mi ∨
mi。</p></li>
<li><p>将极小项<font color = "red">按下标从小到大排列</font>。</p></li>
</ol>
<h3
id="求公式主范式的步骤"><font color = "red">求公式主范式的步骤</font></h3>
<p>设公式A含命题变项p1,p2,…,pn。</p>
<ol type="1">
<li>求A的合取范式A' = B1 ∧ B2 ∧ … ∧ Bs，其中Bj是简单析取式 j=1,2, …
,s。</li>
</ol>
<p>(2)确保每项简单合取式含有n个不同命题变项。若某个Bj既不含pi，又不含¬pi，则将Bj展开成：
Bj ⇔ Bj ∨ (pi ∧ ¬pi) ⇔ (Bj ∨ pi) ∧ (Bj ∨
¬pi)。重复这个过程，直到所有简单析取式都是长度为n的极大项为止。</p>
<ol start="3" type="1">
<li><p>消去重复出现的极大项，即用Mi代替Mi ∧ Mi。</p></li>
<li><p>将极大项按下标从小到大排列。</p></li>
</ol>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8db38cd2f3eb0bee006a209b4b93cd5.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1f10bde7bacb2bad2f2f56d6344f41b.jpg" /></p>
<h2 id="主范式的应用">主范式的应用</h2>
<h3 id="求公式的成真成假赋值">求公式的成真成假赋值</h3>
<p>举例：(p→¬q)→r</p>
<p>由上面可知</p>
<p>(p→¬q)→r ⇔ m1∨m3∨m5∨m6∨m7</p>
<p>成真赋值为 001, 011, 101, 110, 111， 成假赋值为 000, 010, 100.</p>
<h3 id="判断公式的类型">判断公式的类型</h3>
<p>A为重言式 ⇔ A的主析取范式含全部<span
class="math inline">\(2^n\)</span>个极小项 ⇔
A的主合取范式不含任何极大项，记为1.</p>
<p>A为矛盾式 ⇔ A的主合析取范式含全部<span
class="math inline">\(2^n\)</span>个极大项 ⇔
A的主析取范式不含任何极小项，记为0.</p>
<p>A为非重言式的可满足式<br />
⇔ A的主析取范式中至少含一个，但不是全部极小项 ⇔
A的主合取范式中至少含一个，但不是全部极大项.</p>
<p>举例</p>
<ol type="1">
<li>A ⇔ ¬(p→q)∧q<br />
</li>
<li>B ⇔ p→(p∨q)<br />
</li>
<li>C ⇔ (p∨q)→r</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/fa93bc4f19f4d865fe21f49f9ce9552.jpg" /></p>
<h3 id="解实际问题">解实际问题</h3>
<p>例9 某单位要从A,B,C三人中选派若干人出国考察, 需满足下 述条件: (1)
若A去, 则C必须去; (2) 若B去, 则C不能去; (3) A和B必须去一人且只能去一人.
问有几种可能的选派方案?</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/99ba1fd29a01ec68306533acc168ab7.jpg" /></p>
<h2
id="用成真赋值和成假赋值确定主范式">用成真赋值和成假赋值确定主范式</h2>
<p>例10 设A有3个命题变项, 且已知A= m1∨m3∨m7, 求A的主合取范式.</p>
<p>解 A的成真赋值是1,3,7的二进制表示, 成假赋值是在主析取
范式中没有出现的极小项的下角标0,2,4,5,6的二进制表示, 它
们恰好是A的主合取范式的极大项的下角标, 故 A ⇔ M0∧M2∧M4∧M5∧M6</p>
<p><font color = "red">主析取范式和主合取范式下标"互补"</font></p>
<h1 id="联结词完备集">联结词完备集</h1>
<h2 id="联结词完备集-1"><strong>联结词完备集</strong></h2>
<p>定义2.7 设S是一个联结词集合，如果任何n(n≥1)
元真值函数都可以由仅含S中的联结词构成的公式表示，则称S是联结词完备集</p>
<p>若S是联结词完备集, 则任何命题公式都可由S中的联结词表示</p>
<p>定理2.6 <font color = "red">S = {¬, ∧, ∨}是联结词完备集</font></p>
<h2 id="复合联结词">复合联结词</h2>
<p>定义2.8 设 p, q 为两个命题, 非(p且q)称作p与q的与非式, 记作 p↑q,
<font color = "red">即 p↑q ⇔ 非(p且q)</font>,
↑称为与非联结词。非(p或q)称作p与q的或非式, 记作 p↓q, 即 p↓q ⇔ 非(p或q),
↓称为或非联结词。</p>
<p>定理2.7 {↑}与{↓}为联结词完备集。</p>
<p>证明：{非, 且, 或}为完备集 非p ⇔ 非p且非p ⇔ 非(p或p) ⇔ p↓p p且q ⇔
非(非p或非q) ⇔ 非p↓非q ⇔ (p↓p)↓(q↓q) p或q ⇔ 非非(p或q) ⇔ 非(p↓q) ⇔
(p↓q)↓(p↓q)</p>
<p>得证{↓}为联结词完备集。对{↑}类似可证。</p>
<p>举例：用联接集中联接词改写</p>
<ol type="1">
<li><p>{¬, ∧, ∨}： A = (¬p ∨ ¬q) ∧ r</p></li>
<li><p>{¬, ∧}： A = (¬p ∧ ¬q) ∧ r</p></li>
<li><p>{¬, ∨}： A = (¬p ∨ ¬q) ∨ r （这种情况下无法使用∧）</p></li>
<li><p>{¬, →}： A = ¬(p → ¬q) ∧ r</p></li>
<li><p>{↑}： A = (p↑¬q) ∧ r</p></li>
<li><p>{↓}： A = (p↓¬q) ∧ r</p></li>
</ol>
<h1 id="可满足性问题与消解法">可满足性问题与消解法</h1>
<p>空简单析取定义：不含任何文字的简单析取式称作空简单析取式，记作λ。规定λ是不可满足的。</p>
<p>常见字母和含义：</p>
<p>S: 合取范式,</p>
<p>C: 简单析取式,</p>
<p>l: 文字,</p>
<p>α: 赋值,</p>
<p>公式可带下角标或 ′</p>
<p>文字 l 的补 lc: 若 l = p，则 lc = ¬p；若 l = ¬p，则 lc = p。</p>
<p>S <span class="math inline">\(\approx\)</span> S': S
是可满足的当且仅当 S' 是可满足的</p>
<p>消解式定义： 设 C1 = λ ∨ C1'，C2 = λc ∨ C2'，其中 C1' 和 C2' 不含 λ
和 λc，称 C1' ∨ C2' 为 C1 和 C2（以 λ 和 λc
为消解文字）的消解式或消解结果，记作 Res(C1, C2)。</p>
<p>消解式举例：Res(¬p ∨ q ∨ r, p ∨ q ∨ ¬s) = q ∨ r ∨
¬s，<font color = "red">观察可知没有p</font></p>
<p><font color = "yellow">消解步骤：</font></p>
<ol type="1">
<li><font color = "yellow">将公共字母且互为“相反数”的两个字母消去，比如上面的p</font></li>
<li><font color = "yellow">将剩下字母用∨连接</font></li>
</ol>
<h2 id="消解序列与合取范式的否证">消解序列与合取范式的否证</h2>
<p>消解序列的定义：设 S 是一个合取范式，C1, C2, ..., Cn
是一个简单析取式序列。如果对每一个 i (1 ≤ i ≤ n)，Ci 是 S
的一个简单析取式或者是 Res(Cj, Ck) (1 ≤ j &lt; k &lt; i)，则称此序列是由
S 导出 Cn 的消解序列。当 Cn = λ 时，称此序列是 S 的一个否证。</p>
<p><font color = "red">上面说白了就是消解到最后字母没了那么就是否证，否证又说明是不可满足</font></p>
<p>举个例子：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8647c26f8f4942650220ed6b886dc6e.jpg" /></p>
<h2 id="消解算法"><font color = "red">消解算法</font></h2>
<p>算法概括：</p>
<p>首先将<span
class="math inline">\(S_0和S_2设置为空集，S_1设置为原式S中的析取式的集合\)</span></p>
<p>然后每轮循环将<span class="math inline">\(S_0\)</span>与<span
class="math inline">\(S_1\)</span>中元素进行消解运算，运算得到的结果如果没有字母就退出循环，说明不可消解，如果消解结果既不在<span
class="math inline">\(S_0\)</span>中也不在<span
class="math inline">\(S_1\)</span>中就与<span
class="math inline">\(S_2\)</span>取并集</p>
<p>然后一轮消解后将S1赋给<span class="math inline">\(S_0\)</span>,<span
class="math inline">\(S_2\)</span>赋给<span
class="math inline">\(S_1\)</span>,<span
class="math inline">\(S_2\)</span>重置为空集。直到一轮循环后<span
class="math inline">\(S_2\)</span>还是空集循环结束输出yes</p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c81a1fdaf9df2d5784d6fe57958382d.jpg" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章-一阶逻辑等值演算与推理</title>
    <url>/posts/9973ebf8.html</url>
    <content><![CDATA[<h1 id="一阶逻辑等值式与置换规则">一阶逻辑等值式与置换规则</h1>
<span id="more"></span>
<h2 id="基本等值式">基本等值式</h2>
<h3
id="第一组命题逻辑中16组基本等值式">第一组:命题逻辑中16组基本等值式</h3>
<p>就是下面这些东西</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408140333849.png" /></p>
<h3 id="第二组">第二组</h3>
<h4 id="消去量词等值式">消去量词等值式</h4>
<p><font color = "yellow">说白了就是任意就是将所有情况并起来，存在就是将所有情况和起来</font></p>
<p>设D = {a1, a2, … , an}</p>
<p>① ∀xA(x) ≡ A(a1)∧A(a2)∧…∧A(an)</p>
<p>② ∃xA(x) ≡ A(a1)∨A(a2)∨…∨A(an)</p>
<h4 id="量词否定等值式">量词否定等值式</h4>
<p>① ¬∀xA(x) ≡
∃x¬A(x)(<font color = "yellow">任意的非就意味着存在非的情况</font>)</p>
<p>② ¬∃xA(x) ≡
∀x¬A(x)(<font color = "yellow">存在的非就意味着任意都是非</font>)</p>
<h4 id="量词辖域收缩与扩张等值式">量词辖域收缩与扩张等值式。</h4>
<p><font color = "yellow">1.
收缩是指收到约束变量，把自由变量扔出去，扩张就是将自由变量也考虑进来</font></p>
<p><font color = "yellow">2.
无论是∨还是∧收缩辖域时，∀或者∃都只能对含约束变量的作用</font></p>
<p><font color = "yellow">3.
→收缩辖域时，∀或者∃如果约束变量<font color = "red">在前面需要取反</font>,如果约束变量<font color = "red">在后面就不用取反</font></font></p>
<p>关于全称量词的：</p>
<p>①∀x(A(x)∨B) ≡ ∀xA(x)∨B</p>
<p>②∀x(A(x)∧B) ≡ ∀xA(x)∧B</p>
<p>③∀x(A(x)→B) ≡ ∃xA(x)→B</p>
<p>④∀x(B→A(x)) ≡ B→∀xA(x)</p>
<p>关于存在量词的：</p>
<p>①∃x(A(x)∨B) ≡ ∃xA(x)∨B</p>
<p>②∃x(A(x)∧B) ≡ ∃xA(x)∧B</p>
<p>③∃x(A(x)→B) ≡ ∀xA(x)→B</p>
<p>④∃x(B→A(x)) ≡ B→∃xA(x)</p>
<h4 id="量词分配等值式">量词分配等值式</h4>
<p><font color = "yellow">1.
与前面收缩扩张的区别在于，将∀（或者∃）分配给所有约束变量</font></p>
<p><font color = "yellow">2. ∀对∨，∃对∧无分配律</font></p>
<p>① ∀x(A(x)∧B(x)) ≡ ∀xA(x)∧∀xB(x)</p>
<p>② ∃x(A(x)∨B(x)) ≡ ∃xA(x)∨∃xB(x)</p>
<h2 id="置换规则换名规则代替规则">置换规则、换名规则、代替规则</h2>
<h3 id="置换规则">置换规则</h3>
<p><font color = "yellow">等价交换</font></p>
<p>设ϕ(A)是含A的公式，那么，若A⇔B，则ϕ(A)⇔ϕ(B).</p>
<h3 id="换名规则">换名规则</h3>
<p><font color = "yellow">指导变元和约束变量要换一起换</font></p>
<p>设A为一公式，将A中某量词辖域中一个个体变项的所有约束出现及相应的指导变元换成该量词辖域中未曾出现过的某个个体变项符号，其余部分不变，设所得公式为A'，则A'⇔A.</p>
<h3 id="代替规则">代替规则</h3>
<p><font color = "yellow">自由出现自个玩</font></p>
<p>设A为一公式，将A中某个个体变项的所有自由出现用A中未曾出现过的个体变项符号代替，其余部分不变，设所得公式为A'，则A'⇔A.</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例1 将下面命题用两种形式符号化, 并证明两者等值: (1)
没有不犯错误的人</p>
<p><a
href="https://www.bilibili.com/video/BV1Kz42117hH/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<ol start="2" type="1">
<li>不是所有的人都爱看电影</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/40456114877658721cdba1b5a1cf4b3.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>例2：将公式化成等值的不含既有约束出现、又有自由出现的个体变项：</p>
<p>∀x(F(x,y,z)→∃yG(x,y,z))</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/935b94e84a67e326ab9f309c28035cb.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>例3：设个体域D={a,b,c}，消去下述公式中的量词:</p>
<p>∀x∃y(F(x)→G(y))</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/376e0e692502bd7a6eabdca22aed69b.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="一阶逻辑前束范式">一阶逻辑前束范式</h1>
<p><font color = "yellow">1. 指导变元必须在一起</font></p>
<p><font color = "yellow">2. 指导变元前不能有非</font></p>
<p><font color = "yellow">3.
这一条不是必须，当往往遵守，就是不同辖域的指导变元尽量不要重名</font></p>
<p>例如， ∀x¬(F(x)∧G(x)) ∀x∃y(F(x)→(G(y)∧H(x,y))) 是前束范式 而
¬∃x(F(x)∧G(x)) ∀x(F(x)→∃y(G(y)∧H(x,y))) 不是前束范式,</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>求下列公式的前束范式:</p>
<ol type="1">
<li>∀xF(x)∧¬∃xG(x)</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a6fb111098f93eeb048d540d62f55bf.jpg" /></p>
<p>上面这个例子就是呼应了第三点不同指导变元尽量不要重名</p>
<ol start="2" type="1">
<li>∀x(F(x)→∃y(G(x,y)∧¬H(y)))</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9c72c5dce9e6f3093ffcd56f7ff5477.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="一阶逻辑的推论理论">一阶逻辑的推论理论</h1>
<h2 id="推理定律">推理定律</h2>
<h3 id="重言蕴涵式">重言蕴涵式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. A ⇒ (A∨B)                                                   附加律 </span><br><span class="line">2. (A∧B) ⇒ A                                                   化简律</span><br><span class="line">3. (A→B)∧A ⇒ B                                                 假言推理</span><br><span class="line">4. (A→B)∧¬B ⇒ ¬A                                               拒取式    </span><br><span class="line">5. (A∨B)∧¬B ⇒ A                                                析取三段论</span><br><span class="line">6. (A→B)∧(B→C) ⇒ (A→C)                                         假言三段论</span><br><span class="line">7. (A↔B)∧(B↔C) ⇒ (A↔C)                                         等价三段论</span><br><span class="line">8. (A→B)∧(C→D)∧(A∨C) ⇒ (B∨D)                                   构造性二难</span><br><span class="line">    (A→B)∧(¬A→B) ⇒ B                                           构造性二难(特殊形式)</span><br><span class="line">9. (A→B)∧(C→D)∧(¬B∨¬D) ⇒ (¬A∨¬C)                               破坏性二难</span><br></pre></td></tr></table></figure>
<h3 id="基于基本等值式">基于基本等值式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 零律: A∨1 ⇔ 1, A∧0 ⇔ 0</span><br><span class="line">2. 同一律: A∨0 ⇔ A, A∧1 ⇔ A</span><br><span class="line">3. 排中律: A∨¬A ⇔ 1</span><br><span class="line">4. 矛盾律: A∧¬A ⇔ 0</span><br><span class="line">5. 蕴涵等值式: A→B ⇔ ¬A∨B</span><br><span class="line">6. 等价等值式: A↔B ⇔ (A→B)∧(B→A)</span><br><span class="line">7. 假言易位: A→B ⇔ ¬B→¬A</span><br><span class="line">8. 等价否定等值式: A↔B ⇔ ¬A↔¬B</span><br><span class="line">9. 归谬论: (A→B)∧(A→¬B) ⇔ ¬A</span><br></pre></td></tr></table></figure>
<h3 id="量词分配蕴涵律">量词分配蕴涵律</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) ∀x(A(x)∨∀xB(x)) ⇒ ∀x(A(x)∨B(x)) </span><br><span class="line"></span><br><span class="line">(2) ∃x(A(x)∧B(x)) ⇒ ∃xA(x)∧∃xB(x)</span><br><span class="line"></span><br><span class="line">(3) ∀x(A(x)→B(x)) ⇒ ∀xA(x)→∀xB(x)</span><br><span class="line"></span><br><span class="line">(4) ∃x(A(x)→B(x)) ⇒ ∃xA(x)→∃xB(x)</span><br></pre></td></tr></table></figure>
<h2 id="量词消去引入规则">量词消去引入规则</h2>
<h3 id="全称量词消去规则-">全称量词消去规则(∀-)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415142936856.png" /></p>
<p>全称量词消去规则(∀-)</p>
<p>其中 x, y 是个体变项符号，c
是个体常项符号，<font color = "red">并且在 A 中 x 不在 ∀y 和 ∃y
的辖域内自由出现</font></p>
<p>来解释下这句绕口令一样的话</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>要特别注意使用∀-, ∀+, ∃-, ∃+规则的条件。就是上面那句像绕口令的话</p>
<p>反例1. 对 A = ∀x∃yF(x,y) 使用 ∀-规则，推得 B = ∃yF(y,y)。 取解释
I：个体域为 R，F(x, y): x &gt; y 在 I 下 A 被解释为 ∀x∃y(x&gt;y)，真；而
B 被解释为 ∃y(y&gt;y)，假。 原因：在 A 中 x 自由出现在 ∃y 的辖域 F(x,y)
内。</p>
<p>将上述段落重新打印。</p>
<hr style = "border:2px solid yellow">
<h3 id="全称量词引入规则">全称量词引入规则（∀+）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415143917922.png" /></p>
<p>其中 x
是个体变项符号，并且<font color = "red">不在前提的任何公式中自由出现</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>反例2. 前提: P(x)→Q(x), P(x) 结论: ∀xQ(x) 取解释I: 个体域为Z,
P(x):x是偶数， Q(x):x被2整除</p>
<p>在 I 下前提为真，结论为假，从而推理不正确</p>
<p>错误的证明如下</p>
<p>“证明”: ① P(x)→Q(x) 前提引入 ② P(x) 前提引入 ③ Q(x) ①②假言推理 ④
∀xQ(x) ③∀+</p>
<p>错误原因: 在④使用∀+规则，而 x 在前提的公式中自由出现。</p>
<hr style = "border:2px solid yellow">
<h3 id="存在量词消去规则-">存在量词消去规则（∃-）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415144537991.png" /></p>
<p>其中x是个体变项符号, 且不在前提的任何公式和B中自由出现</p>
<h3 id="存在量词引入消去规则">存在量词引入消去规则（∃+）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415150227362.png" /></p>
<p>其中 x, y 是个体变项符号，c 是个体常项符号，且在 A 中 y 和 c 不在 ∀x
和 ∃x 的辖域内自由出现。</p>
<h1 id="自然推理系统的证明">自然推理系统的证明</h1>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b435e0641c7c0e17e51f0c18f399c7b.jpg" /></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e8a5df5c71f58076fc8829a802fb10c.jpg" /></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章-集合代数</title>
    <url>/posts/36cbec99.html</url>
    <content><![CDATA[<h1 id="集合的基本概念">集合的基本概念</h1>
<span id="more"></span>
<p>集合表示法中微词表示法举例：<span class="math inline">\(S =
\{x|x是实数且x^2 - 1 = 0\}\)</span></p>
<h2 id="元素与集合">元素与集合</h2>
<h3 id="性质">性质</h3>
<p>无序性：元素列出的顺序无关 相异性：集合的每个元素只计数一次
确定性：对任何元素和集合都能确定这个元素是否为该集合的元素
任意性：集合的元素也可以是集合</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415082840554.png"
alt="集合1树状表示" />
<figcaption aria-hidden="true">集合1树状表示</figcaption>
</figure>
<p><font color = "yellow">从上图来看，集合中元素属于这个集合必须是直接属于</font></p>
<h2 id="集合与集合">集合与集合</h2>
<p>定义6.1子集: <span class="math inline">\(A \subseteq B
\Leftrightarrow \forall x (x \in A \rightarrow x \in B\)</span></p>
<p>定义6.1非子集: <span class="math inline">\(A \nsubseteq B
\Leftrightarrow \exists x (x \in A \land x \notin B)\)</span></p>
<p>定义6.2相等: <span class="math inline">\(A = B \Leftrightarrow A
\subseteq B \land B \subseteq A\)</span></p>
<p>定义6.3真子集: <span class="math inline">\(A \subsetneq B
\Leftrightarrow A \subseteq B \land A \neq B\)</span></p>
<p>注意： <font color = "yellow"><span
class="math inline">\(\in\)</span>和 <span
class="math inline">\(\subseteq\)</span>是不同层次的问题</font>，其中：</p>
<ul>
<li><span
class="math inline">\(\in\)</span>可以看作是不同层次上的集合元素与集合之间的关系。<font color = "red">通俗点说就是{
}数量不等</font></li>
<li><span
class="math inline">\(\subseteq\)</span>是同一层次上的两个集合之间的关系。<font color = "red">通俗点说就是{
}数量相等</font></li>
</ul>
<h2 id="空集全集和幂集">空集、全集和幂集</h2>
<p>幂集：集合A的全体子集构成的集合，记作 $P(A) = { x , | , x A } $</p>
<p>实例：$P() = {}, P({}) = {, {}}
$<font color = "yellow">第二个例子就是把空集当成1个普通元素就行，同时注意集合包含关系要求{
}层数相等</font></p>
<p>计数：如果 $ |A| = n ，则 |P(A)| = 2^n $</p>
<h1 id="集合的基本运算">集合的基本运算</h1>
<h2 id="初级运算">初级运算</h2>
<p>并: $ A B = {x , | , x A x B} $</p>
<p>交: $ A B = {x , | , x A x B} $</p>
<p>相对补: $ A - B = {x , | , x A x B} $</p>
<p>对称差: $ A B = (A - B) (B - A) $</p>
<p>绝对补: $ A = E - A $</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415084558934.png"
alt="初级运算的文氏图表示" />
<figcaption aria-hidden="true">初级运算的文氏图表示</figcaption>
</figure>
<h2 id="广义运算">广义运算</h2>
<h3 id="集合的广义并与广义交">集合的广义并与广义交</h3>
<p>广义并：集合A的元素的元素构成的集合，记作 $A = { x , | , z (z A x z)
} $</p>
<p>广义交：非空集合A的所有元素的公共元素构成的集合，记作 $ A = { x , | ,
z (z A x z) } $</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240417084719497.png" /></p>
<h3 id="性质-1">性质</h3>
<ol type="1">
<li>$ = ， $无意义</li>
<li><font color = "red">单元集 <span
class="math inline">\(\{x\}\)</span> 的广义并和广义交都等于 <span
class="math inline">\(x\)</span></font></li>
<li><font color ="red">广义运算减少集合的层次（括弧减少一层）</font></li>
<li>广义运算的计算：一般情况下可以转变成初级运算</li>
</ol>
<h2 id="运算的优先权规定">运算的优先权规定</h2>
<ol type="1">
<li><p>类运算：初级运算 $ , , - , $， 优先顺序由括号确定。</p></li>
<li><p>类运算：广义运算和 $ $运算， 运算由右向左进行。</p></li>
</ol>
<p>混合运算：2 类运算优先于 1 类运算。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9b405f93ea904fd3d76b2685b20a14f.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="有穷集的计数">有穷集的计数</h1>
<h2 id="容斥原理">容斥原理</h2>
<p>(多个字母的并事件)：奇数个字母前面是正号，偶数个字母前面是负号，然后组合排列出所有情况</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150120.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150328.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/16d2c959ab4666a7647f250f6251e61.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="集合恒等式">集合恒等式</h1>
<h2 id="只涉及一个运算的算律">只涉及一个运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093700840.png" /></p>
<h2 id="涉及两个不同运算的算律">涉及两个不同运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093725135.png" /></p>
<h2 id="涉及补运算的算律">涉及补运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093821897.png" /></p>
<h2 id="涉及全集和空集的算律">涉及全集和空集的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093841769.png" /></p>
<h2 id="集合证明题">集合证明题</h2>
<ol type="1">
<li><p>证 $ X Y $ 任取 $ x $， $ x X x Y $</p></li>
<li><p>证 $ X = Y $ 方法一：分别证明 $ X Y $ 和 $ Y X $ 方法二：任取
<span class="math inline">\(x\)</span>， $ x X x Y $</p></li>
</ol>
<h3 id="集合等式的证明">集合等式的证明</h3>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f42b9be412e552825a360c5161bd797.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="包含等价条件的证明">包含等价条件的证明</h3>
<p><font color = "red">确定命题，确定顺序</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-一阶（谓词）逻辑基本概念</title>
    <url>/posts/bf8cfd61.html</url>
    <content><![CDATA[<h1 id="一阶逻辑命题符号化">一阶逻辑命题符号化</h1>
<span id="more"></span>
<h2 id="个体词谓词量词">个体词、谓词、量词</h2>
<h3 id="谓词">谓词</h3>
<p>定义：刻画个体词性质或个体词之间相互关系的词，<strong>常用F, G,
H等表示</strong></p>
<p><strong>谓词常项 如, F(a)</strong>：a是人</p>
<p><strong>谓词变项 如, F(x)</strong>：x具有性质F</p>
<p><strong>n（n≥1）元谓词</strong>：P(x1, x2, …, xn)
，可以看成是以个体域为定义域，以{0,1}为值域的n元函数
<strong>一元谓词(n=1)</strong>——表示性质
<strong>多元谓词(n≥2)</strong>——表示事物之间的关系 如, L(x,y)：x与 y
有关系 L；G(x,y)：x≥y；…</p>
<p><strong>0元谓词</strong>——不含个体变项的谓词,
即命题常项或命题变项，<font color = "red">0元谓词是命题。任何命题均可以表示为0元谓词</font></p>
<h3 id="量词">量词</h3>
<p>定义：表示个体常项或变项之间数量关系的词</p>
<p><strong>全称量词∀</strong></p>
<p><strong>存在量词∃</strong></p>
<h2 id="一阶逻辑命题符号化-1">一阶逻辑命题符号化</h2>
<h3 id="元谓词">0元谓词</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401141229538.png" /></p>
<p>解析：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401143755193.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1h1421U7Yt/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e6175f817d342a0f111b3a39332ef34.jpg" /></p>
<hr style = "border:2px solid yellow;">
<h3 id="涉及到量词">涉及到量词</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 人都爱美 (2) 有人用左手写字
个体域分别为 (a) D为人类集合 (b) D为全总个体域</p>
<p>分析：</p>
<ol type="a">
<li></li>
</ol>
<ol type="1">
<li><p>∀xG(x), G(x)：x爱美</p></li>
<li><p>∃xG(x), G(x)：x用左手写字</p></li>
</ol>
<ol start="2" type="a">
<li></li>
</ol>
<p>F(x)：x为人，G(x)：x爱美</p>
<ol type="1">
<li><p>∀x(F(x) → G(x))</p></li>
<li><p>∃x(F(x) ∧ G(x))</p></li>
</ol>
<p><a
href="https://www.bilibili.com/video/BV1wp421y7QA/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/df718134d2f6c900f4199ab6ff090de.jpg" /></p>
<h3 id="多元变量的符号化">多元变量的符号化</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 正数都大于负数 (2)
有的无理数大于有的有理数</p>
<p><a href="">视频讲解</a></p>
<h3 id="带否定的命题符号化">带否定的命题符号化</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 没有不呼吸的人 (2)
不是所有的人都喜欢吃糖</p>
<p><a
href="https://www.bilibili.com/video/BV1fx4y1a7Z1/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="顺序不能调换">顺序不能调换</h3>
<p>设个体域为实数域, 将下面命题符号化 (1)
对每一个数x都存在一个数y使得x&lt;y (2)
存在一个数x使得对每一个数y都有x&lt;y</p>
<p>分析：</p>
<p>解 L(x,y):x&lt;y</p>
<ol type="1">
<li><p>∀x∃yL(x,y)</p></li>
<li><p>∃x∀yL(x,y)</p></li>
</ol>
<h1 id="一阶逻辑公式及其解释">一阶逻辑公式及其解释</h1>
<h2 id="合式公式">合式公式</h2>
<p>合式公式定义如下： (1) 原子公式是合式公式. (2) 若A是合式公式，则
(¬A)也是合式公式 (3) 若A, B是合式公式，则(A∧B), (A∨B), (A→B),
(A↔︎B)也是合式公式 (4) 若A是合式公式，则∀xA, ∃xA也是合式公式 (5)
只有有限次地应用(1)—(4)形成的符号串才是合式公式.
合式公式也称为谓词公式，简称公式 如, F(x), F(x)∨¬G(x,y), ∀x(F(x)→G(x))
∃x∀y(F(x)→G(y)∧L(x,y))等都是合式公式</p>
<h2 id="封闭的公式">封闭的公式</h2>
<h3 id="指导变元和辖域">指导变元和辖域</h3>
<p>定义:在公式 ∀xA 和 ∃xA 中，称 x 为指导变元，A 为相应量词的辖域。在 ∀x
和 ∃x 的辖域中，x 的所有出现都称为约束出现，A
中不是约束出现的其他变项均称为是自由出现的。</p>
<p>举例：</p>
<p>例1：</p>
<p>∀x(F(x,y)→G(x,z))，x 为指导变元，(F(x,y)→G(x,z)) 为 ∀x 的辖域，x
的两次出现均为约束出现，y 与 z 均为自由出现。</p>
<p>例2：</p>
<p>∃x(F(x,y,z)→∀y(G(x,y)∧H(x,y,z)))，∃x 中的 x 是指导变元，辖域为
(F(x,y,z)→∀y(G(x,y)∧H(x,y,z)))。∀y 中的 y 是指导变元，辖域为
(G(x,y)∧H(x,y,z))。x 的 3 次出现都是约束出现，y
的第一次出现是自由出现，后 2 次是约束出现，z 的 2
次出现都是自由出现。</p>
<p><a
href="https://www.bilibili.com/video/BV1NZ421i7Ti/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="闭式">闭式</h3>
<p>定义4.6 若公式 A 中不含自由出现的个体变项，则称 A
为封闭的公式，简称闭式。</p>
<p>例如，∀x∀y(F(x)∧G(y)→H(x,y)) 为闭式，而 ∃x(F(x)∧G(x,y)) 不是闭式</p>
<h2 id="合式公式的解释">合式公式的解释</h2>
<p>说白了就是广义赋值</p>
<hr style = "border:2px solid yellow;">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401231018822.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Qp421C72h/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow;">
<h2 id="永真式矛盾式可满足式">永真式、矛盾式、可满足式</h2>
<ol type="1">
<li>闭式在任何解释下都是命题</li>
<li>若公式A在任何解释下均为真, 则称A为永真式(逻辑有效式).
若A在任何解释下均为假, 则称A为矛盾式(永假式). 若至少有一个解释使A为真,
则称A为可满足式.</li>
</ol>
<blockquote>
<p>注：</p>
<p>永真式为可满足式，但反之不真 判断公式是否是可满足的(永真式,
矛盾式)是不可判定的</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：判断公式类型</p>
<p><font color = "yellow">闭式只用假设前件真假来判断整个公式真假</font></p>
<p><font color = "yellow">非闭式需要找出具体假设</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0864a4cc957e2b8ccb38555953686ce.jpg" /></p>
<hr style = "border:2px solid yellow">
<h2 id="代换实例">代换实例</h2>
<p>说白了就是替换，将复杂的替换成简单的</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401231924387.png" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>一维随机变量及其分布</title>
    <url>/posts/4583997a.html</url>
    <content><![CDATA[<h1 id="一维随机变量及其分布">一维随机变量及其分布</h1>
<h2 id="一-一维随机变量分布函数">(一) 一维随机变量分布函数</h2>
<h3 id="概念fx-px-leqx">1 概念：F(x) = P{X <span
class="math inline">\(\leq\)</span>x}</h3>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211140411.jpg" /></p>
<p>注意求X的分布函数，F(x) = P{X <span
class="math inline">\(\leq\)</span> x} = <span
class="math inline">\(\int_{\infty}^{x} f(x)\,
dx\)</span>(因为这里是连续型)</p>
<h3 id="性质">2 性质</h3>
<h4 id="单调不减">2.1 单调不减</h4>
<h4 id="右连续">2.2 右连续</h4>
<h4 id="向负无穷取极限是0想正无穷取极限是1">2.3
向负无穷取极限是0，想正无穷取极限是1</h4>
<span id="more"></span>
<h3 id="应用求概率">3 应用：求概率</h3>
<h4 id="px-leq-a-fa">3.1 P{X <span class="math inline">\(\leq\)</span>
a} = F(a)</h4>
<h4 id="px-a-fa---0左极限">3.2 P{X &lt; a} = F(a - 0)(左极限)</h4>
<h4 id="px-a-fa---fa---0">3.3 P{X = a} = F(a) - F(a - 0)</h4>
<h2 id="二-一维离散型">(二) 一维离散型</h2>
<h3
id="分布律将每一个正概率点不一定值是正而是对应概率值是正的点-与其对应的概率做成表格">1
分布律：将每一个正概率点(不一定值是正，而是对应概率值是正的点)
与其对应的概率做成表格</h3>
<h4 id="第一行每个正概率点的值">第一行：每个正概率点的值</h4>
<h4
id="第二行每个正概率点对应的概率">第二行：每个正概率点对应的概率</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210173027.jpg" /></p>
<h3 id="分布函数fx对所有小于x的正概率点求和常成阶梯状">2
分布函数F(x)：对所有小于x的正概率点求和，常成阶梯状</h3>
<h3 id="应用求概率说白了就是将区域内所有正概率点求和比如求pa-x-b">3
应用：求概率，说白了就是将区域内所有正概率点求和，比如求P{a &lt; X &lt;
b}</h3>
<h4
id="从分布律角度就是将ab范围内所有正概率点求和">从分布律角度，就是将a~b范围内所有正概率点求和</h4>
<h4 id="从分布函数角度就是fb---0---fa">从分布函数角度，就是F(b - 0) -
F(a)</h4>
<h3 id="常见分布">4 常见分布</h3>
<h4 id="n重伯努利分布n-p">4.1 n重伯努利分布(n, p)</h4>
<h5 id="n重复实验次数">n：重复实验次数</h5>
<h5
id="p一次实验中成功的概率每次实验只有两种结果">p：一次实验中成功的概率(每次实验只有两种结果)</h5>
<h5 id="分布律">分布律</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210174402.jpg" /></p>
<h5
id="n重伯努利分布里几种特殊的分布">n重伯努利分布里几种特殊的分布</h5>
<h6 id="分布就取1次">(1) 0 - 1分布：就取1次</h6>
<h6 id="几何分布前n---1次都没中第n次中">(2) 几何分布：前(n -
1)次都没中，第n次中</h6>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210190359.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191058.jpg" /></p>
<h4
id="超几何分布好的坏的混在一起一共有n个其中好的有m个取n个n个里面有k个好的n---k个坏的">4.2
超几何分布：好的坏的混在一起，一共有N个，其中好的有M个，取n个，n个里面有k个好的，(n
- k)个坏的</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191123.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191326.jpg" /></p>
<h4 id="泊松分布">4.3 泊松分布</h4>
<h5 id="公式">公式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191417.jpg" /></p>
<h5 id="性质-lambda-np">性质 <span
class="math inline">\(\lambda\)</span> = np</h5>
<h5 id="section"></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211072246.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211072409.jpg" /></p>
<p>上面这道题计算要用到<span class="math inline">\(\lambda\)</span> =
np</p>
<h2 id="三-一维连续型">(三) 一维连续型</h2>
<h3 id="概率密度fx">1 概率密度f(x)</h3>
<h3 id="分布函数fx-pleftxleq-x-right-int_-inftyx-fx-dx">2 分布函数：F(x)
= <span class="math inline">\(P\left\{X\leq\ x \right\} =
\int_{-\infty}^{x} f(x)\, dx\)</span></h3>
<h3 id="应用求概率说白了就是对在指定区域的fx求积分">3
应用：求概率,说白了就是对在指定区域的f(x)求积分</h3>
<h3 id="主要分布">4 主要分布</h3>
<h4 id="均匀分布ua-b">4.1 均匀分布U(a, b)</h4>
<h5 id="概率密度">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210192914.jpg" /></p>
<h5 id="分布函数">分布函数</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210192947.jpg" /></p>
<h4 id="指数分布elambda指数分布具有无记忆性">4.2 指数分布E(<span
class="math inline">\(\lambda\)</span>)(指数分布具有无记忆性)</h4>
<h5 id="概率密度-1">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193254.jpg" /></p>
<h5 id="分布函数-1">分布函数</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193311.jpg" /></p>
<p>题型：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210210012.jpg" /></p>
<h4 id="正态分布nu-σ2">4.3 正态分布N(u, σ<sup>2</sup>)</h4>
<h5 id="概率密度-2">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193522.jpg" /></p>
<h5
id="上alpha分位数ualpha使点alpha右侧φ的面积是alpha计算出alpha右侧面积就是下标alpha">上<span
class="math inline">\(\alpha\)</span>分位数u<sub><span
class="math inline">\(\alpha\)</span></sub>：使点<span
class="math inline">\(\alpha\)</span>右侧φ的面积是<span
class="math inline">\(\alpha\)</span>,计算出<span
class="math inline">\(\alpha\)</span>右侧面积就是下标<span
class="math inline">\(\alpha\)</span></h5>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210211242.jpg" /></p>
<h5 id="标准正态分布n0-1">标准正态分布N(0, 1)</h5>
<h6 id="概率密度phix">概率密度<span
class="math inline">\(\phi\)</span>(x)</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193854.jpg" /></p>
<h6
id="分布函数只用记住是phix就行性质围绕其奇偶性展开">分布函数：只用记住是<span
class="math inline">\(\Phi\)</span>(x)就行，性质围绕其奇偶性展开</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210194320.jpg" /></p>
<h5
id="标准化所有有关正态分布不等式的判别都要标准化">标准化(所有有关正态分布不等式的判别都要标准化)</h5>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210210747.jpg" /></p>
<h6 id="换元标准化">换元标准化</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210195631.jpg" /></p>
<h6 id="性质-1">性质</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%A4%B1%E8%B4%A51.jpg" /></p>
<h2
id="四-典型题型一维随机变量函数的分布已知一种随机变量的概率分布fx通过某种函数变换得到另一种函数y-求fy的概率分布">(四)
典型题型：一维随机变量函数的分布，已知一种随机变量的概率分布f(x)，通过某种函数变换得到另一种函数Y,
求f(y)的概率分布</h2>
<h3 id="根据函数变换y-gx得y-gx代入x的范围得到y的范围作为y的定义域">1
根据函数变换Y = g(X)得y = g(x)，代入x的范围得到y的范围作为Y的定义域</h3>
<h3 id="求出fx的分布函数">2 求出F(x)的分布函数</h3>
<h3
id="利用定义fy-pyleqy将y用x代入转化为px-leqhy后将hy代入fx得到fhy和定义域因为fx一般是分段函数所以也要将hy代入到分段的定义域里得到新的分段定义域">3
利用定义F(y) = P{Y<span
class="math inline">\(\leq\)</span>y}，将Y用X代入，转化为P{X <span
class="math inline">\(\leq\)</span>h(y)}后将h(y)代入F(X)得到F(h(y))和定义域(因为F(x)一般是分段函数，所以也要将h(y)代入到分段的定义域里得到新的分段定义域)</h3>
<h3 id="对fy求导得到概率分布fy">4 对F(y)求导得到概率分布f(y)</h3>
<p>开胃小菜</p>
<figure>
<img src="E:\Daershang\概率论\笔记\图片\微信图片_20231119171115.jpg"
alt="微信图片_20231119171115" />
<figcaption aria-hidden="true">微信图片_20231119171115</figcaption>
</figure>
<p>难度加强</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211144008.jpg"
alt="微信图片_20231211144008" />
<figcaption aria-hidden="true">微信图片_20231211144008</figcaption>
</figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%A4%B1%E8%B4%A52.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>随机事件与概率</title>
    <url>/posts/becb01a7.html</url>
    <content><![CDATA[<h1 id="随机事件与概率">随机事件与概率</h1>
<h2 id="事件的关系与运算">事件的关系与运算</h2>
<h3 id="一关系">一：关系</h3>
<h4 id="包含">1 包含</h4>
<h4 id="相等">2 相等</h4>
<h4 id="相容ab-not-emptyset">3 相容：AB <span
class="math inline">\(\not=\)</span> <span
class="math inline">\(\emptyset\)</span></h4>
<h4 id="互斥ab-emptyset">4 互斥：AB = <span
class="math inline">\(\emptyset\)</span></h4>
<h4 id="对立overlinea">5 对立：<span
class="math inline">\(\overline{A}\)</span></h4>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210110051.jpg" /></p>
<h3 id="二运算">二：运算</h3>
<h4 id="运算类型">运算类型</h4>
<h5 id="并">1 并</h5>
<h5 id="交">2 交</h5>
<h5 id="差">3 差</h5>
<h5 id="section"><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210110517.jpg" /></h5>
<h4 id="运算律均只针对交并运算">运算律(均只针对交并运算)</h4>
<h5 id="吸收若asubsetb则abigcupb-b-abigcapb-a">1 吸收：若A<span
class="math inline">\(\subset\)</span>B,则A<span
class="math inline">\(\bigcup\)</span>B = B, A<span
class="math inline">\(\bigcap\)</span>B = A</h5>
<h5 id="交换">2 交换</h5>
<h5 id="结合">3 结合</h5>
<h5 id="分配">4 分配</h5>
<h5 id="德摩根长杠变短杠开口换方向">5
德摩根:长杠变短杠，开口换方向、</h5>
<h3 id="题型">题型</h3>
<h4 id="题型一判断命题是否成立">题型一：判断命题是否成立</h4>
<h5 id="法一画文氏图">法一：画文氏图</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231113154301.jpg" /></p>
<h5 id="法二公式推理">法二：公式推理</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231113154944.jpg" /></p>
<h4 id="题型二关于至少这个事件">题型二：关于“至少”这个事件</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231119152722.jpg" /></p>
<h5 id="ab中至少有一个发生leftrightarrowab">A，B中至少有一个发生<span
class="math inline">\(\Leftrightarrow\)</span>A∪B</h5>
<h5 id="a---b-aoverlineb-a---ab">A - B ↔︎ A<span
class="math inline">\(\overline{B}\)</span> ↔︎ A - AB</h5>
<h2 id="古典概型和几何概型">古典概型和几何概型</h2>
<h3 id="一-古典概型">一 古典概型</h3>
<h4
id="排列从n个元素中取出m个排成一列所有排列的个数-p第一个有n种取法第二个有n---1种取法第m个前面已经选了m---1个还剩n---m---1个所以有n---m-1种取法">1
排列：从n个元素中取出m个排成一列，所有排列的个数
P，第一个有n种取法，第二个有n - 1种取法……第m个,前面已经选了(m -
1)个，还剩n - (m - 1)个，所以有n - m + 1种取法</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210113017.jpg" /></p>
<h4
id="组合从n个元素里挑m个成一种组合因为m个元素有m中排列方式而组合只选择其中一种">2
组合：从n个元素里挑m个成一种组合，因为m个元素有m!中排列方式，而组合只选择其中一种</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210113408.jpg" /></p>
<h4 id="题型-1">3 题型</h4>
<h5 id="随机分配将n个质点放到n个盒子里">3.1
随机分配：将n个质点放到N个盒子里</h5>
<h6 id="盒子容量不限制每个质点有n个选择分法总数-nn">(1)
盒子容量不限制：每个质点有N个选择，分法总数 = n<sup>N</sup></h6>
<h6
id="盒子最多放一个第一个质点有n种选择第二个质点有n-1种选择最后一个前面已经选了n---1个盒子剩下n---n---1个盒子的选择即是pnm">(2)
盒子最多放一个：第一个质点有N种选择，第二个质点有N-1种选择，……最后一个前面已经选了n
- 1个盒子，剩下N - (n -
1)个盒子的选择，即是P<sub>n</sub><sup>m</sup></h6>
<h5 id="简单随机抽样从盒子n个里抽n个">3.2
简单随机抽样：从盒子N个里抽n个</h5>
<h6 id="有放回每次都有n个选择一共nn">(1)
有放回：每次都有N个选择，一共n<sup>N</sup></h6>
<h6
id="无放回第一次有n种选择第二次有n-1种选择最后一个前面已经选了n---1个剩下n---n---1个的选择即是pnm">(2)
无放回：第一次有N种选择，第二次有N-1种选择，……最后一个前面已经选了n -
1个，剩下N - (n - 1)个的选择，即是P<sub>n</sub><sup>m</sup></h6>
<h6 id="一口气取无放回的是排列一口气取的是组合">(3)
一口气取：无放回的是排列，一口气取的是组合</h6>
<h3 id="二-几何概型常见面积问题">二 几何概型：常见面积问题</h3>
<h2 id="概率的基本性质与公式">概率的基本性质与公式</h2>
<h3 id="一-性质">一 性质</h3>
<h4 id="有界性任何一个时间的概率在010与1都能取得到">1
有界性：任何一个时间的概率在0~1(0与1都能取得到)</h4>
<h4 id="单调性若asubsetb则pb--a-pb---pa">2 单调性：若A<span
class="math inline">\(\subset\)</span>B,则P(B- A) = P(B) - P(A)</h4>
<h4 id="逆概率公式poverlinea-1---pa">3 逆概率公式：P(<span
class="math inline">\(\overline{A}\)</span>) = 1 - P(A)</h4>
<h3 id="二-公式">二 公式</h3>
<h4
id="加法公式多个字母的并事件奇数个字母前面是正号偶数个字母前面是负号然后组合排列出所有情况">1
加法公式(多个字母的并事件)：奇数个字母前面是正号，偶数个字母前面是负号，然后组合排列出所有情况</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150120.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150328.jpg" /></p>
<h4 id="减法公式pa---b-pa---pab">2 减法公式：P(A - B) = P(A) -
P(AB)</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210141229.jpg" /></p>
<p>题型： (1) 常在AB 和 A<span
class="math inline">\(\bigcup\)</span>B上做文章</p>
<ol start="2" type="1">
<li>前面公式要熟记</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210144150.jpg" /></p>
<figure>
<img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\微信图片_20231210144201.jpg"
alt="微信图片_20231210144201" />
<figcaption aria-hidden="true">微信图片_20231210144201</figcaption>
</figure>
<h4 id="条件概率公式">3 条件概率公式</h4>
<h4 id="全概率公式由因推果多重因素ai导致事件b发生求事件b发生的概率">4
全概率公式(由因推果，多重因素A<sub>i</sub>导致事件B发生，求事件B发生的概率)</h4>
<h5 id="完备事件组的全集分解">4.1 完备事件组的全集分解</h5>
<h5 id="加法公式的互斥">4.2 加法公式的互斥</h5>
<h5 id="条件概率公式-1">4.3 条件概率公式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210141537.jpg" /></p>
<p>举例：</p>
<p>嵌套：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210153433.jpg" /></p>
<h4 id="贝叶斯公式由果索因已知事件b发生求是因素ai导致其发生的概率">5
贝叶斯公式(由果索因，已知事件B发生，求是因素A<sub>i</sub>导致其发生的概率)</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210142447.jpg" /></p>
<p>举例：</p>
<p>结合全概率公式使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210154248.jpg" /></p>
<h2 id="事件的独立性">事件的独立性</h2>
<h3 id="两两独立与相互独立">两两独立与相互独立</h3>
<h4 id="定义">定义</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210155554.jpg" />
题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210155705.jpg" /></p>
<h4
id="性质如果若干个事件相互独立则其中一部分事件与另一部分事件的运算生成的新事件与另一部分事件运算生成的新事件仍然相互独立">性质：如果若干个事件相互独立，则其中一部分事件与另一部分事件的运算生成的新事件与另一部分事件运算生成的新事件仍然相互独立</h4>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210163747.jpg" /></p>
<p>​</p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章：多维随机变量及其分布</title>
    <url>/posts/d1c25b21.html</url>
    <content><![CDATA[<h1 id="多维随机变量及其分布">多维随机变量及其分布</h1>
<span id="more"></span>
<h2 id="一-二维随机变量">(一) 二维随机变量</h2>
<h3 id="概念">1 概念</h3>
<h3 id="联合分布函数如果说之前一维积分是面积那这里二维积分就是体积">2
联合分布函数(如果说之前一维积分是面积，那这里二维积分就是体积)</h3>
<h4 id="概念fx-y-px-leq-x-y-leq-y">2.1 概念:F(x, y) = P{X <span
class="math inline">\(\leq\)</span> x, Y <span
class="math inline">\(\leq\)</span> y}</h4>
<h4 id="性质">2.2 性质</h4>
<h5 id="单调性固定一个看另一个">(1) 单调性(固定一个，看另一个)</h5>
<h5 id="右连续性固定一个看另一个">(2) 右连续性(固定一个，看另一个)</h5>
<h5 id="有界性全体积为1">(3) 有界性(全体积为1)</h5>
<h5 id="非负性下面这个公式重点根据旁边的图理解是如何计算的">(4)
非负性(下面这个公式重点根据旁边的图理解是如何计算的)</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211153025.jpg" /></p>
<h3 id="边缘分布函数求哪一个保留哪一个另一个极限取到无穷">3
边缘分布函数(求哪一个，保留哪一个，另一个极限取到无穷)</h3>
<h4 id="f_xx-fx-infty"><span class="math inline">\(F_X(x) = F(x,
+\infty)\)</span></h4>
<h4 id="f_yy-finfty-y"><span class="math inline">\(F_Y(y) = F(+\infty,
y)\)</span></h4>
<h2 id="二-二维离散型随机变量">(二) 二维离散型随机变量</h2>
<h3 id="联合分布律">1 联合分布律</h3>
<h3 id="边缘分布律">2 边缘分布律</h3>
<h3 id="条件分布律">3 条件分布律</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211153837.jpg" /></p>
<h3 id="独立性forall-i-j-p_ij-p_i.p_j.-longleftrightarrow-x-y相互对立">4
独立性：<span class="math inline">\(\forall\ i, j, P_{ij} = P_i.P_j.
\Longleftrightarrow X, Y相互对立\)</span></h3>
<h2 id="三-二维连续型随机变量">(三) 二维连续型随机变量</h2>
<h3 id="概率密度">1 概率密度</h3>
<h4 id="联合概率密度fx-y">1.1 联合概率密度：f(x, y)</h4>
<h4
id="边缘概率密度求谁不积谁不积先定限限内画条线先交取下限后交取上限">1.2
边缘概率密度：求谁不积谁，不积先定限，限内画条线，先交取下限，后交取上限</h4>
<h5
id="f_xx-int_-inftyinftyfx-ydy表示的几何意义是求沿x-x对几何体切一刀得到的切片面积关键是要求y的积分范围方法是求谁不积谁限内画条线先交取下限后交取上限"><span
class="math inline">\(f_X(x) = \int_{-\infty}^{+\infty}f(x,
y)\,dy\)</span>(表示的几何意义是求沿X =
x对几何体切一刀得到的切片面积，关键是要求y的积分范围，方法是求谁不积谁，限内画条线，先交取下限，后交取上限)</h5>
<h5 id="f_yy-int_-inftyinftyfx-ydx"><span class="math inline">\(f_Y(y) =
\int_{-\infty}^{+\infty}f(x, y)\,dx\)</span></h5>
<h3 id="分布函数">2 分布函数</h3>
<h4
id="联合分布函数fx-y-px-leq-x-y-leq-y-int_-inftyy-int_inftyxfu-v-dudv">2.1
联合分布函数：F(x, y) = P{X <span class="math inline">\(\leq\)</span> x,
Y <span class="math inline">\(\leq\)</span> y} = <span
class="math inline">\(\int_{-\infty}^{y} \int_{\infty}^{x}f(u, v)\,
dudv\)</span></h4>
<h4 id="边缘分布函数">2.2 边缘分布函数</h4>
<h5 id="已知联合概率密度fx-y">已知联合概率密度<span
class="math inline">\(f(x, y)\)</span></h5>
<h6
id="f_xx-int_-inftyxf_xt-dt-int_-inftyxint_-inftyinftyfu-vdudv"><span
class="math inline">\(F_X(x) = \int_{-\infty}^xf_X(t)\, dt =
\int_{-\infty}^{x}[\int_{-\infty}^{+\infty}f(u, v)du]dv\)</span></h6>
<h6
id="f_yy-int_-inftyyf_yt-dt-int_-inftyyint_-inftyinftyfu-vdvdu"><span
class="math inline">\(F_Y(y) = \int_{-\infty}^yf_Y(t)\, dt =
\int_{-\infty}^{y}[\int_{-\infty}^{+\infty}f(u, v)dv]du\)</span></h6>
<h5
id="已知联合分布函数fx-y不用积分了取极限到无穷就行">已知联合分布函数<span
class="math inline">\(F(x,
y)\)</span>(不用积分了！取极限到无穷就行)</h5>
<h6 id="f_xx-fx-infty-1"><span class="math inline">\(F_X(x) = F(x,
+\infty)\)</span></h6>
<h6 id="f_yy-finfty-y-1"><span class="math inline">\(F_Y(y) = F(+\infty,
y)\)</span></h6>
<h4 id="与概率密度关系">2.3 与概率密度关系</h4>
<h5
id="联合-联合分布函数fx-y求两次偏导就可以得到联合概率密度fx-y-fx-y求二重积分就可以得到fx-y">2.3.1
联合 ：联合分布函数F(x, y)求两次偏导就可以得到联合概率密度f(x, y), f(x,
y)求二重积分就可以得到F(x, y)</h5>
<h5 id="边缘边沿分布函数f_xx和边缘概率密度f_xx不存在这种关系y同理">2.3.2
边缘：<span
class="math inline">\(边沿分布函数F_X(x)和边缘概率密度f_X(x)不存在这种关系,Y同理\)</span></h5>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212113847.jpg" /></p>
<h3 id="条件条件-frac联合边缘">3 条件：<span class="math inline">\(条件
= \frac{联合}{边缘}\)</span></h3>
<h4 id="条件概率密度">3.1 条件概率密度</h4>
<h5 id="f_yxyx-fracfx-yf_xx"><span class="math inline">\(f_{Y|X}(y|x) =
\frac{f(x, y)}{f_{X}(x)}\)</span></h5>
<h5 id="f_xyxy-fracfx-yf_yy"><span class="math inline">\(f_{X|Y}(x|y) =
\frac{f(x, y)}{f_{Y}(y)}\)</span></h5>
<h4
id="条件分布函数哪个是条件哪个保留积另外一个以f_yxyx为例因为叫在x-x条件下的条件分布函数所以是对y积分">3.2
条件分布函数：哪个是条件，哪个保留，积另外一个，以<span
class="math inline">\(F_{Y|X}(y|x)\)</span>为例，因为叫在X =
x条件下的条件分布函数，所以是对y积分</h4>
<h5 id="f_yxyx-int_-inftyyf_yxyxdy"><span
class="math inline">\(F_{Y|X}(y|x) =
\int_{-\infty}^{y}f_{Y|X}(y|x)dy\)</span></h5>
<h5 id="f_xyxy-int_-inftyxf_xyxydx"><span
class="math inline">\(F_{X|Y}(x|y) =
\int_{-\infty}^{x}f_{X|Y}(x|y)dx\)</span></h5>
<p>举个例子</p>
<h3 id="独立性">4 独立性：</h3>
<h4 id="从概率密度角度fx-y-f_xxf_yy">4.1 从概率密度角度：<span
class="math inline">\(f(x, y) = f_{X}(x)f_{Y}(y)\)</span></h4>
<h4 id="从分布函数角度fx-y-f_xxf_yy">4.2 从分布函数角度：<span
class="math inline">\(F(X, Y) = F_X(x)F_Y(y)\)</span></h4>
<p>举个例子，也涉及概率密度与分布函数关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212113501.jpg" /></p>
<h4
id="相互独立随机变量函数的分布及卷积公式积谁不换谁换完求偏导加绝对值如果独立进一步拆分">4.3
相互独立随机变量函数的分布及卷积公式：积谁不换谁，换完求偏导加绝对值,如果独立，进一步拆分</h4>
<p>设(X, Y)~f(x, y)</p>
<h5
id="和的分布z-x-y的概率密度f_zz-int_-inftyinftyfx-z-xdx换成y同理进一步如果x与y相互独立f_zz-int_-inftyinftyfx-z-xdx-int_-inftyinftyf_xxf_yz-xdx">(1)
和的分布:Z = X + Y的概率密度<span class="math inline">\(f_Z(z) =
\int_{-\infty}^{+\infty}f(x,
z-x)dx\)</span>(换成y同理)，进一步如果X与Y相互独立,<span
class="math inline">\(f_Z(z) = \int_{-\infty}^{+\infty}f(x, z-x)dx =
\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx\)</span></h5>
<h5 id="差的分布">(2) 差的分布</h5>
<h5 id="积的分布">(3) 积的分布</h5>
<h5 id="商的分布">(4) 商的分布</h5>
<h5 id="maxx-y的分布">(5) max{X, Y}的分布</h5>
<h5 id="minx-y的分布">(6) min{X, Y}的分布</h5>
<h3 id="两个常见的二维连续分布">5 两个常见的二维连续分布</h3>
<h4 id="二维均匀分布">5.1 二维均匀分布</h4>
<h4 id="二维正态分布这个有大问题">5.2 二维正态分布(这个有大问题)</h4>
<p>概念</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114137.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114147.jpg" /></p>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211204826.jpg" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114251.jpg"
alt="微信图片_20231212114251" />
<figcaption aria-hidden="true">微信图片_20231212114251</figcaption>
</figure>
<h2 id="四-经典题型">(四) 经典题型：</h2>
<h3 id="求二维随机变量在限制条件下概率">1
求二维随机变量在限制条件下概率</h3>
<h4
id="二维随机变量相互独立常见于两个相互独立的正态分布直接将限制条件转换成一个新函数">1.1
二维随机变量相互独立,常见于两个相互独立的正态分布，直接将限制条件转换成一个新函数</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214140814.jpg" /></p>
<h4 id="二维随机变量独立性未知只知fx-y">1.2
二维随机变量独立性未知，只知f(x, y)</h4>
<h5 id="找出正概率区间">1.2.1 找出正概率区间</h5>
<h5 id="画出正概率区间与限定区间的交集">1.2.2
画出正概率区间与限定区间的交集</h5>
<h5 id="计算二重积分或求和">1.2.3 计算二重积分或求和</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212160900.jpg" /></p>
<h3 id="二维复合成一维z-fx-y求复合后的概率密度">2 二维复合成一维(Z =
F(X, Y))，求复合后的概率密度</h3>
<h4 id="连续-连续">2.1连续-连续</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212171443.jpg" /></p>
<h5 id="法一">法一：</h5>
<h6 id="求联合概率密度">1 求联合概率密度</h6>
<h6
id="通过代入定义f_zz-pleftz-leq-zright-pleftfx-y-leq-zright转换成前面求限制条件下概率问题">2
通过代入定义<span class="math inline">\(F_Z(z) = P\left\{Z \leq
z\right\} = P\left\{F(X, Y) \leq
z\right\}\)</span>转换成前面求限制条件下概率问题</h6>
<h6 id="通过分布函数求概率密度">3 通过分布函数求概率密度</h6>
<h5 id="法二如果已知xy相互独立">法二：如果已知x，y相互独立</h5>
<h6
id="求联合概率密度fx-y没讲独立直接将x-z---x代入fx-y即可讲独立就可以不用求fx-y">1
求联合概率密度f(x, y)(没讲独立，直接将x， z - x代入f(x,
y)即可，讲独立，就可以不用求f(x, y))</h6>
<h6 id="积谁不换谁换完求偏导加绝对值">2
积谁不换谁，换完求偏导加绝对值</h6>
<h6
id="确定被积函数fx-z---x确定x的范围再通过y的范围经过还原确定z的范围">3
确定被积函数f(x, z -
x)，确定x的范围，再通过y的范围经过还原确定z的范围</h6>
<h6 id="以x为横轴z为纵轴作图以z为横线讨论z的范围求fz">4
以x为横轴，z为纵轴作图，以z为横线讨论z的范围求f(z)</h6>
<h4 id="连续-离散">2.2 连续-离散</h4>
<h5 id="全概率公式分解">1 全概率公式分解</h5>
<h5 id="条件公式分解">2 条件公式分解</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212144542.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章：数理统计</title>
    <url>/posts/29760bc5.html</url>
    <content><![CDATA[<h1 id="数理统计">数理统计</h1>
<span id="more"></span>
<h2 id="总体与样本">总体与样本</h2>
<h3 id="总体研究对象全体">总体：研究对象全体</h3>
<h3 id="样本">样本：</h3>
<h4 id="n个没有抽样的x_ii1-2-n">1 n个(没有抽样)的<span
class="math inline">\(X_i(i=1, 2, ……, n)\)</span></h4>
<h4 id="相互独立且同分布于某个随机变量x">2
相互独立且同分布于某个随机变量X</h4>
<h4
id="组成的整体x_1-x_2-x_n-叫做一个样本一次抽样结果的n个具体数值x_1-x_2-x_n叫做这个样本的观测值">3
组成的整体<span class="math inline">\((X_1, X_2, ……，X_n)\)</span>
叫做一个样本，一次抽样结果的n个具体数值<span class="math inline">\((x_1,
x_2, ……， x_n)\)</span>叫做这个样本的观测值</h4>
<h3
id="样本的分布如果样本x_1-x_2-x_n服从的x的分布函数是fx则fx_1-x_2-x_n-prod_i1nfx_i理解上就是相互独立所以可以拆分另外什么概率密度分布律类似">样本的分布：如果样本<span
class="math inline">\((X_1, X_2, ……，
X_n)\)</span>服从的X的分布函数是F(x)，则<span
class="math inline">\(F(x_1, x_2, x_n) =
\prod_{i=1}^nF(x_i)\)</span>(理解上就是相互独立所以可以拆分，另外什么概率密度，分布律类似)</h3>
<p>举个例子</p>
<p>离散型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216120104.jpg" /></p>
<p>连续型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216120917.jpg" /></p>
<h2 id="统计量及其分布">统计量及其分布</h2>
<h3 id="统计量">统计量</h3>
<h4 id="样本数字特征">1 样本数字特征</h4>
<h5 id="样本均值-overlinex-frac1nsum_i1nx_i">样本均值： <span
class="math inline">\(\overline{X} =
\frac{1}{n}\sum_{i=1}^{n}X_i\)</span></h5>
<h5
id="样本方差标准差s2-frac1n-1sum_i1nx_i-overline-x2-s-sqrtfrac1n-1sum_i1nx_i-overline-x2">样本方差，标准差：<span
class="math inline">\(S^2 = \frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline
X)^2\)</span>， <span class="math inline">\(S =
\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline X)^2}\)</span></h5>
<h5 id="样本k阶原点矩-a_k-frac1nsum_i1nx_ikk-1-2">样本k阶原点矩： <span
class="math inline">\(A_k = \frac{1}{n}\sum_{i=1}^{n}X_i^k(k = 1, 2,
……)\)</span></h5>
<h5 id="样本k阶中心矩-b_k-frac1nsum_i1nx_i-overlinexk">样本k阶中心矩：
<span class="math inline">\(B_k =
\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\)</span></h5>
<h4 id="顺序统计量">2 顺序统计量</h4>
<h5 id="最大顺序统计量x_n-maxleftx_1-x_2-x_nright">最大顺序统计量：<span
class="math inline">\(X_(n) = max\left\{X_1, X_2,……，
X_n\right\}\)</span></h5>
<h6 id="分布函数f_nx-fxn">分布函数：<span
class="math inline">\(F_{(n)}(x) = [F(x)]^n\)</span></h6>
<h6
id="概率密度f_nx-nfxn-1fx对上面f求导注意是复合函数求导">概率密度：<span
class="math inline">\(f_(n)(x) =
n[F(x)]^{n-1}f(x)\)</span>(对上面F求导，注意是复合函数求导)</h6>
<h5 id="最小顺序统计量x_1minleftx_1-x_2-x_nright">最小顺序统计量：<span
class="math inline">\(X_{(1)}=min\left\{X_1, X_2,
……X_n\right\}\)</span></h5>
<h6 id="分布函数f_1x-1-1-fxn">分布函数：<span
class="math inline">\(F_{(1)}(x) = 1-[1-F(x)]^n\)</span></h6>
<h6 id="概率密度f_1x-n1-fxn-1fx">概率密度：<span
class="math inline">\(f_{(1)}(x) = n[1-F(x)]^{n-1}f(x)\)</span></h6>
<h4 id="性质设总体exmudx-sigma2">3 性质(<span
class="math inline">\(设总体E(X)=\mu,D(X) = \sigma^2\)</span>)</h4>
<h5 id="x_i的期望与方差"><span
class="math inline">\(X_i的期望与方差\)</span></h5>
<h6 id="ex_i-mu"><span class="math inline">\(E(X_i) = \mu\)</span></h6>
<h6 id="dx_i-sigma2"><span class="math inline">\(D(X_i) =
\sigma^2\)</span></h6>
<h5 id="overlinex的期望与方差"><span
class="math inline">\(\overline{X}的期望与方差\)</span></h5>
<h6 id="eoverlinex-ex-mu"><span class="math inline">\(E(\overline{X}) =
E(X) = \mu\)</span></h6>
<h6 id="doverlinex-fracsigma2n"><span
class="math inline">\(D(\overline{X}) = \frac{\sigma^2}{n}\)</span></h6>
<h5 id="s2"><span class="math inline">\(S^2\)</span></h5>
<h6 id="es2-dx-sigma2"><span class="math inline">\(E(S^2) = D(X) =
\sigma^2\)</span></h6>
<h3 id="三大分布">三大分布</h3>
<h4 id="chi2分布">1 <span class="math inline">\(\chi^2分布\)</span></h4>
<h5 id="定义-x_i独立同分布于n0-1x-_i-1nx_i2-2n">1.1 定义：$
X_i独立同分布于N(0, 1)，X = _{i = 1}<sup>{n}X_{i}</sup>2 ^2(n)$</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214194907.jpg" /></p>
<h5 id="性质">1.2 性质：</h5>
<h6
id="若x_1-sim-chi2n_1-x_2-sim-chi2n_2-x_1与x_2相互独立则x_1-x_2-sim-chi2n_1n_2">(1)
<span class="math inline">\(若X_1 \sim \chi^2(n_1), X_2 \sim
\chi^2(n_2), X_1与X_2相互独立，则X_1 + X_2 \sim
\chi^{2}(n_1+n_2)\)</span></h6>
<h6 id="若xsim-chi2nexn-dx2n">(2) <span class="math inline">\(若X\sim
\chi^2(n),E(X)=n, D(X)=2n\)</span></h6>
<h4 id="t分布">2 t分布</h4>
<h5
id="定义xsim-n0-1-ysim-chi2n-x与y相互独立t-fracxsqrtfracyn-sim-tn">2.1
定义：<span class="math inline">\(X\sim N(0, 1), Y\sim \chi^2(n),
X与Y相互独立，t = \frac{X}{\sqrt{\frac{Y}{N}}} \sim t(n)\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214195812.jpg" /></p>
<h5
id="性质-图形关于y轴对称所以t_alphan这个点右侧面积是alpha--t_1-alphan这个点右侧面积是1-alpha">2.2
性质: <span
class="math inline">\(图形关于y轴对称，所以t_{\alpha}(n)(这个点右侧面积是\alpha)
= -t_{1-\alpha}(n)(这个点右侧面积是1-\alpha)\)</span></h5>
<h4 id="f分布">3 F分布</h4>
<h5
id="定义xsim-chi2n_1-ysim-chi2n_2x与y相互独立f-fracxn_1yn_2sim-fn_1-n_2">3.1
定义：<span class="math inline">\(X\sim \chi^2(n_1), Y\sim
\chi^2(n_2),X与Y相互独立，F = \frac{X/{n_1}}{Y/{n_2}}\sim F(n_1,
n_2)\)</span></h5>
<h5 id="性质-1">3.2 性质</h5>
<h6 id="若fsim-fn_1-n_2则frac1fsim-fn_2-n_1">(1) <span
class="math inline">\(若F\sim F(n_1, n_2)，则\frac{1}{F}\sim F(n_2,
n_1)\)</span></h6>
<h6 id="若f_1-alphan_1-n_2-frac1f_alphan_2-n_1">(2)<span
class="math inline">\(若F_{1-\alpha}(n_1, n_2) =
\frac{1}{F_{\alpha}(n_2, n_1)}\)</span></h6>
<p>题型：给一个不标准的分布，去表示出一个标准的分布</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094116.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094141.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094152.jpg" /></p>
<h3
id="x_1-x_2x_n独立同分布正态nmu-sigma2时常用结论这些结论常用于后面区间估计和假设检验"><span
class="math inline">\(X_1, X_2,……X_n独立同分布正态(N(\mu,
\sigma^2))时常用结论\)</span>(这些结论常用于后面区间估计和假设检验)</h3>
<h4
id="overlinexsim-nmu-fracsigma2n从前面overlinex的均值与方差可知所以fracoverlinex-musigmasqrtnsim-n0-1">(1)
<span class="math inline">\(\overline{X}\sim N(\mu,
\frac{\sigma^2}{n})(从前面\overline{X}的均值与方差可知),所以\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}\sim
N(0, 1)\)</span></h4>
<h4
id="sum_i1nfracx_i-musigma2-sim-chi2nx_i标准化后的平方和服从与chi2">(2)
<span class="math inline">\(\sum_{i=1}^{n}(\frac{X_i-\mu}{\sigma})^2
\sim \chi^2(n)(X_i标准化后的平方和服从与\chi^2)\)</span></h4>
<h4
id="sum_i1nfracx_i-overlinexsigma2-fracn-1s2sigma2-sim-chi2n-1上面如果总体期望未知可以用样本均值代替后做相应改动">(3)
<span
class="math inline">\(\sum_{i=1}^{n}(\frac{X_i-\overline{X}}{\sigma})^2
= \frac{(n-1)S^2}{\sigma^2} \sim
\chi^2(n-1)(上面如果总体期望未知，可以用样本均值代替后做相应改动)\)</span></h4>
<h4
id="fracoverlinex-mussqrtn-sim-tn-1将1中的总体标准差sigma用样本标准差s替换-fracnoverlinex-mu2s2-sim-f1-n-1">(4)
<span class="math inline">\(\frac{(\overline{X}-\mu)}{S/\sqrt{n}} \sim
t(n-1)(将(1)中的总体标准差\sigma用样本标准差S替换),
\frac{n(\overline{X}-\mu)^2}{S^2} \sim F(1, n-1)\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216121331.jpg" /></p>
<p>(1)先确定要表示的分布</p>
<p>(2)将要表示的分布里的标准分布通过题干中分布标准化后换元表示</p>
<h2 id="参数的区间估计">参数的区间估计</h2>
<p>首先需要了解一些基本概念：</p>
<p><span
class="math inline">\(\mu\)</span>：表示期望，不随抽样改变而改变</p>
<p><span
class="math inline">\(\overline{X}\)</span>：均值，由每次抽样决定</p>
<p>均值虽然不是期望，但一般来说均值与期望之间距离<span
class="math inline">\(|\overline{X}-u|\)</span>比较小的概率还是很大的，公式表示就是</p>
<p><span class="math inline">\(P\left\{|\overline{X}-\mu| \leq
\varepsilon \right\} = 1 - \alpha\)</span></p>
<p>其中<span class="math inline">\(\alpha\)</span>叫显著性水平，<span
class="math inline">\(1-\alpha\)</span>叫置信区间</p>
<h3
id="sigma2已知时的置信区间overlinex-z_fracalpha2fracsigmasqrtn-overlinexz_fracalpha2fracsigmasqrtn"><span
class="math inline">\(\sigma^2已知时的置信区间：(\overline{X}-z_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}},
\overline{X}+z_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}})\)</span></h3>
<p>证明：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216090745.jpg" /></p>
<h3
id="sigma2未知时的置信区间overlinex-t_fracalpha2n-1fracssqrtn-overlinext_fracalpha2n-1fracssqrtn"><span
class="math inline">\(\sigma^2未知时的置信区间：(\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}},
\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}})\)</span></h3>
<p>证明</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216091229.jpg" /></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216091404.jpg" /></p>
<h2
id="假设检验u只是一个假设的值在求出拒绝域后看实际得到的结果落在哪里如果落在拒绝域说明假设不成立">假设检验(u只是一个假设的值，在求出拒绝域后，看实际得到的结果落在哪里，如果落在拒绝域说明假设不成立)</h2>
<p>基本思想是<span class="math inline">\(P(\overline{A}) = 1 -
P(A)\)</span></p>
<p>拒绝域：拒绝原假设<span
class="math inline">\(H_0\)</span>的全体样本点组成集合</p>
<p>接受域：接受原假设<span
class="math inline">\(H_0\)</span>的全体样本点组成集合</p>
<h3 id="双边检验分布的下标是fracalpha2">1 双边检验(<span
class="math inline">\(分布的下标是\frac{\alpha}{2}\)</span>)</h3>
<h4 id="sigma2已知">(1) <span
class="math inline">\(\sigma^2已知\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216093736.jpg" /></p>
<h4 id="sigma2未知">(2) <span
class="math inline">\(\sigma^2未知\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216093840.jpg" /></p>
<h3 id="单边检验分布的下标是">2 单边检验($分布的下标是$)</h3>
<h4 id="sigma2已知-1">(1) <span
class="math inline">\(\sigma^2已知\)</span></h4>
<h5 id="mu-leq-u_0"><span class="math inline">\(\mu \leq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094230.jpg" /></p>
<h5 id="mu-geq-u_0"><span class="math inline">\(\mu \geq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094312.jpg" /></p>
<h4 id="sigma2未知-1">(2)<span
class="math inline">\(\sigma^2未知\)</span></h4>
<h5 id="mu-leq-u_0-1"><span class="math inline">\(\mu \leq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094446.jpg" /></p>
<h5 id="u-geq-u_0"><span class="math inline">\(u \geq u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094521.jpg" /></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216095445.jpg" /></p>
<h2 id="参数的点估计">参数的点估计</h2>
<h3 id="方法">方法</h3>
<h4
id="矩估计法样本中有未知值theta用样本均值等于总体期望ex-overlinex来计算theta的估计值hattheta">矩估计法：<span
class="math inline">\(样本中有未知值\theta，用样本均值等于总体期望E(X) =
\overline{X}来计算\theta的估计值\hat{\theta}\)</span></h4>
<h4 id="求ex">1 <span class="math inline">\(求E(X)\)</span></h4>
<h4 id="另ex-overlinex">2 <span class="math inline">\(另E(X) =
\overline{X}\)</span></h4>
<h4
id="最大似然估计法-如果是离散型概率分布中含theta如果是连续型概率函数含theta即后面所求将是包含theta的函数">最大似然估计法
<span
class="math inline">\(如果是离散型，概率分布中含\theta，如果是连续型，概率函数含\theta,即后面所求将是包含\theta的函数\)</span></h4>
<h5 id="将样本中所有结果相乘得到ltheta-prod_i1npleftx_i-xright">(1)
<span class="math inline">\(将样本中所有结果相乘得到L(\theta) =
\prod_{i=1}^nP\left\{X_i = x\right\}\)</span></h5>
<h5 id="第一步得到的等式两边取对数">(2) 第一步得到的等式两边取对数</h5>
<h5 id="等式两边关于theta求导并另之为0">(3) <span
class="math inline">\(等式两边关于\theta求导，并另之为0\)</span></h5>
<p>举个例子</p>
<p>离散型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215085510.jpg" /></p>
<p>矩估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215091131.jpg" /></p>
<p>最大似然估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215094536.jpg" /></p>
<p>连续型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215090002.jpg" /></p>
<p>矩估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215091143.jpg" /></p>
<p>最大似然估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215095428.jpg" /></p>
<h3 id="估计量的评价标准">估计量的评价标准</h3>
<h4 id="无偏性得到hattheta后证明ehattheta-theta">无偏性：<span
class="math inline">\(得到\hat{\theta}后证明E(\hat{\theta}) =
\theta\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215142836.jpg" /></p>
<h4 id="有效性比较哪个dhattheta更小">有效性：<span
class="math inline">\(比较哪个D(\hat{\theta})更小\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215143607.jpg" /></p>
<h4
id="一致性相合性证明hattheta依概率收敛于theta即lim_nrightarrowinftyplefthattheta-theta-epsilonright-1使用时往往结合切比雪夫不等式">一致性(相合性)：<span
class="math inline">\(证明\hat{\theta}依概率收敛于\theta，即\lim_{n\rightarrow\infty}P\left\{|\hat{\theta}-\theta|
&lt; \epsilon\right\} = 1\)</span>，使用时往往结合切比雪夫不等式</h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094731.jpg" /></p>
<h2 id="两类错误">两类错误</h2>
<p>以有没有病举例</p>
<h3 id="p拒绝h_0h_0为真-有病但被判成无病的概率">$P{拒绝H_0|H_0为真} = $
有病但被判成无病的概率</h3>
<h3 id="pleft接受h_0h_0为假right-无病但被判成有病的概率"><span
class="math inline">\(P\left\{接受H_0|H_0为假\right\}\)</span>
无病但被判成有病的概率</h3>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216100549.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章：随机变量的数字特征</title>
    <url>/posts/a17c09d9.html</url>
    <content><![CDATA[<h1 id="随机变量的数字特征">随机变量的数字特征</h1>
<span id="more"></span>
<h2 id="一-一维随机变量的数字特征">(一) 一维随机变量的数字特征</h2>
<h3 id="数学期望可以理解为加权平均求和">1
数学期望(可以理解为加权平均求和)</h3>
<h4 id="概念">1.1 概念</h4>
<h5 id="离散型x-p_i">(1) 离散型：X ~ <span
class="math inline">\(P_i\)</span></h5>
<h6
id="ex-sum_in-x_ip_i每一个正概率点是x_i对应的概率是p_i对应相乘后求和"><span
class="math inline">\(E(X) = \sum_{i}^n
x_ip_i\)</span>(每一个正概率点是<span
class="math inline">\(x_i\)</span>，对应的概率是<span
class="math inline">\(p_i\)</span>，对应相乘后求和)</h6>
<h6 id="如果y-gx-ey-sum_ingx_ip_i">如果Y = g(x), <span
class="math inline">\(E(Y) = \sum_{i}^{n}g(x_i)p_i\)</span></h6>
<h5 id="连续型x-fx">(2) 连续型：X ~ <span
class="math inline">\(f(x)\)</span></h5>
<h6
id="ex-int_-inftyinftyxfxdx对于任意在正概率区间内的x可以形成一个以底是dx高是fx的小矩形面积是fxdx可以近似认为是x对应的概率所以在整个区间上对所有的x积分就是int_-inftyinftyxfxdx"><span
class="math inline">\(E(X) =
\int_{-\infty}^{+\infty}xf(x)dx\)</span>(对于任意在正概率区间内的x，可以形成一个以底是dx，高是f(x)的小矩形，面积是f(x)dx,可以近似认为是x对应的概率，所以在整个区间上对所有的x积分就是<span
class="math inline">\(\int_{-\infty}^{+\infty}xf(x)dx\)</span>)</h6>
<h6
id="如果y-gx-ey-int_-inftyinftygxfxdxy-gx只是修改了定义域的范围将定义域从x的范围变成了gx的范围而对概率密度并没有影响">如果Y
= g(x), <span class="math inline">\(E(Y) =
\int_{-\infty}^{+\infty}g(x)f(x)dx\)</span>(Y=
g(x)，只是修改了定义域的范围，将定义域从x的范围变成了g(x)的范围，而对概率密度并没有影响)</h6>
<h4 id="性质">1.2 性质</h4>
<h5 id="线性eax-b-aex-b">1.2.1 线性：E(aX + b) = aE(X) + b</h5>
<h5
id="独立如果x与y相互独立才可以拆分exy-exey也常用这个证明是否相互独立">1.2.2
独立：如果X与Y相互独立，才可以拆分E(XY) =
E(X)E(Y)(也常用这个证明是否相互独立)</h5>
<h3 id="方差标准差">2 方差、标准差</h3>
<h3
id="概念方差反应的是每个数据点对于均值的偏离情况标准差就是方差开根号">2.1
概念：方差反应的是每个数据点对于均值的偏离情况，标准差就是方差开根号</h3>
<h4 id="dx-ex---ex2-ex2---ex2-sigma-sqrtdx"><span
class="math inline">\(D(X) = E((X - E(X)^2) = E(X^2) - (E(X))^2, \sigma
= \sqrt{D(X)}\)</span></h4>
<p>如果是求D(g(X))，或者说所有求D(X),都要利用定义转换成计算均值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214084118.jpg" /></p>
<h3 id="性质-1">2.2 性质</h3>
<h4 id="dax-b-a2dx">2.2.1 <span class="math inline">\(D(aX + b) =
a^2D(X)\)</span></h4>
<h4 id="dxpm-y-dx-dy-pm-2covx-y">2.2.2 <span
class="math inline">\(D(X\pm Y) = D(X) + D(Y) \pm 2Cov(X,
Y)\)</span></h4>
<h4 id="如果x与y相互独立dax-by-a2dx-b2dy">2.2.3 如果X与Y相互独立，<span
class="math inline">\(D(aX + bY) = a^2D(X) + b^2D(Y)\)</span></h4>
<h3 id="切比雪夫不等式偏离期望值的概率小靠近期望值的概率大">3
切比雪夫不等式(偏离期望值的概率小，靠近期望值的概率大)</h3>
<h4 id="pleftx---ex-epsilon-right-geq-1---fracdxepsilon2">3.1 <span
class="math inline">\(P\left\{|X - E(X)| &lt; \epsilon \right\} \geq 1 -
\frac{D(X)}{\epsilon^2}\)</span></h4>
<h4 id="pleftx---ex-geq-epsilonright-leq-fracdxepsilon2">3.2 <span
class="math inline">\(P\left\{|X - E(X)| \geq \epsilon\right\} \leq
\frac{D(X)}{\epsilon^2}\)</span></h4>
<p>常用期望和分布</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231213160527.jpg" /></p>
<h2 id="二-二维随机变量的数字特征">(二) 二维随机变量的数字特征</h2>
<h3 id="期望">1 期望</h3>
<h3
id="离散型-egx-y-sum_isum_jgx-yp_i-jgx-y实际上代表的是平面定义域">1.1
离散型 <span class="math inline">\(E[g(X, Y)] = \sum_{i}\sum_{j}g(x,
y)p_{i, j})\)</span>(g(x, y)实际上代表的是平面定义域)</h3>
<h3 id="连续型-设x-yfx-y-egx-y-iint_-inftyinftygx-yfx-ydxdy">1.2 连续型
，设(x, y)~f(x, y) <span class="math inline">\(E[g(X, Y)] =
\iint_{-\infty}^{+\infty}g(x, y)f(x, y)dxdy\)</span></h3>
<h3 id="协方差与相关系数">2 协方差与相关系数</h3>
<h4 id="概念-1">1 概念：</h4>
<h5 id="协方差概念-covx-y-ex---exy---ey-exy---exey">协方差概念 Cov(X, Y)
= E[(X - E(X))(Y - E(Y))] = E(XY) - E(X)E(Y)</h5>
<h5 id="相关系数概念-rho_xy-fraccovx-ysqrtdx-sqrtdy">相关系数概念 <span
class="math inline">\(\rho_{XY} = \frac{Cov(X, Y)}{\sqrt{D(X)}
\sqrt{D(Y)}}\)</span></h5>
<p>如果<span class="math inline">\(\rho _{XY} =
0\)</span>,说明X与Y之间没有线性相关性，但可能有其他形式的相关，如果不为0，就是有线性相关性</p>
<h4 id="性质都可以从定义推出来">2 性质(都可以从定义推出来)</h4>
<h5 id="对称性">2.1 对称性</h5>
<h5 id="线性性">2.2 线性性</h5>
<h2 id="典型题型">典型题型</h2>
<h3 id="求二维连续型随机变量相关系数">1
求二维连续型随机变量相关系数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231120140922.jpg" /></p>
<h4 id="求ex">求EX</h4>
<h4 id="求ex2">求E(X^2)</h4>
<h4 id="求dx-ex2---ex2">求DX = E(X^2) - (EX)^2</h4>
<h4 id="y同理">Y同理</h4>
<h4 id="求exy">求E(XY)</h4>
<h4 id="利用相关系数公式">利用相关系数公式</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231120143419.jpg" /></p>
<p>### 2 独立性与相关性的判定</p>
<p>#### 计算Cov(X, Y)</p>
<p>#### <span class="math inline">\(Cov(X, Y) \neq 0 \Rightarrow
X与Y相关 \Rightarrow X与Y不相互独立\)</span></p>
<p>####<span class="math inline">\(Cov(X, Y) = 0 \Rightarrow X与Y不相关
\Rightarrow 通过构造事件组P\left\{X \leq a\right\}, P\left\{Y \leq
a\right\}\)</span></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章：大数定律与中心极限定理</title>
    <url>/posts/c0910902.html</url>
    <content><![CDATA[<h1 id="大数定律与中心极限定理">大数定律与中心极限定理</h1>
<span id="more"></span>
<h2 id="一依概率收敛">(一）依概率收敛</h2>
<h3 id="一定义">一：定义</h3>
<h4
id="鬼话forall-epsilon-0-exist-n-0-当n-n时-有lim_n-to-inftypleftx_n-a-epsilonright-1则称x_n依概率收敛于a">鬼话：<span
class="math inline">\(\forall \epsilon &gt; 0, \exist N &gt; 0, 当n &gt;
N时, 有\lim_{n \to \infty}P\left\{|X_n-a| &lt; \epsilon\right\} =
1,则称X_n依概率收敛于a\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126134818.jpg" /></p>
<h4 id="人话形容一列数x_n到点a的距离很近极限状态下概率是1">人话：<span
class="math inline">\(形容一列数X_n到点a的距离很近，极限状态下概率是1\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126134851.jpg" /></p>
<h3
id="题型证明一个随机变量序列收敛">题型：证明一个随机变量序列收敛</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140719.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140649.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140824.jpg" /></p>
<h4 id="方法">方法</h4>
<h5 id="构造xn到一个数的距离小于ε">1 构造Xn到一个数的距离小于ε</h5>
<h5 id="对上面构造的求极限一般会向切比雪夫不等式靠近">2
对上面构造的求极限，一般会向切比雪夫不等式靠近</h5>
<h2 id="二大数定律">(二)大数定律</h2>
<h3 id="切比雪夫">1 切比雪夫</h3>
<h4 id="条件">条件</h4>
<h5 id="变量序列相互独立">(1) 变量序列相互独立</h5>
<h5 id="变量序列的方差存在且有上界">(2) 变量序列的方差存在且有上界</h5>
<h4
id="结论-frac1n-sum_i1n-x_i-oversetprightarrow-frac1nsum_i1nex_i-这堆变量序列的均值最终依概率收敛到这堆变量序列的期望们的均值">结论
<span class="math inline">\(\frac{1}{n} \sum_{i=1}^n X_i
\overset{P}{\rightarrow} \frac{1}{n}\sum_{i=1}^{n}E(X_i)\)</span> ,
这堆变量序列的均值最终依概率收敛到这堆变量序列的期望们的均值</h4>
<h3 id="辛钦">2 辛钦</h3>
<h4 id="条件-1">条件</h4>
<h5 id="独立">(1) 独立</h5>
<h5 id="同分布">(2) 同分布</h5>
<h5 id="期望存在">(3) 期望存在</h5>
<h4
id="结论-frac1nsum_i1nx_i-frac1nsum_i1nex_i-frac1nnu-u-与切比雪夫结论类似不过因为同分布所以ex_i一样">结论
<span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}X_i =
\frac{1}{n}\sum_{i=1}^{n}E(X_i) = \frac{1}{n}nu = u\)</span>,
与切比雪夫结论类似，不过因为同分布所以<span
class="math inline">\(E(X_i)一样\)</span></h4>
<h2 id="三-中心极限定理">(三) 中心极限定理</h2>
<h3 id="条件-2">条件</h3>
<h4 id="xi独立同分布于某种类型的分布">(1)
Xi独立同分布于某种类型的分布</h4>
<h4 id="xi的期望和方差都存在分别设期望是u方差是σ2">(2)
Xi的期望和方差都存在，分别设期望是u，方差是σ^2</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144358.jpg" /></p>
<h3
id="结论对xi求和再取极限n-就趋向于正态分布nnsigma-nsigma2">结论：对Xi求和再取极限(n-&gt;∞)就趋向于正态分布<span
class="math inline">\(N(n\sigma, n\sigma^2)\)</span></h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144404.jpg" /></p>
<h3 id="标准化的结论">标准化的结论</h3>
<h4 id="fracsum_i1nx_i-nsigmasqrtnsigma-sim-n0-1">1 <span
class="math inline">\(\frac{(\sum_{i=1}^{n}X_i)-n\sigma}{\sqrt{n}\sigma}
\sim N(0, 1)\)</span></h4>
<h4
id="lim_nrightarrowinftypleftfracsum_i1nx_i-nsigmasqrtnsigma-leq-xright-phix">2
<span
class="math inline">\(\lim_{n\rightarrow\infty}P\left\{\frac{(\sum_{i=1}^{n}X_i)-n\sigma}{\sqrt{n}\sigma}
\leq x\right\} = \Phi{(x)}\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144407.jpg" /></p>
<p>对于二项分布来说，其实每一次是一个0-1分布，所以均值是0-1分布的均值而不是二项分布的均值</p>
<h3 id="题型求一个范围ab的概率">题型：求一个范围A~B的概率</h3>
<h4 id="看一次取样满足于什么分布">1 看一次取样满足于什么分布</h4>
<h4 id="求这种分布的均值u和方差σ">2 求这种分布的均值u和方差σ</h4>
<h4 id="看取了几次样作为n得到近似正态分布nnu-nσ2">3
看取了几次样，作为n，得到近似正态分布<span class="math inline">\(N(nu,
nσ^2)\)</span></h4>
<h4 id="ab的概率就是φfracb-nuσ---φfraca-nuσ">4 A~B的概率就是<span
class="math inline">\(Φ(\frac{B-nu}{σ}) -
Φ(\frac{A-nu}{σ})\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214163043.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>中文数据库</title>
    <url>/posts/7ee29e1e.html</url>
    <content><![CDATA[<h1 id="cnki的使用">CNKI的使用</h1>
<span id="more"></span>
<h2 id="资源类型选择">资源类型选择</h2>
<p>（1）在首页勾选</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191151252.png" /></p>
<p>（2）在高级检索界面页头的检索设置里删除或添加资源类型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191505385.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191548317.png" /></p>
<h2 id="文献检索的方式">文献检索的方式</h2>
<h3 id="框式检索">框式检索</h3>
<h4 id="步骤">步骤：</h4>
<ol type="1">
<li>选择所需的文献类型（如学术期刊、学位论文、会议等库）；</li>
<li>选择所需的检索字段（/检索项）（如主题、题名、作者、单位等）；</li>
<li>输入相应的检索词。</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191958087.png" /></p>
<h4 id="检索项">检索项</h4>
<ol type="1">
<li><p><font color = "red">主题检索</font>
在中国知网标引出来的主题字段中进行检索，包含一篇文章的所有主题特征，同时在检索过程中嵌入了专业词典、主题词表、中英对照词典、停用词表等工具，并采用关键词截断算法，将低相关或微相关文献进行截断。</p></li>
<li><p><font color = "red">篇关摘检索</font>
在<font color = "yellow">篇名、关键词、摘要范围</font>内进行检索。</p></li>
<li><p><font color = "red">关键词检索</font>(相当于标签)
包括文献原文给出的中、英文关键词，以及对文献进行分析计算后机器标引出的关键词。机器标引的关键词基于对全文内容的分析，结合专业词典，解决了文献作者给出的关键词不够全面准确的问题。</p></li>
<li><p><font color = "red">篇名检索</font>
期刊、会议、学位论文、辑刊的篇名为文章的中、英文标题。报纸文献的篇名包括引题、正标题、副标题。年鉴的篇名为条目题名。专利的篇名为专利名称。标准的篇名为中、英文标准名称。成果的篇名为成果名称。古籍的篇名为卷名。</p></li>
<li><p>全文检索
在文献的全部文字范围内进行检索，包括文献篇名、关键词、摘要、正文、参考文献等。</p></li>
<li><p>作者检索
期刊、报纸、会议、学位论文、年鉴、辑刊的作者为文章中、英文作者。专利的作者为发明人。标准的作者为起草人或主要起草人。成果的作者为成果完成人。古籍的作者为整书著者。</p></li>
<li><p>第一作者检索
只有一位作者时，该作者即为第一作者。有多位作者时，将排在第一个的作者认定为文献的第一责任人。</p></li>
<li><p>通讯作者检索
期刊文献对原文的通讯作者进行了标引，可按通讯作者查找期刊文献。通讯作者指课题的总负责人，也是文章和研究材料的联系人。</p></li>
</ol>
<h4 id="检索词">检索词</h4>
<ol type="1">
<li>输入两个或两个以上的检索词，多个检索词之间的<font color = "red">空格代表了逻辑“与”(AND)。</font></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192521124.png" /></p>
<ol start="2" type="1">
<li><p>二次检索</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192659355.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192708567.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192715170.png" /></p></li>
</ol>
<h4 id="匹配方式">匹配方式</h4>
<p>1、相关度匹配
主题、篇关摘、篇名、全文、摘要、小标题、参考文献、文献来源;根据检索词在该字段的匹配度，得到相关度高的结果。</p>
<p>2、精确匹配 关键词、作者、第一作者、通讯作者。</p>
<p>3、模糊匹配 作者单位、基金、分类号、DOI。</p>
<h4 id="同字段组合运算">同字段组合运算</h4>
<p>1、支持运算符*、+、-、‘’、""、()进行同一检索项内多个检索词的组合运算，检索框内输入的内容不得超过120个字符。</p>
<p>2、输入运算符*(与)、+(或)、-(非)时，前后要空一个字节，优先级需用英文半角括号确定。</p>
<p>3、若检索词本身含空格或*、+、-、()、/、%、=等特殊符号，进行多词组合运算时，为避免歧义，须将检索词用英文半角双引号引起来。</p>
<hr style = "border:2px solid yellow">
<p>例如： （1）篇名检索项后输入：神经网络 *<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
自然语言，可以检索到篇名包含“神经网络”及“自然语言”的文献。</p>
<p>（2）主题检索项后输入：(锻造 + 自由锻) *
裂纹，可以检索到主题为“锻造”或“自由锻”，且有关“裂纹”的文献。</p>
<p>（3）检索篇名包含“digital library”和“information
service”的文献，在篇名检索项后输入：“digital library” * “information
service”。</p>
<p>（4）检索篇名包含“2+3”和人才培养的文献，在篇名检索项后输入：“2+3” *
人才培养。</p>
<hr style = "border:2px solid yellow">
<h4 id="检索推荐引导功能">检索推荐/引导功能</h4>
<p>1、主题词智能提示</p>
<p>适用字段：主题、篇名、关键词、摘要、全文。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194018720.png" /></p>
<p>2、作者引导</p>
<p>检出所有暨南大学的刘增合所发表的文献，检索时精准定位所查找的作者，排除同名作者，并且不管原文机构是否含“暨南大学”字样，只要规范为暨南大学的，都可以被检到</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194144805.png" /></p>
<p>某作者同时有多个单位</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194301775.png" /></p>
<h3 id="高级检索">高级检索</h3>
<h4 id="检索特点">检索特点</h4>
<ol type="1">
<li>由多个检索字段进行逻辑组合检索，并可通过选择精确或模糊的匹配方式、控制条件等方法完成较复杂的检索；</li>
<li>多字段组合检索的运算优先级，按从上到下的顺序依次进行；</li>
<li>通过“+” 、“-”来增加或减少检索项；</li>
<li>控制条件：匹配方式、时间范围、文献来源、基金文献、作者、作者单位、文献分类、网络首发、增强出版、数据论文、中英文扩展、同义词扩展等。</li>
</ol>
<h4 id="检索区">检索区</h4>
<p>① 检索条件输入区
默认显示主题、作者、文献来源三个检索框，可自由选择检索项、检索项间的逻辑关系、检索词的匹配方式。
点击检索框后的按钮可添加或删除检索项，最多支持10个检索项的组合检索。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195137905.png" /></p>
<p>② 检索控制区
主要作用是通过条件筛选、时间选择等，对检索结果进行范围控制。
控制条件包括：出版模式、基金文献、时间范围、检索扩展。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195230532.png" /></p>
<p>③ 切库区</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195327336.png" /></p>
<p>④ 文献导航</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195414849.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195421424.png" /></p>
<p>⑤匹配方式</p>
<p>除主题只提供相关度匹配外，其他检索项均提供精确、模糊两种匹配方式。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195459259.png" /></p>
<p>⑥词频选择</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195530621.png" /></p>
<p>⑦同字段组合运算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195627283.png" /></p>
<p>⑧结果中检索</p>
<p>举例：</p>
<p>例如：检索主题“人工智能”后，在结果中检索主题“机器人”</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195850189.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195813416.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195644126.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>检索华北电力大学师生2000年1月1日-2023年1月1日发表的电力系统继电保护方面的学术期刊文献、学位论文、会议论文各有多少篇。</p>
<p>Step1：点击“检索设置”，选择学术期刊、学位论文、会议，保存设置；
Step2：选择检索项“主题”, 在检索框中输入：电力系统* 继电保护；
Step3：控制条件“发表时间”选择从“2000-01-01 ” –“2023-01-01”；
Step4：作者单位输入“华北电力大学”，默认为“模糊”匹配；
Step5：点击“检索”按钮。</p>
<hr style = "border:2px solid yellow">
<h4 id="作者发文检索">作者发文检索</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200404813.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200740897.png" /></p>
<hr style = "border:2px solid yellow">
<h4
id="句子检索用于查找论文中的事实信息">句子检索（用于查找论文中的事实信息）</h4>
<p>通过输入的两个检索词，在全文范围内查找同时包含这两个词的句子，找到有关事实的问题答案。</p>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>例如：检索同一句包含“人工智能”和“神经网络”的文献</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200954786.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405201025767.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="专业检索">专业检索</h3>
<h4 id="构造专业检索式">构造专业检索式</h4>
<p>①查看检索字段代码。专业检索的检索字段用代码表示，如，主题用SU表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可检索字段和对应代码</span><br><span class="line"></span><br><span class="line">SU=主题,</span><br><span class="line"></span><br><span class="line">TKA=篇关摘,</span><br><span class="line"></span><br><span class="line">KY=关键词,</span><br><span class="line"></span><br><span class="line">TI=篇名,</span><br><span class="line"></span><br><span class="line">FT=全文,</span><br><span class="line"></span><br><span class="line">AU=作者,</span><br><span class="line"></span><br><span class="line">FI=第一作者,</span><br><span class="line"></span><br><span class="line">RP=通讯作者,</span><br><span class="line"></span><br><span class="line">AF=作者单位,</span><br><span class="line"></span><br><span class="line">FU=基金,</span><br><span class="line"></span><br><span class="line">AB=摘要,</span><br><span class="line"></span><br><span class="line">CO=小标题,</span><br><span class="line"></span><br><span class="line">RF=参考文献,</span><br><span class="line"></span><br><span class="line">CLC=分类号,</span><br><span class="line"></span><br><span class="line">LY=文献来源, </span><br><span class="line"></span><br><span class="line">DOI=DOI,</span><br><span class="line"></span><br><span class="line">CF=被引频次</span><br></pre></td></tr></table></figure>
<p>②查看检索表达式语法。注意CNKI专业检索中，不同检索字段之间的“与”“或”“非”用“AND”、“OR”、“NOT”表示，但同一检索字段中的不同检索词之间的“与”“或”“非”则用*、+、-表示；
③输入检索式。检索式的表达形式：</p>
<p><font color = "red">检索字段代码 = 检索式</font></p>
<hr style = "border:2px solid yellow;">
<p>举例</p>
<p>TI=信息素养，</p>
<p>含义是检索篇名(检索代码是TI)中含有信息素养的论文。</p>
<hr style = "border:2px solid yellow;">
<blockquote>
<p>注意：</p>
<p>检索式里的符号都必须使用英文半角字符；</p>
<p>检索词之间用：*、+、-；</p>
<p>字段之间用 AND、OR、 NOT 。</p>
<p>如：SU%=大学生 AND （信息素养 + 信息素质）</p>
</blockquote>
<h4 id="匹配运算符">匹配运算符</h4>
<p><font color = "yellow">下面这图表达什么意思呢</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405203647919.png" /></p>
<hr style = "border:2px solid yellow">
<p>例如： (1)精确检索关键词包含“数据挖掘”的文献：KY = 数据挖掘。
(2)模糊检索摘要包含“计算机教学”的文献：AB %
计算机教学，模糊匹配结果为摘要包含“计算机”和“教学”的文献，“计算机”和“教学”两词不分顺序和间隔。
(3)检索主题与“大数据”相关的文献：SU %=
大数据，主题检索推荐使用相关匹配运算符“%=”。</p>
<hr style = "border:2px solid yellow">
<h4 id="比较运算符">比较运算符</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405203847162.png" /></p>
<p>例如： (1)YE BETWEEN ('2010', ‘2020')
，检索出版年份在2010至2020年的文献。</p>
<p>(2)CF &gt; 0或CF &gt;=1 ，检索被引频次不为0的文献。</p>
<h4 id="逻辑运算符">逻辑运算符</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405204417802.png" /></p>
<hr style = "border:2px solid yellow">
<p>例如： (1)检索邱均平发表的关键词包含知识管理的文章，检索式：KY =
知识管理 AND AU = 邱均平。
(2)检索篇名包含大数据，但不是大数据集的文章，检索式：TI = 大数据 NOT TI
= 大数据集。 (4)检索钱伟长在清华大学或上海大学时发表的文章，检索式：AU =
钱伟长 AND (AF =清华大学 OR AF =上海大学)。
(5)检索钱伟长在清华大学期间发表的题名或摘要中都包含“物理”的文章，检索式：AU
=钱伟长 AND AF=清华大学 AND (TI =物理 OR AB = 物理)。</p>
<hr style = "border:2px solid yellow">
<h2 id="知网研学批量下载">知网研学批量下载</h2>
<ol type="1">
<li><p>规范每页显示文章数量、确定检索优先级（比如按照被索引高低），点击全选后批量下载</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406061749485.png" /></p></li>
<li><p>将下载的es6放入文件夹后从知网研学中导入题录</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406061852627.png" /></p></li>
</ol>
<h2 id="导出格式引文">导出格式引文</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406063236898.png" /></p>
<h1 id="万方">万方</h1>
<p>与CNKI差不多</p>
<p>万方不能用与或非，必须用and，or，not替代</p>
<blockquote>
<p>注：“分析”不能作为检索词</p>
</blockquote>
<h1 id="维普">维普</h1>
<p>也差不多，就是一个期刊导航可以找什么CSCD、北大核心、CSCCI</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>逻辑与<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>引文检索</title>
    <url>/posts/3a9d48aa.html</url>
    <content><![CDATA[<h1 id="中文">中文</h1>
<p>CSSCI</p>
<p>主要是用来查看核心期刊</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408203929253.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408203954962.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="外文">外文</h1>
<h1 id="web-of-science">Web of Science</h1>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>文献检索基础知识</title>
    <url>/posts/f1d400e4.html</url>
    <content><![CDATA[<h1 id="搜索引擎检索技巧">搜索引擎检索技巧</h1>
<span id="more"></span>
<h2 id="布尔逻辑运算">布尔逻辑运算</h2>
<h2 id="双引号进行精确检索">双引号“”进行精确检索</h2>
<p>加引号</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223002226.png" /></p>
<p>不加引号</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223124082.png" /></p>
<p>可以看出加引号的部分搜索结果都包含“大学生信息素质”，不加引号的部分则不一定</p>
<h2
id="书名号检索其中书名号会出现在检索结果中或书名号里的内容不会被拆分">书名号《》检索，其中书名号会出现在检索结果中或书名号里的内容不会被拆分。</h2>
<p><font color = "yellow">与""精确检索有什么区别？</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223541730.png" /></p>
<h2 id="在特定站点中搜索关键词">在特定站点中搜索关键词</h2>
<p>在搜索引擎中，<font color = "yellow">使用"site:站点域名"的语法将会限制搜索结果仅显示来自指定站点的页面，并且包含了您指定的关键词</font>。这样做的效果是，搜索引擎会筛选出特定站点中与您输入的关键词相关的页面，而不会包括其他站点的页面。</p>
<p>在查询内容的后面加上“site:站点域名”，域名不要http://，
“site”和站点名之间不要带空格。</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224423269.png" /></p>
<h2 id="指定文档类型的检索">指定文档类型的检索</h2>
<p>关键词+filetype：文档类型”</p>
<p>举例：信息检索filetype:PPT</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331225931239.png" /></p>
<h2 id="搜索范围限定在url链接中">搜索范围限定在URL链接中</h2>
<p>方法：inurl：+关键词，如检索flash的学习技巧，检索式为：flash
inurl:jiqiao,表示“flash”可以出现在网页的任何位置，而“jiqiao”则必须出现在网页的URL中。</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224750692.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224819975.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224855825.png" /></p>
<h2 id="限定在网页的标题中的检索">限定在网页的标题中的检索</h2>
<p>用“intitle：”限定在网页标题范围内，
“intitle：”和后面的关键词不能有空格。</p>
<p><font color = "yellow">与前面“”和《》有什么区别</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331225246562.png" /></p>
<h1 id="web-of-science">Web of Science</h1>
<p>首页点击资源：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231104019.png" /></p>
<p>网页搜索“web of science"</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231147634.png" /></p>
<p>点击第一个链接，注意一定要关梯子</p>
<p>点击下拉菜单选择web of science核心合集</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231343472.png" /></p>
<p>选择合适年份</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231508309.png" /></p>
<p>选择合适索引</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231526497.png" /></p>
<h1 id="布尔逻辑检索boolean-retrieval">布尔逻辑检索（Boolean
Retrieval）</h1>
<p>与—— AND 或—— OR 非—— NOT</p>
<h2 id="逻辑与">逻辑与</h2>
<p>运算符为 "AND"、"*" 或空格；
表达两个或两个以上检索词之间的相关关系或限定关系的运算；
用以缩小检索范围，减少输出结果，提高检准率</p>
<h2 id="逻辑或">逻辑或</h2>
<p>运算符为 OR 或 +<br />
用于表达两个或两个以上检索词之间的并列关系运算；<br />
常用于连接同一检索词的同义词、近义词；<br />
可扩大检索范围、增加输出结果，提高检全率。</p>
<h2 id="逻辑非">逻辑非</h2>
<p>运算符：NOT 或 "-"<br />
表达在两个或两个检索词之间排除不需要的检索词的运算；<br />
缩小命中信息的范围，提高检索的检准率。<br />
A NOT B——表示含有检索词A而不含有检索词B的文献才能被命中。</p>
<h2 id="综合应用andornot">综合应用：AND、OR、NOT</h2>
<p>运算顺序：NOT &gt; AND &gt; OR 可通过 () 来改变运算的优先顺序，()
必须是英文半角状态下的括号</p>
<h1 id="截词检索">截词检索</h1>
<p>截词符：？ 、 * $</p>
<p>computer * AND technology</p>
<h2 id="无限截词">无限截词</h2>
<p>举例：employ*，可以检索到employ, employer, employers……</p>
<h2 id="有限截词">有限截词</h2>
<p>？表示这个单词这个位置的字母可以任意变化</p>
<p>比如psych????ist*，检索到含有psychologist, psychologists等</p>
<h2 id="前截词">前截词</h2>
<p>*wave</p>
<h2 id="中截词">中截词</h2>
<p>organiza?ion</p>
<h2 id="后截词">后截词</h2>
<p>book？</p>
<p>lancaster*</p>
<p>biolog*</p>
<h1
id="词组检索快速精确找出需要的文献">词组检索快速精确找出需要的文献</h1>
<p>又称“精确检索”或“短语检索”。</p>
<p>将一个词组或短语用双引号“”括起来作为一个独立运算单元，进行严格匹配，即可检索出与“”内形式完全相同的短语，以提高检索的准确度。</p>
<h1 id="检索词">检索词</h1>
<h2 id="如何确定">如何确定</h2>
<h3 id="切分">切分</h3>
<p>如:“国内在线学习投入的研究进展”课题语句可切分为以下自由词：
国内|在线学习|投入|的|研究|进展
注：如果词组切分后失去原来的意思，则不能进行切分，切分要保证词组意思的完整性。如“在线学习”不能切分为“在线”和“学习”。</p>
<h3 id="删除">删除</h3>
<p>删除是将课题语句中不具有实质性检索意义的词语进行删除。包括虚词（如介词、连词、副词等），使用频率低的词，专指性太高或过于宽泛的词，过于具体的限定词、禁用词，不能表达课题实质性的高频词，存在蕴含关系可以合并的词。</p>
<p>如：可以将 国内|在线学习|投入|的|研究|进展
中的国内、的、研究、进展删除，得到在线学习、投入。</p>
<h3 id="替换和补充">替换和补充</h3>
<p>如：“在线学习”可补充同义词、近义词：网络学习、MOOC、慕课、大规模开放课程、E-learning、网络课程等；
“投入”替换为更具体的“学习投入”，并补充同义词、近义词“学习参与”。</p>
<h2 id="分类">分类</h2>
<h3 id="从规范性">从规范性</h3>
<p>① 受控词
经过规范化处理的检索语言，又叫人工语言。取自主题词表、叙词表、分类表等。如标题词、叙词。
② 非受控词 指非规范化的自然语言，如关键词。</p>
<p>Tips：规范化处理，是在文献存储时，对文献中的同义词、近义词、多义词等加以严格的控制和规范，使得同一主题概念的文献相对集中在一个主题词下。
<font color = "red">受控词
——&gt;主题词——&gt;专业，非受控词——&gt;关键词——&gt;不专业</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401204254196.png" /></p>
<h1 id="词表">词表</h1>
<p>第一步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401204507761.png" /></p>
<p>第二步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401205130763.png" /></p>
<p>第三步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401205338573.png" /></p>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>英文数据库</title>
    <url>/posts/c21d49b4.html</url>
    <content><![CDATA[<h1 id="elsevier-sdol">Elsevier SDOL</h1>
<span id="more"></span>
<h2 id="检索语言与检索技巧">检索语言与检索技巧</h2>
<h3 id="逻辑连接符">逻辑连接符</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406081348765.png" /></p>
<h3 id="单数检索">单数检索</h3>
<p>输入单词的单数形式，可检索单数、复数、所有格等多种形式　 输入ｃｉｔｙ
检索ｃｉｔｙ、ｃｉｔｉｅｓ、ｃｉｔｙ’ｓ</p>
<h3 id="词组检索">词组检索</h3>
<p>使用　“”　 “”较宽松精确检索，符号被忽略 　检索“heart-attack”
　或　“heart attack” 　结果一样</p>
<h3 id="停用词">停用词</h3>
<p>搜索引擎会自动忽略某些应用十分广泛，或者是助词、副词、介词等本身无意义的字或词，这些字或词即被称为stop
words(停用词)。</p>
<p>停用词不会被检索</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406081747403.png" /></p>
<h3 id="特殊检索项">特殊检索项</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>检索项</strong></th>
<th><strong>范例</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>希腊字符</td>
<td>检索　Ω 输入　omega 结果包含omega、Ω（大写）、ω（小写）</td>
</tr>
<tr class="even">
<td>上标与下标 直接写在同一行内</td>
<td>检索　Ｈ２Ｏ 输入　Ｈ２Ｏ</td>
</tr>
<tr class="odd">
<td>口音字母 输相近写法的英文字母</td>
<td>检索 Fürst 输入　Furst 或 Fürst</td>
</tr>
<tr class="even">
<td>非字母数字字符</td>
<td>箭头、加号等字符将被忽略</td>
</tr>
</tbody>
</table>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例1：搜索希腊字符</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406082224293.png" /></p>
<p>例2：搜索上下标</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406082235555.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="高级检索">高级检索</h2>
<h3 id="布尔逻辑运算符和cnki差不多">布尔逻辑运算符（和CNKI差不多）</h3>
<p>1、使用布尔运算符组合多个检索词： ①
支持的布尔运算符包括AND，OR，NOT和连字符（或减号-） ②
必须以全部大写形式输入布尔运算符 ③ 连字符（或减号）被解释为NOT运算符
如： black - hole将返回包含“black”的结果，但排除任何出现 ‘hole‘
的结果。</p>
<p>2、优先级 NOT 〉AND 〉OR</p>
<p>3、嵌套句子时可使用括号 如：对于a OR b AND c，输入(a OR b ) AND c
或输入(a OR b ) c</p>
<p>3、引号可用于指定必须彼此相邻的术语 如：("heart attack" OR
"myocardial infarction") AND diabetes AND NOT cancer
（"心脏病发作"或"心肌梗塞"）和糖尿病，而不是癌症</p>
<h3 id="快速检索某个主题相关的文献">快速检索某个主题相关的文献</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083059866.png" /></p>
<h3 id="利用高级检索功能准确定位">利用高级检索功能准确定位</h3>
<p>1、进入检索界面更多限定选择</p>
<p>2、确定检索字段</p>
<p>3、输入检索词</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083208306.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083413578.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083446524.png" /></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401183611530.png" /></p>
<p>首页</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401183755411.png" /></p>
<h1 id="ebsco数据库">EBSCO数据库</h1>
<h2 id="检索技术">检索技术</h2>
<p>1、逻辑算符</p>
<ul>
<li><p>AND :逻辑与 如：information and safety可以检索到既包含information
也包含 safety的文献，在EBSCO中 and 可以省略，直接输入information
safety。</p></li>
<li><p>OR：逻辑或 如：college or university
可以检索到college或university的文献。</p></li>
<li><p>NOT：逻辑非 如：girl not boy 检索到只包含girl 的文献。</p></li>
</ul>
<p>2、通配符</p>
<ul>
<li>*:可替代多个字符 如：输入comput*，可检索到computer computers、
computing、 computed等以comput开头的一系列词。</li>
<li>？：可替代1个字符
如：organi?ation可以检索到organization或organisation的词。</li>
<li>#：可替代0或1个字符 如：colo＃r检索到color或colour 的词。</li>
</ul>
<p>3、位置算符</p>
<ul>
<li><p>N:Near
Operator，N后面加数字，如N3,表示两个检索词不但要出现，而且两者之间最多允许插入3个单词，但先后顺序没有要求。
如：tax N3 reform,可以检索到tax reform， tax police reform，reform of
income tax等，只要tax 和reform之间的距离不超过3个单词即可。</p></li>
<li><p>W：Within operator
,W后加数字，如W3表示两个检索词不但要出现，而且两者直接最多允许插入3个单词，同时规定了两个词的先后顺序。
如：tax W3 reform，可以检索到tax reform， tax police
reform，但不能检索reform of income
tax，因为先后顺序不符合要求。</p></li>
</ul>
<p>4、短语检索 “”:用于检索固定短语，如：“information
literacy”,可以检索到固定格式的词组，位置顺序保持不变。</p>
<p>5、公式检索</p>
<ul>
<li><p>Keyword and FM
T:可以检索到HTML格式的文献，实现全文翻译及在线朗读功能。 如：information
literacy and FM T</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406085951450.png" /></p></li>
<li><p>DT 3 and keyword：可以检索到最近3天发表的文献。 如： DT 30 and
information literacy</p></li>
<li><p>Keyword JN
“Education”:可以检索到指定期刊Education上发表的文献。</p></li>
</ul>
<h2 id="基本检索">基本检索</h2>
<h3 id="检索模式和扩展条件">检索模式和扩展条件</h3>
<p>（1）布尔逻辑/词组
支持3种逻辑运算和扩展运算（一般为截词运算和位置运算）
（2）查找全部检索词语 相当于逻辑“与” （3） 查找任何检索词语
相当于逻辑“或” （4）智能文本搜索
可输入或粘贴大段文字（包括空格最多5000个字符）进行检索</p>
<p>（5）运用相关词 调用数据库的同义词库 （6）同时在文章全文范围内搜索
在默认字段和全文中检索</p>
<h3 id="限制结果">限制结果</h3>
<p>（1）全文 只检索全文的文章 （2）学术（同行评审）期刊
只检索有专家评审的期刊 （3） 有参考 只检索有参考文献的文章 （4）出版物
在限定的出版物中检索</p>
<p>（5）出版日期 限定出版物的出版时间 （6）出版物类型 限定出版物的类型
（7）图像快速查看类型 限定图像类型</p>
<h2 id="asc">ASC</h2>
<h3 id="基本检索-1">基本检索</h3>
<h4 id="同行评审">同行评审</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091052223.png" /></p>
<h4 id="图表查询">图表查询</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091143531.png" /></p>
<h3 id="高级检索-1">高级检索</h3>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>练习2：检索最近300天内发表的有关高校图书馆信息素养方面的文献。
检索式：DT 300 and (college* or universit<em>) and librar</em> and
(“information literacy”or “information quality”) 检索字段：主题
检索方式：高级检索</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091307393.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="bsc">BSC</h2>
<p>首先要切换数据库</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091459834.png" /></p>
<p>“公司信息”页面下提供详细的公司信息，包括分公司结构和公司简介等。</p>
<p>“叙词表”是一个商业术语词汇表，帮助更有效地搜索数据库中的文献。</p>
<h3 id="高级检索-2">高级检索</h3>
<p>公司可以作为一个字段，比如公司=sony</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>阅读索尼公司的SWOT分析，概述公司的优势，劣势，机遇和威胁</p>
<p>1、在搜索框中输入sony，然后从选择字段下拉菜单中选择“CO Company
Entity”，应用“Full Text”限制条件，然后单击Search
2、在结果列表页面左侧的“来源类型”下，单击“显示更多”。 找到“SWOT
分析”，然后单击“更新”。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401195345916.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401195408932.png" /></p>
<hr style = "border:2px solid yellow">
<p><font color = "yellow">主题词(可以用来判断关键词是不是主题词)是怎么做到的?</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401193948136.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401194016022.png" /></p>
<blockquote>
<p>注：查找统计数据可登录国研网</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401194400942.png" /></p>
</blockquote>
<h1 id="springerlink">SpringerLink</h1>
<h2 id="高级检索-3">高级检索</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406102853072.png" /></p>
<h1 id="pqdt数据库">PQDT数据库</h1>
<p>进入</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401202225043.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401202249086.png" /></p>
<p>高级检索中使用""不能表示精确检索，和基础检索一样</p>
<p>截词检索*不能与精确检索同时使用</p>
<p>精确检索中</p>
<h2 id="公式检索">公式检索</h2>
<p>DT 3 and keywork:检索最近3天</p>
<p>不要有停用词</p>
<p>比如of、in</p>
<blockquote>
<p>注：找同义词的技巧</p>
<p>kimi chat</p>
<p>文心一言</p>
<p>chatgpt</p>
</blockquote>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>如何更新github上过期的token</title>
    <url>/posts/499231f7.html</url>
    <content><![CDATA[<p>主要是为了更新picgo，git其实使用ssh就没必要（目前看来）</p>
<h1 id="生成新token">生成新token</h1>
<p><a
href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">参考文章</a></p>
<h1 id="更新picgo">更新picgo</h1>
<p><a href="https://zhuanlan.zhihu.com/p/489236769">参考文章</a></p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f.html</url>
    <content><![CDATA[<h1 id="主要参考">主要参考</h1>
<span id="more"></span>
<h2 id="hexo框架">hexo框架</h2>
<p>https://blog.csdn.net/yushuaigee/article/details/111465155</p>
<h2 id="github-page使用">Github Page使用</h2>
<p>https://blog.csdn.net/xq151750111/article/details/131101229</p>
<h2 id="picgo使用">PicGo使用</h2>
<h1 id="中文无法正常显示">中文无法正常显示</h1>
<p>用utf8保存配置文件</p>
<p>https://blog.csdn.net/Crazy_Diamond_/article/details/114902456</p>
<h1 id="主题优化">主题优化</h1>
<p>https://blog.csdn.net/xq151750111/article/details/131101229</p>
<h2 id="社交图标">社交图标</h2>
<p>https://blog.csdn.net/lhh2333/article/details/126935545</p>
<h2 id="字数统计和阅读时长">字数统计和阅读时长</h2>
<p>https://blog.csdn.net/mqdxiaoxiao/article/details/93670772</p>
<h2 id="修改永久链接">修改永久链接</h2>
<p>https://blog.luzy.top/posts/2424649425/</p>
<h1 id="hexo博客中添加categories分类">hexo博客中添加categories分类</h1>
<h1 id="hexo中配置mathjax">hexo中配置mathjax</h1>
<p>https://xingkunz.github.io/2020/01/13/hexo-%E8%A7%A3%E5%86%B3%E5%8D%9A%E5%AE%A2%E6%B8%B2%E6%9F%93%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</p>
<h1 id="站内搜索">站内搜索</h1>
<p>https://zhuanlan.zhihu.com/p/361143962</p>
<h1 id="如何让谷歌检索到自己博客">如何让谷歌检索到自己博客</h1>
<p>https://zhuanlan.zhihu.com/p/129022264</p>
<p>解释：导出的两个文件都放在项目source文件夹下，不是theme/source，并且都需要hexo
clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
<h1 id="博客背景设置和文章透明度优化">博客背景设置和文章透明度优化</h1>
<p>https://www.snowmoon.top/2021/02/21/next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</p>
<p>目前博客配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">//  更改背景图片</span><br><span class="line">body &#123;</span><br><span class="line">	// 透明度 0.6 的黑色半透明遮罩</span><br><span class="line">	background-color: rgba(0, 0, 0, 0.5);</span><br><span class="line">	// 設置背景混和模式為相乘模式</span><br><span class="line">	background-blend-mode: multiply;</span><br><span class="line">	// 图片自适应剪裁,56.25%=1080/1920</span><br><span class="line">	// padding-top: 56.25%</span><br><span class="line">	background-image:url(https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/j20_girl_background.webp);</span><br><span class="line">	//这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下</span><br><span class="line">	background-repeat: no-repeat;</span><br><span class="line">	background-attachment:fixed;</span><br><span class="line">	background-position:50% 50%;  //设置背景图像的起始位置</span><br><span class="line">	background-size:cover;</span><br><span class="line">&#125;</span><br><span class="line">.main-inner &#123; </span><br><span class="line">   //margin-top: 0px;</span><br><span class="line">   //padding: 0px 100px 100px 100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-block &#123;</span><br><span class="line">    border-radius : 12px;</span><br><span class="line">    background: rgba(255,255,255,0.9) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.comments &#123;</span><br><span class="line">    border-radius : 12px;</span><br><span class="line">    background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="修改内容区域的宽度">修改内容区域的宽度</h1>
<p>https://lamirs.vercel.app/hexo-next-%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%AE%BD%E5%BA%A6</p>
<h1 id="文章圆角设置">文章圆角设置</h1>
<p>https://gis90.github.io/articles/3412/</p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>清理c盘</title>
    <url>/posts/3d89e1fc.html</url>
    <content><![CDATA[<p>利用软链接</p>
<p>好处是既可以迁移到其他盘，也不会因为影响环境变量带来头疼的影响</p>
<p>比如我一开始少不懂事地把JetBrain撞到了C盘，后来发现这玩意能占用到5个G</p>
<p>先将整个目录从原来的盘剪切到其他盘（一定要剪切，原来的盘不能有这个文件了！）</p>
<p>然后再win窗口输入命令提示符选择以管理员身份运行</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123114108084.png" />
输入 mklink /D "原来的位置" "现在的位置"（引号不能省)就行了</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123114222834.png" /></p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>softmax的定义与实现</title>
    <url>/posts/ebe4d421.html</url>
    <content><![CDATA[<h1 id="基本术语的介绍">基本术语的介绍</h1>
<h2 id="特征feature">特征：（feature）：</h2>
<h3
id="描述一件事物的特性如一个人的身高体重年龄和五官">描述一件事物的特性，如一个人的身高、体重、年龄和五官。</h3>
<h3
id="代码里就是用来表示某样事物的矩阵">代码里就是用来表示某样事物的矩阵</h3>
<h2 id="样本sample">样本（sample）：</h2>
<h3
id="由一个人的特征组成的数据如1807019精致1807019精致">由一个人的特征组成的数据，如{180,70,19,精致}{180,70,19,精致}。</h3>
<h3
id="代码里就是从整个数据集里抽取的一部分">代码里就是从整个数据集里抽取的一部分</h3>
<h2 id="标签label">标签（label）：</h2>
<h3
id="描述一件事物的特性如一个人帅或丑一个人的财富数量注特征和标记没有明确的划分由于问题的不同可能导致">描述一件事物的特性，如一个人帅或丑、一个人的财富数量。<strong>注：特征和标记没有明确的划分，由于问题的不同可能导致</strong></h3>
<h3
id="a问题的特征是b问题的标记b问题的标记是a问题的特征"><strong>A问题的特征是B问题的标记，B问题的标记是A问题的特征。</strong></h3>
<h3
id="在代码里面往往表示的是真正的结果">在代码里面往往表示的是真正的结果</h3>
<h2 id="样例example">样例（example）：</h2>
<h3
id="由一个人的特征和标记组成的数据如1807019精致帅1807019精致帅">由一个人的特征和标记组成的数据，如{180,70,19,精致,帅}{180,70,19,精致,帅}。</h3>
<h2 id="特征空间feature-space">特征空间（feature space）：</h2>
<h2
id="特征向量feature-vector特征空间内的某一个具体的向量">特征向量（feature
vector）：特征空间内的某一个具体的向量</h2>
<h1 id="softmax回归">softmax回归</h1>
<h2 id="要解决的问题-分类问题">要解决的问题: 分类问题</h2>
<p>从一个图像分类问题开始。 假设每次输入是一个2×2的灰度图像。
我们可以用一个标量表示每个像素值，每个图像对应四个特征<span
class="math inline">\(x1,x2,x3,x4\)</span>。
此外，假设每个图像属于类别“猫”“鸡”和“狗”中的一个。</p>
<p>独热编码： （1）一个向量，它的分量和类别一样多
（2）类别对应的分量设置为1，其他所有分量设置为0。
（3）举例：标签y将是一个三维向量，
其中(1,0,0)对应于“猫”、(0,1,0)对应于“鸡”、(0,0,1)对应于“狗”：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114211802509.png" /></p>
<h2
id="优点softmax函数能够将未规范化的预测变换为非负数并且总和为1同时让模型保持可导的性质">优点：softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质</h2>
<h2 id="形成的网络架构">形成的网络架构</h2>
<p>（1）估计所有可能类别的条件概率，我们需要一个有多个输出的模型，每个类别对应一个输出</p>
<p>（2）所以需要和输出一样多的<em>仿射函数</em>（affine
function）(没那么高大上，就是实现映射关系的函数)，
每个输出对应于它自己的仿射函数</p>
<p>（3）有4个特征(因为前面说的灰度图有4个像素点）和3个可能的输出类别（猫，鸡，狗）</p>
<p>（4）所以需要12个标量来表示权重（带下标的<span
class="math inline">\(w\)</span>）， 3个标量来表示偏置（带下标的<span
class="math inline">\(b\)</span>），每个输入计算三个**（logit）：<span
class="math inline">\(o1、o2和o3\)</span>。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114213059124.png" /></p>
<p>（5）所以softmax回归是一个单层神经网络。softmax回归的输出层也是全连接层</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114213251337.png" /></p>
<h2 id="运算">运算</h2>
<h3 id="对每个项求幂使用exp">1.
对每个项求幂（使用<code>exp</code>）；</h3>
<h3 id="对每一行求和小批量中每个样本是一行得到每个样本的规范化常数">2.
对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</h3>
<h3 id="将每一行除以其规范化常数确保结果的和为1">3.
将每一行除以其规范化常数，确保结果的和为1。</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115162440275.png" /></p>
<h1 id="实现">实现</h1>
<h2 id="读取数据集">读取数据集</h2>
<p>练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型</p>
<p>打乱数据集中的样本并以小批量方式获取数据</p>
<p>接收批量大小、特征矩阵和标签向量作为输入</p>
<p>生成大小为<code>batch_size</code>的小批量。
每个小批量包含一组特征和标签。</p>
<p>读取第一个小批量数据样本并打印。
每个批量的特征维度显示批量大小和输入特征数。
同样的，批量的标签形状与<code>batch_size</code>相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[-0.594405    0.7975923 ]</span><br><span class="line"> [ 0.5477517   0.15074243]</span><br><span class="line"> [-0.34835348  0.929739  ]</span><br><span class="line"> [-1.5249145   0.701587  ]</span><br><span class="line"> [-2.298264    0.10911477]</span><br><span class="line"> [ 1.6356094   0.14286116]</span><br><span class="line"> [-0.19882555 -0.85171705]</span><br><span class="line"> [ 1.2024101  -1.7029836 ]</span><br><span class="line"> [-0.60534513 -0.39319903]</span><br><span class="line"> [-1.771029   -0.5459446 ]]</span><br><span class="line"> [[ 0.30207413]</span><br><span class="line"> [ 4.786745  ]</span><br><span class="line"> [ 0.33858034]</span><br><span class="line"> [-1.2297847 ]</span><br><span class="line"> [-0.75900215]</span><br><span class="line"> [ 6.979927  ]</span><br><span class="line"> [ 6.7001796 ]</span><br><span class="line"> [12.39533   ]</span><br><span class="line"> [ 4.3220677 ]</span><br><span class="line"> [ 2.517848  ]]</span><br></pre></td></tr></table></figure>
<h2 id="定义模型">定义模型</h2>
<h3 id="手搓版本">手搓版本</h3>
<h4 id="初始化模型参数">初始化模型参数</h4>
<h5 id="展平">展平</h5>
<p>每个样本都将用固定长度的向量表示。 原始数据集中的每个样本都是28×28 =
784的图像。 展平每个图像，把它们看作长度为784的向量</p>
<h5 id="输出维度">输出维度</h5>
<p>输出与类别一样多。
因为我们的数据集有10个类别，所以网络输出维度为10</p>
<h5 id="权重矩阵和偏置矩阵">权重矩阵和偏置矩阵</h5>
<h6 id="大小">大小</h6>
<p>因此，权重将构成一个784×10（每个数据由一维列向量构成，这个一维向量由784个数字构成，一共有10个输出，每个输出对应的每一行就是一个公式)的权重矩阵，
偏置将构成一个1×10的<strong>行向量</strong>（每个输出对应一个偏置，一共10个输出），注意这里是<strong>“立”</strong>着来，从上往下计算，不像前面提到和一般从左到右</p>
<h6 id="初始化">初始化</h6>
<p>使用正态分布初始化我们的权重<code>W</code>，偏置初始化为0。</p>
<h5 id="代码">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 使用 PyTorch 的 torch.normal 函数生成行数为 num_inputs，列数为 num_outputs的二维矩阵，并且服从正态分布（均值为0，标准差为0.01），并设置 requires_grad=True</span></span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="定义softmax操作">定义softmax操作</h4>
<h5 id="对每个项求幂使用exp-1">1.
对每个项求幂（使用<code>exp</code>）；</h5>
<h5 id="对每一行求和小批量中每个样本是一行得到每个样本的规范化常数-1">2.
对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</h5>
<h5 id="将每一行除以其规范化常数确保结果的和为1-1">3.
将每一行除以其规范化常数，确保结果的和为1。</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115162440275.png" />
##### 代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure></p>
<p>其中sum操作，如果指定在一个轴（同一列（轴0）或同一行（轴1））上求和，</p>
<p>如果<code>X</code>是一个形状为<code>(2, 3)</code>的张量，我们对列进行求和</p>
<p>默认情况会降维，得到一个形状<code>(3,)</code>的向量</p>
<p>但keepdim=True指定保持在原始张量的轴数，将产生一个具有形状<code>(1, 3)</code>的二维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">X.<span class="built_in">sum</span>(<span class="number">0</span>, keepdim=<span class="literal">True</span>), X.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(tensor([[5., 7., 9.]]),</span><br><span class="line"> tensor([[ 6.],</span><br><span class="line">         [15.]]))</span><br></pre></td></tr></table></figure>
<h4 id="合并">合并</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br></pre></td></tr></table></figure>
<p><code>X.reshape((-1, W.shape[0]))</code>：这一步将输入 <code>X</code>
重塑为一个二维张量，其形状的第二个维度与权重 <code>W</code>
的第一个维度相同。<code>-1</code> 表示该维度的大小会自动计算，以保持
<code>X</code> 中元素的总数不变</p>
<p><code>torch.matmul(X.reshape((-1, W.shape[0])), W)</code>：这一步执行矩阵乘法，将重塑后的
<code>X</code> 与权重 <code>W</code> 相乘</p>
<p>。<code>torch.matmul(X.reshape((-1, W.shape[0])), W) + b</code>：这一步将偏置
<code>b</code>
加到矩阵乘法的结果上。注意，由于广播（broadcasting）机制，即使
<code>b</code> 的形状与矩阵乘法的结果不同，这一步也能正确执行。</p>
<p><code>softmax(torch.matmul(X.reshape((-1, W.shape[0])), W) + b)</code>：最后，这一步将
softmax 函数应用到加上偏置的结果上。softmax 函数能将其输入（通常被称为
logits 或分数）转换为正值且和为 1 的概率分布。</p>
<h3 id="导包版本">导包版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PyTorch不会隐式地调整输入的形状,我们在线性层前定义了展平层（flatten），来调整网络输入的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接将模型定义和损失函数合并到一起去了</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="定义损失函数">定义损失函数</h2>
<h3 id="损失函数是什么">损失函数是什么</h3>
<p>量化目标的<em>实际</em>值与<em>预测</em>值之间的差距</p>
<p>选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0</p>
<p>回归问题中最常用的损失函数是平方误差函数 ###
对数似然(就是大二上学的概率论里的第六章的最大似然估计，与矩估计并列)</p>
<h3 id="交叉熵损失">交叉熵损失</h3>
<p>观察到的不仅仅是一个结果，现在用一个概率向量表示，如(0.1,0.2,0.7)，
而不是仅包含二元项的向量(0,0,1)。使用下面这个公式定义损失，它是所有标签分布的预期损失值。称为<em>交叉熵损失</em>（cross-entropy
loss）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/11.png" />
实现交叉熵损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y])</span><br><span class="line"></span><br><span class="line">cross_entropy(y_hat, y)</span><br></pre></td></tr></table></figure>
<h2 id="定义优化算法">定义优化算法</h2>
<p>每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。
接下来，朝着减少损失的方向更新我们的参数</p>
<p>接受模型参数集合、学习速率和批量大小作为输入。</p>
<p>每 一步更新的大小由学习速率<code>lr</code>决定</p>
<p>计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>）
来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br></pre></td></tr></table></figure>
<h2
id="分类精度确预测数量与总预测数量之比">分类精度：确预测数量与总预测数量之比</h2>
<p>须输出硬预测（hard prediction）时，
我们通常选择<strong>预测概率最高</strong>的类</p>
<p>当预测与标签分类<code>y</code>一致时，即是正确的。</p>
<p>计算方法：</p>
<p>如果<code>y_hat</code>是矩阵，那么假定第二个维度存储每个类的预测分数。
我们使用<code>argmax</code>获得每行中最大元素的索引来获得预测类别。
然后我们将预测类别与真实<code>y</code>元素进行比较。
由于等式运算符“<code>==</code>”对数据类型很敏感，
因此我们将<code>y_hat</code>的数据类型转换为与<code>y</code>的数据类型一致。
结果是一个包含0（错）和1（对）的张量。
最后，我们求和会得到正确预测的数量。</p>
<p>举例说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.tensor([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 标签y, 在第一个样本中，第一类是正确的预测； 而在第二个样本中，第三类是正确的预测</span></span><br><span class="line">y_hat = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>], [<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.5</span>]])</span><br><span class="line"><span class="comment"># y_hat包含2个样本在3个类别的预测概率， 以及它们对应的标签y</span></span><br><span class="line">y_hat[[<span class="number">0</span>, <span class="number">1</span>], y]</span><br><span class="line"><span class="comment"># 对一个二维张量 y_hat 进行索引。具体来说，它选择了 y_hat 的第 0 行和第 1 行中，由 y 指定的列</span></span><br></pre></td></tr></table></figure>
<p>输出 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([0.1000, 0.5000])</span><br></pre></td></tr></table></figure> 定义计算精度的函数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>)</span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure></p>
<p>使用之前定义的变量<code>y_hat</code>和<code>y</code>分别作为预测的概率分布和标签，第一个样本的预测类别是2（该行的最大元素为0.6，索引为2），这与实际标签0不一致。
第二个样本的预测类别是2（该行的最大元素为0.5，索引为2），这与实际标签2一致。
因此，这两个样本的分类精度率为0.5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accuracy(y_hat, y) / <span class="built_in">len</span>(y)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.5</span><br></pre></td></tr></table></figure>
<h2 id="训练">训练</h2>
<h3
id="在每次迭代中我们读取一小批量训练样本">在每次迭代中，我们读取一小批量训练样本</h3>
<h3
id="通过调用模型来获得一组预测并计算损失l前向传播">通过调用模型来获得一组预测并计算损失l（前向传播）</h3>
<h3
id="计算完损失后开始反向传播来计算每个参数的梯度">计算完损失后，开始反向传播来计算每个参数的梯度。</h3>
<h3
id="最后我们调用优化器比如sgd来更新模型参数">最后，我们调用优化器(比如sgd)来更新模型参数。</h3>
<h2 id="预测">预测</h2>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>transformer在cv中应用</title>
    <url>/posts/f8648800.html</url>
    <content><![CDATA[<h1 id="基础transformer讲解">基础transformer讲解</h1>
<h2 id="position-encoding">Position Encoding</h2>
<p>前面是没有考虑位置信息的，举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = nn.MultiheadAttention(embed_dim=<span class="number">2</span>, num_heads=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># embed_dim=2：指定了输入的嵌入维度（embedding dimension），即每个输入样本的特征维度为2，说白了就是图像的列数</span></span><br><span class="line"><span class="comment"># num_heads=1：指定了注意力头的数量，即将输入特征分成几份进行注意力计算。在这个例子中，只使用了1个注意力头。</span></span><br><span class="line">t1 = [[[<span class="number">1.</span>, <span class="number">2.</span>],   <span class="comment"># q1, k1, v1</span></span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>],   <span class="comment"># q2, k2, v2</span></span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>]]]  <span class="comment"># q3, k3, v3</span></span><br><span class="line"></span><br><span class="line">t2 = [[[<span class="number">1.</span>, <span class="number">2.</span>],   <span class="comment"># q1, k1, v1</span></span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>],   <span class="comment"># q3, k3, v3</span></span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>]]]  <span class="comment"># q2, k2, v2</span></span><br><span class="line"></span><br><span class="line">q, k, v = torch.as_tensor(t1), torch.as_tensor(t1), torch.as_tensor(t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result1: \n&quot;</span>, m(q, k, v))</span><br><span class="line"></span><br><span class="line">q, k, v = torch.as_tensor(t2), torch.as_tensor(t2), torch.as_tensor(t2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result2: \n&quot;</span>, m(q, k, v))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/20210611164732523.png" /></p>
<p>发现对b1没有影响</p>
<p>所以</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/20210611154758830.png" /></p>
<h1 id="vision-transformer模型详解">Vision Transformer模型详解</h1>
<p><strong><a
href="https://blog.csdn.net/qq_37541097/article/details/118242600#078b00d2-5d7d-f09f-c2b7-5f65765519fb">参考文章一</a></strong></p>
<p><a
href="https://blog.csdn.net/qq_37541097/article/details/117691873">参考文章二</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>卷积神经网络理论基础</title>
    <url>/posts/6b55376.html</url>
    <content><![CDATA[<h1 id="卷积">卷积</h1>
<h2 id="互相关运算">互相关运算：</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/correlation.svg" /></p>
<p>卷积核的每一位与待卷积矩阵对应位相乘后求和</p>
<p>0 x 0+1 x 1+3 x 2+4 x 3=19，其他类似</p>
<p>卷积核向右移动一位后，0 * 1 + 2 * 1 + 4 * 2 + 5 * 3 = 25</p>
<p>卷积核到下一行：0 * 3 + 1 * 4 + 6 * 2 + 7 * 3 = 37</p>
<p>再向右移动一位：0 * 4 + 1 * 5 + 7 * 2 + 8 * 3 = 43</p>
<h2 id="卷积层">卷积层</h2>
<p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。所以卷积层中的两个被训练的参数是卷积核权重和标量偏置</p>
<p>机初始化卷积核权重。</p>
<h3 id="手搓实现">手搓实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure>
<h3 id="导包实现">导包实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line">conv1 = nn.Conv2d(in_channel = , out_channel = , kernel_size = )</span><br></pre></td></tr></table></figure>
<p>一般首先关心的就是输入的通道数，输出的通道数，卷积核大小，初始化权重什么的不用操心</p>
<h2 id="特征映射和感受野">特征映射和感受野</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/correlation.svg" /></p>
<p>上图输出的卷积层有时被称为<em>特征映射</em>（feature
map），因为它可以被视为一个输入映射到下一层的空间维度的转换器，</p>
<p>卷积神经网络中，对于某一层的任意元素x，其<em>感受野</em>（receptive
field）是指在前向传播期间可能影响x计算的所有元素（来自所有先前层）。如上图,给定2×2卷积核，阴影输出元素值19的感受野是输入阴影部分的四个元素</p>
<p>感受野可能大于输入的实际大小。(这个很好理解，因为来自前面所有层，二输入仅仅指的是输出的前一层)</p>
<h2 id="卷积中的填充">卷积中的填充：</h2>
<p>减少边缘像素的丢失</p>
<h2 id="卷积中的步幅">卷积中的步幅</h2>
<h2 id="多输入多输出">多输入多输出</h2>
<h3 id="多输入">多输入</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/conv-multi-in.svg" /></p>
<p>输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数的卷积核，以便与输入数据进行互相关运算</p>
<p>先是各自通道上卷积核与各自通道进行互相关运算，然后将得到的两个输入求和成一个数作为对应位置的输出</p>
<h3 id="多输出">多输出</h3>
<p>随着神经网络层数的加深，我们常会增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度。</p>
<h1 id="汇聚">汇聚</h1>
<p>处理图像时，我们希望逐渐降低隐藏表示的空间分辨率、聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p>
<p>通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p>
<h2 id="目的">目的</h2>
<p>降低卷积层对位置的敏感性</p>
<p>同时降低对空间降采样表示的敏感性。</p>
<h2 id="种类">种类</h2>
<h3 id="最大汇聚层">最大汇聚层</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/pool.svg" /></p>
<p>每次取核里面最大的作为对应位置的输出</p>
<h3 id="平均汇聚层">平均汇聚层</h3>
<p>每次对核里面的求和取平均作为对应位置的输出</p>
<h2 id="多个通道">多个通道</h2>
<p>汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。
这意味着汇聚层的输出通道数与输入通道数相同。</p>
<h1 id="调整大小计算宽和高">调整大小计算宽和高</h1>
<p>参数计算主要是在从最后的卷积层或者池化层后，进行映射的全连接层的第一层前，需要展平成一维张量，这时就要通过参数计算来确定目前输出通道数，全部相乘的结果作为全连接层的第一层的输入通道数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">卷积后宽和高常用计算公式：</span><br><span class="line">(图像尺寸-卷积核尺寸 + 2*填充值)/步长+1</span><br><span class="line">池化后宽和高常用计算公式：</span><br><span class="line">(图像尺寸-池化窗尺寸 + 2*填充值)/步长+1</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/205453986">参考文章</a></p>
<h1 id="不成文规定">不成文规定</h1>
<p>池化参数一般就是（2， 2）</p>
<p>中间的channel数量都是自己设定的，二的次方就行</p>
<p>kernelsize一般3或者5之类的</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>多层感知机</title>
    <url>/posts/c3f7cdb7.html</url>
    <content><![CDATA[<h1
id="多层感知机定义与前面提到的softmax回归构成的全连接层相比就是增加了隐藏层">多层感知机定义：与前面提到的softmax回归构成的全连接层相比就是增加了隐藏层</h1>
<p>通过在网络中加入一个或多个隐藏层</p>
<p>最简单的方法是将许多全连接层堆叠在一起。
每一层都输出到上面的层，直到生成最后的输出</p>
<p>这种架构通常称为<em>多层感知机</em>（multilayer
perceptron），通常缩写为<em>MLP</em>。</p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116133945207.png" /></p>
<span id="more"></span>
<p>4个输入，3个输出</p>
<p>隐藏层包含5个隐藏单元。</p>
<p>输入层不涉及任何计算</p>
<p>产生输出只需要实现隐藏层和输出层的计算。</p>
<p>因此，这个多层感知机中的层数为2。</p>
<p>两个层都是全连接的。 每个输入都会影响隐藏层中的每个神经元，
而隐藏层中的每个神经元又会影响输出层中的每个神经元。</p>
<h1 id="激活函数">激活函数</h1>
<h2 id="定义">定义：</h2>
<p>在仿射变换之后对每个隐藏单元应用非线性的<em>激活函数</em>（activation
function）<span
class="math inline">\(\sigma\)</span>，防止多层感知机退化成线性模型</p>
<p>大多数激活函数都是非线性的</p>
<h2 id="作用">作用：</h2>
<p>过计算加权和并加上偏置来确定神经元是否应该被激活</p>
<h2 id="种类">种类</h2>
<h3 id="relu函数">ReLU函数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/output_mlp_76f463_21_0.svg" /></p>
<p>当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。</p>
<p>输入值精确等于0时，ReLU函数不可导。
在此时，我们默认使用左侧的导数，即当输入为0时导数为0</p>
<h3 id="sigmoid函数">sigmoid函数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-7c4e9e545f0cc76bb5202fec4202f873_r.jpg" /></p>
<h1 id="实现">实现</h1>
<h2 id="初始化模型参数">初始化模型参数</h2>
<p>每个图像由 28×28=784个灰度像素值组成。 所有图像共分为10个类别。
忽略像素之间的空间结构， 我们可以将每个图像视为具有784个输入特征
和10个类的简单分类数据集</p>
<p>实现一个具有单隐藏层的多层感知机， 它包含256个隐藏单元</p>
<p>可以将这两个变量都视为超参数。
通常，我们选择2的若干次幂作为层的宽度</p>
<p>对于每一层我们都要记录一个权重矩阵和一个偏置向量</p>
<h2 id="激活函数relu">激活函数RELU</h2>
<h2 id="模型">模型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">                    nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">                    nn.ReLU(),</span><br><span class="line">                    nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<h2 id="损失函数交叉熵损失">损失函数：交叉熵损失</h2>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>图像增广</title>
    <url>/posts/c2a0da7c.html</url>
    <content><![CDATA[<h1 id="翻转和裁剪">翻转和裁剪</h1>
<h2 id="水平翻转-transforms.randomhorizontalflip">水平翻转
transforms.RandomHorizontalFlip()</h2>
<p>有50%的几率水平翻转图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像</span></span><br><span class="line">img_path = <span class="string">&quot;/home/ztb/CV_method/image_augmentation/img.png&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义水平翻转变换</span></span><br><span class="line">horizontal_flip = transforms.RandomHorizontalFlip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用水平翻转</span></span><br><span class="line">flipped_image = horizontal_flip(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存水平翻转后的图像</span></span><br><span class="line">flipped_image.save(<span class="string">&quot;/home/ztb/CV_method/image_augmentation/flip.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于图像读取的补充：</p>
<p>PIL：推荐使用，读出来就是RGB</p>
<p>cv2：也可以用，不过读出来</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>配置带参数的远程调试</title>
    <url>/posts/5b87369e.html</url>
    <content><![CDATA[<h1 id="如何配置带参数的远程调试">如何配置带参数的远程调试</h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240131130659524.png" /></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>手写数字识别LeNet的实现</title>
    <url>/posts/9ffa7954.html</url>
    <content><![CDATA[<h1 id="前期准备工作">前期准备工作</h1>
<h2 id="配置环境和解释器">配置环境和解释器</h2>
<h3 id="配置远程环境">配置远程环境</h3>
<p>命令行查看所有环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<p>命令行创建环境</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python=X.X</span><br></pre></td></tr></table></figure>
<p>激活指定环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117084339703.png" /></p>
<p>再用查看所有环境，打*的环境表示是当前激活的环境</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117084441366.png" /></p>
<h3 id="配置本地解释器">配置本地解释器</h3>
<p>添加SSH解释器</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082843831.png" /></p>
<p>选择现有</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082955955.png" /></p>
<p>等待内省完毕</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117083008284.png" /></p>
<p>选择现有，找到之前创建的环境位置，后面加上/bin/pythonX.X(最初创建python的版本号)</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085311087.png" /></p>
<p>修改同步文件夹的远程文件夹为之前创建project的位置</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085448125.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085511661.png" /></p>
<p>如下所示则配置完成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085811089.png" /></p>
<h2 id="安装pytorch框架">安装pytorch框架</h2>
<p>查看当前cuda版本和python版本，这两个都会决定要下载的pytorch版本</p>
<p>cuda版本查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117092054384.png" /></p>
<p><a
href="https://github.com/pytorch/vision#installation">python版本对应</a></p>
<p>到<a
href="https://pytorch.org/get-started/previous-versions/">官网</a>下载(下载的版本可以略低与当前CUDA版本),基本上是宁高勿低</p>
<p>查看当前虚拟环境中cuda版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda activate cp36</span><br><span class="line">python</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line">torch.cuda.is_available()   <span class="comment"># cuda是否可用</span></span><br><span class="line">torch.version.cuda          <span class="comment"># cuda版本</span></span><br><span class="line"> </span><br><span class="line">torch.backends.cudnn.is_available()  <span class="comment"># cudnn是否可用</span></span><br><span class="line">torch.backends.cudnn.version()       <span class="comment"># cudnn版本</span></span><br></pre></td></tr></table></figure>
<h2 id="项目同步部署到远程服务器">项目同步部署到远程服务器</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081508016.png" /></p>
<p>新建选择SFTP</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081637151.png" /></p>
<p>便于区分输入项目名称作为新的服务器部署</p>
<p>配置SSH并测试连接</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081834114.png" /></p>
<p>设置项目主文件夹为根路径</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082019469.png" /></p>
<p>因为之前根路径就是项目主目录，所以部署路径是相对于根目录的相对路径</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082555518.png" /></p>
<p>将这个服务器的部署作为默认值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082738866.png" /></p>
<h1 id="读取数据集">读取数据集</h1>
<p><code>datasets.MNIST(...)</code> 返回一个
<code>torchvision.datasets.MNIST</code> 的实例，而
<code>torch.utils.data.DataLoader</code>
则接收这个数据集实例，并使用指定的参数创建一个 <code>DataLoader</code>
实例</p>
<h2
id="利用torch.util.data.dataloader创建dataloader的实例">利用torch.util.data.DataLoader创建DataLoader的实例</h2>
<h3
id="创建一个dataset的实例pytorch框架中已经实现了mnist的set">创建一个dataset的实例(pytorch框架中已经实现了MNIST的set)</h3>
<h4 id="数据集要被存储的根目录">数据集要被存储的根目录</h4>
<h4 id="下载的是训练集还是测试集">下载的是训练集还是测试集</h4>
<h4 id="如果数据集尚未下载是否下载">如果数据集尚未下载，是否下载</h4>
<h4
id="创建对数据集的操作的transform实列一般是必备的两条">创建对数据集的操作的transform实列（一般是必备的两条）</h4>
<h5 id="将数据集里的图片转化为张量">将数据集里的图片转化为张量</h5>
<h5 id="将数据集里的图片归一化">将数据集里的图片归一化</h5>
<h3
id="从数据集里面一次读取的batch_size大小">从数据集里面一次读取的batch_size大小</h3>
<h3
id="每次读取后是否打乱原来的数据集">每次读取后是否打乱原来的数据集</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立训练集</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">	datasets.MNIST(</span><br><span class="line">    	<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">        train = <span class="literal">True</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ]),</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 建立测试集</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">   		train = <span class="literal">False</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="搭建网络">搭建网络</h1>
<h2 id="模板">模板</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConvNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br></pre></td></tr></table></figure>
<p>根据下图搭建</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/lenet-vert.svg" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 第一个卷积层，输入是1个通道（因为输入的是灰度图只有1个通道），输出根据图是6个通道</span></span><br><span class="line">        <span class="comment"># 卷积核大小是5 * 5</span></span><br><span class="line">        self.avgPool = nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)   <span class="comment"># 第一个汇聚层，汇聚层不改变通道数量</span></span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x : 1 * 28 * 28</span></span><br><span class="line">        out = self.conv1(x)     <span class="comment"># 28 - 5 + 2 * 2 + 1 = 28, 6 * 28 * 28</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (28 - 2) / 2 + 1 = 14, 6 * 14 * 14</span></span><br><span class="line">        out = self.conv2(out)   <span class="comment"># 14 - 5 + 1 = 10, 16 * 10 * 10</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (10 - 2) / 2 + 1 = 5, 16 * 5 * 5</span></span><br><span class="line">        out = self.flatten(out)</span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc3(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h1 id="定义训练函数">定义训练函数</h1>
<h2 id="将模型设置为训练模式">将模型设置为训练模式</h2>
<h2
id="利用enumerate遍历dataloader从中获取训练的批次核数据标签数据-标签对">利用enumerate遍历dataloader，从中获取训练的批次核（数据，标签）数据-标签对</h2>
<h2 id="将数据和标签移动到gpu上">将数据和标签移动到GPU上</h2>
<h2 id="梯度清零">梯度清零</h2>
<h2 id="将数据传入模型进行前向传播">将数据传入模型进行前向传播</h2>
<h2 id="计算损失">计算损失</h2>
<h2 id="反向传播">反向传播</h2>
<h2 id="调用优化器更新参数">调用优化器更新参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, label = data.to(device), label.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(batch_idx + <span class="number">1</span>) % <span class="number">30</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="定义测试函数">定义测试函数</h1>
<h2 id="设置模型为评估模式">设置模型为评估模式</h2>
<h2
id="初始化测试损失和正确预测的样本数为零">初始化测试损失和正确预测的样本数为零</h2>
<h2 id="关闭梯度计算">关闭梯度计算</h2>
<h2 id="迭代测试集加载器">迭代测试集加载器</h2>
<h2 id="将输入数据和标签移动到gpu上">将输入数据和标签移动到GPU上</h2>
<h2
id="使用模型进行前向传播得到输出">使用模型进行前向传播，得到输出</h2>
<h2
id="计算交叉熵损失并将损失累加到test_loss中">计算交叉熵损失，并将损失累加到<code>test_loss</code>中</h2>
<p>利用output和对应label之间计算交叉熵损失，并通过取.item()将张量转换成标量</p>
<h2
id="找到每个样本预测的类别即具有最大概率的类别">找到每个样本预测的类别，即具有最大概率的类别。</h2>
<p>通过argmax(dim =
1)获得一行的最大值，也就是这一行表示的数据被预测的类别</p>
<p>argmax函数：获得最大值下标</p>
<p>dim=0时获得的是每一列的最大值的下标</p>
<p>dim=1时获得的是每一行的最大值的下标</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213618509.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213640494.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213723361.png" /></p>
<h2
id="将预测结果与label比较其中正确预测的样本数累加到correct中">将预测结果与label比较，其中正确预测的样本数累加到<code>correct</code>中</h2>
<h2 id="计算平均测试损失">计算平均测试损失</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="完整代码">完整代码</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=<span class="number">512</span> <span class="comment">#大概需要2G的显存</span></span><br><span class="line">EPOCHS=<span class="number">20</span> <span class="comment"># 总共训练批次</span></span><br><span class="line">DEVICE = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>) <span class="comment"># 让torch判断是否使用GPU，建议使用GPU环境，因为会快很多</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 第一个卷积层，输入是1个通道（因为输入的是灰度图只有1个通道），输出根据图是6个通道</span></span><br><span class="line">        <span class="comment"># 卷积核大小是5 * 5</span></span><br><span class="line">        self.avgPool = nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)   <span class="comment"># 第一个汇聚层，汇聚层不改变通道数量</span></span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x : 1 * 28 * 28</span></span><br><span class="line">        out = self.conv1(x)     <span class="comment"># 28 - 5 + 2 * 2 + 1 = 28, 6 * 28 * 28</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (28 - 2) / 2 + 1 = 14, 6 * 14 * 14</span></span><br><span class="line">        out = self.conv2(out)   <span class="comment"># 14 - 5 + 1 = 10, 16 * 10 * 10</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (10 - 2) / 2 + 1 = 5, 16 * 5 * 5</span></span><br><span class="line">        out = self.flatten(out)</span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc3(out)</span><br><span class="line">        out = F.log_softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, label = data.to(device), label.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(batch_idx + <span class="number">1</span>) % <span class="number">30</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据读取</span></span><br><span class="line"><span class="comment"># 建立训练集</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">	datasets.MNIST(</span><br><span class="line">    	<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">        train = <span class="literal">True</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ]),</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 建立测试集</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">   		train = <span class="literal">False</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化网络</span></span><br><span class="line">model = LeNet().to(DEVICE)</span><br><span class="line"><span class="comment">#定义优化器</span></span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, EPOCHS + <span class="number">1</span>):</span><br><span class="line">    train(model, DEVICE, train_loader, optimizer, epoch)</span><br><span class="line">    test(model, DEVICE, test_loader)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>注意力机制</title>
    <url>/posts/141d1667.html</url>
    <content><![CDATA[<h1 id="注意力提示">注意力提示</h1>
<h2 id="查询键和值">查询、键和值</h2>
<p>（参照下图理解定义）</p>
<p>是否包含自主性提示”将注意力机制与全连接层或汇聚层区别开来。
在注意力机制的背景下，自主性提示被称为<em>查询</em>（query）</p>
<p>给定任何查询，注意力机制通过<em>注意力汇聚</em>（attention pooling）
将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。</p>
<p>在注意力机制中，这些感官输入被称为<em>值</em>（value）
更通俗的解释，每个值都与一个<em>键</em>（key）配对，
这可以想象为感官输入的非自主提示。</p>
<p>如下图，可以通过设计注意力汇聚的方式，
便于给定的查询（自主性提示）与键（非自主性提示）进行匹配，
这将引导得出最匹配的值（感官输入）。或者说通过注意力汇聚将<em>查询</em>（自主性提示）和<em>键</em>（非自主性提示）结合在一起，实现对<em>值</em>（感官输入）的选择倾向</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/qkv.svg" /></p>
<h2 id="注意力的可视化">注意力的可视化</h2>
<p>平均汇聚层可以被视为输入的加权平均值， 其中各输入的权重是一样的</p>
<p>实际上，注意力汇聚得到的是加权平均的总和值，
其中权重是在给定的查询和不同的键之间计算得出的。</p>
<p>下图当且仅当查询和键相同时，注意力权重为1，否则为0。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/output_attention-cues_054b1a_36_0.svg" /></p>
<h2 id="注意力汇聚nadaraya-watson-核回归">注意力汇聚：Nadaraya-Watson
核回归</h2>
<p><strong>查询（自主提示）</strong>和<strong>键（非自主提示）</strong>之间的交互形成了<strong>注意力汇聚</strong></p>
<h3 id="非参数注意力汇聚">非参数注意力汇聚</h3>
<p><em>注意力汇聚</em>（attention pooling）公式：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119152405466.png" /></p>
<p>注意力汇聚是输出<span class="math inline">\(y_i\)</span>的加权平均。
将<strong>查询<span class="math inline">\(x\)</span>和键<span
class="math inline">\(x_i\)</span>之间的关系建模为
<em>注意力权重</em>（attention weight）<span
class="math inline">\(\alpha(x,x_i)\)</span></strong>，
<strong>这个权重将被分配给每一个对应值<span
class="math inline">\(y_i\)</span></strong>。 如果一个键<span
class="math inline">\(x_i\)</span>越是接近给定的查询x，
那么分配给这个键对应值<span
class="math inline">\(y_i\)</span>的注意力权重就会越大，
也就“获得了更多的注意力”。</p>
<p>对于任何查询，模型在所有键值对注意力权重都是一个有效的概率分布：
它们是非负的，并且总和为1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">n_train = <span class="number">50</span>  <span class="comment"># 训练样本数</span></span><br><span class="line">x_train, _ = torch.sort(torch.rand(n_train) * <span class="number">5</span>)   <span class="comment"># 排序后的训练样本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * torch.sin(x) + x**<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">y_train = f(x_train) + torch.normal(<span class="number">0.0</span>, <span class="number">0.5</span>, (n_train,))  <span class="comment"># 训练样本的输出</span></span><br><span class="line">x_test = torch.arange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0.1</span>)  <span class="comment"># 测试样本</span></span><br><span class="line">y_truth = f(x_test)  <span class="comment"># 测试样本的真实输出</span></span><br><span class="line">n_test = <span class="built_in">len</span>(x_test)  <span class="comment"># 测试样本数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X_repeat的形状:(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span></span><br><span class="line">X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="number">1</span>, n_train))</span><br><span class="line"><span class="comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span></span><br><span class="line">attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span></span><br><span class="line">y_hat = torch.matmul(attention_weights, y_train)</span><br><span class="line">plot_kernel_reg(y_hat)</span><br></pre></td></tr></table></figure>
<h3 id="带参数注意力汇聚">带参数注意力汇聚</h3>
<p>带参数的模型加入可学习的参数后，
曲线在注意力权重较大的区域变得更不平滑。</p>
<p>在带参数的注意力汇聚模型中，
任何一个训练样本的输入都会和除自己以外的所有训练样本的“键－值”对进行计算，
从而得到其对应的预测输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NWKernelRegression</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        self.w = nn.Parameter(torch.rand((<span class="number">1</span>,), requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values</span>):</span><br><span class="line">        <span class="comment"># queries和attention_weights的形状为(查询个数，“键－值”对个数)</span></span><br><span class="line">        queries = queries.repeat_interleave(keys.shape[<span class="number">1</span>]).reshape((-<span class="number">1</span>, keys.shape[<span class="number">1</span>]))</span><br><span class="line">        self.attention_weights = nn.functional.softmax(</span><br><span class="line">            -((queries - keys) * self.w)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># values的形状为(查询个数，“键－值”对个数)</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.attention_weights.unsqueeze(<span class="number">1</span>),</span><br><span class="line">                         values.unsqueeze(-<span class="number">1</span>)).reshape(-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line"><span class="comment"># X_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输入</span></span><br><span class="line">X_tile = x_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># Y_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输出</span></span><br><span class="line">Y_tile = y_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># keys的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">keys = X_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># values的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">values = Y_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br><span class="line">net = NWKernelRegression()</span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line">animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, xlim=[<span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    trainer.zero_grad()</span><br><span class="line">    l = loss(net(x_train, keys, values), y_train)</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    trainer.step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(l.<span class="built_in">sum</span>()):<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    animator.add(epoch + <span class="number">1</span>, <span class="built_in">float</span>(l.<span class="built_in">sum</span>()))</span><br></pre></td></tr></table></figure>
<h1 id="注意力评分函数">注意力评分函数</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/attention-output.svg" /></p>
<p>高斯核指数部分可以视为<em>注意力评分函数</em>（attention scoring
function）， 简称<em>评分函数</em>（scoring function）</p>
<p>然后把这个函数的输出结果输入到softmax函数中进行运算。
通过上述步骤，将得到与键对应的值的概率分布（即注意力权重）</p>
<p>最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</p>
<p>由于注意力权重是概率分布， 因此加权和其本质上是加权平均值。</p>
<p>softmax操作用于输出一个概率分布作为注意力权重</p>
<h1 id="bahdanau-注意力">Bahdanau 注意力</h1>
<h1 id="自注意力和位置编码">自注意力和位置编码</h1>
<p>每个查询都会关注所有的键－值对并生成一个注意力输出。
由于查询、键和值来自同一组输入，因此被称为
<em>自注意力</em>（self-attention）</p>
<h1 id="transformer">Transformer</h1>
<p>Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源（输入）序列和目标（输出）序列的<em>嵌入</em>（embedding）表示将加上<em>位置编码</em>（positional
encoding），再分别输入到编码器和解码器中。</p>
<p><img src="https://zh.d2l.ai/_images/transformer.svg" /></p>
<p>编码器</p>
<p>从宏观角度来看，Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为sublayer）。第一个子层是<em>多头自注意力</em>（multi-head
self-attention）汇聚；第二个子层是<em>基于位置的前馈网络</em>（positionwise
feed-forward network）。</p>
<p>具体来说，在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出</p>
<p>每个子层都采用了<em>残差连接</em>（residual connection）</p>
<p>在残差连接的加法计算之后，紧接着应用<em>层规范化</em>（layer
normalization）</p>
<p>解码器</p>
<p>由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。</p>
<p>除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<em>编码器－解码器注意力</em>（encoder-decoder
attention）层</p>
<p>在编码器－解码器注意力中，查询来自前一个解码器层的输出，而键和值来自整个编码器的输出。在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。</p>
<p>但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<em>掩蔽</em>（masked）注意力保留了<em>自回归</em>（auto-regressive）属性，确保预测仅依赖于已生成的输出词元。</p>
<h2 id="基于位置的前馈网络">基于位置的前馈网络</h2>
<h2 id="残差连接和层规范化">残差连接和层规范化</h2>
<h2 id="编码器">编码器</h2>
<h2 id="解码器">解码器</h2>
<h1 id="预训练">预训练</h1>
<p><strong>越浅的层学到的特征越通用（横竖撇捺），越深的层学到的特征和具体任务的关联性越强（人脸-人脸轮廓、汽车-汽车轮廓）</strong></p>
<p>上述利用网络上现有图片的思想就是预训练的思想，具体做法就是：</p>
<ol type="1">
<li>通过 ImageNet 数据集我们训练出一个模型 A</li>
<li>由于上面提到 CNN 的浅层学到的特征通用性特别强，我们可以对模型 A
做出一部分改进得到模型 B（两种方法）：
<ol type="1">
<li>冻结：浅层参数使用模型 A
的参数，高层参数随机初始化，<strong>浅层参数一直不变</strong>，然后利用领导给出的
30 张图片训练参数</li>
<li>微调：浅层参数使用模型 A
的参数，高层参数随机初始化，然后利用领导给出的 30
张图片训练参数，<strong>但是在这里浅层参数会随着任务的训练不断发生变化</strong></li>
</ol></li>
</ol>
<p>对于一个具有少量数据的任务 A，首先通过一个现有的大量数据搭建一个 CNN
模型 A，由于 CNN的浅层学到的特征通用性特别强，因此在搭建一个 CNN 模型
B，其中模型 B 的浅层参数使用模型 A 的浅层参数，模型 B
的高层参数随机初始化，然后通过冻结或微调的方式利用任务 A 的数据训练模型
B，模型 B 就是对应任务 A 的模型。</p>
<p>预训练的思想：任务 A 对应的模型 A
的参数不再是随机初始化的，而是通过任务 B 进行预先训练得到模型
B，然后利用模型 B 的参数对模型 A 进行初始化，再通过任务 A 的数据对模型 A
进行训练。</p>
<p>注：模型 B 的参数是随机初始化的。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>现代卷积神经网络</title>
    <url>/posts/d17cd37c.html</url>
    <content><![CDATA[<h1 id="深度卷积神经网络alexnet">深度卷积神经网络AlexNet</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/alexnet.svg" /></p>
<h2 id="组成">组成</h2>
<ol type="1">
<li>AlexNet比相对较小的LeNet5要深得多。AlexNet由八层组成：五个卷积层、两个全连接隐藏层和一个全连接输出层。</li>
<li>AlexNet使用ReLU而不是sigmoid作为其激活函数</li>
<li>通过暂退法控制全连接层的模型复杂度</li>
</ol>
<h1 id="vgg网络">VGG网络</h1>
<h2 id="组成-1">组成</h2>
<p>经典卷积神经网络的基本组成部分是下面的这个序列：</p>
<ol type="1">
<li>带填充以保持分辨率的卷积层；</li>
<li>非线性激活函数，如ReLU；</li>
<li>汇聚层，如最大汇聚层。</li>
</ol>
<p>VGG网络可以分为两部分：</p>
<p>第一部分主要由卷积层和汇聚层组成</p>
<p>第二部分由全连接层组成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/vgg.svg" /></p>
<p>VGG神经网络连接
的几个VGG块（在<code>vgg_block</code>函数中定义）。其中有超参数变量<code>conv_arch</code>。该变量指定了每个VGG块里卷积层个数和输出通道数。</p>
<p>如下是一种VGG11网络</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1375095-20210521111000341-99893785.png" /></p>
<h2
id="运用在前向传播的过程中从之前层的拼接变成块的拼接">运用：在前向传播的过程中从之前层的拼接变成块的拼接</h2>
<p>就是常常用如下写法将卷积层，激活函数，池化层放到一个块中，全连接层，激活函数，Dropout函数放到另一个层，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">self.block1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(in_channel, out_channel, kernel_size),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size)</span><br><span class="line">)</span><br><span class="line">self.block2 = nn.Sequential(</span><br><span class="line">    nn.Linear(in_features, out_features),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Dropout2d(<span class="number">0.5</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="网络中的网络nin">网络中的网络NiN</h1>
<h2 id="设计思想">设计思想</h2>
<p>1.NiN的想法是在每个像素位置（针对每个高度和宽度）应用一个全连接层</p>
<p>2.将空间维度中的每个像素视为单个样本，将通道维度视为不同特征（feature）。</p>
<h2 id="组成-2">组成</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/nin.svg" /></p>
<h3 id="卷积块nin设计">卷积块NiN设计</h3>
<ol type="1">
<li><p>NiN块以一个普通卷积层开始，后面是两个1×1的卷积层。这两个1×1卷积层充当带有ReLU激活函数的逐像素全连接层。
第一层的卷积窗口形状通常由用户设置。
随后的卷积窗口形状固定为1×1。</p></li>
<li><p>上面这样的块设计三个，每个块的第一个卷积层窗口形状为11×11、5×5和3×3</p></li>
<li><p>每个NiN块后有一个最大汇聚层，汇聚窗口形状为3×3，步幅为2。</p></li>
</ol>
<h3 id="取消全连接层的替代设计">取消全连接层的替代设计</h3>
<ol type="1">
<li><p>NiN完全取消了全连接层，使用一个NiN块，其输出通道数等于标签类别的数量</p></li>
<li><p>通过一个<em>全局平均汇聚层</em>（global average pooling
layer），生成一个对数几率 （logits）</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, strides, padding</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU())</span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标签类别数是10</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span></span><br><span class="line">    nn.Flatten())</span><br></pre></td></tr></table></figure>
<h1 id="含并行连结的网络googlenet">含并行连结的网络（GoogLeNet）</h1>
<p>吸收了NiN中串联网络的思想，并在此基础上做了改进</p>
<p>解决了什么样大小的卷积核最合适的问题</p>
<h2 id="组成-3">组成</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/inception-full.svg" /></p>
<h3 id="卷积块inception块">卷积块Inception块</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/inception.svg" /></p>
<ol type="1">
<li><p>由四条并行路径组成</p></li>
<li><p>前三条路径使用窗口大小为1×1、3×3和5×5的卷积层，从不同空间大小中提取信息，其中1×1卷积层直接接到通道合并层，3×3和5×5的卷积层是先在输入上执行1×1卷积，以减少通道数，从而降低模型的复杂性，然后再分别接上，最后接到合并层</p></li>
<li><p>第四条路径使用3×3最大汇聚层，然后使用1×1卷积层来改变通道数</p></li>
<li><p>这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出</p></li>
</ol>
<p>注：通常调整的超参数是每层输出通道数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module):</span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 线路1，单1x1卷积层</span></span><br><span class="line">        self.p1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c1, kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        self.p2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>),	<span class="comment">#c2[0]表示这一路1 x 1层的输出，也是3 x 3层的输入 	</span></span><br><span class="line">            nn.Conv2d(c2[<span class="number">0</span>], c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),	<span class="comment">#c2[0]表示这一路3 x 3层的输出</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        self.p3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.Conv2d(c3[<span class="number">0</span>], c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        self.p4 = nn.Sequential(</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.Conv2d(in_channels, c4, kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 在通道维度上连结输出</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="其他块">其他块</h3>
<h4 id="b1">b1</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091329812.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b2">b2</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091422012.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b2 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b3">b3</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091547062.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b3 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">192</span>, <span class="number">64</span>, (<span class="number">96</span>, <span class="number">128</span>), (<span class="number">16</span>, <span class="number">32</span>), <span class="number">32</span>),</span><br><span class="line">    Inception(<span class="number">256</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">192</span>), (<span class="number">32</span>, <span class="number">96</span>), <span class="number">64</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b4">b4</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091624806.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b4 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">480</span>, <span class="number">192</span>, (<span class="number">96</span>, <span class="number">208</span>), (<span class="number">16</span>, <span class="number">48</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">160</span>, (<span class="number">112</span>, <span class="number">224</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">256</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">112</span>, (<span class="number">144</span>, <span class="number">288</span>), (<span class="number">32</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">528</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b5">b5</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091759065.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">b5 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">384</span>, (<span class="number">192</span>, <span class="number">384</span>), (<span class="number">48</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">1024</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="残差网络resnet">残差网络（ResNet）</h1>
<p>## 组成</p>
<h3 id="残差块">残差块</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/residual-block.svg" /></p>
<h4 id="基本定义">基本定义：</h4>
<ol type="1">
<li><p>假设我们的原始输入为x，而希望学出的理想映射为f(x),上图左图虚线框中的部分需要直接拟合出该映射f(x)，而右图虚线框中的部分则需要拟合出残差映射f(x)
- x</p></li>
<li><p>在残差块中，输入可通过跨层数据线路更快地向前传播</p></li>
</ol>
<h4 id="组成-4">组成</h4>
<h5 id="基本结构">基本结构</h5>
<ol type="1">
<li><p>残差块里首先有2个有相同输出通道数的3×3卷积层。
每个卷积层后接一个批量规范化层和ReLU激活函数,然后通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前</p></li>
<li><p>要求2个卷积层的输出与输入形状一样，从而使它们可以相加</p></li>
</ol>
<h5 id="改变通道数">改变通道数</h5>
<p>通过引入一个额外的1×1卷积层来将输入变换成需要的形状（另一条正常计算的路已经改变通道数了）后再做相加运算</p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels, use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.block1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(input_channels, num_channels,kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(num_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = self.block1(X)</span><br><span class="line">        Y = self.block2(Y)</span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure>
<p>生成两种类型的网络：
一种是当<code>use_1x1conv=False</code>时，应用ReLU非线性函数之前，将输入添加到输出。
另一种是当<code>use_1x1conv=True</code>时，添加通过1×1卷积调整通道和分辨率。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/resnet-block.svg" /></p>
<h3 id="其他块以resnet-18为例">其他块(以ResNet-18为例)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/resnet18.svg" /></p>
<h4 id="b1-1">b1</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119105305392.png" /></p>
<p>前两层在输出通道数为64、步幅为2的7×7卷积层后接批量规范化层，再接步幅为2的3×3的最大汇聚层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.BatchNorm2d(<span class="number">64</span>), </span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b2-b3-b4-b5">b2, b3, b4, b5</h4>
<p>使用4个由残差块组成的模块，</p>
<p>每个模块使用若干个残差块构成（下面举的例子是2个）。</p>
<p>第一个模块的通道数同输入通道数一致。
因为之前已经使用了步幅为2的最大汇聚层，所以无须减小高和宽。
之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="comment"># 第一个模块（b2）的resnet块我们不进行高宽减半、通道翻倍，不然减太多了</span></span><br><span class="line">        <span class="comment"># 如果不是第一个模块，就在该模块第一个resnet块进行一次高宽减半通道加倍操作,因此要用1x1conv处理变换残差项X       </span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block: <span class="comment"># i为bx模块中的第i个残差块，first_block表示为b2模块</span></span><br><span class="line">            blk.append(Residual(input_channels, num_channels, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line">self.b2 = nn.Sequential(resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">self.b3 = nn.Sequential(resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">self.b4 = nn.Sequential(resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">self.b5 = nn.Sequential(resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>在ResNet中加入全局平均汇聚层，以及全连接层输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>完整残差网络实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels, use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.block1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(num_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = self.block1(X)</span><br><span class="line">        Y = self.block2(Y)</span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet18</span>(nn.Module):</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span><br><span class="line">        blk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">                blk.append(Residual(input_channels, num_channels, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                blk.append(Residual(num_channels, num_channels))</span><br><span class="line">        <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet18, self).__init__()</span><br><span class="line">        self.b1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>), </span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.b2 = nn.Sequential(*self._resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">        self.b3 = nn.Sequential(*self._resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">        self.b4 = nn.Sequential(*self._resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">        self.b5 = nn.Sequential(*self._resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br><span class="line">        self.last = nn.Sequential(</span><br><span class="line">            nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            nn.Flatten(), </span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.b1(x)</span><br><span class="line">        output = self.b2(output)</span><br><span class="line">        output = self.b3(output)</span><br><span class="line">        output = self.b4(output)</span><br><span class="line">        output = self.b5(output)</span><br><span class="line">        output = self.last(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习中过拟合和欠拟合及其解决方法</title>
    <url>/posts/807ee252.html</url>
    <content><![CDATA[<h1 id="专有名词解释">专有名词解释</h1>
<h2
id="用于对抗过拟合的技术称为正则化">用于对抗过拟合的技术称为<em>正则化</em></h2>
<h2 id="训练误差training-error"><em>训练误差</em>（training error）</h2>
<p>模型在训练数据集上计算得到的误差</p>
<h2 id="泛化误差generalization-error"><em>泛化误差</em>（generalization
error）</h2>
<p>模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。实际中，我们只能通过将模型应用于一个独立的测试集来估计泛化误差，
该测试集由随机选取的、未曾在训练集中出现的数据样本构成</p>
<span id="more"></span>
<h1 id="解决方法">解决方法</h1>
<h2 id="k折交叉验证">K折交叉验证</h2>
<p>原始训练数据被分成k个不重叠的子集。
然后执行k次模型训练和验证，每次在k−1个子集上进行训练，
并在剩余的一个子集（在该轮中没有用于训练的子集）上进行验证。
最后，通过对k次实验的结果取平均来估计训练和验证误差。</p>
<h2
id="应用最广泛的解决过拟合的正则化方法权重衰减">应用最广泛的解决过拟合的正则化方法：权重衰减</h2>
<p>通常也被称为L2<em>正则化</em></p>
<p>L2正则化线性模型构成经典的<em>岭回归</em>（ridge regression）算法</p>
<p>使用L2范数的一个原因是它对权重向量的大分量施加了巨大的惩罚。
这使得我们的学习算法偏向于在大量特征上均匀分布权重的模型</p>
<h2 id="暂退法dropout">暂退法(Dropout)</h2>
<h3 id="定义">定义</h3>
<p>在前向传播过程中，计算每一内部层的同时注入噪声</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116143311841.png" /></p>
<h3 id="应用">应用</h3>
<p>可以将暂退法应用于每个隐藏层的输出（在激活函数之后）），
并且可以为每一层分别设置暂退概率</p>
<p>常见的技巧是在靠近输入层的地方设置较低的暂退概率</p>
<p>对于深度学习框架的高级API，我们只需在每个全连接层之后添加一个<code>Dropout</code>层，
将暂退概率作为唯一的参数传递给它的构造函数。
在训练时，<code>Dropout</code>层将根据指定的暂退概率随机丢弃上一层的输出（相当于下一层的输入）。
在测试时，<code>Dropout</code>层仅传递数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">        nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout1),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout2),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<h2 id="批量规范化">批量规范化</h2>
<h3 id="基本原理">基本原理</h3>
<p>在每次训练迭代中，我们首先规范化输入，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。
接下来，我们应用比例系数和比例偏移。</p>
<h3 id="批量规范化层">批量规范化层</h3>
<h4 id="全连接层">全连接层</h4>
<p>将批量规范化层置于全连接层中的仿射变换和激活函数之间</p>
<h4 id="卷积层">卷积层</h4>
<p>在卷积层之后和非线性激活函数之前应用批量规范化</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), </span><br><span class="line">    BatchNorm(<span class="number">6</span>, num_dims=<span class="number">4</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    </span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), </span><br><span class="line">    BatchNorm(<span class="number">16</span>, num_dims=<span class="number">4</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), </span><br><span class="line">    </span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">120</span>), </span><br><span class="line">    BatchNorm(<span class="number">120</span>, num_dims=<span class="number">2</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    </span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), </span><br><span class="line">    BatchNorm(<span class="number">84</span>, num_dims=<span class="number">2</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>自动编码器</title>
    <url>/posts/8ed365e4.html</url>
    <content><![CDATA[<h1 id="自动编码器特点">自动编码器特点</h1>
<p>1
跟数据相关程度很高，这意味着自动编码器只能压缩与训练数据相似的数据</p>
<p>2 压缩后数据是有损的</p>
<h1 id="自动编码器的构成">自动编码器的构成</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-e627f25d4e5766c8876ef6251291c3b8_r.jpg" /></p>
<p>第一个部分是编码器（Encoder），第二个部分是解码器（Decoder），编码器和解码器都可以是任意的模型，通常使用神经网络作为编码器和解码器</p>
<h1 id="自动编码器应用">自动编码器应用</h1>
<p>1 <strong>数据去噪</strong></p>
<p>噪声是测量中的随机误差或偏差，包括错误值或者偏离期望的孤立点。简单来说就是对任务或者模型没有帮助甚至有误导作用的数据。</p>
<p>编码器通过学习将潜在空间中的尽可能多的相关信息保留，丢弃不相关部分（噪声）。</p>
<p>解码器学习潜在空间信息重建与输入一致的，这样就达到了去噪。</p>
<p>2 <strong>可视化降维</strong></p>
<p>设置合适的维度和稀疏约束，自编码器可以学习到比PCA等技术更有意思的数据投影。因为自编码属于无监督学习，所以只需要训练数据就可以得到较好的特征</p>
<p>3 <strong>特征提取</strong></p>
<p>自动编码器学习到的特征h，可以作为有监督模型的输入，这样就起到了特征提取器的作用。</p>
<h1
id="自动编码器对深层网络分层训练的过程">自动编码器对深层网络分层训练的过程</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-986dfffa005ff2b3fae2d88e928d5e03_720w.webp" /></p>
<p>传递到一层，先通过这层的encode编码，再通过decode解码，将解码出来的结果output与原始input比较，相似到某种程度(专业点就是重构误差最小)，这时候可以将这一层的output传递作为下一层的input，否则继续调整参数，每一层操作都类似</p>
<h1
id="几种自动编码器基于pytorch的实现">几种自动编码器基于pytorch的实现</h1>
<h2 id="基于全连接层的实现">基于全连接层的实现</h2>
<h3 id="特点">特点</h3>
<p>1 上一层的输出通道等于下一层的输入</p>
<p>2 解码器正好与编码器对称</p>
<p>3 损失函数：均方误差损失函数
<code>nn.MSELoss()</code>，而不是交叉熵损失。这是因为自动编码器的任务是重建输入数据，而不是进行分类。</p>
<p>4 图片保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;&#125;, loss is &#123;&#125;&quot;</span>.<span class="built_in">format</span>((epoch+<span class="number">1</span>), loss.data))</span><br><span class="line">    pic = to_img(output.cpu().data)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./simple_autoencoder&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./simple_autoencoder&#x27;</span>)</span><br><span class="line">    save_image(pic, <span class="string">&#x27;./simple_autoencoder/image_&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><code>to_img(output.cpu().data)</code>
将模型输出转换成图像格式，然后通过 <code>save_image</code>
函数将这个batch的图像拼接保存到一个文件中，文件名包含了该周期的信息。这样，就可以观察到每5个周期训练过程中模型生成的图像重建效果。</p>
<p>4 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122175827883.png" /></p>
<h3 id="代码">代码</h3>
<h2 id="基于卷积神经网络的实现">基于卷积神经网络的实现</h2>
<h3 id="特点-1">特点</h3>
<p>反卷积</p>
<p>1
卷积神经网络相对于全连接的实现要自由得多，<strong>解码器</strong>只需要在<strong>第一层反卷积输入通道数</strong>等于<strong>编码器最后一层卷积输出通道数</strong>，<strong>解码器最后一层反卷积输出通道数</strong>等于<strong>编码器第一层卷积输入通道数</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123081036211.png" /></p>
<p>2 计算公式</p>
<p>解码器前面可以随便浪，但最后一层一定要将图片恢复到原来输入的样子，不仅包括通道，还有宽和高</p>
<p>常用公式的简化版本</p>
<p><span class="math inline">\(图像输出尺寸 = (图像输入尺寸 - 1) × 步长
- 2 × 填充 + 卷积核大小\)</span></p>
<h3 id="代码-1">代码</h3>
<h2 id="变分自动编码器">变分自动编码器</h2>
<h3 id="特点-2">特点</h3>
<p>一般的编码器只能“一对一”，给它什么它就会尽可能解码出什么</p>
<p>变分自动编码器通过给它一个标准正态分布的随机隐含向量，通过解码器就能够生成想要的图片，而不需要先给它一张原始图片编码。</p>
<p>在实际情况中，需要在模型的准确率和隐含向量服从标准正态分布之间做一个权衡，所谓模型的准确率就是指解码器生成的图片与原始图片的相似程度。可以让神经网络自己做这个决定，只需要将两者都做一个loss，然后求和作为总的loss，这样网络就能够自己选择如何做才能使这个总的loss下降</p>
<p>另外要衡量两种分布的相似程度，需要引入一个新的概念，KL
divergence，这是用来衡量两种分布相似程度的统计量，它越小，表示两种概率分布越接近。</p>
<p>本质上VAE就是在encoder的结果添加了高斯噪声，通过训练要使得decoder对噪声有一定的鲁棒性，这样的话我们生成一张图片就没有必须用一张图片先做编码了，可以想象，我们只需要利用训练好的encoder对一张图片编码得到其分布后，符合这个分布的隐含向量理论上都可以通过decoder得到类似这张图片的图片。</p>
<p>n.MSE()函数，需要声明的是nn.MSE(reduction='sum')求的是每个batchsize上的loss值，最后除以batchsize就可以得到每个输入的loss均值；nn.MSE(reduction='mean')求的是所有元素的均值，而非每个输入的均值，因为每个输入是28<em>28的向量，使用nn.MSE(reduction='mean')计算出来的是nn.MSE(reduction='sum')/(784
</em> batchsize)。所以我们这里用的是nn.MSE(reduction='sum'。)</p>
<h3 id="代码-2">代码</h3>
<p><a
href="https://zhuanlan.zhihu.com/p/34998569">关于VAE的详细解释</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/67742390">参考文章</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>高斯模糊</title>
    <url>/posts/a45cef5f.html</url>
    <content><![CDATA[<h1 id="滤波">滤波</h1>
<p>1 滤波是对输入信号进行卷积处理的一个过程，分两步 1.1
<strong>计算掩膜</strong></p>
<p>1.2
将计算出的掩膜与原图<strong>卷积</strong>——掩膜上每一个位置的值和图像上对应位置的像素值的乘加运算</p>
<p>2 <strong>卷积模板/掩膜
的不同决定了不同的滤波方式</strong>，也因此产生了高通、低通、带通、带阻等基本的滤波方式。</p>
<p>低通滤波，就是保留将信号中的低频部分，抑制高频部分。要达到这个目的，可以利用均值掩膜、<a
href="https://www.zhihu.com/search?q=高斯掩膜&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142137732%7D">高斯掩膜</a>等对输入信号进行处理。
采用均值掩膜对输入信号进行卷积的滤波方式叫<a
href="https://www.zhihu.com/search?q=均值滤波&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142137732%7D">均值滤波</a>；
采用高斯掩膜对输入信号进行卷积的滤波方式叫高斯滤波；</p>
<p>举个例子：<strong>均值掩膜</strong></p>
<p>3x3均值滤波的掩膜：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-2924c99c9034c212da82d089991efd8c_720w.webp" /></p>
<p>均值掩膜内所有<strong>系数均相等</strong>——为1/9，且他们的<strong>和为1</strong></p>
<h1
id="高斯滤波高斯滤波和高斯模糊指的是一个操作">高斯滤波（高斯滤波和高斯模糊指的是一个操作）</h1>
<h2 id="高斯分布">高斯分布</h2>
<p>正态分布,<span
class="math inline">\(\mu\)</span>决定了分布对称中心，<span
class="math inline">\(\sigma\)</span>决定了分布的形状——越小形状越瘦高，越大越矮胖</p>
<h3
id="作用计算高斯滤波用的掩膜mask">作用:<strong>计算高斯滤波用的掩膜(Mask)</strong></h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-0f390685117a9510871e3c241ce76d8a_720w.webp" /></p>
<h3 id="如何利用高斯分布求掩膜">如何利用高斯分布求掩膜</h3>
<p><em>高斯分布公式是一维的，但掩膜是二维的怎么办？</em>
很简单，只需要<strong>把数值<span
class="math inline">\(x\)</span>变为向量<span
class="math inline">\(\vec{x}\)</span>即可</strong>：</p>
<p><span class="math inline">\(\vec{x}\)</span>表示一个点的坐标</p>
<p><span
class="math inline">\(\vec{u}\)</span>表示这个mask中心的坐标</p>
<p>举例说明</p>
<p>对于图像中任意一点(x,y)，它周围的坐标为：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-177899f81dea69abe4f6bc7f818a4da8_720w.webp" /></p>
<h4 id="遍历所有点与均值做差后平方">遍历所有点与均值做差后平方</h4>
<p>中间的(x,y)就是<span class="math inline">\(\vec{u}\)</span>了，
当<span class="math inline">\(\vec{x}\)</span>遍历图中所有点时,计算<span
class="math inline">\((\vec{x}-\vec{u})^2\)</span>，其中x和y被消除，得到下面</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-c45553599da9cf3f2a5a612c3107ac9b_720w.webp" /></p>
<h4 id="带入正态分布公式">带入正态分布公式</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-b39cae58ca1a5f39c46ac5ba918787f5_720w.webp" /></p>
<h4 id="归一化">归一化</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-0d1b6a4c714641309b05a89343425cac_720w.webp" /></p>
<p><strong>利用高斯掩膜和图像进行卷积求解高斯模糊</strong></p>
<p>如下图所示，没有别的，就是卷积</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-87320686a30a2d0f682c144436e54704_720w.webp" /></p>
<p><a
href="https://www.zhihu.com/question/54918332/answer/142137732">参考文章</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>自建数据集完成二分类任务</title>
    <url>/posts/8f9c7cbf.html</url>
    <content><![CDATA[<h1 id="自建数据集完成二分类任务参考文章">自建数据集完成二分类任务（<a
href="https://zhuanlan.zhihu.com/p/466699075">参考文章</a>）</h1>
<h2 id="图片预处理">1 图片预处理</h2>
<h3 id="统一图片格式">1 .1 统一图片格式</h3>
<p><strong>找到的图片需要首先做相同尺寸的裁剪，归一化</strong>，否则会因为图片大小不同报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RuntimeError: stack expects each tensor to be equal size,</span><br><span class="line">but got [3, 667, 406] at entry 0 and [3, 600, 400] at entry 1</span><br></pre></td></tr></table></figure>
<p>pytorch的<code>torchvision.transforms</code>模块提供了许多用于图片变换/增强的函数。</p>
<h4 id="把图片压缩为固定大小">1.1.1 把图片压缩为固定大小</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.Resize((600,600)),</span><br></pre></td></tr></table></figure>
<h4 id="裁剪保留核心区">1.1.2 裁剪保留核心区</h4>
<p>因为主体要识别的图像一般在中心位置，所以使用<code>CenterCrop</code>，这里设置为（400，
400）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.CenterCrop((400,400)),</span><br></pre></td></tr></table></figure>
<h4 id="处理成统一数据类型">1.1.3 处理成统一数据类型</h4>
<p>这里统一成<code>torch.float64</code>方便神经网络计算,也可以统一成其他比如uint32等类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.ConvertImageDtype(torch.float64),</span><br></pre></td></tr></table></figure>
<h4 id="归一化进一步缩小图片范围">1.1.4 归一化进一步缩小图片范围</h4>
<p>对于图片来说<code>0~255</code>的范围有点大，并不利于模型梯度计算，我们应该进行归一化。pytorch当中也提供了归一化的函数<code>torchvision.transforms.Normalize(mean,std)</code>，</p>
<ul>
<li>我们可以使用<code>[0.5,0.5,0.5]</code>的<code>mean,std</code>来把数据归一化至<code>[-1,1]</code></li>
<li>也可以手动计算出所有的图片<code>mean,std</code>来归一化至均值为0，标准差为1的正态分布，</li>
<li>一些深度学习代码常常使用<code>mean=[0.485, 0.456, 0.406]</code>
,<code>std=[0.229, 0.224, 0.225]</code>的归一化数据，这是在<code>ImageNet</code>的几百万张图片数据计算得出的结果</li>
<li><code>BN</code>等方法也具有很出色的归一化表现，我们也会使用到</li>
</ul>
<blockquote>
<p><a
href="https://zhuanlan.zhihu.com/p/33173246">Juliuszh：详解深度学习中的Normalization，BN/LN/WN</a>
<a
href="https://zhuanlan.zhihu.com/p/93643523">Algernon：【基础算法】六问透彻理解BN(Batch
Normalization）</a></p>
</blockquote>
<p>我们这里使用简单的<code>[0.5,0.5,0.5]</code>归一化方法，更新<code>cls_dataset</code>,加入<code>transform</code>操作
，作为图片裁剪的预处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.Normalize([0.5,0.5,0.5],[0.5,0.5,0.5])</span><br></pre></td></tr></table></figure>
<p>关于<code>transforms</code>的操作大体分为裁剪/翻转和旋转/图像变换/transform自身操作，具体见<a
href="https://zhuanlan.zhihu.com/p/53367135">余霆嵩：PyTorch
学习笔记（三）：transforms的二十二个方法</a>，这里不进行详细展开。</p>
<h3 id="数据增强">1.2 数据增强</h3>
<p>当数据集较小时，可以通过对已有图片做数据增强，利用之前提到的<code>transforms</code>中的函数
，也可以混合使用来<strong>根据已有数据创造新数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.data_enhancement = transforms.Compose([</span><br><span class="line">    transforms.RandomHorizontalFlip(p=<span class="number">1</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">30</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="创建自制数据集">2 创建自制数据集</h2>
<h3 id="以dataset类接口为模版">2.1 以Dataset类接口为模版</h3>
<h4 id="构造函数__init__self">构造函数__init__(self)</h4>
<p>用于初始化对象。在这个方法中，可以进行一些必要的设置和准备工作，例如加载数据、指定数据集路径等
#### <strong>getitem</strong>(self, index) Dataset
类的一个必须实现的方法。在这个方法中，需要实现如何从数据集中获取数据和标签，并以返回数据样本(feature)对应的标签(label)。
#### <strong>len</strong>(self) Dataset
类的一个必须实现的方法。它用于返回数据集中样本的总数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.util.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cls_dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">       <span class="comment"># initialization</span></span><br><span class="line">      。</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># return data,label in set </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return the length of the dataset</span></span><br></pre></td></tr></table></figure>
<h3 id="创建set">2.2 创建set</h3>
<h4
id="定义两个空列表data_list和target_list">2.2.1定义两个空列表data_list和target_list</h4>
<h4 id="遍历文件夹">2.2.2遍历文件夹</h4>
<h4
id="读取图片对象对每一个图片对象预处理后分别将图片对象和对应的标签加入data_list和target_list中">2.2.3读取图片对象，对每一个图片对象预处理后，分别将图片对象和对应的标签加入data_list和target_list中</h4>
<h4
id="将data_list和target_list加入h5dfile中">2.2.4将data_list和target_list加入h5dfile中</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">from</span> torchvision.io <span class="keyword">import</span> read_image</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bird_flower_dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path, train_dataset_path, test_dataset_path</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.labels = [<span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;flower&#x27;</span>]</span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.train_dataset_path = train_dataset_path</span><br><span class="line">        self.test_dataset_path = test_dataset_path</span><br><span class="line">        <span class="comment"># 如果保存数据集的文件不存在,就创建这个文件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">            self._create_h5_file(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 如果对应下标的label是bird，返回的label是一维张量0，反之返回1</span></span><br><span class="line">            <span class="keyword">if</span> f[<span class="string">&#x27;label&#x27;</span>][index].decode() == <span class="string">&quot;bird&quot;</span>:</span><br><span class="line">                label = torch.tensor(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label = torch.tensor(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> f[<span class="string">&#x27;image&#x27;</span>][index], label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(f[<span class="string">&#x27;label&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果文件不存在，就创建文件的静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_create_h5_file</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 定义转换图片格式的轨道</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">600</span>, <span class="number">600</span>)),</span><br><span class="line">                transforms.CenterCrop((<span class="number">400</span>, <span class="number">400</span>)),</span><br><span class="line">                transforms.ConvertImageDtype(torch.float64),    <span class="comment"># 这行代码的作用是将图片像素点的数据类型转换为double（float64就是double）</span></span><br><span class="line">                transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">            ])</span><br><span class="line">            <span class="comment"># 创建保存图片的列表</span></span><br><span class="line">            img_list = []</span><br><span class="line">            <span class="comment"># 创建保存每个index对应图片的label</span></span><br><span class="line">            label_list = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断是训练集还是测试集, 因为数据集文件名称要么是train.hdf5,要么是test.hdf5</span></span><br><span class="line">            dataset_kind = self.file_path.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> dataset_kind == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                dataset_path = self.train_dataset_path</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dataset_path = self.test_dataset_path</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                文件夹组成</span></span><br><span class="line"><span class="string">                | —— train</span></span><br><span class="line"><span class="string">                |   | —— flower</span></span><br><span class="line"><span class="string">                |   |   | —— 图片1</span></span><br><span class="line"><span class="string">                |   | —— bird</span></span><br><span class="line"><span class="string">                |   | —— | —— 图片2</span></span><br><span class="line"><span class="string">                | —— test</span></span><br><span class="line"><span class="string">                |   | —— flower</span></span><br><span class="line"><span class="string">                |   | —— bird</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历数据集</span></span><br><span class="line">            <span class="keyword">for</span> directory, _, images <span class="keyword">in</span> tqdm(os.walk(dataset_path)):</span><br><span class="line">                label = directory.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">                    img = read_image(os.path.join(directory, img))  <span class="comment">#以张量形式读取图片对象</span></span><br><span class="line">                    img = transform(img)    <span class="comment">#预处理图片</span></span><br><span class="line">                    img = np.array(img).astype(np.float64)  <span class="comment"># 这里的作用也是呼应之前转为64位</span></span><br><span class="line">                    img_list.append(img)    <span class="comment">#将图片对象添加到列表里</span></span><br><span class="line">                    label_list.append(label.encode())   <span class="comment">#将label编码后添加到列表里</span></span><br><span class="line">            f.create_dataset(<span class="string">&quot;image&quot;</span>, data=img_list)</span><br><span class="line">            <span class="comment"># 在一个 HDF5 文件中创建了一个名为 &quot;image&quot; 的数据集，并将 data_list 中的数据作为该数据集的内容</span></span><br><span class="line">            f.create_dataset(<span class="string">&quot;label&quot;</span>, data=label_list)</span><br><span class="line">            <span class="comment"># 在同一个HDF5文件中创建了一个名为 &quot;label&quot; 的数据集，并将 label_list 中的数据作为该数据集的内容，并且该数据集在index相同时与前面 data_list 是一一对应</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/微信图片_20231115173321.jpg" /></p>
<h3 id="创建loader">2.3 创建loader</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义加载训练集的loader</span></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    bird_flower_dataset(<span class="string">&quot;train.hdf5&quot;</span>, train_set_path, test_set_path),</span><br><span class="line">    batch_size=<span class="number">4</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定义加载测试集的loader</span></span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    bird_flower_dataset(<span class="string">&quot;test.hdf5&quot;</span>, train_set_path, test_set_path),</span><br><span class="line">    batch_size=<span class="number">4</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="搭建网络">3 搭建网络</h2>
<h3 id="网络结构">网络结构</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231115172005.jpg" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">conv_net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">16</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(in_features=<span class="number">64</span> * <span class="number">98</span> * <span class="number">98</span>, out_features=<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(in_features=<span class="number">500</span>, out_features=<span class="number">2</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__forward__</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.conv1(x)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.maxpool(output)</span><br><span class="line">        output = self.conv2(output)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.maxpool(output)</span><br><span class="line">        output = self.flatten(output)</span><br><span class="line">        output = self.fc1(output)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.fc2(output)</span><br><span class="line">        <span class="keyword">return</span>  output</span><br></pre></td></tr></table></figure>
<h2 id="训练与测试">4 训练与测试</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 这里将data加载到device前需要将其数据用type(torch.FloatTensor)自适应为网络可以接受的数据类型</span></span><br><span class="line">        data, label = data.<span class="built_in">type</span>(torch.FloatTensor).to(DEVICE), label.to(DEVICE)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.<span class="built_in">type</span>(torch.FloatTensor).to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="保存模型">5 保存模型</h2>
<h3 id="训练好后保存模型">训练好后保存模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在训练完成,导出保存的模型，测试</span></span><br><span class="line">model = ConvNet().to(DEVICE)</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">f&#x27;model_weights/best_model.pth&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="使用之前保存好的模型">使用之前保存好的模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载并预处理测试图像</span></span><br><span class="line">test_image = load_and_preprocess_image(test_image_path)</span><br><span class="line"><span class="comment"># 利用训练好的模型进行预测</span></span><br><span class="line">prediction = predict_single_image(model, test_image, DEVICE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>第一章</title>
    <url>/posts/b2041fc0.html</url>
    <content><![CDATA[<h1 id="信息就是位上下文">信息就是位+上下文</h1>
<p>8个位成一组，称为字节。每个字节表示程序中</p>
]]></content>
  </entry>
  <entry>
    <title>实验三-进程通信</title>
    <url>/posts/e62e4f7b.html</url>
    <content><![CDATA[<h1 id="pipe">pipe</h1>
<span id="more"></span>
<p>创建管道要在创建子进程之前</p>
<h2 id="创建管道">创建管道</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">pipe(fd);</span><br></pre></td></tr></table></figure>
<p>其中fd[1]用来往管道里写，fd[1]用来向管道中读</p>
<h2 id="向管道中写">向管道中写</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(fd1[<span class="number">1</span>], inLine, LENGTH);</span><br></pre></td></tr></table></figure>
<p>fd[1]表示现在是写，inLine是写入管道字符串的字符数组，LENGTH是写入的长度（一般和写入的长度相同）</p>
<h2 id="从管道中读">从管道中读</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read(fd2[0], outLine, LENGTH);</span><br></pre></td></tr></table></figure>
<p>fd2[0]表示现在是读，outLine是从保存从管道中读取的字符数组，LENGTH是从管道中读取的长度</p>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> outLine[LENGTH];</span><br><span class="line">    <span class="type">int</span> fd2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> inLine[LENGTH];</span><br><span class="line">    pipe(fd1);</span><br><span class="line">    <span class="type">pid_t</span> p1 = fork();</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create p1 failed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(inLine, <span class="string">&quot;Child 1 is sending a message!&quot;</span>);</span><br><span class="line">        write(fd1[<span class="number">1</span>], inLine, LENGTH);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fd1[<span class="number">0</span>], outLine, LENGTH);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, outLine);</span><br><span class="line">        pipe(fd2);</span><br><span class="line">        <span class="type">pid_t</span> p2 = fork();</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create p2 failed\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(inLine, <span class="string">&quot;Child 2 is sending a message!&quot;</span>);</span><br><span class="line">            write(fd2[<span class="number">1</span>], inLine, LENGTH);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(fd2[<span class="number">0</span>], outLine, LENGTH);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, outLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="消息队列">消息队列</h1>
<h2 id="写入消息队列">写入消息队列</h2>
<h3 id="创建消息队列">创建消息队列</h3>
<p>创建消息结构体,定义一个全局的消息结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[LENGTH];</span><br><span class="line">&#125;msgbuf;</span><br></pre></td></tr></table></figure>
<p>再在全局定义一个消息队列的键，这个键就是表示消息队列的编号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> MSG_KEY;</span><br></pre></td></tr></table></figure>
<p>然后利用msgget创建消息队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
<p>详细解释：</p>
<ul>
<li><p>MSG_KEY作用：</p>
<p><code>MSG_KEY</code>
应该是一个用于唯一标识消息队列的键值，但是它在代码中并没有被定义。通常情况下，可以使用
<code>ftok()</code> 函数来生成一个唯一的键值</p></li>
<li><p>IPC_CREAT作用</p>
<p><font color = "yellow"><code>IPC_CREAT</code>
表示如果消息队列不存在则创建</font></p></li>
<li><p>0666作用</p>
<p><font color = "yellow">表示消息队列的权限</font></p>
<p>在 Linux/Unix
中，文件权限通常以八进制数表示。每个权限对应的数值如下：</p>
<ul>
<li><code>0</code>：没有任何权限</li>
<li><code>1</code>：执行权限（可执行文件）</li>
<li><code>2</code>：写权限（写入文件）</li>
<li><code>4</code>：读权限（读取文件）</li>
</ul>
<p>这些权限可以组合使用，通过将对应的数值相加来表示多个权限的组合。例如：</p>
<ul>
<li><code>3</code>：执行权限和写权限（1 + 2）</li>
<li><code>5</code>：执行权限和读权限（1 + 4）</li>
<li><code>6</code>：写权限和读权限（2 + 4）</li>
<li><code>7</code>：执行权限、写权限和读权限（1 + 2 + 4）</li>
</ul>
<p>在 <code>0666</code> 中，表示的权限是：</p>
<ul>
<li><code>0</code>：表示特殊权限位，通常为文件类型或文件特性（如设备文件、管道、套接字等），在这里不涉及文件类型的权限，因此这个位置通常用0填充。</li>
<li><code>666</code>：表示读权限和写权限，即文件的所有者、所属组和其他用户都有读和写的权限。</li>
</ul></li>
</ul>
<p>整条语句的作用是<font color = "red">用来创建消息队列,
可以理解返回的是消息队列的地址</font></p>
<h3 id="将缓存中消息发送到消息队列">将缓存中消息发送到消息队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msNum</code>：消息队列的标识符，它是由 <code>msgget</code>
函数返回的值。</li>
<li><code>&amp;msgbuf</code>：一个指向消息缓冲区的指针，消息将从这个缓冲区中发送。</li>
<li><code>1024</code>：消息的大小，以字节为单位。在这里，消息的大小为
1024 字节。</li>
<li><code>0</code>：这是一个标志参数，用于指定在发送消息时的行为。在这里，它是一个控制参数，通常可以用来设置一些特殊的行为，但在这个例子中被设置为
0，表示没有设置特殊的行为。</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 上面语句用来创建消息队列, 可以理解返回的是消息队列的地址，注意与msgNum的区别</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上面语句用来将要发送的消息暂时存入缓冲区，并设置这种消息的类型为1</span></span><br><span class="line">    msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>); <span class="comment">// 将内存中消息发送到消息队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从消息队列中读取">从消息队列中读取</h2>
<h3 id="获取消息队列">获取消息队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
<h3 id="从消息队列中读取-1">从消息队列中读取</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgNum</code>：消息队列的标识符，它是由 <code>msgget()</code>
函数返回的值。</li>
<li><code>&amp;msgbuf</code>：一个指向消息缓冲区的指针，用于存储接收到的消息。</li>
<li><code>LENGTH</code>：消息的最大长度，以字节为单位。在这里，消息的最大长度被设置为
1024 字节。</li>
<li><code>0</code>：这是一个消息的类型，它指定了要接收的消息的类型。在这里，设置为
0 表示接收队列中的第一个消息。</li>
<li><code>0</code>：这是一个标志参数，用于指定在接收消息时的行为。在这里，它是一个控制参数，表示没有设置特殊的行为。</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The save line is %s\n&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgctl(msgNum, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by pilot on 24-4-11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY 24</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[LENGTH];</span><br><span class="line">&#125;msgbuf;</span><br><span class="line"><span class="type">int</span> msgNum = <span class="number">0</span>;     <span class="comment">//利用全局变量定义消息队列的序号，这个是1个键，相当于消息队列的编号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 上面语句用来创建消息队列, 可以理解返回的是消息队列的地址，注意与msgNum的区别</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上面语句用来将要发送的消息暂时存入缓冲区，并设置这种消息的类型为1</span></span><br><span class="line">    msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>); <span class="comment">// 将内存中消息发送到消息队列中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The save line is %s\n&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgctl(msgNum, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> p1 = fork();</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create p1 failed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process1\n&quot;</span>);</span><br><span class="line">        server();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;process1 end\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">pid_t</span> p2 = fork();</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create p2 failed\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;this is child process2\n&quot;</span>);</span><br><span class="line">            client();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process2 end\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task end\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>实验二-fork、wait、exec</title>
    <url>/posts/383d6a1d.html</url>
    <content><![CDATA[<h1 id="fork">fork</h1>
<span id="more"></span>
<p><code>fork()</code>被用于创建一个子进程。这个函数返回0代表创建成功，返回负数代表创建失败。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int apple = 5; //5个苹果</span><br><span class="line">  pid_t pid;</span><br><span class="line"></span><br><span class="line">  pid = fork(); //创建子进程</span><br><span class="line">  if(pid &lt; 0)&#123; //如果没有创建成功</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">    exit(EXIT_FAILURE); //退出</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;// 如果创建成功</span><br><span class="line">    //在这个if中的所有操作都是子进程的。</span><br><span class="line">    apple -= 4; //吃掉4个苹果</span><br><span class="line">  &#125;else if(pid &gt;= 0)&#123; // 如果不在子进程中</span><br><span class="line">    printf(&quot;There are %d apples&quot;, apple); //输出苹果的数量</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 C 语言中，<font color = "yellow"><code>pid_t</code>
是一种数据类型</font>，它用来表示进程 ID（Process ID），在头文件
<code>&lt;sys/types.h&gt;</code> 中定义。<code>pid_t</code> 不是
<code>int</code>，<font color = "yellow">尽管在许多系统上
<code>pid_t</code> 被定义为
<code>int</code>，</font>但这并不是必然的，因为它可以是不同平台上不同的类型。</p>
</blockquote>
<p>当我们创建一个子进程的时候，这段代码，包括它当前的所有参数都被复制给了子进程。这样一来，子进程的操作无论怎么更改都是在子进程里生效。见下图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/p1.svg" /></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 5 apples</span><br></pre></td></tr></table></figure>
<p>这些参数里面，唯一不同的是<code>pid</code>，子进程的<code>pid</code>是0，而父进程的<code>pid</code>没有赋值。我们不能说，子进程的作用域只在那个if语句中，在if外面就不是子进程了。其实不然，我们可以试一下下面的代码来证明子进程和父进程都拥有苹果，而且互不干扰。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int apple = 5; //5个苹果</span><br><span class="line">  pid_t pid;</span><br><span class="line"></span><br><span class="line">  pid = fork(); //创建子进程</span><br><span class="line">  if(pid &lt; 0)&#123; //如果没有创建成功</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">    exit(EXIT_FAILURE); //退出</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;// 如果创建成功</span><br><span class="line">    //在这个if中的所有操作都是子进程的。</span><br><span class="line">    apple -= 4; //吃掉4个苹果</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;There are %d apples\n&quot;, apple); //输出苹果的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 5 apples</span><br><span class="line">There are 1 apples</span><br></pre></td></tr></table></figure>
<p>前一个是父进程的苹果，没有被吃掉，后一个是子进程的苹果，吃掉了四个。即使是在if语句外面也是可以被执行的。<font color = "yellow">if仅仅只是用于辅助判断哪些代码可以在子进程执行，哪些代码可以在父进程执行而已</font></p>
<p><a
href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork的进一步了解</a></p>
<h1 id="wait">wait</h1>
<p>搭配<code>fork()</code>使用。<font color = "yellow">本质上就是为了回收已经执行完毕的子进程，释放子进程的资源</font></p>
<ol type="1">
<li><p>没有用wait()主进程不会受到影响，但是子进程即使终止了资源也不会被回收，从而会变成<strong>僵尸进程</strong></p></li>
<li><p>进程一旦调用了 wait，就
<font color = "red">立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出</font>，如果让它找到了这样一个已经变成僵尸的子进程，wait
就会收集这个子进程的信息，
并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p></li>
<li><p><code>wait()</code>的返回值是子进程的ID。</p></li>
</ol>
<p>如果你对第一次写 <em>hello world</em>
有印象，你一定记得代码最后的<code>return 0;</code>。课本上只会跟你说：“return
0代表这个函数的返回值是0”，但是你无法理解为什么要返回0，返回给谁。现在明白了父进程和子进程的概念，你就知道这个0是返回给父进程的,
是告诉父进程子进程的退出状态。</p>
<p>要接住这个返回值，我们要定义一个整型<code>status</code>。后面通过这个变量来确定子进程退出的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  //输入的是</span><br><span class="line">  if(pid &lt; 0)&#123;</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;</span><br><span class="line">    return 0; //尝试换掉这个返回值看看输出的结果。</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    int status;</span><br><span class="line">    int id = wait(&amp;status);</span><br><span class="line">    printf(&quot;%d\n&quot;, status);</span><br><span class="line">    printf(&quot;Child process return status is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">    printf(&quot;Child process id is %d&quot;, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">Child process return status is 0</span><br><span class="line">Child process id is 99932</span><br></pre></td></tr></table></figure>
<p><code>WEXITSTATUS</code>是预设的函数，用来查看函数的返回值的。还有很多其他的函数可供使用，
详情<a href="https://linux.die.net/man/2/wait">点这里</a>。</p>
<p>这里有一个很大的问题，一定不要弄混淆了</p>
<ol type="1">
<li><p><code>wait()</code>的返回值不是子进程的返回值,
而是子进程的id。</p></li>
<li><p><code>status</code>不是子进程的返回值，而是进程的状态。所以子进程无论return什么，只要正常返回，status都是0</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331193109603.png" /></p></li>
</ol>
<p>另外需要说明的是<code>wait()</code>函数并不仅仅是在等到子进程结束，而是在子进程<strong>状态转移</strong>的时候返回</p>
<h1 id="exec">exec</h1>
<p><code>exec()</code>是一系列函数的总称，主要的作用是执行某个文件。它们分别是<code>execl()</code>,
<code>execlp()</code>, <code>execle()</code>, <code>execv()</code>,
<code>execvp()</code>,
<code>execvpe()</code>。我后面会补充一期文件系统的复习。现在只要假设<code>exec()</code>可以用来跑一个程序就好。</p>
<p>这么多函数，我应该用哪一个？别慌。以<code>exec</code>作为前缀，我们可以这样确定要用哪一个函数：</p>
<ul>
<li><code>l</code>代表输入的是参数，而<code>v</code>代表输入的是数组。</li>
<li>带<code>e</code>表示需要设置环境，不带<code>e</code>表示不需要。</li>
<li>带<code>p</code>表示输入的是可执行文件的名字，不带表示输入的是可执行文件的路径（函数会根据<code>$PATH</code>的路径来判断可执行文件的位置）。
下面这段代码介绍了<code>execlp()</code>和<code>execvp()</code>的区别。
程序会输出两段一样的结果，分别是子进程和父进程的运行结果。不同的是，父进程用<code>execvp()</code>,
根据上面的判断这是一个接受参数数组和可执行文件名的函数。你可以试着自己换不同的函数来尝试他们的效果。</li>
<li><code>NULL</code>在函数中的作用是告诉函数参数到此为止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  char args1[] = &quot;ls&quot;;</span><br><span class="line">  char args2[] = &quot;-la&quot;;</span><br><span class="line"></span><br><span class="line">  char* command[] = &#123;args1, args2, NULL&#125;;</span><br><span class="line">  pid_t pid1;</span><br><span class="line"></span><br><span class="line">  pid1 = fork();</span><br><span class="line">  if(pid1 &lt; 0)&#123;</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid1 == 0)&#123;</span><br><span class="line">    //execlp 接收n个参数，其中第一个是可执行文件名，后面的都是可执行参数。</span><br><span class="line">    //最后一个参数必须为NULL。</span><br><span class="line">    execlp(args1, args1, args2, NULL);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    wait(NULL);</span><br><span class="line">    //execvp 接收两个参数，一个是可执行文件名，一个是执行参数的数组。</span><br><span class="line">    //数组最后的元素必须为NULL。</span><br><span class="line">    execvp(args1, command);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<ol type="1">
<li>要创建子进程我们要用<code>fork()</code>，这个函数的返回值告诉我们子进程是否创建成功。</li>
<li>要在子进程中运行可执行文件要用<code>exec()</code>，这个函数有多个变种，用哪一个根据手头有的变量确定。</li>
<li><code>wait()</code>被父进程用于等待子进程的状态。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>jupyter-notebook的安装与卸载</title>
    <url>/posts/d50567ed.html</url>
    <content><![CDATA[<p>参考文章 安装
https://blog.csdn.net/Withadream/article/details/125440035 卸载
https://www.cnblogs.com/kaerxifa/p/12963733.html</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>数据分析第一章-pandas基础</title>
    <url>/posts/c138cc70.html</url>
    <content><![CDATA[<h1 id="导入">导入</h1>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<h1 id="pandas的数据结构介绍">pandas的数据结构介绍</h1>
<h2 id="series">Series</h2>
<h3 id="创建最简单的series">创建最简单的series</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060409357.png" /></p>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。</p>
<h3
id="获取series的数组表示形式和索引对象">获取series的数组表示形式和索引对象</h3>
<p>可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.values</span><br><span class="line">obj.index</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060628380.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060655444.png" /></p>
<h3 id="指定创建的series的索引">指定创建的Series的索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj2</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060854021.png" /></p>
<h3
id="通过索引的形式选取series中单个或者一组值">通过索引的形式选取Series中单个或者一组值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="修改series中数组对象里的值">修改Series中数组对象里的值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   -<span class="number">10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="与字典的关系">与字典的关系</h3>
<h4
id="可以将series看成是一个定长的有序字典因为它是索引值到数据值的一个映射它可以用在许多原本需要字典参数的函数中">可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="直接传入一个python字典">直接传入一个python字典</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4
id="通过传入一个python列表修改series中的索引从而修改series中的键值对排序">通过传入一个python列表，修改Series中的索引，从而修改Series中的键值对排序</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not
a
number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<h4
id="isnull和notnull函数可用于检测缺失数据">isnull和notnull函数可用于检测缺失数据：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>Series也有类似的实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [34]: obj4.isnull()</span><br><span class="line">Out[34]: </span><br><span class="line">California     True</span><br><span class="line">Ohio          False</span><br><span class="line">Oregon        False</span><br><span class="line">Texas         False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h4 id="name属性">name属性</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>
<h4 id="修改索引">修改索引</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="dataframe">DataFrame</h2>
<h3
id="通过传入等长列表或numpy数组组成的字典建立dataframe">通过传入等长列表或Numpy数组组成的字典建立DataFrame</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304054932701.png" /></p>
<h3 id="head方法">head方法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.head()</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304055151225.png" /></p>
<h3 id="指定列的排列顺序">指定列的排列顺序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(data, columns = [<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304055531166.png" /></p>
<h3 id="指定行的编号">指定行的编号</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame2 = pd.DataFrame(data, columns = [<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>], index = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>])</span><br><span class="line">frame2</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304060033591.png" /></p>
<h3
id="从dataframe的列获取为一个series">从DataFrame的列获取为一个Series</h3>
<h4 id="类似字典标记的方式">类似字典标记的方式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h4 id="属性的方式">属性的方式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure>
<p>注：
frame2[column]<font color = 'red'>适用于任何列的名</font>，但是frame2.column只有在<font color = "red">列名是一个合理的Python变量名</font>时才适用。</p>
<h3 id="用loc获取行">用loc获取行</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [53]: frame2.loc[&#x27;three&#x27;]</span><br><span class="line">Out[53]: </span><br><span class="line">year     2002</span><br><span class="line">state    Ohio</span><br><span class="line">pop       3.6</span><br><span class="line">Name: three, dtype: object</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304061850402.png" /></p>
<h3 id="给缺失值的列赋值">给缺失值的列赋值</h3>
<h4 id="赋同一个值">赋同一个值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br></pre></td></tr></table></figure>
<h4 id="赋不同的值">赋不同的值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">0.0</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>   <span class="number">1.0</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">2.0</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>   <span class="number">3.0</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>   <span class="number">4.0</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<p>注：将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。</p>
<h3
id="赋值的是一个series就会精确匹配dataframe的索引所有的空位都将被填上缺失值">赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: frame2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN</span><br></pre></td></tr></table></figure>
<h3
id="根据state是否为ohio添加一列名为eastern的列">根据state是否为'Ohio'添加一列名为eastern的列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: frame2[<span class="string">&#x27;eastern&#x27;</span>] = frame2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: frame2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>注意：不能用frame2.eastern创建新的列。</p>
<h3 id="用del删除列">用del删除列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> frame2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="通过嵌套字典创建dataframe最外层会作为行往内一层会作为列再往里作为行与列交叉对应空格的值">通过嵌套字典创建DataFrame，最外层会作为行，往内一层会作为列，再往里作为行与列交叉对应空格的值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: frame3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<h3 id="转置dataframe">转置DataFrame</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.T</span><br></pre></td></tr></table></figure>
<h3
id="截取一个dataframe前两行的两种写法">截取一个DataFrame前两行的两种写法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>:frame3[<span class="string">&#x27;Ohio&#x27;</span>][:-<span class="number">1</span>],</span><br><span class="line">         <span class="string">&#x27;Nevada&#x27;</span>:frame3[<span class="string">&#x27;Nevada&#x27;</span>][:<span class="number">2</span>]&#125;</span><br><span class="line">pd.DataFrame(pdata)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305063001812.png" /></p>
<h3
id="设置dataframe的index和columns属性">设置DataFrame的index和columns属性</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305063455936.png" /></p>
<h3 id="dataframe的values属性">DataFrame的values属性</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">2.4</span>,  <span class="number">1.7</span>],</span><br><span class="line">       [ <span class="number">2.9</span>,  <span class="number">3.6</span>]])</span><br></pre></td></tr></table></figure>
<p>注：如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型</p>
<h2 id="索引对象">索引对象</h2>
<p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: index</span><br><span class="line">Out[<span class="number">78</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><font color = "red">Index对象是不可变的，因此用户不能对其进行修改</font></p>
<p>pandas与python不同，可以包含重复的标签</p>
<h1 id="基本功能">基本功能</h1>
<h2 id="重新索引">重新索引</h2>
<h3
id="用series的reindex会根据新索引重排如果当前索引不存在就引入缺失值">用Series的reindex会根据新索引重排，如果当前索引不存在就引入缺失值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="用method进行插值处理">用method进行插值处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: obj3</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe中使用reindex修改行索引">DataFrame中使用reindex，修改行索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe使用columns修改列索引">DataFrame使用columns修改列索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: states = [<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;California&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="number">1</span>   NaN           <span class="number">2</span></span><br><span class="line">c      <span class="number">4</span>   NaN           <span class="number">5</span></span><br><span class="line">d      <span class="number">7</span>   NaN           <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h2 id="丢弃指定轴上的项">丢弃指定轴上的项</h2>
<h3
id="series中使用drop方法返回在指定轴上删除指定值的新对象">Series中使用Drop方法返回在指定轴上删除指定值的新对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: obj</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: new_obj</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe用标签序列调用drop会从行标签axis-0删除值">DataFrame用标签序列调用drop会从行标签（axis
0）删除值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe通过传递axis1或axiscolumns可以删除列的值">DataFrame通过传递axis=1或axis='columns'可以删除列的值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">&#x27;two&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data.drop([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3
id="用inplace就地修改不返回新对象">用inplace就地修改不返回新对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: obj.drop(<span class="string">&#x27;c&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: obj</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="索引选取和过滤">索引、选取和过滤</h2>
<h3
id="series索引类似numpy索引可以切片但是这个切片是包含末端的还可以索引的对象不是整数而是字符">Series索引，类似numpy索引，可以切片,但是这个切片是包含末端的，还可以索引的对象不是整数而是字符</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3
id="用切片可以对series的相应部分进行设置">用切片可以对Series的相应部分进行设置</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308054828881.png" /></p>
<h3
id="通过一个值对dataframe进行索引">通过一个值对DataFrame进行索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br></pre></td></tr></table></figure>
<h3
id="通过一个序列对dataframe索引主要要套两层">通过一个序列对DataFrame索引，主要要套两层[]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line">In [<span class="number">131</span>]: data[[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]]</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="number">2</span>    <span class="number">0</span></span><br><span class="line">Colorado      <span class="number">6</span>    <span class="number">4</span></span><br><span class="line">Utah         <span class="number">10</span>    <span class="number">8</span></span><br><span class="line">New York     <span class="number">14</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="通过切片索引选取行">通过切片索引选取行</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308055742644.png" /></p>
<h3 id="通过在列基础上条件判断索引">通过在列基础上条件判断索引</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308060054604.png" /></p>
<h3 id="通过对整体条件判断">通过对整体条件判断</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2
id="用loc和iloc从dataframe选择行和列的子集">用loc和iloc从DataFrame选择行和列的子集。</h2>
<h3 id="使用loc直接选取轴名称">使用loc直接选取轴名称</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308060814326.png" /></p>
<h3 id="使用iloc通过轴下标选取">使用iloc通过轴下标选取</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/31c156b894c83af0378386730f25873.jpg" /></p>
<h3 id="切片获取标签">切片获取标签</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: data.loc[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">141</span>]: </span><br><span class="line">Ohio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line">In [<span class="number">142</span>]: data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h2 id="算术运算和数据对齐">算术运算和数据对齐</h2>
<h3 id="series的数据对齐">Series的数据对齐</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="dataframe的对齐">DataFrame的对齐</h3>
<p>先取行标签和列标签的并集，然后两个DataFrame对象公共部分才会保留并运算，如果两个都没有或者只有1个有都是认为NAN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure>
<h3 id="在算术方法中填充值">在算术方法中填充值</h3>
<p>使用df1的add方法，传入df2以及一个fill_value参数，可以让原本产生NaN的值得到指定的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure>
<h3 id="dataframe和series之间的运算">DataFrame和Series之间的运算</h3>
<h4 id="广播">广播</h4>
<p>从arr减去arr[0]，每一行都会执行这个操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240311063147918.png" /></p>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis='index'
or axis=0）并进行广播。</p>
<h3 id="排序和排名">排序和排名</h3>
<h4 id="排序">排序</h4>
<h5 id="sort_index">sort_index</h5>
<p>在Series中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在DataFrame中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>降序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h5 id="sort_values">sort_values</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<p>根据某一列排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">214</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="排名">排名</h4>
<h5 id="按average排名">按“average”排名</h5>
<p>相同值的元素将被分配平均排名。例如，如果有n个元素并列，那么它们的排名将是：并列首行所在的行数+0.5*(n-1)。</p>
<p>举个例子：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3320338d6e68533862a5af71232b456.jpg" /></p>
<h5 id="按first排名">按“first”排名</h5>
<p>据出现顺序分配排名，按从小到大，排名等于行所在的行数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/62e313c1e197c77cf6b54978175b713.jpg" /></p>
<h5 id="max排名">max排名</h5>
<p>相同值的元素将被分配最高排名。例如，如果有n个元素并列，那么它们的排名将都是最后一个元素所在的行数。</p>
<h5
id="dataframe可以在行或列上计算排名">DataFrame可以在行或列上计算排名：</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240319062648290.png" /></p>
<h3 id="带有重复标签的轴索引">带有重复标签的轴索引</h3>
<h2 id="汇总和计算描述统计">汇总和计算描述统计</h2>
<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320054354757.png" /></p>
<p>传入axis='columns'或axis=1将会按行进行求和运算：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055013896.png" /></p>
<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055248960.png" /></p>
<p>求最大值与最小值的索引</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055957031.png" /></p>
<p>累积求和</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320060151721.png" /></p>
<p>到b那一层就是b = b + a</p>
<p>到c那一层就是c = c + b + a</p>
<h3 id="多个股票代码的demo">多个股票代码的demo</h3>
<h4 id="download模块">download模块。</h4>
<p>举例：一次性获取 Amazon、Apple 和 Google 的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = yf.download(<span class="string">&quot;AMZN AAPL GOOG&quot;</span>, start=<span class="string">&quot;2017-01-01&quot;</span>, end=<span class="string">&quot;2017-04-30&quot;</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-ef7734b928680d5172e82b910cba68f3_720w.webp" /></p>
<p>按股票代码而不是开盘价/最高价/最低价/收盘价进行分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = yf.download(<span class="string">&quot;AMZN AAPL GOOG&quot;</span>, start=<span class="string">&quot;2017-01-01&quot;</span>,</span><br><span class="line">                    end=<span class="string">&quot;2017-04-30&quot;</span>, group_by=<span class="string">&#x27;tickers&#x27;</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-359419adff58f22c6e0c1f2b4e6ef95e_720w.webp" /></p>
<h4 id="市盈率">市盈率</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aapl = yf.Ticker(<span class="string">&quot;aapl&quot;</span>)</span><br><span class="line">aapl.info[<span class="string">&#x27;forwardPE&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>yf.Ticker("aapl")</code> 创建了一个 <code>Ticker</code>
对象，该对象表示了苹果公司的股票。</li>
<li><code>aapl.info</code>
属性返回一个字典，包含了苹果公司股票的各种信息，如公司名称、市值、市盈率等。</li>
<li><code>aapl.info['forwardPE']</code> 从返回的字典中获取了键为
<code>'forwardPE'</code> 的值，该值代表了苹果公司的预测市盈率（forward
PE ratio）。</li>
</ol>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24.95391</span><br></pre></td></tr></table></figure>
<h4 id="股息">股息</h4>
<p>年度股息百分比：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aapl.info[<span class="string">&#x27;dividendRate&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.96</span><br></pre></td></tr></table></figure>
<p>在发生的日期对每笔股息支付进行细分</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date</span><br><span class="line">1987-05-11 00:00:00-04:00    0.000536</span><br><span class="line">1987-08-10 00:00:00-04:00    0.000536</span><br><span class="line">1987-11-17 00:00:00-05:00    0.000714</span><br><span class="line">1988-02-12 00:00:00-05:00    0.000714</span><br><span class="line">1988-05-16 00:00:00-04:00    0.000714</span><br><span class="line">                               ...   </span><br><span class="line">2023-02-10 00:00:00-05:00    0.230000</span><br><span class="line">2023-05-12 00:00:00-04:00    0.240000</span><br><span class="line">2023-08-11 00:00:00-04:00    0.240000</span><br><span class="line">2023-11-10 00:00:00-05:00    0.240000</span><br><span class="line">2024-02-09 00:00:00-05:00    0.240000</span><br><span class="line">Name: Dividends, Length: 82, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="相关系数和协方差">相关系数和协方差</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取股票数据</span></span><br><span class="line">all_data = &#123;ticker: yf.Ticker(ticker).history(period=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;GOOG&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建价格 DataFrame</span></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Close&#x27;</span>]</span><br><span class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建成交量 DataFrame</span></span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">                       <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure>
<p>相关系数</p>
<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].corr(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">244</span>]: <span class="number">0.49976361144151144</span></span><br></pre></td></tr></table></figure>
<p>协方差</p>
<p>cov用于计算协方差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">245</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].cov(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">245</span>]: <span class="number">8.8706554797035462e-05</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">1.000000</span>  <span class="number">0.407919</span>  <span class="number">0.386817</span>  <span class="number">0.389695</span></span><br><span class="line">GOOG  <span class="number">0.407919</span>  <span class="number">1.000000</span>  <span class="number">0.405099</span>  <span class="number">0.465919</span></span><br><span class="line">IBM   <span class="number">0.386817</span>  <span class="number">0.405099</span>  <span class="number">1.000000</span>  <span class="number">0.499764</span></span><br><span class="line">MSFT  <span class="number">0.389695</span>  <span class="number">0.465919</span>  <span class="number">0.499764</span>  <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">0.000277</span>  <span class="number">0.000107</span>  <span class="number">0.000078</span>  <span class="number">0.000095</span></span><br><span class="line">GOOG  <span class="number">0.000107</span>  <span class="number">0.000251</span>  <span class="number">0.000078</span>  <span class="number">0.000108</span></span><br><span class="line">IBM   <span class="number">0.000078</span>  <span class="number">0.000078</span>  <span class="number">0.000146</span>  <span class="number">0.000089</span></span><br><span class="line">MSFT  <span class="number">0.000095</span>  <span class="number">0.000108</span>  <span class="number">0.000089</span>  <span class="number">0.000215</span></span><br></pre></td></tr></table></figure>
<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [249]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[249]: </span><br><span class="line">AAPL    0.386817</span><br><span class="line">GOOG    0.405099</span><br><span class="line">IBM     1.000000</span><br><span class="line">MSFT    0.499764</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [250]: returns.corrwith(volume)</span><br><span class="line">Out[250]: </span><br><span class="line">AAPL   -0.075565</span><br><span class="line">GOOG   -0.007067</span><br><span class="line">IBM    -0.204849</span><br><span class="line">MSFT   -0.092950</span><br><span class="line"></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入axis='columns'即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h3 id="唯一值值计数以及成员资格">唯一值、值计数以及成员资格</h3>
<h4 id="unique">unique</h4>
<p>它可以得到Series中的唯一值数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [251]: obj = pd.Series([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;])</span><br><span class="line">In [252]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [253]: uniques</span><br><span class="line">Out[253]: array([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;], dtype=object)</span><br></pre></td></tr></table></figure>
<h4 id="value_counts">value_counts</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [254]: obj.value_counts()</span><br><span class="line">Out[254]: </span><br><span class="line">c    3</span><br><span class="line">a    3</span><br><span class="line">b    2</span><br><span class="line">d    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="isin">isin</h4>
<p>用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [256]: obj</span><br><span class="line">Out[256]: </span><br><span class="line">0    c</span><br><span class="line">1    a</span><br><span class="line">2    d</span><br><span class="line">3    a</span><br><span class="line">4    a</span><br><span class="line">5    b</span><br><span class="line">6    b</span><br><span class="line">7    c</span><br><span class="line">8    c</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [257]: mask = obj.isin([&#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line"></span><br><span class="line">In [258]: mask</span><br><span class="line">Out[258]: </span><br><span class="line">0     True</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5     True</span><br><span class="line">6     True</span><br><span class="line">7     True</span><br><span class="line">8     True</span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">In [259]: obj[mask]</span><br><span class="line">Out[259]: </span><br><span class="line">0    c</span><br><span class="line">5    b</span><br><span class="line">6    b</span><br><span class="line">7    c</span><br><span class="line">8    c</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h4 id="index.get_indexer">Index.get_indexer</h4>
<p>给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [260]: to_match = pd.Series([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;])</span><br><span class="line"></span><br><span class="line">In [261]: unique_vals = pd.Series([&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;])</span><br><span class="line"></span><br><span class="line">In [262]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[262]: array([0, 2, 1, 1, 0, 2])</span><br></pre></td></tr></table></figure>
<h4 id="apply">apply</h4>
<p>产生柱状图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [265]: result = data.apply(pd.value_counts).fillna(0)</span><br><span class="line"></span><br><span class="line">In [266]: result</span><br><span class="line">Out[266]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line">1  1.0  1.0  1.0</span><br><span class="line">2  0.0  2.0  1.0</span><br><span class="line">3  2.0  2.0  0.0</span><br><span class="line">4  2.0  0.0  2.0</span><br><span class="line">5  0.0  0.0  1.0</span><br></pre></td></tr></table></figure>
<p>结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-数据加载</title>
    <url>/posts/963d95c9.html</url>
    <content><![CDATA[<h1 id="一读取文本格式数据">一、读取文本格式数据</h1>
<span id="more"></span>
<h2 id="read_csv">read_csv</h2>
<p>将以逗号分隔的csv文件读入DataFrame中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [9]: df = pd.read_csv(&#x27;examples/ex1.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [10]: df</span><br><span class="line">Out[10]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="处理没有标题行的文件">处理没有标题行的文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,hello</span><br><span class="line">5,6,7,8,world</span><br><span class="line">9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="分配默认的列名">分配默认的列名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [13]: pd.read_csv(&#x27;examples/ex2.csv&#x27;, header=None)</span><br><span class="line">Out[13]: </span><br><span class="line">   0   1   2   3      4</span><br><span class="line">0  1   2   3   4  hello</span><br><span class="line">1  5   6   7   8  world</span><br><span class="line">2  9  10  11  12    foo</span><br></pre></td></tr></table></figure>
<h4 id="自己定义列名">自己定义列名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [14]: pd.read_csv(&#x27;examples/ex2.csv&#x27;, names=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;message&#x27;])</span><br><span class="line">Out[14]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="将多个列做成一个层次化索引">将多个列做成一个层次化索引</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,1,2</span><br><span class="line">one,b,3,4</span><br><span class="line">one,c,5,6</span><br><span class="line">one,d,7,8</span><br><span class="line">two,a,9,10</span><br><span class="line">two,b,11,12</span><br><span class="line">two,c,13,14</span><br><span class="line">two,d,15,16</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [18]: parsed = pd.read_csv(&#x27;examples/csv_mindex.csv&#x27;,</span><br><span class="line">   ....:                      index_col=[&#x27;key1&#x27;, &#x27;key2&#x27;])</span><br><span class="line"></span><br><span class="line">In [19]: parsed</span><br><span class="line">Out[19]: </span><br><span class="line">           value1  value2</span><br><span class="line">key1 key2                </span><br><span class="line">one  a          1       2</span><br><span class="line">     b          3       4</span><br><span class="line">     c          5       6</span><br><span class="line">     d          7       8</span><br><span class="line">two  a          9      10</span><br><span class="line">     b         11      12</span><br><span class="line">     c         13      14</span><br><span class="line">     d         15      16</span><br></pre></td></tr></table></figure>
<h3 id="处理不固定分隔符">处理不固定分隔符</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [20]: list(open(&#x27;examples/ex3.txt&#x27;))</span><br><span class="line">Out[20]: </span><br><span class="line">[&#x27;            A         B         C\n&#x27;,</span><br><span class="line"> &#x27;aaa -0.264438 -1.026059 -0.619500\n&#x27;,</span><br><span class="line"> &#x27;bbb  0.927272  0.302904 -0.032399\n&#x27;,</span><br><span class="line"> &#x27;ccc -0.264273 -0.386314 -0.217601\n&#x27;,</span><br><span class="line"> &#x27;ddd -0.871858 -0.348382  1.100491\n&#x27;]</span><br></pre></td></tr></table></figure>
<p>上面不是txt文档中不是像csv统一同逗号分隔，而是用不等长空格分隔，所以使用read_table方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [21]: result = pd.read_table(&#x27;examples/ex3.txt&#x27;, sep=&#x27;\s+&#x27;)</span><br><span class="line"></span><br><span class="line">In [22]: result</span><br><span class="line">Out[22]: </span><br><span class="line">            A         B         C</span><br><span class="line">aaa -0.264438 -1.026059 -0.619500</span><br><span class="line">bbb  0.927272  0.302904 -0.032399</span><br><span class="line">ccc -0.264273 -0.386314 -0.217601</span><br><span class="line">ddd -0.871858 -0.348382  1.100491</span><br></pre></td></tr></table></figure>
<h3 id="跳过指定行">跳过指定行</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hey!</span><br><span class="line">a,b,c,d,message</span><br><span class="line"># just wanted to make things more difficult for you</span><br><span class="line"># who reads CSV files with computers, anyway?</span><br><span class="line">1,2,3,4,hello</span><br><span class="line">5,6,7,8,world</span><br><span class="line">9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [24]: pd.read_csv(&#x27;examples/ex4.csv&#x27;, skiprows=[0, 2, 3])</span><br><span class="line">Out[24]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="缺失值处理">缺失值处理</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">something,a,b,c,d,message</span><br><span class="line">one,1,2,3,4,NA</span><br><span class="line">two,5,6,,8,world</span><br><span class="line">three,9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: result = pd.read_csv(&#x27;examples/ex5.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [27]: result</span><br><span class="line">Out[27]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line">0       one  1   2   3.0   4     NaN</span><br><span class="line">1       two  5   6   NaN   8   world</span><br><span class="line">2     three  9  10  11.0  12     foo</span><br><span class="line"></span><br><span class="line">In [28]: pd.isnull(result)</span><br><span class="line">Out[28]: </span><br><span class="line">   something      a      b      c      d  message</span><br><span class="line">0      False  False  False  False  False     True</span><br><span class="line">1      False  False  False   True  False    False</span><br><span class="line">2      False  False  False  False  False    False</span><br></pre></td></tr></table></figure>
<h4
id="用一个列表或集合的字符串表示缺失值指定原来文件中特定的值是缺失值">用一个列表或集合的字符串表示缺失值，指定原来文件中特定的值是缺失值</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentials = &#123;&#x27;something&#x27;:[&#x27;two&#x27;], &#x27;message&#x27;:[&#x27;foo&#x27;, &#x27;NA&#x27;]&#125;</span><br><span class="line">result = pd.read_csv(&#x27;examples/ex5.csv&#x27;, na_values=sentials)</span><br><span class="line">result</span><br><span class="line">something  a   b     c   d message</span><br><span class="line">0       one  1   2   3.0   4     NaN</span><br><span class="line">1       NaN  5   6   NaN   8   world</span><br><span class="line">2     three  9  10  11.0  12     NaN</span><br></pre></td></tr></table></figure>
<p>其中'something':['two']表示针对something这一列，其中值为two的值替换成缺失值</p>
<h2 id="逐块读取文本文件">逐块读取文本文件</h2>
<h3 id="读取文件中指定行数">读取文件中指定行数</h3>
<p>通过nrows进行指定读取行数即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [36]: pd.read_csv(&#x27;examples/ex6.csv&#x27;, nrows=5)</span><br><span class="line">Out[36]: </span><br><span class="line">        one       two     three      four key</span><br><span class="line">0  0.467976 -0.038649 -0.295344 -1.824726   L</span><br><span class="line">1 -0.358893  1.404453  0.704965 -0.200638   B</span><br><span class="line">2 -0.501840  0.659254 -0.421691 -0.057688   G</span><br><span class="line">3  0.204886  1.074134  1.388361 -0.982404   R</span><br><span class="line">4  0.354628 -0.133116  0.283763 -0.837063   Q</span><br></pre></td></tr></table></figure>
<h3 id="逐块读取文件">逐块读取文件</h3>
<p>可以指定chunksize（行数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [874]: chunker = pd.read_csv(&#x27;ch06/ex6.csv&#x27;, chunksize=1000)</span><br><span class="line"></span><br><span class="line">In [875]: chunker</span><br><span class="line">Out[875]: &lt;pandas.io.parsers.TextParser at 0x8398150&gt;</span><br></pre></td></tr></table></figure>
<h3 id="逐块迭代文件">逐块迭代文件</h3>
<p>比如说，我们可以迭代处理ex6.csv，将值计数聚合到"key"列中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunker = pd.read_csv(&#x27;examples/ex6.csv&#x27;, chunksize=1000)</span><br><span class="line"></span><br><span class="line">tot = pd.Series([])</span><br><span class="line">for piece in chunker:</span><br><span class="line">    tot = tot.add(piece[&#x27;key&#x27;].value_counts(), fill_value=0)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=False)</span><br><span class="line">In [40]: tot[:10]</span><br><span class="line">Out[40]: </span><br><span class="line">E    368.0</span><br><span class="line">X    364.0</span><br><span class="line">L    346.0</span><br><span class="line">O    343.0</span><br><span class="line">Q    340.0</span><br><span class="line">M    338.0</span><br><span class="line">J    337.0</span><br><span class="line">F    335.0</span><br><span class="line">K    334.0</span><br><span class="line">H    330.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="将数据写出到文本格式">将数据写出到文本格式</h2>
<h3 id="to_csv">to_csv</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [43]: data.to_csv(&#x27;examples/out.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [44]: !cat examples/out.csv</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line">0,one,1,2,3.0,4,</span><br><span class="line">1,two,5,6,,8,world</span><br><span class="line">2,three,9,10,11.0,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="使用其他分隔符">使用其他分隔符</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [45]: import sys</span><br><span class="line"></span><br><span class="line">In [46]: data.to_csv(sys.stdout, sep=&#x27;|&#x27;)</span><br><span class="line">|something|a|b|c|d|message</span><br><span class="line">0|one|1|2|3.0|4|</span><br><span class="line">1|two|5|6||8|world</span><br><span class="line">2|three|9|10|11.0|12|foo</span><br></pre></td></tr></table></figure>
<h4 id="禁用行和列的标签">禁用行和列的标签</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [48]: data.to_csv(sys.stdout, index=False, header=False)</span><br><span class="line">one,1,2,3.0,4,</span><br><span class="line">two,5,6,,8,world</span><br><span class="line">three,9,10,11.0,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="操作指定列">操作指定列</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [49]: data.to_csv(sys.stdout, index=False, columns=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line">a,b,c</span><br><span class="line">1,2,3.0</span><br><span class="line">5,6,</span><br><span class="line">9,10,11.0</span><br></pre></td></tr></table></figure>
<h2 id="处理分隔符格式">处理分隔符格式</h2>
<p>对于任何单字符分隔符文件，可以直接使用Python内置的csv模块。将任意已打开的文件或文件型的对象传给csv.reader：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">f = open(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">reader = csv.reader(f)</span><br></pre></td></tr></table></figure>
<p><font color = "red">对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In [56]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">   ....:     <span class="built_in">print</span>(line)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="创建数据列的字典">创建数据列的字典</h3>
<p>首先解释zip的作用：</p>
<p>zip()
函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>举例1：</p>
<p>a = [1,2,3]</p>
<p>b = [4,5,6]</p>
<p>c = [4,5,6,7,8]</p>
<p>ipped = zip(a,b) # 打包为元组的列表</p>
<p>输出：[(1, 4), (2, 5), (3, 6)]</p>
<p>举例2：</p>
<p><code>zip(*values)</code>的作用是将<code>values</code>列表中的元素解压缩为多个独立的元组，然后将这些元组组合在一起成为一个迭代器。</p>
<p>具体来说，假设<code>values</code>列表是一个包含多个元组的列表，例如<code>[(v1_1, v2_1, ...), (v1_2, v2_2, ...), ...]</code>，<code>zip(*values)</code>会将这些元组解压缩并重新组合，将它们的第一个元素组成一个元组，第二个元素组成一个元组，依此类推</p>
<p>具体使用：</p>
<p>首先，读取文件到一个多行的列表中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [57]: with open(&#x27;examples/ex7.csv&#x27;) as f:</span><br><span class="line">   ....:     lines = list(csv.reader(f))</span><br></pre></td></tr></table></figure>
<p>然后，我们将这些行分为标题行和数据行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [58]: header, values = lines[0], lines[1:]</span><br></pre></td></tr></table></figure>
<p>接着，我们可以用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [59]: data_dict = &#123;h: v for h, v in zip(header, zip(*values))&#125;</span><br><span class="line"></span><br><span class="line">In [60]: data_dict</span><br><span class="line">Out[60]: &#123;&#x27;a&#x27;: (&#x27;1&#x27;, &#x27;1&#x27;), &#x27;b&#x27;: (&#x27;2&#x27;, &#x27;2&#x27;), &#x27;c&#x27;: (&#x27;3&#x27;, &#x27;3&#x27;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义新格式的csv文件">定义新格式的csv文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_dialect(csv.Dialect):</span><br><span class="line">    lineterminator = &#x27;\n&#x27;</span><br><span class="line">    delimiter = &#x27;;&#x27;</span><br><span class="line">    quotechar = &#x27;&quot;&#x27;</span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>lineterminator = '\n'</code>：定义行终止符为换行符
<code>\n</code>。</li>
<li><code>delimiter = ';'</code>：定义字段之间的分隔符为分号
<code>;</code>。</li>
<li><code>quotechar = '"'</code>：定义引号字符为双引号
<code>"</code>，用于包围包含特殊字符的字段。</li>
<li><code>quoting = csv.QUOTE_MINIMAL</code>：定义引用约定为最小引用，表示只在必要时才使用引号。</li>
</ol>
<h2 id="json数据">JSON数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = &quot;&quot;&quot;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Wes&quot;,</span><br><span class="line"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span><br><span class="line"> &quot;pet&quot;: null,</span><br><span class="line"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span><br><span class="line">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span><br><span class="line">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="json.loads">json.loads</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [62]: import json</span><br><span class="line"></span><br><span class="line">In [63]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [64]: result</span><br><span class="line">Out[64]: </span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;Wes&#x27;,</span><br><span class="line"> &#x27;pet&#x27;: None,</span><br><span class="line"> &#x27;places_lived&#x27;: [&#x27;United States&#x27;, &#x27;Spain&#x27;, &#x27;Germany&#x27;],</span><br><span class="line"> &#x27;siblings&#x27;: [&#123;&#x27;age&#x27;: 30, &#x27;name&#x27;: &#x27;Scott&#x27;, &#x27;pets&#x27;: [&#x27;Zeus&#x27;, &#x27;Zuko&#x27;]&#125;,</span><br><span class="line">  &#123;&#x27;age&#x27;: 38, &#x27;name&#x27;: &#x27;Katie&#x27;, &#x27;pets&#x27;: [&#x27;Sixes&#x27;, &#x27;Stache&#x27;, &#x27;Cisco&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="json.dumps">json.dumps</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [65]: asjson = json.dumps(result)</span><br></pre></td></tr></table></figure>
<h3 id="将json转换为dataframe">将json转换为DataFrame</h3>
<p>最简单方便的方式是：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [66]: siblings = pd.DataFrame(result[&#x27;siblings&#x27;], columns=[&#x27;name&#x27;, &#x27;age&#x27;])</span><br><span class="line"></span><br><span class="line">In [67]: siblings</span><br><span class="line">Out[67]: </span><br><span class="line">    name  age</span><br><span class="line">0  Scott   30</span><br><span class="line">1  Katie   38</span><br></pre></td></tr></table></figure>
<h3 id="read_json">read_json</h3>
<p>特别格式的JSON数据集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3&#125;,//里面字典,字典之间用“,”分割</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;]//外边整体列表</span><br></pre></td></tr></table></figure>
<p>自动将特别格式的JSON数据集转换为Series或DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [69]: data = pd.read_json(&#x27;examples/example.json&#x27;)</span><br><span class="line"></span><br><span class="line">In [70]: data</span><br><span class="line">Out[70]: </span><br><span class="line">   a  b  c</span><br><span class="line">0  1  2  3</span><br><span class="line">1  4  5  6</span><br><span class="line">2  7  8  9</span><br></pre></td></tr></table></figure>
<h3 id="to_json">to_json</h3>
<p>将数据从pandas输出到JSON</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [71]: print(data.to_json())</span><br><span class="line">&#123;&quot;a&quot;:&#123;&quot;0&quot;:1,&quot;1&quot;:4,&quot;2&quot;:7&#125;,&quot;b&quot;:&#123;&quot;0&quot;:2,&quot;1&quot;:5,&quot;2&quot;:8&#125;,&quot;c&quot;:&#123;&quot;0&quot;:3,&quot;1&quot;:6,&quot;2&quot;:9&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [72]: print(data.to_json(orient=&#x27;records&#x27;))</span><br><span class="line">[&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;,&#123;&quot;a&quot;:4,&quot;b&quot;:5,&quot;c&quot;:6&#125;,&#123;&quot;a&quot;:7,&quot;b&quot;:8,&quot;c&quot;:9&#125;]</span><br></pre></td></tr></table></figure>
<h1 id="二二进制数据格式">二、二进制数据格式</h1>
<p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p>
<p>to_pickle:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [87]: frame = pd.read_csv(&#x27;examples/ex1.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [88]: frame</span><br><span class="line">Out[88]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br><span class="line"></span><br><span class="line">In [89]: frame.to_pickle(&#x27;examples/frame_pickle&#x27;)</span><br></pre></td></tr></table></figure>
<p>read_pickle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [90]: pd.read_pickle(&#x27;examples/frame_pickle&#x27;)</span><br><span class="line">Out[90]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h2 id="使用hdf5格式">使用HDF5格式</h2>
<h3 id="准备数据集">准备数据集</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&#x27;a&#x27;: np.random.randn(100)&#125;)</span><br></pre></td></tr></table></figure>
<p>创建了一个名为<code>frame</code>的Pandas
DataFrame对象，其中包含一个名为<code>a</code>的列，该列包含了随机生成的100个标准正态分布（均值为0，标准差为1）的随机数值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325061822293.png" /></p>
<h3 id="创建">创建</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store = pd.HDFStore(&#x27;mydata.h5&#x27;)</span><br></pre></td></tr></table></figure>
<p>创建了一个名为<code>store</code>的Pandas
HDFStore对象，并打开了一个名为<code>mydata.h5</code>的HDF5文件。</p>
<h3 id="像python中键值对一样存取">像python中键值对一样存取</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store[&#x27;obj1&#x27;] = frame</span><br><span class="line">store[&#x27;obj1_col&#x27;] = frame[&#x27;a&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="table存储方式">table存储方式</h3>
<p>obj2表示存储的键，frame表示存储的值，format定义存储形式，用table形式存储好处在于可以用特殊语法查询</p>
<h3 id="read_hdf和to_hdf">read_hdf和to_hdf</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame.to_hdf(&#x27;mydata.h5&#x27;, &#x27;obj3&#x27;, format=&#x27;table&#x27;)</span><br></pre></td></tr></table></figure>
<p>将frame中内容保存在mydata.h5的hdf5文件中，对应的键是obj3，形式是table</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [102]: pd.read_hdf(&#x27;mydata.h5&#x27;, &#x27;obj3&#x27;, where=[&#x27;index &lt; 5&#x27;])</span><br><span class="line">Out[102]: </span><br><span class="line">          a</span><br><span class="line">0 -0.204708</span><br><span class="line">1  0.478943</span><br><span class="line">2 -0.519439</span><br><span class="line">3 -0.555730</span><br><span class="line">4  1.965781</span><br></pre></td></tr></table></figure>
<h2 id="读写microsoft-excel文件">读写Microsoft Excel文件</h2>
<h3 id="读取excel文件">读取excel文件</h3>
<h4 id="创建实例">创建实例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [104]: xlsx = pd.ExcelFile(&#x27;examples/ex1.xlsx&#x27;)</span><br></pre></td></tr></table></figure>
<h4
id="通过read_excel读取到dataframe">通过read_excel读取到DataFrame</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [105]: pd.read_excel(xlsx, &#x27;Sheet1&#x27;)</span><br><span class="line">Out[105]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h4 id="根据表单sheet读取">根据表单（sheet）读取</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [106]: frame = pd.read_excel(&#x27;examples/ex1.xlsx&#x27;, &#x27;Sheet1&#x27;)</span><br><span class="line"></span><br><span class="line">In [107]: frame</span><br><span class="line">Out[107]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="写入excel文件">写入excel文件</h3>
<h4 id="创建实例-1">创建实例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(&#x27;examples/ex2.xlsx&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="写入">写入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame.to_excel(writer, &#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="保存">保存</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h2 id="web-apis交互">Web APIs交互</h2>
<h3 id="发送http-get请求">发送HTTP GET请求</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [113]: import requests</span><br><span class="line"></span><br><span class="line">In [114]: url = &#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span><br><span class="line"></span><br><span class="line">In [115]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [116]: resp</span><br><span class="line">Out[116]: &lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<h3
id="将相应返回的json字典加载到python对象中">将相应返回的json字典加载到python对象中</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [117]: data = resp.json()</span><br><span class="line"></span><br><span class="line">In [118]: data[0][&#x27;title&#x27;]</span><br><span class="line">Out[118]: &#x27;Period does not round down for frequencies less that 1 hour&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="通过dataframe提取感兴趣字段">通过DataFrame提取感兴趣字段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">issues = pd.DataFrame(data, columns=[&#x27;number&#x27;, &#x27;title&#x27;, &#x27;labels&#x27;, &#x27;state&#x27;])</span><br><span class="line">issues</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 4%" />
<col style="width: 43%" />
<col style="width: 43%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">number</th>
<th style="text-align: right;">title</th>
<th style="text-align: right;">labels</th>
<th style="text-align: right;">state</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">58019</td>
<td style="text-align: right;">CLN/PERF: Simplify argmin/argmax</td>
<td style="text-align: right;">[{'id': 2822342, 'node_id':
'MDU6TGFiZWwyODIyM...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">58018</td>
<td style="text-align: right;">PERF: Allow Index.to_frame to return
RangeInde...</td>
<td style="text-align: right;">[{'id': 8935311, 'node_id':
'MDU6TGFiZWw4OTM1M...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">58017</td>
<td style="text-align: right;">Docs: Add note about exception for
integer sli...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">58016</td>
<td style="text-align: right;">PERF: Allow np.integer Series/Index to
convert...</td>
<td style="text-align: right;">[{'id': 8935311, 'node_id':
'MDU6TGFiZWw4OTM1M...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">4</td>
<td style="text-align: right;">58015</td>
<td style="text-align: right;">BUG: Behaviour of sum/mean on sparse
boolean a...</td>
<td style="text-align: right;">[{'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td style="text-align: right;">58013</td>
<td style="text-align: right;">Potential regression induced by "CLN:
Enforce ...</td>
<td style="text-align: right;">[{'id': 2822342, 'node_id':
'MDU6TGFiZWwyODIyM...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td style="text-align: right;">58012</td>
<td style="text-align: right;">Add tests for transform sum with
series</td>
<td style="text-align: right;">[{'id': 127685, 'node_id':
'MDU6TGFiZWwxMjc2OD...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">7</td>
<td style="text-align: right;">58011</td>
<td style="text-align: right;">DEPR: enforce deprecation of non-standard
argu...</td>
<td style="text-align: right;">[{'id': 211029535, 'node_id':
'MDU6TGFiZWwyMTE...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8</td>
<td style="text-align: right;">58008</td>
<td style="text-align: right;">Backport PR #57553 on branch 2.2.x (API:
avoid...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">9</td>
<td style="text-align: right;">58007</td>
<td style="text-align: right;">API: Make <code>Series.array</code> a
read-only NumpyExte...</td>
<td style="text-align: right;">[{'id': 2085877452, 'node_id':
'MDU6TGFiZWwyMD...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">10</td>
<td style="text-align: right;">58006</td>
<td style="text-align: right;">CLN: remove unnecessary check
<code>needs_i8_conver... | [&#123;'id': 1218227310, 'node_id': 'MDU6TGFiZWwxMj... | open | |     11 | 58001 |     BUG: Implement</code>fillna(...,
limit=x)<code>for EAs | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     12 | 57999 |           DEPR: Enforce datetimelike deprecations | [&#123;'id': 211029535, 'node_id': 'MDU6TGFiZWwyMTE... | open | |     13 | 57995 | FIX #57645: Cannot use numpy FLS as indicies s... |                                                [] | open | |     14 | 57994 | DOC: DataFrame.reset_index names param can't b... | [&#123;'id': 134699, 'node_id': 'MDU6TGFiZWwxMzQ2OT... | open | |     15 | 57993 | BUG: Nones in pd.concat MultiIndex keys are no... | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     16 | 57990 | DOC: ecosystem.md: add pygwalker, add seaborn ... | [&#123;'id': 134699, 'node_id': 'MDU6TGFiZWwxMzQ2OT... | open | |     17 | 57989 |  BUG: CONTAINS_OP run on pd.NA results in pd.N... | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     18 | 57988 | PERF: (partial) fix for np_datetime.c performa... | [&#123;'id': 8935311, 'node_id': 'MDU6TGFiZWw4OTM1M... | open | |     19 | 57987 |              DEPR: 'epoch' date format in to_json | [&#123;'id': 49379259, 'node_id': 'MDU6TGFiZWw0OTM3... | open | |     20 | 57986 | CLN: enforce deprecation of frequencies deprec... | [&#123;'id': 53181044, 'node_id': 'MDU6TGFiZWw1MzE4... | open | |     21 | 57985 | BUG: Fix error for</code>boxplot<code>when using a pre-... |                                                [] | open | |     22 | 57984 | Fix</code>to_timedelta<code></code>np.int32`
casting bug with...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">23</td>
<td style="text-align: right;">57980</td>
<td style="text-align: right;">BUG: Unexpected Styler.format
behavior</td>
<td style="text-align: right;">[&#123;'id': 1728592794, 'node_id':
'MDU6TGFiZWwxNz...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">24</td>
<td style="text-align: right;">57979</td>
<td style="text-align: right;">ENH: Add leftsemi merge</td>
<td style="text-align: right;">[&#123;'id': 76812, 'node_id':
'MDU6TGFiZWw3NjgxMg=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">25</td>
<td style="text-align: right;">57976</td>
<td style="text-align: right;">ENH: set <strong>module</strong> for
objects in pandas Scal...</td>
<td style="text-align: right;">[&#123;'id': 13101118, 'node_id':
'MDU6TGFiZWwxMzEw...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">26</td>
<td style="text-align: right;">57974</td>
<td style="text-align: right;">BUG: Fixed ADBC to_sql creation of table
when ...</td>
<td style="text-align: right;">[&#123;'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">27</td>
<td style="text-align: right;">57972</td>
<td style="text-align: right;">BUG: Wrong kurtosis outcome due to
inadequate ...</td>
<td style="text-align: right;">[&#123;'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">28</td>
<td style="text-align: right;">57968</td>
<td style="text-align: right;">BUG: #57954 encoding ignored for
filelike</td>
<td style="text-align: right;">[&#123;'id': 42670965, 'node_id':
'MDU6TGFiZWw0MjY3...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">29</td>
<td style="text-align: right;">57967</td>
<td style="text-align: right;">BUG: 7023 allow style when using error
bars</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
</tbody>
</table>
<h2 id="数据库交互">数据库交互</h2>
<h3 id="将数据从sql加载到dataframe">将数据从SQL加载到DataFrame</h3>
<h4 id="创建表">创建表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query = &quot;&quot;&quot;</span><br><span class="line">CREATE TABLE test</span><br><span class="line">(a VARCHAR(20), b VARCHAR(20),</span><br><span class="line">c REAL,        d INTEGER</span><br><span class="line">);</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>一个SQL查询语句，用于创建一个名为<code>test</code>的表。该表包含了四个列，分别是<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>，对应的数据类型分别为VARCHAR(20)、VARCHAR(20)、REAL和INTEGER。</p>
<h4 id="创建到数据库的连接">创建到数据库的连接</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con = sqlite3.connect(&#x27;mydata.sqlite&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="执行在sql中创建表">执行在sql中创建表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.execute(query)</span><br></pre></td></tr></table></figure>
<h4 id="将修改提交到数据库">将修改提交到数据库</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
<h4 id="创建用于插入的数据">创建用于插入的数据</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = [(&#x27;Atlanta&#x27;, &#x27;Georgia&#x27;, 1.25, 6),</span><br><span class="line">(&#x27;Tallahassee&#x27;, &#x27;Florida&#x27;, 2.6, 3),</span><br><span class="line">(&#x27;Sacramento&#x27;, &#x27;California&#x27;, 1.7, 5)]</span><br></pre></td></tr></table></figure>
<h4 id="sql-插入语句的模板">SQL 插入语句的模板</h4>
<p>使用了参数化查询的形式，其中 <code>?</code>
是占位符，表示待插入的值将在执行查询时动态地填充到相应的位置上。这种参数化查询的方式可以防止
SQL 注入攻击，并且使得查询更加灵活和可维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stmt = &quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="sql插入操作">SQL插入操作</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.executemany(stmt, data)</span><br></pre></td></tr></table></figure>
<h4 id="sql-查询">SQL 查询</h4>
<p>创建了一个游标对象 <code>cursor</code>，并使用 <code>execute</code>
方法执行了一个 SQL 查询操作，从 <code>test</code>
表中选择所有的行和列。执行这个操作后，游标 <code>cursor</code>
将会指向查询结果的第一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor = con.execute(&#x27;select * from test&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="获取查询结果">获取查询结果</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rows = cursor.fetchall()</span><br><span class="line">rows</span><br></pre></td></tr></table></figure>
<p>调用了游标对象 <code>cursor</code> 的 <code>fetchall()</code>
方法，用于获取执行 SQL
查询后返回的所有结果行。这将返回一个包含所有结果行的列表
<code>rows</code>。</p>
<h4 id="返回描述列的元祖项的集合">返回描述列的元祖项的集合</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor.description</span><br></pre></td></tr></table></figure>
<p>返回一个包含查询结果的元数据的元组，其中每个元组项描述了结果集中的一个列。每个元组项通常包含列的名称、数据类型、宽度、精度</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-数据清洗</title>
    <url>/posts/ad398b17.html</url>
    <content><![CDATA[<h1 id="处理缺失数据">处理缺失数据</h1>
<span id="more"></span>
<p>对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据</p>
<h2 id="初始化数据">初始化数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [10]: string_data = pd.Series([&#x27;aardvark&#x27;, &#x27;artichoke&#x27;, np.nan, &#x27;avocado&#x27;])</span><br><span class="line"></span><br><span class="line">In [11]: string_data</span><br><span class="line">Out[11]:</span><br><span class="line">0     aardvark</span><br><span class="line">1    artichoke</span><br><span class="line">2          NaN</span><br><span class="line">3      avocado</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h2 id="isnull">isnull()</h2>
<p>判断当前数据是否是缺失值，是就返回true，否就返回false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [12]: string_data.isnull()</span><br><span class="line">Out[12]: </span><br><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h2 id="利用索引直接置为none">利用索引直接置为None</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [13]: string_data[0] = None</span><br><span class="line"></span><br><span class="line">In [14]: string_data.isnull()</span><br><span class="line">Out[14]: </span><br><span class="line">0     True</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h2 id="滤除缺失数据">滤除缺失数据</h2>
<h3 id="dropna">dropna</h3>
<h4 id="对于series">对于Series</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330064314334.png" /></p>
<p>等价于data[data.notnull()]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [18]: data[data.notnull()]</span><br><span class="line">Out[18]: </span><br><span class="line">0    1.0</span><br><span class="line">2    3.5</span><br><span class="line">4    7.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h4 id="对于dataframe">对于DataFrame</h4>
<h5 id="默认丢弃任何含有缺失值的行">默认丢弃任何含有缺失值的行：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [19]: data = pd.DataFrame([[1., 6.5, 3.], [1., NA, NA],</span><br><span class="line">   ....:                      [NA, NA, NA], [NA, 6.5, 3.]])</span><br><span class="line"></span><br><span class="line">In [20]: cleaned = data.dropna()</span><br><span class="line"></span><br><span class="line">In [21]: data</span><br><span class="line">Out[21]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br><span class="line"></span><br><span class="line">In [22]: cleaned</span><br><span class="line">Out[22]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br></pre></td></tr></table></figure>
<h5
id="传入howall将只丢弃全为na的那些行">传入how='all'将只丢弃全为NA的那些行：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [23]: data.dropna(how=&#x27;all&#x27;)</span><br><span class="line">Out[23]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
<h5 id="丢弃全为na的列传入axis1即可">丢弃全为NA的列，传入axis=1即可</h5>
<p>先添加第四列为全NA的列：data[4] = NA</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330065154332.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: data.dropna(axis=1, how=&#x27;all&#x27;)</span><br><span class="line">Out[26]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
<p>利用thresh参数删除指定确实个数的行</p>
<p>用切片将不用观察的行和列之间赋值NA，然后再用默认dropna丢弃</p>
<p>切片赋值NA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n [27]: df = pd.DataFrame(np.random.randn(7, 3))</span><br><span class="line"></span><br><span class="line">In [28]: df.iloc[:4, 1] = NA</span><br><span class="line"></span><br><span class="line">In [29]: df.iloc[:2, 2] = NA</span><br><span class="line"></span><br><span class="line">In [30]: df</span><br><span class="line">Out[30]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708       NaN       NaN</span><br><span class="line">1 -0.555730       NaN       NaN</span><br><span class="line">2  0.092908       NaN  0.769023</span><br><span class="line">3  1.246435       NaN -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [31]: df.dropna()</span><br><span class="line">Out[31]: </span><br><span class="line">          0         1         2</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h2 id="填充缺失数据">填充缺失数据</h2>
<p>主要使用fillna这个方法</p>
<h3 id="将缺失值替换为指定的常数值">将缺失值替换为指定的常数值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [33]: df.fillna(0)</span><br><span class="line">Out[33]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.000000  0.000000</span><br><span class="line">1 -0.555730  0.000000  0.000000</span><br><span class="line">2  0.092908  0.000000  0.769023</span><br><span class="line">3  1.246435  0.000000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="通过字典对不同的列填充不同的值">通过字典对不同的列填充不同的值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [34]: df.fillna(&#123;1: 0.5, 2: 0&#125;)</span><br><span class="line">Out[34]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.500000  0.000000</span><br><span class="line">1 -0.555730  0.500000  0.000000</span><br><span class="line">2  0.092908  0.500000  0.769023</span><br><span class="line">3  1.246435  0.500000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="默认会返回新对象但也可以对现有对象进行就地修改">默认会返回新对象，但也可以对现有对象进行就地修改</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [35]: _ = df.fillna(0, inplace=True)</span><br><span class="line"></span><br><span class="line">In [36]: df</span><br><span class="line">Out[36]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.000000  0.000000</span><br><span class="line">1 -0.555730  0.000000  0.000000</span><br><span class="line">2  0.092908  0.000000  0.769023</span><br><span class="line">3  1.246435  0.000000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="对reindexing有效的那些插值方法也可用于fillna">对reindexing有效的那些插值方法也可用于fillna：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [37]: df = pd.DataFrame(np.random.randn(6, 3))</span><br><span class="line"></span><br><span class="line">In [38]: df.iloc[2:, 1] = NA</span><br><span class="line"></span><br><span class="line">In [39]: df.iloc[4:, 2] = NA</span><br><span class="line"></span><br><span class="line">In [40]: df</span><br><span class="line">Out[40]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772       NaN  1.343810</span><br><span class="line">3 -0.713544       NaN -2.370232</span><br><span class="line">4 -1.860761       NaN       NaN</span><br><span class="line">5 -1.265934       NaN       NaN</span><br><span class="line"></span><br><span class="line">In [41]: df.fillna(method=&#x27;ffill&#x27;)</span><br><span class="line">Out[41]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772  0.124121  1.343810</span><br><span class="line">3 -0.713544  0.124121 -2.370232</span><br><span class="line">4 -1.860761  0.124121 -2.370232</span><br><span class="line">5 -1.265934  0.124121 -2.370232</span><br><span class="line"></span><br><span class="line">In [42]: df.fillna(method=&#x27;ffill&#x27;, limit=2)</span><br><span class="line">Out[42]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772  0.124121  1.343810</span><br><span class="line">3 -0.713544  0.124121 -2.370232</span><br><span class="line">4 -1.860761       NaN -2.370232</span><br><span class="line">5 -1.265934       NaN -2.370232</span><br></pre></td></tr></table></figure>
<h3 id="传入series的平均值或中位数">传入Series的平均值或中位数：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [43]: data = pd.Series([1., NA, 3.5, NA, 7])</span><br><span class="line"></span><br><span class="line">In [44]: data.fillna(data.mean())</span><br><span class="line">Out[44]: </span><br><span class="line">0    1.000000</span><br><span class="line">1    3.833333</span><br><span class="line">2    3.500000</span><br><span class="line">3    3.833333</span><br><span class="line">4    7.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h1 id="数据转换">数据转换</h1>
<h2 id="移除重复数据">移除重复数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [45]: data = pd.DataFrame(&#123;&#x27;k1&#x27;: [&#x27;one&#x27;, &#x27;two&#x27;] * 3 + [&#x27;two&#x27;],</span><br><span class="line">   ....:                      &#x27;k2&#x27;: [1, 1, 2, 3, 3, 4, 4]&#125;)</span><br><span class="line"></span><br><span class="line">In [46]: data</span><br><span class="line">Out[46]: </span><br><span class="line">    k1  k2</span><br><span class="line">0  one   1</span><br><span class="line">1  two   1</span><br><span class="line">2  one   2</span><br><span class="line">3  two   3</span><br><span class="line">4  one   3</span><br><span class="line">5  two   4</span><br><span class="line">6  two   4</span><br></pre></td></tr></table></figure>
<h3 id="duplicated方法">duplicated方法</h3>
<p>表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [47]: data.duplicated()</span><br><span class="line">Out[47]: </span><br><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5    False</span><br><span class="line">6     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h3 id="drop_duplicates方法">drop_duplicates方法</h3>
<p>指定部分列进行重复项判断。假设我们还有一列值，且只希望根据k1列过滤重复项：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401064533732.png" /></p>
<p>duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [51]: data.drop_duplicates([&#x27;k1&#x27;, &#x27;k2&#x27;], keep=&#x27;last&#x27;)</span><br><span class="line">Out[51]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line">0  one   1   0</span><br><span class="line">1  two   1   1</span><br><span class="line">2  one   2   2</span><br><span class="line">3  two   3   3</span><br><span class="line">4  one   3   4</span><br><span class="line">6  two   4   6</span><br></pre></td></tr></table></figure>
<h2
id="利用函数或映射进行数据转换主要使用map">利用函数或映射进行数据转换(主要使用map)</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [52]: data = pd.DataFrame(&#123;&#x27;food&#x27;: [&#x27;bacon&#x27;, &#x27;pulled pork&#x27;, &#x27;bacon&#x27;,</span><br><span class="line">   ....:                               &#x27;Pastrami&#x27;, &#x27;corned beef&#x27;, &#x27;Bacon&#x27;,</span><br><span class="line">   ....:                               &#x27;pastrami&#x27;, &#x27;honey ham&#x27;, &#x27;nova lox&#x27;],</span><br><span class="line">   ....:                      &#x27;ounces&#x27;: [4, 3, 12, 6, 7.5, 8, 3, 5, 6]&#125;)</span><br><span class="line"></span><br><span class="line">In [53]: data</span><br><span class="line">Out[53]: </span><br><span class="line">          food  ounces</span><br><span class="line">0        bacon     4.0</span><br><span class="line">1  pulled pork     3.0</span><br><span class="line">2        bacon    12.0</span><br><span class="line">3     Pastrami     6.0</span><br><span class="line">4  corned beef     7.5</span><br><span class="line">5        Bacon     8.0</span><br><span class="line">6     pastrami     3.0</span><br><span class="line">7    honey ham     5.0</span><br><span class="line">8     nova lox     6.0</span><br></pre></td></tr></table></figure>
<p>添加一列表示该肉类食物来源的动物类型</p>
<p>编写一个不同肉类到动物的映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  &#x27;bacon&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;pulled pork&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;pastrami&#x27;: &#x27;cow&#x27;,</span><br><span class="line">  &#x27;corned beef&#x27;: &#x27;cow&#x27;,</span><br><span class="line">  &#x27;honey ham&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;nova lox&#x27;: &#x27;salmon&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用map前，有些肉类肉类首字母大写，比如前面0 bacon和5
Bacon，所以需要先转换成小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [55]: lowercased = data[&#x27;food&#x27;].str.lower()</span><br><span class="line"></span><br><span class="line">In [56]: lowercased</span><br><span class="line">Out[56]: </span><br><span class="line">0          bacon</span><br><span class="line">1    pulled pork</span><br><span class="line">2          bacon</span><br><span class="line">3       pastrami</span><br><span class="line">4    corned beef</span><br><span class="line">5          bacon</span><br><span class="line">6       pastrami</span><br><span class="line">7      honey ham</span><br><span class="line">8       nova lox</span><br><span class="line">Name: food, dtype: object</span><br></pre></td></tr></table></figure>
<p>然后使用字典形式在原先data基础上再加1列，用map实现肉类与肉类动物来源一一对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [57]: data[&#x27;animal&#x27;] = lowercased.map(meat_to_animal)</span><br><span class="line"></span><br><span class="line">In [58]: data</span><br><span class="line">Out[58]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line">0        bacon     4.0     pig</span><br><span class="line">1  pulled pork     3.0     pig</span><br><span class="line">2        bacon    12.0     pig</span><br><span class="line">3     Pastrami     6.0     cow</span><br><span class="line">4  corned beef     7.5     cow</span><br><span class="line">5        Bacon     8.0     pig</span><br><span class="line">6     pastrami     3.0     cow</span><br><span class="line">7    honey ham     5.0     pig</span><br><span class="line">8     nova lox     6.0  salmon</span><br></pre></td></tr></table></figure>
<p>一个能够完成全部这些工作的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [59]: data[&#x27;food&#x27;].map(lambda x: meat_to_animal[x.lower()])</span><br><span class="line">Out[59]: </span><br><span class="line">0       pig</span><br><span class="line">1       pig</span><br><span class="line">2       pig</span><br><span class="line">3       cow</span><br><span class="line">4       cow</span><br><span class="line">5       pig</span><br><span class="line">6       cow</span><br><span class="line">7       pig</span><br><span class="line">8    salmon</span><br><span class="line">Name: food, dtype: object</span><br></pre></td></tr></table></figure>
<h2 id="替换值主要使用replace">替换值(主要使用replace)</h2>
<p>map可用于修改对象的数据子集，而replace则提供了一种实现该功能的更简单、更灵活的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [60]: data = pd.Series([1., -999., 2., -999., -1000., 3.])</span><br><span class="line"></span><br><span class="line">In [61]: data</span><br><span class="line">Out[61]: </span><br><span class="line">0       1.0</span><br><span class="line">1    -999.0</span><br><span class="line">2       2.0</span><br><span class="line">3    -999.0</span><br><span class="line">4   -1000.0</span><br><span class="line">5       3.0</span><br></pre></td></tr></table></figure>
<p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为pandas能够理解的NA值，我们可以利用replace来产生一个新的Series（除非传入inplace=True）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [62]: data.replace(-999, np.nan)</span><br><span class="line">Out[62]: </span><br><span class="line">0       1.0</span><br><span class="line">1       NaN</span><br><span class="line">2       2.0</span><br><span class="line">3       NaN</span><br><span class="line">4   -1000.0</span><br><span class="line">5       3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="一次性替换多个值">一次性替换多个值</h3>
<p>可以传入一个由待替换值组成的列表以及一个替换值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [63]: data.replace([-999, -1000], np.nan)</span><br><span class="line">Out[63]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    NaN</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="每个值有不同的替换值">每个值有不同的替换值</h3>
<p>可以传递一个替换列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [64]: data.replace([-999, -1000], [np.nan, 0])</span><br><span class="line">Out[64]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入的参数也可以是字典：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [65]: data.replace(&#123;-999: np.nan, -1000: 0&#125;)</span><br><span class="line">Out[65]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换。我们会在后面学习Series的字符串方法。</p>
</blockquote>
<h2 id="重命名轴索引">重命名轴索引</h2>
<p>跟Series中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构</p>
<h3 id="data.index中map">data.index中map</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [66]: data = pd.DataFrame(np.arange(12).reshape((3, 4)),</span><br><span class="line">   ....:                     index=[&#x27;Ohio&#x27;, &#x27;Colorado&#x27;, &#x27;New York&#x27;],</span><br><span class="line">   ....:                     columns=[&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;])</span><br></pre></td></tr></table></figure>
<h4 id="使用匿名函数实现修改所有列">使用匿名函数实现修改所有列</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">one</th>
<th style="text-align: right;">two</th>
<th style="text-align: right;">three</th>
<th style="text-align: right;">four</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Ohio</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td>3</td>
</tr>
<tr class="even">
<td style="text-align: right;">Colorado</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td>7</td>
</tr>
<tr class="odd">
<td style="text-align: right;">New York</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td>11</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [67]: transform = lambda x: x[:4].upper()</span><br><span class="line"></span><br><span class="line">In [68]: data.index.map(transform)</span><br><span class="line">Out[68]: Index([&#x27;OHIO&#x27;, &#x27;COLO&#x27;, &#x27;NEW &#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="就地修改">就地修改</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [69]: data.index = data.index.map(transform)</span><br><span class="line"></span><br><span class="line">In [70]: data</span><br><span class="line">Out[70]:</span><br><span class="line">one  two  three  four</span><br><span class="line">OHIO    0    1      2     3</span><br><span class="line">COLO    4    5      6     7</span><br><span class="line">NEW     8    9     10    11</span><br></pre></td></tr></table></figure>
<h3 id="rename">rename</h3>
<h4 id="创建转换版不修改原式数据">创建转换版不修改原式数据</h4>
<p>创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [71]: data.rename(index=str.title, columns=str.upper)</span><br><span class="line">Out[71]: </span><br><span class="line">      ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio    0    1      2     3</span><br><span class="line">Colo    4    5      6     7</span><br><span class="line">New     8    9     10    11</span><br></pre></td></tr></table></figure>
<h4 id="部分轴标签的更新">部分轴标签的更新：</h4>
<p>用字典指明将原来换成对应的什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [72]: data.rename(index=&#123;&#x27;OHIO&#x27;: &#x27;INDIANA&#x27;&#125;,</span><br><span class="line">   ....:             columns=&#123;&#x27;three&#x27;: &#x27;peekaboo&#x27;&#125;)</span><br><span class="line">Out[72]:</span><br><span class="line">one  two  peekaboo  four</span><br><span class="line">INDIANA    0    1         2     3</span><br><span class="line">COLO       4    5         6     7</span><br><span class="line">NEW        8    9        10    11</span><br></pre></td></tr></table></figure>
<h4 id="就地修改-1">就地修改</h4>
<p>inplace=True</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [73]: data.rename(index=&#123;&#x27;OHIO&#x27;: &#x27;INDIANA&#x27;&#125;, inplace=True)</span><br><span class="line"></span><br><span class="line">In [74]: data</span><br><span class="line">Out[74]: </span><br><span class="line">         one  two  three  four</span><br><span class="line">INDIANA    0    1      2     3</span><br><span class="line">COLO       4    5      6     7</span><br><span class="line">NEW        8    9     10    11</span><br></pre></td></tr></table></figure>
<h2 id="检测和过滤异常值">检测和过滤异常值</h2>
<p>一个含有正态分布数据的DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [92]: data = pd.DataFrame(np.random.randn(1000, 4))</span><br><span class="line"></span><br><span class="line">In [93]: data.describe()</span><br><span class="line">Out[93]: </span><br><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean      0.049091     0.026112    -0.002544    -0.051827</span><br><span class="line">std       0.996947     1.007458     0.995232     0.998311</span><br><span class="line">min      -3.645860    -3.184377    -3.745356    -3.428254</span><br><span class="line">25%      -0.599807    -0.612162    -0.687373    -0.747478</span><br><span class="line">50%       0.047101    -0.013609    -0.022158    -0.088274</span><br><span class="line">75%       0.756646     0.695298     0.699046     0.623331</span><br><span class="line">max       2.653656     3.525865     2.735527     3.366626</span><br></pre></td></tr></table></figure>
<h3 id="在列中找指定范围的值">在列中找指定范围的值</h3>
<p>找出某列中绝对值大小超过3的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [94]: col = data[2]</span><br><span class="line"></span><br><span class="line">In [95]: col[np.abs(col) &gt; 3]</span><br><span class="line">Out[95]: </span><br><span class="line">41    -3.399312</span><br><span class="line">136   -3.745356</span><br><span class="line">Name: 2, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="挑选指定行any">挑选指定行，any</h3>
<p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型DataFrame中使用any方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [96]: data[(np.abs(data) &gt; 3).any(1)]</span><br><span class="line">Out[96]: </span><br><span class="line">            0         1         2         3</span><br><span class="line">41   0.457246 -0.025907 -3.399312 -0.974657</span><br><span class="line">60   1.951312  3.260383  0.963301  1.201206</span><br><span class="line">136  0.508391 -0.196713 -3.745356 -1.520113</span><br><span class="line">235 -0.242459 -3.056990  1.918403 -0.578828</span><br><span class="line">258  0.682841  0.326045  0.425384 -3.428254</span><br><span class="line">322  1.179227 -3.184377  1.369891 -1.074833</span><br><span class="line">544 -3.548824  1.553205 -2.186301  1.277104</span><br><span class="line">635 -0.578093  0.193299  1.397822  3.366626</span><br><span class="line">782 -0.207434  3.525865  0.283070  0.544635</span><br><span class="line">803 -3.645860  0.255475 -0.549574 -1.907459</span><br></pre></td></tr></table></figure>
<p>any(1)表示每一行，any(0)表示每一列</p>
<h3 id="限制值的范围">限制值的范围</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [97]: data[np.abs(data) &gt; 3] = np.sign(data) * 3</span><br><span class="line"></span><br><span class="line">In [98]: data.describe()</span><br><span class="line">Out[98]: </span><br><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean      0.050286     0.025567    -0.001399    -0.051765</span><br><span class="line">std       0.992920     1.004214     0.991414     0.995761</span><br><span class="line">min      -3.000000    -3.000000    -3.000000    -3.000000</span><br><span class="line">25%      -0.599807    -0.612162    -0.687373    -0.747478</span><br><span class="line">50%       0.047101    -0.013609    -0.022158    -0.088274</span><br><span class="line">75%       0.756646     0.695298     0.699046     0.623331</span><br><span class="line">max       2.653656     3.000000     2.735527     3.000000</span><br></pre></td></tr></table></figure>
<p>根据数据的值是正还是负，np.sign(data)可以生成1和-1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [99]: np.sign(data).head()</span><br><span class="line">Out[99]: </span><br><span class="line">     0    1    2    3</span><br><span class="line">0 -1.0  1.0 -1.0  1.0</span><br><span class="line">1  1.0 -1.0  1.0 -1.0</span><br><span class="line">2  1.0  1.0  1.0 -1.0</span><br><span class="line">3 -1.0 -1.0  1.0 -1.0</span><br><span class="line">4 -1.0  1.0 -1.0 -1.0</span><br></pre></td></tr></table></figure>
<h2 id="计算指标哑变量">计算指标/哑变量</h2>
<h3 id="get_dummies">get_dummies</h3>
<h4 id="实现独热编码">实现独热编码</h4>
<p>独热编码就是用来表示当前这个数据点属于什么类，如果是这个类对应位置就是1，不是这个类对应位置就是0.</p>
<p>下面这个例子是对key这一列进行独热编码。以第0行为例。第0行是b，所以在独热矩阵中第0行，b对应的列是1，a和c对应的列是0，表示第一行表示的数是b</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403055529559.png" /></p>
<h4 id="加前缀">加前缀</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403060851823.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [112]: df_with_dummy = df[[&#x27;data1&#x27;]].join(dummies)</span><br><span class="line"></span><br><span class="line">In [113]: df_with_dummy</span><br><span class="line">Out[113]: </span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line">0      0      0      1      0</span><br><span class="line">1      1      0      1      0</span><br><span class="line">2      2      1      0      0</span><br><span class="line">3      3      0      0      1</span><br><span class="line">4      4      1      0      0</span><br><span class="line">5      5      0      1      0</span><br></pre></td></tr></table></figure>
<h3 id="movielens-1m数据集">MovieLens 1M数据集：</h3>
<h4 id="读取">读取</h4>
<p>利用read_table，从路径下读取文件，其中以"::"作为分隔符，列名不用原来的列名，而用之前规定好的列名</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403063124153.png" /></p>
<h4
id="从数据集中抽取出不同的genre值">从数据集中抽取出不同的genre值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: all_genres = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">   .....:     all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: genres = pd.unique(all_genres)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [120]: genres</span><br><span class="line">Out[120]: </span><br><span class="line">array([&#x27;Animation&#x27;, &quot;Children&#x27;s&quot;, &#x27;Comedy&#x27;, &#x27;Adventure&#x27;, &#x27;Fantasy&#x27;,</span><br><span class="line">       &#x27;Romance&#x27;, &#x27;Drama&#x27;, &#x27;Action&#x27;, &#x27;Crime&#x27;, &#x27;Thriller&#x27;,&#x27;Horror&#x27;,</span><br><span class="line">       &#x27;Sci-Fi&#x27;, &#x27;Documentary&#x27;, &#x27;War&#x27;, &#x27;Musical&#x27;, &#x27;Mystery&#x27;, &#x27;Film-Noir&#x27;,</span><br><span class="line">       &#x27;Western&#x27;], dtype=object)</span><br></pre></td></tr></table></figure>
<h4 id="构建指标dataframe">构建指标DataFrame</h4>
<h5 id="首先从全零开始">首先从全零开始</h5>
<p>全零矩阵的行是之前读取的电影部数，列是之前抽取的genre值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zero_matrix = np.zeros((len(movies), len(genres)))</span><br><span class="line">dummies = pd.DataFrame(zero_matrix, columns=genres)</span><br><span class="line">dummies</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403064032847.png" /></p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>汇编常用脚本</title>
    <url>/posts/4e8adcf4.html</url>
    <content><![CDATA[<h1 id="通用启动模版">通用启动模版</h1>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 定义数据段</span><br><span class="line">数据段名  SEGMENT</span><br><span class="line">                      </span><br><span class="line">数据段名  ENDS</span><br><span class="line">; 定义堆栈段</span><br><span class="line">堆栈段名  SEGMENT</span><br><span class="line">                      </span><br><span class="line">堆栈段名  ENDS</span><br><span class="line">; 定义代码段</span><br><span class="line">代码段名  SEGMENT</span><br><span class="line">	; 定义映射关系</span><br><span class="line">    ASSUME ┅</span><br><span class="line">START:</span><br><span class="line">	段地址装填</span><br><span class="line">    </span><br><span class="line">    ; 结束扫尾工作</span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H                   </span><br><span class="line">代码段名  ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="判断一个数的正负">判断一个数的正负</h1>
<p><strong>使用指令TEST</strong></p>
<p>TEST功能简介：将两个操作数<font color = "red">进行逻辑与运算，并根据运算结果设置相关的标志位</font>。但是，Test命令的<font color = "yellow">两个操作数<strong>不会</strong>被改变</font>。运算结果在设置过相关标记位后会被丢弃。</p>
<p>作用详细说明</p>
<p>将两个操作数进行按位AND,设结果是TEMP</p>
<ol type="1">
<li>SF =
<font color = "red">将结果的最高位赋给SF标志位</font>，例如结果最高位是1，SF就是1</li>
<li><font color = "red">看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0</font></li>
</ol>
<p>指令书写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEST AL 80H</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>根据补码表示，最高位是符号位，如果符号位是1，那么这个数就是负数。所以选择十六进制中8（二进制表示1000H）作为测试数据。如果寄存器中数据第一位不是1，那么SF=0，ZF
= 1。反之SF=1，ZF = 0</p>
<p><font color = "yellow">上面这个例子体现的是TEST可以比较指定位（设置测试数据中指定位为1），</font>但只能测试1位，多位目前没碰到</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422144353872.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422144420203.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="求一个数的相反数">求一个数的相反数</h1>
<p>所用指令：NEG</p>
<p>指令语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG AX</span><br></pre></td></tr></table></figure>
<h1 id="高精度数的运算">高精度数的运算</h1>
<p>所用指令：ADD,ADC;SUB, SBB</p>
<p>总结</p>
<ol type="1">
<li>用DX、AX表示双精度数</li>
<li>低位用AX，高位用DX</li>
<li>先用非进位运算低位，再用进位运算高位</li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>题1：高精度加减</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX，X       ；用DX，AX来表示双精度数</span><br><span class="line">MOV   DX，X+2     ；低位用AX，高位用DX</span><br><span class="line">ADD    AX，Y       ；先低位运算</span><br><span class="line">ADC    DX，Y+2    ；完成X+Y </span><br><span class="line">ADD    AX，24      ；低位运算</span><br><span class="line">ADC    DX，0       ；高位运算，该语句不能少</span><br><span class="line">SUB     AX，Z      ；先低位减法</span><br><span class="line">SBB      DX，Z+2   ；完成运算</span><br><span class="line">MOV    W，AX      ；存储结果</span><br><span class="line">MOV    W+2，DX</span><br></pre></td></tr></table></figure>
<p>题2：高精度取反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG AX            ; Negate AX if negative</span><br><span class="line">NEG DX            ; Negate DX since DX is higher order word</span><br><span class="line">SBB DX, 0         ; Subtract 1 from DX if borrow occurred from AX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：最后一行很关键，因为取反的本质是用0减，所以存在借位，高精度计算就需要考虑这点</p>
</blockquote>
<hr style = "border:2px solid yellow">
<h1 id="寻址">寻址</h1>
<p>寻址没有什么特别的脚本，但是有一点需要注意</p>
<p>内存与[内存]没有区别</p>
<p>寄存器与[寄存器]有区别</p>
<p>寄存器表示取的是寄存器的地址值</p>
<p>[寄存器]表示取的是寄存器里面的值</p>
<h1 id="寻找最值">寻找最值</h1>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>实验1：熟悉emu8086</title>
    <url>/posts/558433c7.html</url>
    <content><![CDATA[<h1 id="快速入门">快速入门</h1>
<span id="more"></span>
<h2 id="熟悉主控界面">熟悉主控界面</h2>
<h3 id="寄存器栏">寄存器栏</h3>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,1200H</span><br><span class="line">MOV DS,AX </span><br><span class="line">MOV BX,AX</span><br><span class="line">MOV CX,2</span><br><span class="line">MOV DX,09H</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Df421d7aV/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="观察内存的变化">观察内存的变化</h3>
<p>例代码功能：将4行小写字母使用2层循环变成大写</p>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;原理：因为小写字母比大写字母的ASCII值大32，32是2的5次方，即00100000b，</span><br><span class="line">;那么我们就可以将小写字母和11011111b进行and操作，实现小写字母转换成大写。</span><br><span class="line">assume cd:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;ibm             &#x27;</span><br><span class="line">    db &#x27;dec             &#x27;</span><br><span class="line">    db &#x27;dos             &#x27;</span><br><span class="line">    db &#x27;vax             &#x27;  </span><br><span class="line">    dw 0        ;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:</span><br><span class="line">        mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line">        </span><br><span class="line">        mov cx,4</span><br><span class="line">     s0:</span><br><span class="line">    mov ds:[40h],cx  ;将外层循环的cx值保存在datasg：40h单元中</span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,3         ;cx设置为内层循环的次数</span><br><span class="line">        </span><br><span class="line">      s:</span><br><span class="line">    mov al,[bx+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">        </span><br><span class="line">        loop s</span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,ds:[40h]     ;用datasg：40h单元中的值恢复cx</span><br><span class="line">        loop s0  </span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mm421n7PQ/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h3 id="有条件终止">有条件终止</h3>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX，1                     </span><br><span class="line">MOV CX,5</span><br><span class="line"></span><br><span class="line">text:</span><br><span class="line">    ADD AX,1</span><br><span class="line">    </span><br><span class="line">LOOP text</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mj42197Zh/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><a
href="http://www.sund-xys.cn/emu8086%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E7%82%92%E9%B8%A1%E6%96%B0%E6%89%8B%E5%8F%8B%E5%A5%BD%E5%90%91%EF%BC%89/">参考文章</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第一章_汇编语言基础</title>
    <url>/posts/cfbc6a45.html</url>
    <content><![CDATA[<h1 id="计算机系统概述">计算机系统概述</h1>
<span id="more"></span>
<h2 id="硬件">硬件</h2>
<h3 id="中央处理单元cpu">中央处理单元CPU</h3>
<ol type="1">
<li>控制器</li>
<li>运算器</li>
<li>寄存器(最重要)</li>
</ol>
<h3 id="存储器">存储器</h3>
<ol type="1">
<li><p>主存储器：RAM和ROM</p>
<p>主要关心存储器地址</p>
<ol type="1">
<li><p>存储器地址是存储器中存储单元的编号</p></li>
<li><p>每个存储单元存放一个字节量的数据
一个字节B（Byte）＝8个二进制位b（bit）</p></li>
<li><p>采用十六进制数来表达地址</p></li>
</ol>
<p>​ ①Intel 8086具有1兆字节（1MB）存储器容量 ​ ②存储器地址表示为：00000H
～ FFFFFH ​ ③其中大写H（或小写h）表示是十六进制数</p></li>
<li><p>辅助存储器：磁盘，光盘和U盘</p>
<p>主要关心端口(I/O地址)</p>
<ol type="1">
<li><p>I/O地址是接口电路中寄存器的编号</p></li>
<li><p>采用十六进制数来表达端口 ①Intel 8086支持64K个8位端口
②I/O地址可以表示为：0000H ～ FFFFH</p></li>
</ol></li>
</ol>
<h2 id="软件">软件</h2>
<h3 id="系统软件">系统软件</h3>
<h3 id="应用软件">应用软件</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308185821691.png" /></p>
<h1 id="数据表示">数据表示</h1>
<h2 id="bcd码">BCD码</h2>
<p>BCD码在加法运算超过10的时候需要矫正，在原先运算基础上加6</p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/984017b6ecc5d609438bb184f04daf8.jpg" /></p>
<h2 id="有符号数的表示方法">有符号数的表示方法</h2>
<h3 id="原码">原码：</h3>
<p>符号位1表示负数，0表示正数</p>
<h3 id="反码">反码</h3>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<h3 id="补码">补码</h3>
<p>正数的补码就是其本身</p>
<p>负数的补码是在反码的基础上+1</p>
<p><font color = "yellow">取反加1得到负数的绝对值，正数的相反数</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/630ba071fb63fe371f7f4559de2ab93.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>概念判断</p>
<ol type="1">
<li>汇编语言是用符号表示的面向机器的语言，因此它是机器语言。 （ ）</li>
</ol>
<p>错误</p>
<p>汇编语言是一种低级别的编程语言，它使用助记符（例如，<code>MOV</code>、<code>ADD</code>）来表示机器指令，这些指令直接对应于计算机的操作码。机器语言是计算机硬件直接能够理解和执行的二进制指令。</p>
<ol start="2" type="1">
<li>汇编语言是一种高级语言,其程序源代码必须编译成目标代码,程序才能执行。</li>
</ol>
<p>错误</p>
<p>这个说法是<strong>错误的</strong>。汇编语言实际上是一种<strong>低级别的编程语言</strong>，而不是高级语言。让我来解释一下：</p>
<ol type="1">
<li><strong>汇编语言</strong>：
<ul>
<li>汇编语言是一种<strong>符号化的</strong>机器语言。它使用助记符（例如，<code>MOV</code>、<code>ADD</code>）来表示机器指令，这些指令直接对应于计算机的操作码。</li>
<li>程序员编写的汇编程序源代码需要经过<strong>汇编器</strong>的处理，将其转换为机器码（目标代码）。这个过程称为<strong>汇编</strong>。</li>
<li>汇编语言程序不需要像高级语言那样进行完整的编译过程，因为它们已经接近于底层的机器指令。</li>
</ul></li>
<li><strong>高级语言</strong>：
<ul>
<li>高级语言（例如C、Java、Python）是相对于汇编语言的概念。它们更接近人类自然语言，具有更高的抽象级别。</li>
<li>高级语言的程序源代码需要经过<strong>编译器</strong>的处理，将其转换为机器码。这个过程称为<strong>编译</strong>。</li>
<li>高级语言程序的执行不需要直接生成机器码，而是通过解释器或虚拟机来执行。</li>
</ul></li>
</ol>
<p>因此，汇编语言不是高级语言，它不需要完整的编译过程，而是通过汇编器将源代码转换为机器码。高级语言的编译过程更复杂，需要将源代码转换为目标代码，然后再执行。</p>
<ol start="3" type="1">
<li>汇编语言是最快最有效的计算机语言,在自动控制、通信与接口中是必不可少的。
（ ）</li>
</ol>
<p>正确</p>
<ol start="4" type="1">
<li>汇编语言与机器低层关系不大,所以它具有很好的移植性。 ( )</li>
</ol>
<p>错误</p>
<p>虽然汇编语言相对于高级语言来说较低级，但它与机器的关系非常密切，因此移植性并不总是很好</p>
<ol start="5" type="1">
<li>将汇编语言源代码转换成机器目标代码的过程称为编译。 ( )</li>
</ol>
<p>错误</p>
<p><font color = "red">将汇编语言源代码转换成机器目标代码的过程称为<strong>汇编</strong>，而不是编译。</font>让我来解释一下：</p>
<ul>
<li><strong>编译</strong>：
<ul>
<li>编译是将高级语言（例如C、Java）源代码转换为机器目标代码的过程。</li>
<li>编译器将高级语言源代码分析、优化，并生成与目标平台（计算机体系结构和操作系统）兼容的目标代码。</li>
<li>目标代码可以直接在目标平台上执行，而不需要进一步的转换。</li>
</ul></li>
<li><strong>汇编</strong>：
<ul>
<li>汇编是将汇编语言源代码转换为机器目标代码的过程。</li>
<li>汇编器将汇编语言源代码翻译成机器码（操作码），这些指令直接对应于计算机硬件的操作。</li>
<li>汇编语言程序员编写的源代码需要经过汇编器处理，生成可执行的目标代码。</li>
</ul></li>
</ul>
<p>因此，编译是高级语言到目标代码的过程，而汇编是汇编语言到目标代码的过程。</p>
<h1 id="寄存器">8086寄存器</h1>
<p>下面这张图要能背下来</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309105501021.png" /></p>
<h2 id="通用寄存器">通用寄存器</h2>
<h3
id="数据寄存器保存操作数或运算结果">数据寄存器(保存操作数或运算结果)</h3>
<h5 id="累加器ax">累加器AX</h5>
<h5 id="基址寄存器bx">基址寄存器BX</h5>
<h5 id="计数器cx">计数器CX</h5>
<h5 id="数据寄存器dx">数据寄存器DX</h5>
<h3
id="指针寄存器存放某个存储单元的偏移地址">指针寄存器(存放某个存储单元的偏移地址)</h3>
<h4
id="sp堆栈指针寄存器存放堆栈段中栈顶的偏移地址">SP堆栈指针寄存器(存放堆栈段中栈顶的偏移地址)</h4>
<h4
id="bp基址指针寄存器存放堆栈段中某一存储单元的偏移地址">BP基址指针寄存器(存放堆栈段中某一存储单元的偏移地址)</h4>
<h3
id="变址寄存器存放某个存储单元的偏移地址">变址寄存器(存放某个存储单元的偏移地址)</h3>
<h4 id="si源地址变址指针寄存器">SI源地址变址指针寄存器</h4>
<h4 id="di目标地址变址寄存器">DI目标地址变址寄存器</h4>
<h2 id="控制寄存器">控制寄存器</h2>
<h3 id="ip指令指针寄存器">IP指令指针寄存器</h3>
<h3 id="flags标志寄存器">FLAGS标志寄存器</h3>
<h4 id="状态标志">状态标志</h4>
<h5 id="afauxiliary-carry-flag辅助进位标志">AF(Auxiliary carry
Flag)辅助进位标志</h5>
<h5 id="cfcarry-flag进位标志">CF：（Carry Flag）进位标志</h5>
<h5 id="ofoverflow-flag溢出标志">OF（Overflow Flag）溢出标志</h5>
<h5 id="pfparity-flag奇偶标志">PF：（Parity Flag）奇偶标志</h5>
<h5 id="sfsign-flag符号标志">SF（Sign Flag）符号标志</h5>
<h5 id="zfzero-flag零标志">ZF（Zero Flag）零标志</h5>
<h2 id="段寄存器">段寄存器</h2>
<h3 id="cs代码段段寄存器">CS代码段段寄存器</h3>
<h3 id="ds数据段段寄存器">DS数据段段寄存器</h3>
<h3 id="es附加段段寄存器">ES附加段段寄存器</h3>
<h3 id="ss堆栈段段寄存器">SS堆栈段段寄存器</h3>
<h1 id="的存储器组织">8086的存储器组织</h1>
<h2 id="存储单元的地址">存储单元的地址</h2>
<p>每一个字节单元都有一个与之对应的单元地址。</p>
<p>对于<font color = "red">多字节单元（字，双字，4字等），其地址同样是采用最低位字节地址</font>来表示的。</p>
<h2 id="存储单元内容">存储单元内容</h2>
<p>如果X是地址，(X)表示从X地址从取内容</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3ce32cf4927c2ff47e2c099d44e73ec.jpg" /></p>
<p>如果X是地址的地址，取内容用((X))</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9797900060a9c41f8aed43cee8b8465.jpg" /></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308210519536.png" /></p>
<h2 id="存储器地址的分段">存储器地址的分段</h2>
<h3
id="分段基本规则从0地址开始每16个字节为一小段">分段基本规则：从0地址开始，每16个字节为一小段。</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/98860d01c0511f26de2dfa18b5e9051.jpg" /></p>
<h3 id="段地址和偏移地址">段地址和偏移地址</h3>
<p>段地址：表示一个段的开始</p>
<p>偏移地址：在段内相对于段起始地址的偏移值。如当偏移量为‘0’时，就在这个段的起始单元，当偏移量为0FFFFH时，就是这个段（最大）最末一个字节单元。</p>
<h3
id="物理地址和逻辑地址的关系重点">物理地址和逻辑地址的关系(重点)</h3>
<p>常见的组合形式：</p>
<p>段地址：偏移地址(IP)</p>
<p>其中段地址保存的是起始段的首地址，偏移地址(IP)里面保存的是相对于段地址的数据偏移地址空间</p>
<p>段地址有：CS, DS, ES, SS</p>
<p><font color = "red">物理地址=段地址×10H+偏移地址</font></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309093717036.png" /></p>
<h3 id="段地址与段寄存器">段地址与段寄存器</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/685f27bbbf97e9c4ca1d29071730ad2.jpg" /></p>
<h3 id="段分配"><font color = "red">段分配</font></h3>
<p>举例1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/32bbea229e905b0430279f328aaa050.jpg" /></p>
<p>举例2</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/316ac3958e20793b38dea949f3d5969.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/354ddb143d764b0e56bb9d6b116a99d.jpg" /></p>
<h3 id="隐含段和偏移寄存器">隐含段和偏移寄存器</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309105258368.png" /></p>
<p>本章小结</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309110053694.png" /></p>
<p>一图以释之</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/b54e8199a208f025c45f807db50839f.jpg" /></p>
<h1 id="的寻址方式">8086的寻址方式</h1>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="基本格式">基本格式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321105752191.png" /></p>
<p>操作数字段可以为0个、一个、二个或三个。对应的称为零地址指令、一地址指令、二地址指令或三地址指令</p>
<p>典型二地址指令，源操作数和目标操作数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321111124457.png" /></p>
<p>执行的操作： （DST）←（SRC）</p>
<h2 id="数据寻址方式">数据寻址方式</h2>
<p><font color = "red">从最本质的出发看，MOV指令就3种用法</font></p>
<p><font color = "yellow">1. 直接将数据保存到目标寄存器中</font></p>
<p><font color = "yellow">2.
直接将源寄存器中保存的内容转移保存到目标寄存器中</font></p>
<p><font color = "yellow">3.
根据偏移地址计算物理地址再放入寄存器中，只要源操作数带[]，就是这种方法</font></p>
<p><font color = "red">综上，MOV之后目标寄存器里保存的是内容而不是地址！</font></p>
<p>举例：读取地址为10000H这个单元里面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax 1000H</span><br><span class="line">mov ds ax</span><br><span class="line">mov ax [0]</span><br></pre></td></tr></table></figure>
<p><font color = "red">比较重要的点：</font></p>
<p><font color = "yellow">1.
8086CPU中是不支持将数据直接保存到段寄存器的，需要先保存到通用寄存器(AX,
BX, CX, DX), 再保存到段寄存器(CS,DS, ES, SS)</font></p>
<p><font color = "yellow">2.
直接MOV立即数进内存的时候要在内存前加前缀，来指明立即数的位数</font></p>
<p><font color = "yellow">3. MOV不能修改CS和IP这两个寄存器</font></p>
<p>1张图概括</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/addressing_mode.gif" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321105958351.png" /></p>
<h3
id="立即寻址方式形如ax寄存器名称3064h-直接的数">立即寻址方式：（形如AX(寄存器名称)，3064H
直接的数）</h3>
<p>操作数直接存放在指令中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL, 5</span><br><span class="line">MOV  AX, 3064H</span><br><span class="line">MOV  EBX,12345678H</span><br></pre></td></tr></table></figure>
<p><font color = "yellow">其中AL表示的意思是数据寄存器中累加器的低八位</font></p>
<p><font color = "yellow">AX表示数据寄存器中累加器</font></p>
<p><font color = "yellow">EBX表示比8086更高级寄存器中拓展的累加器，8086是16位，拓展后是32位</font></p>
<p>注意： ●
<font color = "red">该寻址方式只能用在SRC（即源操作数）的寻址上，不能用于DST。</font>
● SRC 和 DST 的字长（位数）要一致。</p>
<p>错误指令事例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误的指令：</span><br><span class="line">       MOV    2000H，AX     源操作数和目标操作数位置反了</span><br><span class="line">       MOV    DL，300H      DL是低8位，两个字节，300H，一个数字由4个字节组成，所以说是16进制，3个数字说明是3个字节，长度不等</span><br><span class="line">       MOV    AH，257       AH是累加器中高八位，最大可以放大数字在不考虑符号情况下是255(2^8 = 256)</span><br></pre></td></tr></table></figure>
<p>执行指令举例</p>
<p>【例】：执行指令 MOV AX，5678H</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321112102379.png" /></p>
<h3
id="寄存器寻址方式形如ax目标地址寄存器名称-bx源地址寄存器名称">寄存器寻址方式:(形如AX（目标地址寄存器名称）,
BX（源地址寄存器名称）)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL, CL</span><br><span class="line">MOV  CX, DX</span><br><span class="line">MOV  EAX,EBX </span><br></pre></td></tr></table></figure>
<p>注意： ● SRC 和 DST 的字长（位数）要一致。 ●
<font color = "red">DST不能为CS（代码段寄存器）</font></p>
<p>错误举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误的指令：</span><br><span class="line">       MOV    CS，AX  		CS不能作为目标操作数</span><br><span class="line">       MOV    DL，BX			长度不等</span><br><span class="line">       MOV    SI，EAX		长度不等</span><br></pre></td></tr></table></figure>
<h3
id="直接寻址方式形如ax寄存器名称-2000h内存中保存的数是一个偏移量前面有段就看段没有就默认ds">直接寻址方式（形如AX(寄存器名称)，
[2000H](内存中保存的数，是一个偏移量，前面有段就看段，没有就默认DS）)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321114357850.png" /></p>
<p>默认情况： 物理地址=DS×10H+EA</p>
<p>举例</p>
<pre><code>例如，若指令为  MOV  AX，ES：[VALUE]
则对应该SRC的物理地址为 ES×10H+EA</code></pre>
<p>例题</p>
<p>【例】： 指令 MOV AX, [ 2000H ] ，其中DS=3000H。（32000H） =
3050，该指令执行完后，AX的值。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321115541141.png" /></p>
<p><font color = "red">一种比较容易犯的经典错误</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ce90479ea367fbeef3267fd2ff0b770.jpg" /></p>
<h3
id="寄存器间接寻址方式形如ax寄存器名称-bx作为偏移量的寄存器名称">寄存器间接寻址方式：（形如AX(寄存器名称)，
[BX](作为偏移量的寄存器名称))</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321205557045.png" /></p>
<p>计算物理地址公式：</p>
<p><font color = "yellow">除了BP寄存器默认段地址是SS，其他寄存器默认的段地址都是DS</font></p>
<p>如果<font color = "red">指令中指定的寄存器是BX</font>，没有指出段跨越前缀，则操作数默认放在数据段中，所以用DS寄存器的内容作为段地址，即操作数的物理地址（PA）为：
<font color = "red">PA=DS×10H十BX或SI或DI </font></p>
<p>如果<font color = "red">指令指定BP寄存器</font>，则操作数默认放在堆栈段中，段地址在SS中，即操作数的物理地址为：
<font color = "red">PA=SS×10H十BP</font></p>
<p>与直接寻址方式一样，寄存器间接寻址指令也可<font color = "red">指定段跨越前缀</font>来取得其它段中的数据。对于指定段跨越前缀（如使用ES），则操作数的物理地址为：
<font color = "red">PA=ES×10H十BX或SI或DI </font></p>
<p>举例：</p>
<p>【例】: 分析指令① MOV AX，ES：[BX] ② MOV AX，[BX]<br />
执行后AX的值各是多少？ 已知 DS=2000H，
ES=4000H，BX=0300H，(40300H)=0DE10H ，（20300H）=27ABH 【解】： ①
（确定是ES）源操作数对应的物理地址 =4000H×10H十0300H = 40300H
则执行指令后， AX=0DE10H。 ② （默认是DS）源操作数对应的物理地址
=2000H×10H十0300H = 20300H 则执行指令后， AX=27ABH。</p>
<p>【例】: ADD AX，[BP]<br />
指令执行前： AX=50A0H，BP=0025H， SS=3000H，（30025H）=471AH。
<font color = "red">源操作数对应的物理地址</font> =SS× 10H 十 BP
=3000H×10H十0025H =30025H
<font color = "red">执行指令:(注意，是ADD，要将之前计算出的物理地址内存储的数取出与目标地址原来保存的数相加)</font>
（30025H）+ AX<br />
=471AH+50A0H =97BAH 则指令执行完后，AX=97BAH。</p>
<h3
id="寄存器相对寻址方式形如ax目标寄存器名称disp偏移量1di偏移量2">寄存器相对寻址方式:(形如AX(目标寄存器名称)，DISP(偏移量1)[DI](偏移量2))</h3>
<p><font color = "red">注意：对于8位位移量，计算时要扩展到16位（带符号）。即：对于00H---7FH的数，扩展成16位带符号数时，高8位直接填零，为：0000H---007FH；若为8XH以上的数，扩展后为0FF8XH。</font></p>
<p>举例：</p>
<p>【例】 分析指令 MOV AX，DISP[DI] （或写成MOV AX，[DI+DISP]）
执行后，AX的值。 已知 DS=4000H，DI=2000H，DISP=1000H；设指令执行前：
AX=7C69H，（43000H）=55H，（43001H）=66H。</p>
<p><font color = "red">计算有效地址EA：</font> EA=2000H+1000H=3000H
<font color = "red">对应物理地址=DS×10H+EA</font> =40000H+3000H=43000H。
指令执行后： AX=6655H，（43000H）=55H，（43001H）=66H，
DS=4000H，DI=2000H。</p>
<h3
id="基址变址寻址方式形如ax目标寄存器名称-bx基址寄存器名称di变址寄存器名称">基址变址寻址方式：（形如AX（目标寄存器名称），
[BX](基址寄存器名称)[DI](变址寄存器名称)</h3>
<p>基址2个：BP和BX</p>
<p><font color = "red">其中BP指针寄存器默认对应SS段寄存器，BX指针寄存器默认对应BS段寄存器</font></p>
<p>变址2个：SI和DI</p>
<pre><code>      EA=(RB)+(RI)</code></pre>
<p>RB为基址寄存器,RI为变址寄存器.</p>
<p>【例】分析指令MOV DX，[BP+DI] （ MOV DX，[BP][DI]）指令执行结果。
设SS=3000H，DS=2000H，BP=2000H，DI=0500H；指令执行前：DX=1234H，（32500H）=78H，(32501H)=56H</p>
<p>【解】：源操作数有效地址： EA=BP+DI=2000H+0500H=2500H；
源操作数的物理地址 PA=SS×10H+EA=30000H+2500H=32500H。 指令执行后：
DX=5678H</p>
<h3 id="相对基址变址寻址方式">相对基址变址寻址方式</h3>
<p><font color = "red">物理地址表示：若无段前缀，使用BX时，默认使用段寄存器为DS，使用BP时，默认使用的段寄存器为SS。</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321215207910.png" /></p>
<h2 id="程序存储器寻址方式">程序存储器寻址方式</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321224843342.png" /></p>
<h3 id="jmp指令">JMP指令</h3>
<p>jmp 是无条件转移指令，</p>
<p>无条件转移指令可转到内存中任何程序段，</p>
<p>转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。</p>
<p>它可以只修改 <strong>IP</strong> ，也可以同时修改 <strong>CS</strong>
和 <strong>IP</strong></p>
<p><font color = "red">只修改IP的称为段内转移</font>：<code>jmp ax</code>
相当于 <code>mov ax,ip</code></p>
<p><font color = "red">同时修改 <code>cs:ip</code> 的叫
<strong>段间转移</strong></font>：<code>jmp 1000:0</code></p>
<p><font color = "red">jmp 指令要给出两种信息：</font></p>
<p><font color = "yellow">1. 转移的目的地址</font>
<font color = "yellow">2.
转移的距离(段间转移、段内转移、段内近转移)</font></p>
<h3 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令：</h3>
<p>语法： <code>jmp short 标号</code>（转到标号处执行指令）</p>
<p>这种格式的 <strong>jmp</strong> 指令实现的是段内短转移</p>
<p>它对 <strong>IP</strong> 的修改范围为 <code>-128~127</code></p>
<p><font color = "red"><code>short</code>
符号表示指令进行的是短转移</font></p>
<p><code>标号</code> 指明了指令要转移的目的地</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	start:mov ax,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>程序执行后，<strong>ax</strong> 中的值为 <strong>1</strong></p>
<p>因为执行 <code>jmp short s</code> 后，越过了
<code>add ax,1</code></p>
<p><strong>IP</strong> 指向了 标号 <strong>s</strong> 处的
<code>inc ax</code></p>
<p>也就是说，程序只进行了一次 <strong>ax</strong> 加 <strong>1</strong>
操作</p>
<p>此种转移方式并没有转移的目的地址，而是相对于当前 <strong>IP</strong>
的转移位移</p>
<p>另外，近转移ip修改范围： <code>-32768~32767</code></p>
<h3
id="转移的目的地址在指令中的jmp指令">转移的目的地址在指令中的jmp指令：</h3>
<p>语法： <code>jmp far ptr 标号</code></p>
<p>这种实现的是 <strong>段间转移</strong> ，又称为远转移</p>
<p><strong>(CS)=标号所在段的段地址</strong>；
<strong>(IP)=标号在段中的偏移地址</strong></p>
<p><font color = "red"><strong>far ptr</strong>
指明了指令用标号的段地址和偏移地址修改 <strong>CS 和
IP</strong></font></p>
<p><font color = "yellow">上面只是解释jmp过程中cpu执行了什么，实际写程序直到jmp就是往设置的标号跳就行</font></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	start:mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp far ptr s</span><br><span class="line">		db 256 dup (0)</span><br><span class="line">	s:add ax,1</span><br><span class="line">		inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="转移地址在寄存器中的jmp指令">转移地址在寄存器中的jmp指令</h3>
<p>指令格式： <code>jmp 16 位 reg</code></p>
<p>功能： <code>(IP)=(16 位 reg)</code></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令执行前： ax=1000H ，CS=2000H ，IP=0003H</span><br><span class="line">jmp ax</span><br><span class="line">指令执行后： ax=1000H ，CS=2000H ，IP=1000H</span><br></pre></td></tr></table></figure>
<p>jmp ax ，相当于： mov IP,ax ### 转移地址在内存中的jmp指令：</p>
<p>转移地址在内存中的jmp指令有两种格式</p>
<h4 id="jmp-word-ptr-内存单元地址段内转移">(1) jmp word ptr
内存单元地址（段内转移）</h4>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</p>
<p>内存单元地址执行后， (IP)=0123H可用寻址方式的任一格式给出。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax	;将寄存器 AX 中的值移动到数据段（DS）中偏移量为 0 的位置处。</span><br><span class="line"></span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后， (IP)=0123H</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov [bx],ax</span><br><span class="line"></span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure>
<p>执行后， (IP)=0123H</p>
<h4 id="jmp-dword-ptr-内存单元地址段间转移">(2) jmp dword ptr
内存单元地址（段间转移）</h4>
<p>功能：从内存单元地址处开始存放着两个字，</p>
<p>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(CS) = (内存单元地址+2)</span><br><span class="line">(IP) = (内存单元地址)</span><br></pre></td></tr></table></figure>
<p>内存单元地址可用寻址方式的任一格式给出</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line"></span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后， (CS)=0 ，(IP)=0123H ，CS:IP 指向 0000:0123</p>
<p>再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov [bx],ax</span><br><span class="line"></span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line"></span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>
<p>执行后， (CS)=0 ，(IP)=0123H ，CS:IP 指向 0000:0123</p>
<p>小结：</p>
<p><code>jmp short 标号</code> 功能为：段内短转移</p>
<p><strong>(IP)=(IP)+8位位移</strong></p>
<ol type="1">
<li>8位位移 <strong>=</strong> 标号处的地址 <strong>-</strong>
jmp指令后的第一个字节地址</li>
<li>short指明的此处是8位位移</li>
<li>8位位移的范围为-128-127，用补码表示</li>
<li>8位位移是编译程序时在编译时算出的</li>
</ol>
<hr />
<p><code>jmp near ptr 标号</code> 功能为：段内近转移</p>
<p><strong>(IP)=(IP)+16位位移</strong></p>
<ol type="1">
<li>16位位移 <strong>=</strong> 标号处的地址 <strong>-</strong>
jmp指令后的第一个字节地址</li>
<li>short指明的此处是8位位移</li>
<li>16位位移的范围为-32768-32767，用补码表示</li>
<li>16位位移是编译程序时在编译时算出的</li>
</ol>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章_8086的指令系统</title>
    <url>/posts/f42d18b1.html</url>
    <content><![CDATA[<p><font color = "red">所有指令都有1个共同特点，就是如果有2个操作数的话，两个操作数不能同时在内存</font></p>
<h1 id="数据传送类指令">数据传送类指令</h1>
<span id="more"></span>
<h2 id="通用数据传送指令">通用数据传送指令</h2>
<h3 id="传送指令mov">传送指令MOV</h3>
<p>定义</p>
<p>把一个字节或字的操作数从源地址传送至目的地址</p>
<p>举例</p>
<p>例1：立即数传送</p>
<ul>
<li>mov al,4
；al←4，字节传送，是一条将立即数4（十进制）移动到寄存器AL（即8位的累加器）的指令</li>
<li>mov cx,0ffh
；cx←00ffh，字传送，<font color = "red">传送前要根据高位补齐</font>一条将立即数0xFF（十六进制）移动到寄存器CX（即16位的计数器）的指令</li>
<li>mov si,200h ；si←0200h，字传送</li>
<li>mov byte ptr [si],0ah ；byte ptr
说明是字节操作，将立即数0x0A（十六进制）移动到以SI寄存器作为基址的内存位置。这里的<font color = "red"><code>byte ptr</code>指定了操作数的大小为一个字节，</font><code>[si]</code>表示SI寄存器中的地址处。因此，这条指令<font color = "red">将0x0A写入到SI寄存器指向的内存地址中。</font></li>
<li>mov word ptr [si+2],0bh ；word ptr 说明是字操作</li>
</ul>
<p>注：</p>
<p>注意立即数是字节量还是字量 明确指令是字节操作还是字操作</p>
<p>例2：寄存器传送</p>
<p>mov ax,bx ；ax←bx，字传送 mov ah,al ；ah←al，字节传送 mov ds,ax
；ds←ax，字传送 mov [bx],al ；[bx]←al，字节传送</p>
<p>例3：存储器传送</p>
<p>mov al,[bx] mov dx,[bp] ；dx←ss:[bp] mov es,[si] ；es←ds:[si]</p>
<p><font color = "red"> 不存在存储器向存储器的传送指令</font></p>
<p>小结</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322195241486.png" /></p>
<p>非法传送</p>
<ul>
<li><p>两个操作数的类型不一致
例如源操作数是字节，而目的操作数是字；或相反</p>
<p>常见错误：对于存储器单元与立即数同时作为操作数的情况，必须显式指明；byte
ptr指示字节类型，word ptr指示字类型</p>
<p>就是想MOV word ptr[ax] 000AH</p></li>
<li><p>两个操作数不能都是存储器
传送指令很灵活，但主存之间的直接传送却不允许</p></li>
<li><p>段寄存器的操作有一些限制
段寄存器属专用寄存器，对他们的操作能力有限</p>
<ol type="1">
<li>不允许立即数传送给段寄存器 MOV DS,100H
；非法指令：立即数不能传送段寄存器</li>
<li>不允许直接改变CS值 MOV CS,[SI] ；不允许使用的指令</li>
<li>不允许段寄存器之间的直接数据传送 MOV DS,ES
；非法指令：不允许段寄存器间传送</li>
</ol></li>
</ul>
<h3 id="交换指令xchg">交换指令XCHG</h3>
<h4 id="寄存器与寄存器之间对换数据">寄存器与寄存器之间对换数据</h4>
<p>mov ax,1234h ；ax=1234h mov bx,5678h ；bx=5678h xchg ax,bx
；ax=5678h，bx=1234h xchg ah,al ；ax=7856h</p>
<h4 id="寄存器与存储器之间对换数据">寄存器与存储器之间对换数据</h4>
<p>xchg ax,[2000h] ；字交换 等同于 xchg [2000h],ax xchg al,[2000h]
；字节交换 等同于 xchg [2000h],al</p>
<h4
id="不能在存储器与存储器之间对换数据">不能在存储器与存储器之间对换数据</h4>
<h3 id="换码指令xlat">换码指令XLAT</h3>
<p>定义</p>
<p>将BX指定的缓冲区中、AL指定的位移处的一个字节数据取出赋给AL</p>
<h2 id="堆栈操作指令">堆栈操作指令</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322201903196.png" /></p>
<p><font color = "red">SS指向的基准量，SP指向的是“偏移量”，计算SP指向的物理地址需要加上SS*
10H</font></p>
<h3 id="堆栈的操作">堆栈的操作</h3>
<p>PUSH ；进栈指令先使堆栈指针SP减2，然后把一个字操作数存入堆栈顶部</p>
<p>【例】 PUSH BX 指令执行前： SS＝4000H，SP＝2000H，BX＝3248H</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/73300a8f811300979366c931b4109d6.png" /></p>
<p>POP
；出栈指令把栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP加2</p>
<p>注</p>
<ul>
<li>堆栈操作的单位是字，进栈和出栈只对字量</li>
<li>字量数据从栈顶压入和弹出时，都是低地址字节送低字节，高地址字节送高字节</li>
<li>堆栈操作遵循先进后出原则，但可用存储器寻址方式随机存取堆栈中的数据</li>
<li>堆栈常用来
<ol type="1">
<li>临时存放数据</li>
<li>传递参数</li>
<li>保存和恢复寄存器</li>
</ol></li>
</ul>
<h2 id="标志传送指令">标志传送指令</h2>
<h3 id="定义">定义</h3>
<ul>
<li>标志寄存器传送指令用来传送标志寄存器FLAGS的内容</li>
<li>标志位操作指令直接对CF、DF、IF标志进行复位或置位</li>
</ul>
<h3 id="标志寄存器传送">标志寄存器传送</h3>
<h4 id="标志低字节进出ah指令">标志低字节进出AH指令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LAHF	;AH←FLAGS的低字节</span><br></pre></td></tr></table></figure>
<p>LAHF指令将标志寄存器的低字节送寄存器AH
SF/ZF/AF/PF/CF状态标志位分别送入AH的第7/6/4/2/0位，而AH的第5/3/1位任意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAHF	;FLAGS的低字节←AH</span><br></pre></td></tr></table></figure>
<p>SAHF将AH寄存器内容送FLAGS的低字节
用AH的第7/6/4/2/0位相应设置SF/ZF/AF/ PF/CF标志</p>
<h4 id="标志寄存器进出堆栈指令">标志寄存器进出堆栈指令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSHF	 ；SP←SP－2</span><br><span class="line">		 ；SS:[SP]←FLAGS</span><br></pre></td></tr></table></figure>
<p>PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POPF</span><br><span class="line">；FLAGS←SS:[SP]</span><br><span class="line">；SP←SP＋2</span><br></pre></td></tr></table></figure>
<p>POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushf	；保存全部标志到堆栈</span><br><span class="line">pop ax	；堆栈中取出全部标志</span><br><span class="line">or ax,0100h	；设置D8=TF=1，</span><br><span class="line">	；ax其他位不变</span><br><span class="line">push ax	；将ax压入堆栈</span><br><span class="line">popf	；FLAGS←AX</span><br><span class="line">；将堆栈内容取到标志寄存器</span><br></pre></td></tr></table></figure>
<h3 id="标志位操作">标志位操作</h3>
<h4 id="进位标志操作指令">进位标志操作指令</h4>
<p>用于任意设置进位标志 CLC ；复位进位标志：CF←0 STC
；置位进位标志：CF←1 CMC ；求反进位标志：CF←～CF</p>
<h4 id="方向标志操作指令">方向标志操作指令</h4>
<p>串操作指令中，需要使用 CLD ；复位方向标志：DF←0 STD
；置位方向标志：DF←1</p>
<h4 id="中断标志操作指令">中断标志操作指令</h4>
<p>在编写中断服务程序时，需要控制可屏蔽中断的允许和禁止 CLI
；复位中断标志：DF←0 STI ；置位中断标志：DF←1</p>
<h2 id="地址传送指令">地址传送指令</h2>
<p>定义：</p>
<ol type="1">
<li>地址传送指令将存储器单元的逻辑地址送至指定的寄存器
<ul>
<li>有效地址传送指令 LEA</li>
<li>指针传送指令 LDS和LES</li>
</ul></li>
<li>注意不是获取存储器单元的内容</li>
</ol>
<h3 id="有效地址传送指令leaload-ea">有效地址传送指令LEA（load EA）</h3>
<p>定义：</p>
<p>将存储器操作数的有效地址传送至指定的16位寄存器中</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bx,0400h</span><br><span class="line">mov si,3ch</span><br><span class="line">lea bx,[bx+si+0f62h]  </span><br><span class="line">；BX＝0400h＋003ch＋0f62h＝139EH</span><br></pre></td></tr></table></figure>
<p>注</p>
<ul>
<li><font color = "red">
获得主存单元的有效地址；不是物理地址，也不是该单元的内容</font></li>
<li>可以实现计算功能</li>
</ul>
<h1 id="算术运算类指令">算术运算类指令</h1>
<ul>
<li>掌握：</li>
</ul>
<p>​ ADD</p>
<p>​ ADC(带进位的加)</p>
<p>​ INC(加1)</p>
<p>​ SUB</p>
<p>​ SBB(带进位的减)</p>
<p>​ DEC（减1）</p>
<p>​ NEG（变补，没有正负之分）</p>
<p>​ CMP</p>
<ul>
<li>熟悉：</li>
</ul>
<p>​ MUL</p>
<p>​ IMUL（有符号乘）</p>
<p>​ DIV</p>
<p>IDIV（有符号除）</p>
<ul>
<li><p>理解：</p>
<p>CBW/CWD</p>
<p>DAA/DAS</p>
<p>AAA/ AAS/AAM/AAD</p></li>
</ul>
<h3 id="状态标志">状态标志</h3>
<p>常用状态标志： 进位标志CF、溢出标志OF 零位标志ZF、符号标志SF
奇偶标志PF</p>
<h4 id="进位标志cfcarry-flag">进位标志CF（Carry Flag）</h4>
<p>定义：</p>
<p>当运算结果的<font color = "red">最高有效位有进位（加法）或借位（减法）</font>时，进位标志置1，即CF
= 1；否则CF = 0。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H	;没有进位：CF = 0</span><br><span class="line">AAH + 7CH＝（1）26H	;有进位：CF = 1</span><br></pre></td></tr></table></figure>
<h4 id="溢出标志ofoverflow-flag">溢出标志OF（Overflow Flag）</h4>
<p>若算术运算的结果有溢出，则OF＝1； 否则 OF＝0</p>
<p><font color = "red">溢出和进位的区别</font></p>
<p>首先什么是溢出</p>
<p>处理器内部以补码表示有符号数 8位表示的整数范围是：－128～＋127
16位表示的整数范围是：－32768～＋32767
如果运算结果超出这个范围，就产生了溢出
有溢出，说明有符号数的运算结果不正确</p>
<p>举例：</p>
<p>3AH＋7CH＝B6H，就是58＋124＝182，
已经超出－128～＋127范围，产生溢出，故OF＝1；
另一方面，补码B6H表达真值是-74， 显然运算结果也不正确</p>
<p><font color = "red">本质区别</font></p>
<p><font color = "red">进位</font>标志表示<font color = "red">无符号数</font>运算结果是否超出范围，超出范围后加上进位或借位运算结果仍然正确；
<font color = "red">溢出</font>标志表示<font color = "red">有符号数</font>运算结果是否超出范围，超出范围后运算结果不正确。</p>
<p><font color = "red">溢出和进位的对比</font></p>
<p>举例：</p>
<p>例1：3AH + 7CH＝B6H 无符号数运算： 58＋124＝182 范围内，无进位
有符号数运算： 58＋124＝182 范围外，有溢出</p>
<p>用二进制运算表示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ec451bff30b7466d36ba1ce30ef05dc.jpg" /></p>
<p>例2：AAH + 7CH＝（1）26H 无符号数运算： 170＋124＝294 范围外，有进位
有符号数运算： －86＋124＝38 范围内，无溢出</p>
<p>二进制表示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dbcdf8d7466a93840c23d3aaa7be99e.jpg" /></p>
<p>如何运用溢出和进位</p>
<p>如果将参加运算的操作数认为是无符号数，就应该关心进位；</p>
<p>认为是有符号数，则要注意是否溢出</p>
<p><font color = "red">溢出的判断</font></p>
<p>当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出</p>
<h4 id="零标志zfzero-flag">零标志ZF（Zero Flag）</h4>
<p>若运算结果为0，则ZF = 1； 否则ZF = 0</p>
<h4 id="符号标志sfsign-flag">符号标志SF（Sign Flag）</h4>
<p>运算结果最高位为1，则SF = 1；否则SF = 0</p>
<h4 id="奇偶标志pfparity-flag">奇偶标志PF（Parity Flag）</h4>
<p>当运算结果最低字节中“1”的个数为零或偶数时，PF = 1；否则PF = 0</p>
<h4 id="辅助进位标志afauxiliary-carry-flag">辅助进位标志AF（Auxiliary
Carry Flag）</h4>
<p>运算时<font color = "red">第3位（低半字节）</font>有进位或借位时，AF
= 1；否则AF = 0。</p>
<h3 id="加法">加法</h3>
<h4 id="加法指令add">加法指令ADD</h4>
<p>定义：</p>
<p>ADD指令将源与目的操作数相加，结果送到目的操作数</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0fbh	；al=0fbh</span><br><span class="line">add al,07h	；00FB + 0007 = 0102H, AL = 02H</span><br><span class="line">mov word ptr [200h],4652h	；[200h]=4652h(重复就是重要，涉及到内存的时候必须要告知是wordptr还是byteptr)</span><br><span class="line">mov bx,1feh	；bx=1feh</span><br><span class="line">add al,bl	；al=00h</span><br><span class="line">add word ptr [bx+2],0f0f0h	；[200h]=3742h</span><br></pre></td></tr></table></figure>
<h4 id="带进位加法指令adc">带进位加法指令ADC</h4>
<p>定义：</p>
<ul>
<li><p>ADC指令将源与目的操作数相加，再加上进位CF标志，结果送到目的操作数</p></li>
<li><p>ADC指令主要与ADD配合，实现多精度加法运算</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4652h	；ax=4652h</span><br><span class="line">add ax,0f0f0h	；ax=3742h，CF=1</span><br><span class="line">mov dx,0234h	；dx=0234h</span><br><span class="line">adc dx,0f0f0h	；dx=f324h，CF=0</span><br><span class="line">；DX.AX＝ 0234 4652H</span><br><span class="line">	   ＋F0F0 F0F0H</span><br><span class="line">	   ＝F325 3742H</span><br></pre></td></tr></table></figure>
<h4 id="增量指令incincrement">增量指令INC（increment）</h4>
<p>INC指令对操作数加1（增量）
INC指令不影响进位CF标志，按定义设置其他状态标志</p>
<h3 id="减法">减法</h3>
<h4 id="减法指令subsubtract">减法指令SUB（subtract）</h4>
<p>定义：</p>
<p>SUB指令将目的操作数减去源操作数，结果送到目的操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0fbh	；al=0fbh</span><br><span class="line">sub al,07h	；al=0f4h，CF＝0</span><br><span class="line">mov word ptr [200h],4652h	；[200h]=4652h</span><br><span class="line">mov bx,1feh	；bx=1feh</span><br><span class="line">sub al,bl	；al=0f6h</span><br><span class="line">sub word ptr [bx+2],0f0f0h</span><br><span class="line">；[200h]=5562h，CF＝1</span><br></pre></td></tr></table></figure>
<h4 id="带借位减法指令sbb">带借位减法指令SBB</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4652h	；ax=4652h</span><br><span class="line">sub ax,0f0f0h	；ax=5562h，CF=1</span><br><span class="line">mov dx,0234h	；dx=0234h</span><br><span class="line">sbb dx,0f0f0h	；dx=1143h，CF=1</span><br><span class="line">；DX.AX＝  0234 4652H</span><br><span class="line">		－F0F0 F0F0H</span><br><span class="line">		＝1143 5562H</span><br></pre></td></tr></table></figure>
<h4 id="减量指令decdecrement">减量指令DEC（decrement）</h4>
<p>定义</p>
<ul>
<li>DEC指令对操作数减1（减量）</li>
<li>DEC指令不影响进位CF标志，按定义设置其他状态标志</li>
</ul>
<h3 id="求补指令negnegative">求补指令NEG（negative）</h3>
<p>定义：</p>
<ul>
<li>NEG指令对操作数执行求补运算：用零减去操作数，然后结果返回操作数</li>
<li>求补运算也可以表达成：将</li>
<li>NEG指令对标志的影响与用零作减法的SUB指令一样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0ff64h</span><br><span class="line">neg al	；ax=ff9ch，OF=0、SF=1、ZF=0、PF=1、CF=1</span><br><span class="line">sub al,9dh	；ax=ffffh，OF=0、SF=1、ZF=0、PF=1、CF=1</span><br><span class="line">neg ax	；ax=0001h，OF=0、SF=0、ZF=0、PF=0、CF=1</span><br><span class="line">dec al	；ax=0000h，OF=0、SF=0、ZF=1、PF=1、CF=1</span><br><span class="line">neg ax	；ax=0000h，OF=0、SF=0、ZF=1、PF=1、CF=0</span><br></pre></td></tr></table></figure>
<p><font color = "red">NEG对CF/OF的影响</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240324091424121.png" /></p>
<p><font color = "red">根本原因：虽然人在计算的时候是求反加1，但CPU运算是用0-操作数</font></p>
<h3 id="比较指令cmpcompare">比较指令CMP（compare）</h3>
<p>CMP指令将目的操作数减去源操作数，按照定义相应设置状态标志
CMP指令执行的功能与SUB指令，但结果不回送目的操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	cmp al,100	；al-100</span><br><span class="line">	jb below	；al&lt;100，跳转到below执行</span><br><span class="line">	sub al,100	；al≥100，al←al-100</span><br><span class="line">	inc ah	；ah←ah+1</span><br><span class="line">below:	...</span><br></pre></td></tr></table></figure>
<p><font color = "red">经典例题</font></p>
<p>题1：</p>
<p>【例】：
设X、Y、Z均为双精度数。其存放地址为：X，X+2，Y，Y+2，Z，Z+2。存放时，高位字在高位地址，低位字存放在低地址中。
试编程完成 W←X+Y+24-Z ，结果存放在W和W+2单元。</p>
<p><font color = "red">总结</font></p>
<p><font color = "red">1. 用DX、AX表示双精度数</font></p>
<p><font color = "red">2. 低位用AX，高位用DX</font></p>
<p><font color = "red">3.
先用非进位运算低位，再用进位运算高位</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX，X       ；用DX，AX来表示双精度数</span><br><span class="line">MOV   DX，X+2     ；低位用AX，高位用DX</span><br><span class="line">ADD    AX，Y       ；先低位运算</span><br><span class="line">ADC    DX，Y+2    ；完成X+Y </span><br><span class="line">ADD    AX，24      ；低位运算</span><br><span class="line">ADC    DX，0       ；高位运算，该语句不能少</span><br><span class="line">SUB     AX，Z      ；先低位减法</span><br><span class="line">SBB      DX，Z+2   ；完成运算</span><br><span class="line">MOV    W，AX      ；存储结果</span><br><span class="line">MOV    W+2，DX</span><br></pre></td></tr></table></figure>
<h3 id="乘法指令">乘法指令</h3>
<p>MUL：无符号乘法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL r8/m8	；AX←AL×r8/m8</span><br><span class="line">MUL r16/m16	；DX.AX←AX×r16/m16</span><br></pre></td></tr></table></figure>
<p>IMUL：有符号乘法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMUL r8/m8	；AX←AL×r8/m8</span><br><span class="line">IMUL r16/m16	；DX.AX←AX×r16/m16</span><br></pre></td></tr></table></figure>
<p><font color = "red">乘法指令的源操作数显式给出，隐含使用另一个操作数AX和DX</font></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0b4h	；al=b4h=180</span><br><span class="line">mov bl,11h	；bl=11h=17</span><br><span class="line">mul bl	；ax=Obf4h=3060</span><br><span class="line">；OF=CF=1，AX高8位不为0</span><br><span class="line">mov al,0b4h	；al=b4h=－76</span><br><span class="line">mov bl,11h	；bl=11h=17</span><br><span class="line">imul bl	；ax=faf4h=－1292</span><br><span class="line">；OF=CF=1，AX高8位含有效数字</span><br></pre></td></tr></table></figure>
<h3 id="除法指令">除法指令</h3>
<p><font color = "red">除法指令的除数显式给出，隐含使用另一个操作数AX和DX作为被除数</font></p>
<p><font color = "red">被除数位数至少是除数1倍</font></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0400h	；ax=400h=1024</span><br><span class="line">mov bl,0b4h	；bl=b4h=180</span><br><span class="line">div bl	；商al＝05h＝5</span><br><span class="line">	；余数ah＝7ch＝124</span><br><span class="line">mov ax,0400h	；ax=400h=1024</span><br><span class="line">mov bl,0b4h	；bl=b4h=－76</span><br><span class="line">idiv bl	；商al＝f3h＝－13</span><br><span class="line">	；余数ah＝24h＝36</span><br></pre></td></tr></table></figure>
<p><font color = "red">对进位标志CF的影响</font></p>
<ul>
<li>会修改CF
<ol type="1">
<li>ADD/ADC</li>
<li>SUB/SBB</li>
</ol></li>
<li>不会修改CF
<ol type="1">
<li>INC</li>
<li>DEC</li>
</ol></li>
<li>不确定
<ol type="1">
<li>MUC/IMUL</li>
<li>DIV/IDIV</li>
</ol></li>
</ul>
<h3 id="符号扩展指令">符号扩展指令</h3>
<p>定义：</p>
<p>符号扩展是指用一个操作数的符号位（即最高位）形成另一个操作数，后一个操作数的各位是全0（正数）或全1（负数）。符号扩展不改变数据大小</p>
<p>种类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CBW		；AL的符号扩展至AH</span><br><span class="line">；如AL的最高有效位是0，则AH＝00</span><br><span class="line">；AL的最高有效位为1，则AH＝FFH。AL不变</span><br><span class="line"></span><br><span class="line">CWD		；AX的符号扩展至DX</span><br><span class="line">；如AX的最高有效位是0，则DX＝00</span><br><span class="line">；AX的最高有效位为1，则DX＝FFFFH。AX不变</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,80h	；al=80h</span><br><span class="line">cbw	；ax=ff80h</span><br><span class="line">add al,255	；al=7fh</span><br><span class="line">cbw	；ax=007fh</span><br></pre></td></tr></table></figure>
<p><font color = "red">典型例题：指令的综合运用</font></p>
<p>【例】：综合运算举例。计算： （V-（X*Y+Z-540））/X
其中X、Y、Z、V均为16位带符号数，已分别装入X、Y、Z、V单元中，要求计算结果把商存入AX，余数存入DX。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/54e90db558c32af218213452a594db0.jpg" /></p>
<h3 id="十进制算术运算指令">十进制算术运算指令</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240329151725488.png" /></p>
<p>十进制数的运算步骤： 1.对BCD码进行二进制运算
2.用十进制调整指令进行调整</p>
<h4
id="非压缩的bcd码调整指令无操作数默认对放在al的数据操作">非压缩的BCD码调整指令(无操作数，默认对放在AL的数据操作)</h4>
<h5 id="daadevimal-adjust-for-addition加法">DAA(Devimal Adjust for
Addition)(加法)</h5>
<p>①AF=1或AL低四位为A到F，则AL+06H→AL，1→AF</p>
<p>②CF=1或AL高四位为A到F，则AL+60H→AL，1→CF</p>
<p>解释：为什么第②点是加60H：因为只要BCD码超了都要加6，但是是AL中高四位超过，直接加6会误解，所以就要加60H，6分配给高4位，0分配给低4位。如果高低一起超过就加66H</p>
<h5 id="dasdevimal-adjust-for-subdition减法">DAS(Devimal Adjust for
Subdition)(减法)</h5>
<p>①AF=1或AL低四位为A到F，则AL-06H→AL，1→AF</p>
<p>②CF=1或AL高四位为A到F，则AL-60H→AL，1→CF</p>
<h5 id="aam乘法">AAM(乘法)</h5>
<p>将二进制乘法的结构调整成十进制非压缩的形式，<font color = "red">所以跟在乘法操作后面</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c03ade250a8aee923bb78f4b37da18e.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1wm421n7as/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h5 id="aad除法">AAD(除法)</h5>
<p>先将十进制表示调整成二进制形式，再做除法，<font color = "red">所以放在除法前面</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/18be2878e728fe3e3735fb3320f8686.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1JA4m1N7t9/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h4 id="压缩的bcd码调整指令">压缩的BCD码调整指令</h4>
<h5 id="aaa加法">AAA(加法)</h5>
<p>①AL低4位在0~9之间且AF=0则转③</p>
<p>②AL低4位在A~F之间或AF=1，</p>
<p>则AL+06H→AL，</p>
<p>AH+1→AH，</p>
<p>AF=1</p>
<p>③清除AL寄存器的高四位</p>
<h5 id="aas减法">AAS(减法)</h5>
<p>①AL低4位在0~9之间且AF=0则转③</p>
<p>②AL低4位在A~F之间或AF=1，则AL-06H→AL，AH-1→AH，AF=1</p>
<p>③清除AL寄存器的高四位</p>
<p>④AF→CF</p>
<p><font color = "red">总结</font></p>
<ol type="1">
<li>非压缩和压缩的共同点都是当1个字节表示的数如果用十进制表示大于等于10就加6</li>
<li>非压缩和压缩的不同点在于非压缩不需要给AH加1，压缩要给AH加1</li>
</ol>
<h1 id="位操作类指令">位操作类指令</h1>
<h2 id="逻辑与指令and">逻辑与指令AND</h2>
<p>AND指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑或指令or">逻辑或指令OR</h2>
<p>OR指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑异或指令xor">逻辑异或指令XOR</h2>
<p><font color = "red">与0异或不变，与1异或得相反数</font></p>
<p>XOR指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑非指令not">逻辑非指令NOT</h2>
<p>NOT指令是一个单操作数指令 NOT指令不影响标志位</p>
<h2 id="测试指令test">测试指令TEST</h2>
<p>对两个操作数<font color = "red">执行逻辑与运算，结果不回送到目的操作数</font></p>
<h2 id="移位指令shift">移位指令（shift）</h2>
<h3 id="移位指令的种类">移位指令的种类</h3>
<p><strong>SHL reg/mem,1/CL</strong>
；逻辑左移，最高位进入CF，最低位补0</p>
<p><strong>SAL reg/mem,1/CL</strong>
；算术左移，最高位进入CF，最低位补0</p>
<p>逻辑左移和算术左移没什么区别</p>
<p><strong>SHR reg/mem,1/CL</strong>
；逻辑右移，最低位进入CF，<font color = "red">最高位补0</font></p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/53c6c2518a3aac3e6f447378d2d625f.jpg" /></p>
<p><strong>SAR reg/mem,1/CL</strong>
；算术右移，最低位进入CF，<font color = "red">最高位(符号位)不变</font></p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5fd885e4eec0d58c9c1383423bb759d.jpg" /></p>
<p><font color = "red">算术</font>左移和算术右移主要用来进行<font color = "red">有符号数</font>的倍增、减半；</p>
<p><font color = "red">逻辑</font>左移和逻辑右移主要用来进行<font color = "red">无符号数</font>的倍增、减半。</p>
<h3 id="移位指令的操作数">移位指令的操作数</h3>
<p>移位指令的<font color = "red">第一个操作数是指定的被移位的操作数</font>，可以是寄存器或存储单元
<font color = "red">后一个操作数表示移位位数</font>，该操作数为1，表示移动一位；<font color = "red">当移位位数大于1时，用且只能用CL寄存器值表示</font>，该操作数表达为CL</p>
<h2 id="循环移位指令rotate">循环移位指令（rotate）</h2>
<p>ROL reg/mem,1/CL ；不带进位循环左移</p>
<p>ROR reg/mem,1/CL ；不带进位循环右移</p>
<p>RCL reg/mem,1/CL ；带进位循环左移</p>
<p>RCR reg/mem,1/CL ；带进位循环右移</p>
<p>带进位和不带进位的区别:</p>
<p>比如<font color = "red">不带进位的左移</font>，是<font color = "red">将最高位移动到CF里</font>；</p>
<p>而<font color = "red">带进位的左移</font>，是将CF和要移动的8位<font color = "red">合起来看做一个整体</font>一起移动</p>
<p><font color = "red">带进位一般用来处理多精度数的移动</font></p>
<p>举例：</p>
<p>题1：高精度移位</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330150914140.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1vx421Q7Ft/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p>题2：BCD码合并</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bc3e302c70e3c9e2f4481d5e6b7b9d6.jpg" /></p>
<h1 id="控制转移类指令">控制转移类指令</h1>
<h2 id="条件转移指令">条件转移指令</h2>
<h3 id="判断单个标志位状态">判断单个标志位状态</h3>
<p>⑴JZ/JE和JNZ/JNE：利用零标志ZF，判断结果是否为零（或相等）</p>
<p>⑵JS和JNS：利用符号标志SF，判断结果是正是负</p>
<p>⑶JO和JNO：利用溢出标志OF，判断结果是否产生溢出</p>
<p>⑷JP/JPE和JNP/JPO：利用奇偶标志PF，判断结果中“1”的个数是偶是奇</p>
<p>⑸JC/JB/JNAE和JNC/JNB/JAE：利用进位标志CF，判断结果是否进位或借位</p>
<p>上面5种每种里面记1个就行</p>
<p>举例：</p>
<p>题1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	test al,80h	；测试最高位</span><br><span class="line">	jz next0	；D7＝0（ZF＝1），转移</span><br><span class="line">	mov ah,0ffh	；D7＝1，顺序执行</span><br><span class="line">	jmp done	；无条件转向</span><br><span class="line">next0:	mov ah,0</span><br><span class="line">done:	...</span><br><span class="line">	test al,80h	；测试最高位</span><br><span class="line">	jnz next1	；D7＝1（ZF＝0），转移</span><br><span class="line">	mov ah,0	；D7＝0，顺序执行</span><br><span class="line">	jmp done	；无条件转向</span><br><span class="line">next1:	mov ah,0ffh</span><br><span class="line">done:	...</span><br></pre></td></tr></table></figure>
<p>题2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">；计算|X－Y|（绝对值）</span><br><span class="line">；X和Y为存放于X单元和Y单元的16位操作数</span><br><span class="line">；结果存入result</span><br><span class="line">	mov ax,X</span><br><span class="line">	sub ax,Y</span><br><span class="line">	jns nonneg</span><br><span class="line">	neg ax	；neg是求补指令</span><br><span class="line">nonneg:	mov result,ax</span><br></pre></td></tr></table></figure>
<h3 id="比较无符号数高低">比较无符号数高低</h3>
<h3 id="比较有符号数大小">比较有符号数大小</h3>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/posts/f15db2c6.html</url>
    <content><![CDATA[<p><font color = "red">子序列：可以不连续；子串：必须连续</font></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第一章概述</title>
    <url>/posts/7cc56e97.html</url>
    <content><![CDATA[<h1 id="算法复杂性分析">算法复杂性分析</h1>
<span id="more"></span>
<p>•<strong>算法复杂性</strong> <strong>=</strong>
<strong>算法所需要的计算机资源</strong></p>
<p>•算法的时间复杂性T(n)</p>
<p>•算法的空间复杂性S(n)</p>
<p>•其中n是问题的规模（输入大小）</p>
<h2 id="算法的时间复杂性"><strong>算法的时间复杂性</strong></h2>
<p>I是问题的规模为n的实例</p>
<p>p(I)是实例I出现的概率，数学期望</p>
<p>最坏情况下的时间复杂度</p>
<p><span class="math inline">\(T_{max}(n) =
max\{T(I)|size(I)=n\}\)</span></p>
<p>最好情况下的时间复杂性</p>
<p><span class="math inline">\(T_{min}(n) = min\{T(I)|size(I)=n
\}\)</span></p>
<p>平均情况</p>
<p><span class="math inline">\(T_{avg}(n) = \sum_{size(I) =
n}p(I)T(I)\)</span></p>
<h3 id="算法渐近复杂性"><strong>算法渐近复杂性</strong></h3>
<h5 id="渐近不严格小大">渐近（不严格小/大）</h5>
<h6 id="渐近上界o">渐近上界<span class="math inline">\(O\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/21e10616849eeb6c492d56a6d3b41be.jpg" /></p>
<h6 id="渐进下界omega">渐进下界<span
class="math inline">\(\Omega\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/b700b630ba0004cbee424bdc38592bd.jpg" /></p>
<h5 id="非紧严格小大">非紧（严格小/大)</h5>
<h6 id="非紧上界omicron">非紧上界<span
class="math inline">\(\omicron\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0e1f5a0b6a92e17917927986bacfd24.jpg" /></p>
<h6 id="非紧下界omega">非紧下界<span
class="math inline">\(\omega\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/08f6221450cb6ba14c2c2df81694a3f.jpg" /></p>
<h5 id="紧渐近界theta">紧渐近界<span
class="math inline">\(\Theta\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5871c004daa7406e10db03a220c0f91.jpg" /></p>
<p>注：上面符号与其说表示的是一个函数，不如说表示的是一个函数簇</p>
<p>总结</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/781bac2d8552666d91e544d982e3115.jpg" /></p>
<h3 id="渐近的性质">渐近的性质</h3>
<h4 id="传递性">传递性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ce3b468a13f85ec631264d592dee717.jpg" /></p>
<h4 id="反身性">反身性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ae5577611fdde16022baac1ce83e840.jpg" /></p>
<h4
id="互对称性一个是另一个的上界另一个就是一个的下界">互对称性：一个是另一个的上界，另一个就是一个的下界</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6de93f7cdffe787c012d9e24ac2ff64.jpg" /></p>
<h4 id="对称性">对称性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/40f632977b0e41fcd25df8ca64f8a56.jpg" /></p>
<h4 id="算术运算">算术运算</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/df382f960d96e54faf0842061571483.jpg" /></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-动态规划</title>
    <url>/posts/10f9c13d.html</url>
    <content><![CDATA[<h1 id="矩阵连乘问题">矩阵连乘问题</h1>
<span id="more"></span>
<h2 id="问题描述">问题描述</h2>
<p>给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p>
<p>详细说明：</p>
<h3 id="完全加括号的矩阵连乘积">完全加括号的矩阵连乘积</h3>
<p>定义</p>
<p>递归定义如下</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404142841417.png" /></p>
<h3 id="计算乘法次数">计算乘法次数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404143033534.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Jx4y1v7Pg/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h2 id="解决方案">解决方案</h2>
<h3 id="穷举">穷举</h3>
<p>时间复杂度分析：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4bb32aa7f3c7a09736383e8366ee372.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1oZ421v7i7/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="动态规划">动态规划</h3>
<p>状态转移方程</p>
<p>其中参数的含义：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bb31de1a4e6e0c728fed7ba5f77af60.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404165259820.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404165317052.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1uZ421B7zS/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MatrixChain &#123;</span><br><span class="line">    public static void matrixChain(int[] p, int n, int[][] m, int[][] s) &#123;</span><br><span class="line">        // Initialize diagonal elements of m to 0</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            m[i][i] = 0;</span><br><span class="line"></span><br><span class="line">        for (int r = 2; r &lt;= n; r++) &#123;</span><br><span class="line">            for (int i = 1; i &lt;= n - r + 1; i++) &#123;</span><br><span class="line">                int j = i + r - 1;</span><br><span class="line">                m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];</span><br><span class="line">                s[i][j] = i;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];</span><br><span class="line">                    if (t &lt; m[i][j]) &#123;</span><br><span class="line">                        m[i][j] = t;</span><br><span class="line">                        s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="备忘录">备忘录</h3>
<p>动归的优化，与纯动态规划区别在于，原来的动态规划的递归方向<font color = "red">从底往上</font>，比如上面是先计算出长度为i的矩阵，再利用得到的结果计算长度为i+1的矩阵</p>
<p>备忘录是利用递归<font color = "red">从顶往下</font></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lookupChain</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[i][j]; <span class="comment">// 说明之前已经计算过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 同1个矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> lookupChain(i, i) + lookupChain(i + <span class="number">1</span>, j) + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">    <span class="comment">// 上面这步类似纯动归的初始化，分割线在i后面</span></span><br><span class="line">    s[i][j] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lookupChain(i, k) + lookupChain(k + <span class="number">1</span>, j) + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">        <span class="comment">// 上面这个就是针对i, j序列找最小的m[i, j]</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; u) &#123;</span><br><span class="line">            u = t;</span><br><span class="line">            s[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子序列">最长公共子序列</h1>
<h2 id="结构">结构</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404204318582.png" /></p>
<blockquote>
<p>注：公共子序列不一定连续</p>
<p>举例：X：A, B, C, C, D, E</p>
<p>​ Y:A, B, E, F</p>
<p>最长公共子序列：A, B, E</p>
</blockquote>
<h2 id="状态转移方程">状态转移方程</h2>
<p><strong>c[ i ][ j ]</strong>记录序列和的最长公共子序列的长度</p>
<p>其中，
Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i][j]=0。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c2f7a9fa4b9a76331c2b73ef9c22c07.jpg" /></p>
<h2 id="动归计算最长子序列长度">动归计算最长子序列长度</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b[i][j] = 1 //情况一：X尾和Y尾相等</span><br><span class="line">b[i][j] = 2 //情况二：去X尾更长</span><br><span class="line">b[i][j] = 3 //情况三：去Y尾更长</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lcsLength</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">char</span>[] x, <span class="type">char</span>[] y, <span class="type">int</span>[][] c, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize DP tables</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;	<span class="comment">//列代表字符串X</span></span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;	<span class="comment">//行代表字符串Y</span></span><br><span class="line">        c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制变量法，先固定x的结尾，移动y的结尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;	<span class="comment">// 如果末尾相同</span></span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;	</span><br><span class="line">                b[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i - <span class="number">1</span>][j] &gt;= c[i][j - <span class="number">1</span>]) &#123;	<span class="comment">//如果末尾不同且去x尾更长</span></span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果末尾相同且去y尾更长</span></span><br><span class="line">                c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面得到的b矩阵构造最长公共子序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lcs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] x, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (b[i][j] == <span class="number">1</span>) &#123;	<span class="comment">// 情况一：结尾相等</span></span><br><span class="line">        lcs(i - <span class="number">1</span>, j - <span class="number">1</span>, x, b);</span><br><span class="line">        System.out.print(x[i - <span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i][j] == <span class="number">2</span>) &#123;	<span class="comment">//情况而：结尾是y尾，y不动，去x尾</span></span><br><span class="line">        lcs(i - <span class="number">1</span>, j, x, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">//情况三：结尾是x尾，y不动，去x尾</span></span><br><span class="line">        lcs(i, j - <span class="number">1</span>, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405051912387.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Cr421t7Ur/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h1 id="最大子段和">最大子段和</h1>
<h2 id="定义">定义</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405052621608.png" /></p>
<p><font color = "red">最大子段和要求是连续的</font></p>
<h2 id="分治算法">分治算法</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0496c608796c48b6712341468cab3d8.jpg" /></p>
<p>时间复杂度分析（类似快排）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405053751915.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4634de1a817caf595e3d8ee97132df3.jpg" /></p>
<h2 id="动归算法">动归算法</h2>
<h3 id="状态转移方程-1">状态转移方程：</h3>
<p>定义数组<strong>b[ j
]</strong>表示含义为<font color = "red">一定要取数组<strong>a[ i
]</strong>的情况下</font>，能得到的最大子列和</p>
<p><strong>b[ j ]=max{ b[ j-1 ]+a[ j ]，a[ j ]}，1≤j≤n</strong></p>
<h3 id="代码">代码</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405060709253.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b += a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; sum) &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="凸多边形最优三角剖分">凸多边形最优三角剖分</h1>
<h2 id="定义-1">定义</h2>
<ol type="1">
<li>用多边形顶点的<font color = "red">逆时针序列</font>表示凸多边形</li>
<li>若vi与vj是多边形上<font color = "red">不相邻的2个顶点</font>，则线段vivj称为多边形的一条弦。</li>
<li>多边形的三角剖分是将多边形分割成互不相交的三角形的<font color = "red">弦的集合T</font>。</li>
<li>给定凸多边形P，以及定义在由多边形的<font color = "red">边和弦组成的三角形上的权函数w</font>。要求确定该凸多边形的三角剖分，使得即该三角剖分中诸三角形上<font color = "red">权之和最小</font>。</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405061347814.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/14fae356ce0e5d90eea1611eb8145d5.jpg" /></p>
<h2 id="状态转移方程-2">状态转移方程</h2>
<p>• 定义<strong>t[ i ][ j ]</strong><a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>为凸子多边形{vi-1,vi,…,vj}<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>的最优三角剖分所对应的权函数值，为方便起见，设退化的多边形{vi-1,vi}具有权值0。据此定义，要计算的凸(n+1)边形P的最优权值为t[1][n]。</p>
<p>•
t[i][j]的值可以利用最优子结构性质递归地计算。当j-i≥1时，凸子多边形至少有3个顶点。由最优子结构性质，<font color = "red">t[i][j]的值应为t[i][k]的值加上t[k+1][j]的值，再加上三角形vi-1vkvj的权值</font>，其中i≤k≤j-1。由于在计算时还不知道k的确切位置，而k的所有可能位置只有j-i个，因此可以在这j-i个位置中选出使t[i][j]值达到最小的位置。由此，t[i][j]可递归地定义为：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405070956331.png" /></p>
<p>和之前矩阵连乘定义比较：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405071037433.png" /></p>
<p><font color = "red">凸多边形是矩阵连乘的拓展，拓展结果就是最后w函数可以是各种自定义</font></p>
<h2 id="代码-1">代码</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a02052d33e6631f72bc6947aba020ca.jpg" /></p>
<h1 id="背包">0-1 背包</h1>
<h2 id="定义-2">定义：</h2>
<p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p>
<p>0-1背包问题是一个特殊的整数规划问题。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4d16b8d8311d7cd652e8117af7b3147.jpg" /></p>
<h2 id="动态转移方程">动态转移方程</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bd839e9436f7cff13fb968d1d867628.jpg" /></p>
<h2 id="代码-2">代码</h2>
<h3 id="原始版本求最大价值">原始版本求最大价值</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/2e4539f504399446b33100d53a2abff.jpg" /></p>
<h3 id="原始版本求产生最大价值的方法">原始版本求产生最大价值的方法</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b93650f105ff8c2a37a6e03c1e0aee9.jpg" /></p>
<h3 id="滚动数组优化">滚动数组优化</h3>
<h1 id="流水作业调度">流水作业调度</h1>
<h2 id="定义-3">定义</h2>
<p>n个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。
流水作业调度问题要求<font color = "red">确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少</font></p>
<p>直观来看，最佳调度应该是使机器M1没有空闲时间，同时机器M2的空闲时间最少。通常情况下，机器M2上会出现两种情况：一种是机器空闲，另一种是作业积压。</p>
<p>假设所有作业的集合为N={1, 2, ...,
n}。S⊆N是N的作业子集。在<font color = "yellow">一般情况下，当机器M1开始处理S中的作业时，机器M2可能正在处理其他作业，需要等待时间t才能开始处理S中的作业。我们将在这种情况下完成S中作业所需的最短时间记为T(S,
t)。</font><font color = "red">流水作业调度问题的最优解为T(N,
0)。</font>(t = 0表示机器M2积压时间为0)</p>
<h2 id="johnson不等式">Johnson不等式</h2>
<p>如果作业i和j满足min{bi,aj}≥min{bj,ai}，则称作业i和j满足Johnson不等式。</p>
<h2 id="算法">算法</h2>
<p>流水作业调度问题的Johnson算法 (1)令</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240417053251214.png" />
(2)将N1中作业依ai的递增排序(不严格)；将N2中作业依bi的递减排序(不严格)；
(3)N1中作业接N2中作业构成满足Johnson法则的最优调度。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/50afce87f860ee16279ee01d4e31883.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1gm41127Sq/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h1 id="最优二叉搜索树">最优二叉搜索树</h1>
<h2 id="二叉搜索树定义">二叉搜索树定义</h2>
<ol type="1">
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ol>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423094143694.png" style="zoom:50%;" /></p>
<h2 id="搜索的期望耗费">搜索的期望耗费</h2>
<h3
id="所有节点包括成功与不成功的概率和是1">所有节点（包括成功与不成功）的概率和是1</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/906b29131c6f62f386c68f2b44fff07.jpg" /></p>
<h3 id="期望耗费">期望耗费</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/cc165ddcce07e99faabd4b728085569.jpg" /></p>
<h4 id="从深度角度根节点深度为0">从深度角度（根节点深度为0）</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423095637747.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/328544f39d8dd9887c3dae0b2efd2ee.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>也可以从比较次数角度，比如根节点比较1次就能确定</p>
<h2 id="构建最优二叉搜索树">构建最优二叉搜索树</h2>
<h3 id="任务描述">任务描述</h3>
<p>给了一堆节点和每个节点被搜索到的概率，要求建立一棵二叉搜索树，这棵树的期望耗费要最小</p>
<h3 id="问题分析">问题分析</h3>
<h4 id="最优子结构">最优子结构</h4>
<p><span class="math inline">\(w_{i,
j}\)</span>表示包括i到j的节点组成的子树的可能性的和，从i到j的节点是实际存在的节点序号，但是还包括他们的子节点</p>
<p><span class="math inline">\(p_{i,
j}\)</span>表示包括i到j的节点组成的子树的平均“路长”</p>
<p><span class="math inline">\(w_{i,
j}p_{i,j}\)</span>的积表示的是包括i到j的节点组成的树的"贡献"</p>
<p>一棵树要想期望耗费最小，就是这棵树的左右子树贡献最小</p>
<p><a href="">视频讲解：一步一步推出算法设计思想</a></p>
<h4 id="状态转移方程-3">状态转移方程</h4>
<h3 id="代码分析">代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Void <span class="title function_">OBST</span> <span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b, <span class="type">int</span> n, <span class="type">int</span> **m, <span class="type">int</span> **s, <span class="type">int</span> **w)</span> </span><br><span class="line">&#123;  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123; w[i+<span class="number">1</span>][i]=a[i]; m[i+<span class="number">1</span>][i]=<span class="number">0</span>; &#125; <span class="comment">//初始状态</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> r=<span class="number">0</span>;r&lt;n;r++)              <span class="comment">//r+1为结点个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n-r;i++)   <span class="comment">//考虑xi～xj共r+1个结点的</span></span><br><span class="line">      &#123; <span class="type">int</span> j=i+r;                       <span class="comment">//最优二叉搜索树</span></span><br><span class="line">         w[i][j]=w[i][j-<span class="number">1</span>]+a[j]+b[j];       <span class="comment">//以xi为根节点</span></span><br><span class="line">         m[i][j]=m[i+<span class="number">1</span>][j]; s[i][j]=i;      <span class="comment">//注意m(i,i-1)=0</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k=i+<span class="number">1</span>; k&lt;=j; k++)</span><br><span class="line">           &#123; <span class="type">int</span> t=m[i][k-<span class="number">1</span>]+m[k+<span class="number">1</span>][j];    <span class="comment">//以xk为根节点</span></span><br><span class="line">              <span class="keyword">if</span> (t&lt;m[i][j])      <span class="comment">//t为当前最小值</span></span><br><span class="line">                   &#123; m[i][j]=t; s[i][j]=k; &#125; <span class="comment">//s记录当前子树根节点xk</span></span><br><span class="line">           &#125;</span><br><span class="line">         m[i][j] += w[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面最好要有个矩阵模拟过程</p>
<p><font color = "yellow">问题：数组a是什么？数组b又是什么？</font></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>(1≤i&lt;j≤n)。<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>(这是顶点集，边数就是j - (i - 1) -1 = j -
i条，每天边对应1个矩阵)。<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-递归与分治</title>
    <url>/posts/49cf79ef.html</url>
    <content><![CDATA[<h1 id="主定理解析">主定理解析</h1>
<span id="more"></span>
<h2 id="结论">结论</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-a0299344bcf4a294e5c05d0dd65e6009_720w.webp" /></p>
<h2 id="分析">分析</h2>
<p>递归公式通用形式</p>
<p><span class="math inline">\(T(n) = aT(\frac{n}{b}) +
O(n^d)\)</span></p>
<p>最后的时间复杂度和这a, b ,d几个参数有关。</p>
<p>把递归问题每一层的问题数目，计算量都一一列出，可以得到如下公式</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/246a8395cdf4300171bd87f00b5e9ce.jpg" /></p>
<p>最终的总规模是<font color = "red">等比数列</font>，因为初始问题规模n是固定的，d是规定的，将<span
class="math inline">\(O(n^d)\)</span>看作常数，公比是<span
class="math inline">\(\frac{a}{b^d}\)</span></p>
<ul>
<li><p>情况一：公比小于1</p>
<p>时间复杂度由第一项确定</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317142649653.png" /></p></li>
<li><p>情况二：公比大于1</p>
<p>时间复杂度由最后一项确定</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317142728426.png" /></p></li>
</ul>
<p>​ 化简过程：<br />
​<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/835962a26e5043f390ee6143d828324.jpg" /></p>
<ul>
<li><p>公比等于1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317143800605.png" /></p></li>
</ul>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-贪心</title>
    <url>/posts/f5cda7c8.html</url>
    <content><![CDATA[<h1 id="活动安排">活动安排</h1>
<span id="more"></span>
<h2 id="算法分析">算法分析</h2>
<p>想法很简单：就是先将活动结束时间按从小到大排个序，然后选择最早的开始时间晚于结束时间的活动，将结束时间重置为这个活动的结束时间后</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240424191240622.png" /></p>
<p><a href="">视频讲解</a></p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedySelector</span>&lt;Type&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greedySelector</span><span class="params">(<span class="type">int</span> n, Type[] s, Type[] f, <span class="type">boolean</span>[] A)</span> &#123;</span><br><span class="line">        A[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((Comparable&lt;Type&gt;) s[i]).compareTo(f[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                A[i] = <span class="literal">true</span>;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GreedySelector&lt;Integer&gt; greedySelector = <span class="keyword">new</span> <span class="title class_">GreedySelector</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        Integer[] s = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Integer[] f = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span>[] A = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        greedySelector.greedySelector(n, s, f, A);</span><br><span class="line">        System.out.print(<span class="string">&quot;A[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">boolean</span> b : A) &#123;</span><br><span class="line">            System.out.print(b ? <span class="string">&quot;true &quot;</span> : <span class="string">&quot;false &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="背包问题">背包问题</h1>
<h2 id="算法分析-1">算法分析</h2>
<p>这里的物品是可以“拆分”的，不像前面0-1背包物品一个一个都是完整的</p>
<p>贪心：将尽可能多高“性价比"货物放入背包，这里的”性价比“计算是<span
class="math inline">\(\frac{货物价格}{货物重量}\)</span></p>
<h2 id="代码-1">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> M, <span class="type">float</span>[] v, <span class="type">float</span>[] w, <span class="type">float</span>[] x)</span> &#123;</span><br><span class="line">        sort(n, v, w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; c) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            c -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            x[i] = c / w[i]; <span class="comment">// 最后装入部分物品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span>[] v, <span class="type">float</span>[] w)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设已经实现排序算法</span></span><br><span class="line">        <span class="comment">// 这里使用Arrays.sort()进行排序</span></span><br><span class="line">        <span class="type">float</span>[][] items = <span class="keyword">new</span> <span class="title class_">float</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            items[i][<span class="number">0</span>] = v[i];</span><br><span class="line">            items[i][<span class="number">1</span>] = w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(items, (a, b) -&gt; Float.compare(b[<span class="number">0</span>] / b[<span class="number">1</span>], a[<span class="number">0</span>] / a[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i] = items[i][<span class="number">0</span>];</span><br><span class="line">            w[i] = items[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Knapsack</span> <span class="variable">knapsack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knapsack</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">float</span>[] v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">float</span>[] w = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">float</span>[] x = <span class="keyword">new</span> <span class="title class_">float</span>[n];</span><br><span class="line">        knapsack.knapsack(n, M, v, w, x);</span><br><span class="line">        System.out.print(<span class="string">&quot;x[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> value : x) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = "red">动态规划和贪心的相似与区别</font></p>
<p>动态规划是先解决子问题然后选择一个最好的解决方案，像0-1背包中dp数组</p>
<p>贪心是先选择一个解决方案然后再解决子问题，像活动安排时先找第一个活动一样</p>
<p><a
href="https://www.bilibili.com/video/BV1Xm411y743/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：课堂老师讲解原声大碟</a></p>
<h1 id="最优装载">最优装载</h1>
<h2 id="算法分析-2">算法分析</h2>
<p>目标尽可能多，所以就先装重量小的</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Loading</span>&lt;Type&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loading</span><span class="params">(<span class="type">int</span>[] x, Type[] w, Type c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Integer[] t = <span class="keyword">new</span> <span class="title class_">Integer</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            t[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(w, t, n);  <span class="comment">// 将所有集装箱按重量排序</span></span><br><span class="line">        Arrays.fill(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;</span><br><span class="line">            x[t[i]] = <span class="number">1</span>;</span><br><span class="line">            c = c - w[t[i]];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Type[] w, Integer[] t, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设已经实现排序算法</span></span><br><span class="line">        <span class="comment">// 这里使用Arrays.sort()进行排序</span></span><br><span class="line">        Arrays.sort(t, <span class="number">1</span>, n + <span class="number">1</span>, (a, b) -&gt; compare(w[b], w[a])); <span class="comment">// 根据重量w进行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出排序结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted indexes:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(t[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较方法，假设 Type 类型实现了 Comparable 接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Type a, Type b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Comparable &amp;&amp; b <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Comparable&lt;Type&gt;) a).compareTo(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Type must implement Comparable interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Loading&lt;Integer&gt; loading = <span class="keyword">new</span> <span class="title class_">Loading</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        Integer[] w = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">// 集装箱重量</span></span><br><span class="line">        <span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// 装载情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 船的载重量</span></span><br><span class="line">        loading.loading(x, w, c, n);</span><br><span class="line">        System.out.print(<span class="string">&quot;x[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : x) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼编码">哈夫曼编码</h1>
<h1 id="单源最短路">单源最短路</h1>
<h1 id="最小生成树">最小生成树</h1>
<h2 id="prim算法">Prim算法</h2>
<h2 id="kruskal算法">Kruskal算法</h2>
<h1 id="并查集">并查集</h1>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>Acw730机器人跳跃问题</title>
    <url>/posts/1adefb1.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/732/">题目</a></h1>
<p>机器人正在玩一个古老的基于 DOS 的游戏。 <span id="more"></span></p>
<p>游戏中有 N+1座建筑——从 0 到 N 编号，从左到右排列。</p>
<p>编号为 0 的建筑高度为 0 个单位，编号为 i 的建筑高度为 H(i)
个单位。</p>
<p>起初，机器人在编号为 0 的建筑处。</p>
<p>每一步，它跳到下一个（右边）建筑。</p>
<p>假设机器人在第 k 个建筑，且它现在的能量值是 E ，下一步它将跳到第 k+1
个建筑。</p>
<p>如果 H(k+1)&gt;E ，那么机器人就失去 H(k+1)−E 的能量值，否则它将得到
E−H(k+1) 的能量值。</p>
<p>游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。</p>
<p>现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行输入整数 N 。</p>
<p>第二行是 N 个空格分隔的整数，H(1),H(2),…,H(N) 代表建筑物的高度。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(1≤N,H(i)≤10^5\)</span>,</p>
<h2 id="输入样例1">输入样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例1">输出样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输入样例2">输入样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 4 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例2">输出样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输入样例3">输入样例3：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 6 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例3">输出样例3：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>为什么这题可以联想到二分呢？因为如果找打一个E(0)的最小值，那么所有比E(0)大的值就一定满足题意，所有比E(0)小的值就一定不满足</p>
<p>另外，一定不要忽视第0栋楼的</p>
<p>当跳到第i栋楼时，能量与楼层的关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3a633398726baa6bf8a2ecfa262e0af.jpg" /></p>
<p>结合代码分析</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6a705dce19fbf5d71bd13700ded281f.jpg" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXHEIGHT</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] building = <span class="keyword">new</span> <span class="title class_">int</span>[MAXHEIGHT];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] energy = <span class="keyword">new</span> <span class="title class_">int</span>[MAXHEIGHT];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> startEnergy, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		energy[<span class="number">0</span>] = startEnergy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			energy[i] = <span class="number">2</span> * energy[i - <span class="number">1</span>] - building[i];</span><br><span class="line">			<span class="keyword">if</span>(energy[i] &gt; maxHeight) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(energy[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			building[i] = scan.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(building[i] &gt; maxHeight) &#123;</span><br><span class="line">				maxHeight = building[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = maxHeight;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid, n)) end = mid;</span><br><span class="line">			<span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(start);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>中等题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing1221拉格朗日定理</title>
    <url>/posts/d57017e8.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/1223/">题目</a></h1>
<p>四平方和定理，又称为拉格朗日定理：</p>
<span id="more"></span>
<p>每个正整数都可以表示为至多 4个正整数的平方和。</p>
<p>如果把 0 包括进去，就正好可以表示为 4 个数的平方和。</p>
<p>比如：</p>
<p><span class="math inline">\(5=0^2+0^2+1^2+2^2\)</span> <span
class="math inline">\(7=1^2+1^2+1^2+2^2\)</span></p>
<p>对于一个给定的正整数，可能存在多种平方和的表示法。</p>
<p>要求你对 4 个数排序：</p>
<p>0≤a≤b≤c≤d</p>
<p>并对所有的可能表示法按 a,b,c,d , , ,
为联合主键升序排列，最后输出第一个表示法。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入一个正整数 N 。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出4个非负整数，按从小到大排序，中间用空格分开。</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(0&lt;N&lt;5∗10^6\)</span></p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>利用空间换时间，首先将<span class="math inline">\(c^2 +
d^2\)</span>的所有结果保存，然后枚举<span class="math inline">\(a^2 +
b^2\)</span>的结果，用二分在之前保存的结果中查找</p>
<p>保存<span class="math inline">\(c^2 +
d^2\)</span>的结果时，由于题目中有对键值排序的要求，所以利用要按<span
class="math inline">\(c^2 + d^2, c, d\)</span>优先级排序</p>
<h2 id="java中接口在排序中的使用">java中接口在排序中的使用</h2>
<h3
id="首先定义实现比较接口的类在这个类中定义构造函数和重写比较函数">首先定义实现比较接口的类，在这个类中定义构造函数和重写比较函数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square_sum</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Square_sum&gt; &#123;</span><br><span class="line">    <span class="type">int</span> sum_square, c, d;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sum_square</span><span class="params">(<span class="type">int</span> sum_square, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sum_square = sum_square;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Square_sum t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.sum_square != t.sum_square) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.sum_square, t.sum_square);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.c != t.c) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.c, t.c);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.d, t.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="然后定义类数组">然后定义类数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Square_sum[] data = <span class="keyword">new</span> <span class="title class_">Square_sum</span>[MAXSIZE];</span><br></pre></td></tr></table></figure>
<h3 id="接着实例化类数组中每一个对象">接着实例化类数组中每一个对象</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data[k++] = <span class="keyword">new</span> <span class="title class_">Square_sum</span>(c * c + d * d, c, d)</span><br></pre></td></tr></table></figure>
<h3
id="利用arrays.sort排序arrays.sort会使用类数组中重写的比较函数作为排序依据">利用Arrays.sort排序，Arrays.sort会使用类数组中重写的比较函数作为排序依据</h3>
<h2 id="java加速读取与打印的方法">java加速读取与打印的方法</h2>
<p>利用BufferdReader和BuffedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine())</span><br><span class="line">writer.write(String.format(<span class="string">&quot;%d %d %d %d\n&quot;</span>), a, b, c, d)</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum_square</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Sum_square&gt; &#123;</span><br><span class="line">    <span class="type">int</span> square_sum, c, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sum_square</span><span class="params">(<span class="type">int</span> square_sum, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.square_sum = square_sum;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Sum_square t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.square_sum != t.square_sum) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.square_sum, t.square_sum);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.c != t.c) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.c, t.c);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.d, t.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXNUM</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">5e6</span>;</span><br><span class="line">    <span class="keyword">static</span> Sum_square[] record_sum_square = <span class="keyword">new</span> <span class="title class_">Sum_square</span>[MAXNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">             <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c * c &lt;= n; c++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c; c * c + d * d &lt;= n; d++) &#123;</span><br><span class="line">                    record_sum_square[count++] = <span class="keyword">new</span> <span class="title class_">Sum_square</span>(c * c + d * d, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.sort(record_sum_square, <span class="number">0</span>, count);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a * a &lt;= n; a++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; a * a + b * b &lt;= n; b++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n - (a * a + b * b);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = count - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (record_sum_square[mid].square_sum &gt;= t) &#123;</span><br><span class="line">                            end = mid;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            start = mid + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (record_sum_square[start].square_sum == t) &#123;</span><br><span class="line">                        writer.write(String.format(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, record_sum_square[start].c, record_sum_square[start].d));</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing789数的范围-二分基础</title>
    <url>/posts/c9bce4fa.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/791/">题目</a></h1>
<p>给定一个按照升序排列的长度为 n的整数数组，以及 q 个查询。</p>
<p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0
开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<span id="more"></span>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含整数 n和 q，表示数组长度和询问个数。</p>
<p>第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p>
<p>接下来 q 行，每行包含一个整数 k ，表示一个询问元素。</p>
<h2 id="输出格式">输出格式</h2>
<p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤n≤1000001≤ ≤100000 1≤q≤100001≤ ≤10000 1≤k≤100001≤ ≤10000</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>二分模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找左边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="keyword">void</span> <span class="title function_">search_left</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环结束的时候start = end</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) end = mid;	<span class="comment">//关键一:check(mid)怎么决定，一种是data[mid] &gt;= target,详解见下文</span></span><br><span class="line">        <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="这种二分是要在一个范围内找到指定范围的最左端和最右端">这种二分是要在一个范围内，找到指定范围的最左端和最右端</h2>
<h2 id="以找最左端为例">以找最左端为例</h2>
<h3 id="checkmid如何决定">check(mid)如何决定</h3>
<p>mid的目的是将一段区间分割成两端，其中一段（包括mid）均满足check规定的性质，另一端都不满足</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/499015168eb010e1f1caecd12076fdd.jpg" /></p>
<h3 id="总结">总结</h3>
<h4 id="决定check函数">决定check函数</h4>
<ol type="1">
<li>一定包含mid，就是一定要有=</li>
<li>向危险的边缘疯狂试探的思想</li>
</ol>
<h4
id="口诀左边界无加必有加有边界有加必有减">口诀：左边界，无加必有加；有边界有加必有减</h4>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.kerberos.KerberosKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search_left</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(data[mid] &gt;= target) end = mid;</span><br><span class="line">			<span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search_right</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			mid = (start + end) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(data[mid] &lt;= target) start = mid;</span><br><span class="line">			<span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			data[i] = scan.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftSide</span> <span class="operator">=</span> search_left(target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(data[leftSide] != target) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(leftSide + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightSide</span> <span class="operator">=</span> search_right(target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(data[rightSide] != target) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(rightSide);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/792/">题目二</a></h2>
<h3 id="分析-1">分析：</h3>
<p>在while循环里使用stride表示left与right之间的距离，当距离足够小的时候可以近似认为相等</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line">		<span class="type">double</span> <span class="variable">left</span> <span class="operator">=</span> (-<span class="number">1.0</span>) * <span class="number">10000</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">10000.0</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">stride</span> <span class="operator">=</span> <span class="number">1e-8</span>;</span><br><span class="line">		<span class="keyword">while</span>(right - left &gt; stride) &#123;</span><br><span class="line">			<span class="type">double</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(mid * mid * mid &gt;= n) right = mid;</span><br><span class="line">			<span class="keyword">else</span> left = mid + stride;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.format(<span class="string">&quot;%.6f&quot;</span>, right);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目三"><a
href="https://www.acwing.com/problem/content/798/">题目三</a></h2>
<h3 id="分析-2">分析</h3>
<p>二维</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/93445804d4b28971e344e072d6fbff4.jpg" /></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				data[i][j] = scan.nextInt();</span><br><span class="line">				<span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">					prefixSum[i][j] = prefixSum[i - <span class="number">1</span>][m] + data[i][j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					prefixSum[i][j] = prefixSum[i][j - <span class="number">1</span>] + data[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">			<span class="type">int</span> leftX, leftY;</span><br><span class="line">			leftX = scan.nextInt();</span><br><span class="line">			leftY = scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightX</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightY</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> leftX; row &lt;= rightX; row++) &#123;</span><br><span class="line">				totalSum += (prefixSum[row][rightY] - prefixSum[row][leftY - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(totalSum);</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>BFS - 灌溉</title>
    <url>/posts/e305a760.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/551/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116113111905.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">3 4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="多源bfs的思路">多源BFS的思路</h2>
<h2
id="定义一个节点类记录这个节点的x坐标y坐标和这个节点的层数放在这道题里面其实就是第几分钟灌溉好的">定义一个节点类，记录这个节点的x坐标，y坐标和这个节点的“层数”（放在这道题里面其实就是第几分钟灌溉好的）</h2>
<h2
id="定义一个辅助二维数组记录当前节点是否访问过">定义一个辅助二维数组，记录当前节点是否访问过</h2>
<h2
id="每轮循环先访问队列中队首节点如果当前队首节点的层数小于等于时间说明可以继续按上下左右顺序访问当前弹出的节点的临近节点如果临近节点之前没有访问过就压入队列并且设为访问过">每轮循环先访问队列中队首节点，如果当前队首节点的层数小于等于时间，说明可以继续，按上下左右顺序访问当前弹出的节点的临近节点，如果临近节点之前没有访问过，就压入队列并且设为访问过</h2>
<h3 id="java中队列操作">Java中队列操作</h3>
<h4 id="声明">声明</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="加入元素">加入元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.add(Node);</span><br></pre></td></tr></table></figure>
<h4 id="访问队首元素">访问队首元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.peek()</span><br></pre></td></tr></table></figure>
<h4 id="弹出队首元素">弹出队首元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.poll()</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> floor;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> floor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">		<span class="built_in">this</span>.floor = floor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[][] graph = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        	<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        	queue.add(newNode);</span><br><span class="line">        	graph[x][y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> t;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        	<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        	<span class="keyword">if</span>(newNode.floor &lt;= k) &#123;</span><br><span class="line">            	queue.poll();</span><br><span class="line">            	<span class="type">int</span> <span class="variable">centerX</span> <span class="operator">=</span> newNode.x;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">centerY</span> <span class="operator">=</span> newNode.y;</span><br><span class="line">            	<span class="comment">//向上的方向</span></span><br><span class="line">            	<span class="keyword">if</span>(centerX - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; graph[centerX - <span class="number">1</span>][centerY] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX - <span class="number">1</span>][centerY] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX - <span class="number">1</span>, centerY, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向下的方向</span></span><br><span class="line">            	<span class="keyword">if</span>(centerX + <span class="number">1</span> &lt;= n &amp;&amp; graph[centerX + <span class="number">1</span>][centerY] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX + <span class="number">1</span>][centerY] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX + <span class="number">1</span>, centerY, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向左</span></span><br><span class="line">            	<span class="keyword">if</span>(centerY - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; graph[centerX][centerY -<span class="number">1</span> ] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX][centerY - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX, centerY - <span class="number">1</span>, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向右</span></span><br><span class="line">            	<span class="keyword">if</span>(centerY + <span class="number">1</span> &lt;= m &amp;&amp; graph[centerX][centerY + <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX][centerY + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX, centerY + <span class="number">1</span>, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">        		</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(count);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>排列，递归实现排列型枚举</title>
    <url>/posts/19de5275.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/96/">题目</a></h1>
<p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<span id="more"></span>
<h4 id="输入格式">输入格式</h4>
<p>一个整数 n</p>
<h4 id="输出格式">输出格式</h4>
<p>按照从小到大的顺序输出所有方案，每行 1 个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一
一比较，字典序较小的排在前面。</p>
<h4 id="数据范围">数据范围</h4>
<p>1≤n≤9</p>
<h4 id="输入样例">输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="每到一层root含义">每到一层root含义</h2>
<p>和<a
href="">这道题</a>相比，上一题每一层是当前层的数选还是不选从而分叉，本题是选哪一个从而分叉</p>
<h2 id="isvisited">isVisited</h2>
<p>记录当前root是否访问过</p>
<h2 id="data">data</h2>
<p>记录输出序列</p>
<h2 id="count">count</h2>
<p>记录当前root是序列里第几个元素</p>
<h2 id="回溯往往与递归相辅相成">回溯（往往与递归相辅相成）</h2>
<p>每一个root退出递归后，要将isVisited和data，count恢复成原样</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/2.png" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == n) &#123;							<span class="comment">//如果输出序列已满，全部打印输出</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				System.out.print(data[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i != root &amp;&amp; isVisited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">					isVisited[i] = <span class="literal">true</span>;	</span><br><span class="line">					data[count + <span class="number">1</span>] = i;</span><br><span class="line">					dfs(i, count + <span class="number">1</span>);</span><br><span class="line">					isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">					data[count + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			isVisited[i] = <span class="literal">true</span>;	<span class="comment">//标记当前的root为已经访问</span></span><br><span class="line">			data[<span class="number">1</span>] = i;			<span class="comment">//将当前root加入输出序列</span></span><br><span class="line">			dfs(i, <span class="number">1</span>);</span><br><span class="line">			isVisited[i] = <span class="literal">false</span>;	<span class="comment">//回溯，将当前的root重置为0</span></span><br><span class="line">			data[<span class="number">1</span>] = <span class="number">0</span>;			<span class="comment">//将当前root从输出序列弹出</span></span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全排列dfs代码模板">全排列dfs代码模板</h2>
<h3
id="作为递归参数传递记录当前层数的count当count等于全排列数字位数后意味着搜索树到底">作为递归参数传递，记录当前层数的count，当count等于全排列数字位数后，意味着搜索树到底</h3>
<h3
id="记录当前这个数是否访问过的isvisited数组">记录当前这个数是否访问过的isVisited数组</h3>
<h3 id="回溯还原">回溯还原</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int n;</span><br><span class="line">static StringBuffer stringNum = new StringBuffer();</span><br><span class="line">static boolean[] isVisited = new boolean[MAX];</span><br><span class="line">static void dfs(int count) &#123;	//count表示当前层</span><br><span class="line">	if(count == n) &#123;</span><br><span class="line">		根据题意的其他操作</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		if(isVisited[i] == false) &#123;</span><br><span class="line">			isVisited[i] = true;</span><br><span class="line">             stringNum.append(i);</span><br><span class="line">             dfs(count + 1);</span><br><span class="line">             isVisited[i] = false;</span><br><span class="line">             stringNum.deleteCharAt(stringNum.length() - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/1539/">题目二</a></h2>
<p>这一题关键在如何剪枝：首先将数组排个序，然后每一层的root返回后，一直向下遍历到和当前root不相同的位置位置，因为从排列角度来说，只要前一个遍历过了，后一个如果相同，一定是重复的</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/64845_fc80efef68-7C344E16678378354C1F3D3558D18A05.png" /></p>
<p>另外关于java中如何加速读写</p>
<p>使用StreamTokenizer和PrintWriter加速</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StreamTokenizer tokenizer;</span><br><span class="line"><span class="keyword">static</span> PrintWriter writer;</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out);</span><br><span class="line">   tokenizer = <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(reader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span>&#123;</span><br><span class="line">       tokenizer.nextToken();</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>) tokenizer.nval;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>使用时就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = nextInt()</span><br></pre></td></tr></table></figure>
<h2 id="题目三"><a
href="https://www.acwing.com/problem/content/1211/">题目三</a></h2>
<h4 id="分析-1">分析：</h4>
<p>通过枚举解决，难点是如何枚举</p>
<p>题目实际上是n = a + b / c</p>
<p>等式两边同乘以c，得到n * c = a * c + b</p>
<p>先通过dfs全排列找到所有排列，在对排列按照位数划分得到a， b，
剩下的位组成c，代入看是否满足公式</p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0242354a6fd667e83152bd75a6e7321.jpg" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">StringBuffer</span> <span class="variable">stringNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == m + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//System.out.println(stringNum);</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringNum.length(); i++) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">subStringa</span> <span class="operator">=</span> stringNum.substring(<span class="number">0</span>, i);</span><br><span class="line">				<span class="keyword">if</span>(subStringa.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(subStringa);</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; stringNum.length(); j++) &#123;</span><br><span class="line">						<span class="type">String</span> <span class="variable">subStringb</span> <span class="operator">=</span> stringNum.substring(i, j);</span><br><span class="line">						<span class="keyword">if</span>(subStringb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(subStringb);</span><br><span class="line">							<span class="type">String</span> <span class="variable">subStringc</span> <span class="operator">=</span> stringNum.substring(j, stringNum.length());</span><br><span class="line">							<span class="keyword">if</span>(subStringc.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">								<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.parseInt(subStringc);</span><br><span class="line">								<span class="comment">//System.out.format(&quot;a = %d	b = %d	c = %d\n&quot;, a, b, c);</span></span><br><span class="line">								<span class="keyword">if</span>(n * c == a * c + b) &#123;</span><br><span class="line">									totalNum++;</span><br><span class="line">								&#125;								</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;-------------------------&quot;);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isVisited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">				isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">				stringNum.append(i);</span><br><span class="line">				dfs(count + <span class="number">1</span>);</span><br><span class="line">				isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">				stringNum.deleteCharAt(stringNum.length() - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">			stringNum.append(i);</span><br><span class="line">			dfs(<span class="number">2</span>);</span><br><span class="line">			isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">			stringNum.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(totalNum);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="补充java中stringbuffer可变字符串的使用">补充：java中StringBuffer可变字符串的使用</h4>
<h5 id="切割子字符串左闭右开">切割子字符串：左闭右开</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> stringNum.subString(start, end);</span><br></pre></td></tr></table></figure>
<h4 id="字符串转数字">字符串转数字</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(subString)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>递归实现指数型枚举</title>
    <url>/posts/b9f8e3d9.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/94/">题目</a></h1>
<p>从 1∼n 这 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<span id="more"></span>
<h2 id="输入格式">输入格式</h2>
<p>输入一个整数 n。</p>
<h2 id="输出格式">输出格式</h2>
<p>每行输出一种方案。</p>
<p>同一行内的数必须升序排列，相邻两个数用恰好 11 个空格隔开。</p>
<p>对于没有选任何数的方案，输出空行。</p>
<p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤n≤15</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>利用dfs的思想递归，每一层对应当前的数，分成两个子树，左子树代表选，右子树代表不选</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1.png" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isChoose = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(a &gt; n) &#123;	<span class="comment">//如果当前层超过最后一层，就可以输出全部结果了</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(isChoose[i]) &#123;</span><br><span class="line">					System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果还没有超过最后一层</span></span><br><span class="line">			<span class="comment">// 选当前层</span></span><br><span class="line">			isChoose[a] = <span class="literal">true</span>;</span><br><span class="line">			dfs(a + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 不选当前层</span></span><br><span class="line">			isChoose[a] = <span class="literal">false</span>;</span><br><span class="line">			dfs(a + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		dfs(<span class="number">1</span>);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目一"><a
href="https://www.acwing.com/problem/content/95/">题目一</a></h2>
<p>递归三要素：参数值和返回值，终止条件，递归逻辑</p>
<p>root表示当前的根，count表示当前root对应是第几层</p>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/description/118/">题目二</a></h2>
<h3 id="分析-1">分析</h3>
<p>为什么要把这题放在枚举里面了？</p>
<p>因为这是就是一道用dfs解决的题目</p>
<p>因为一共有16个开关，每个开关有2种选择，所以一共有<span
class="math inline">\(2^{16}\)</span>种选择，所以可以用暴力解决</p>
<p>用dfs树的思路：当前层的开关不调整是左子树，调整是右子树，如果是右子树就要将该开关本身所在的行与列都调整</p>
<p>举个例子</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4512499dcce75216a9c1d978eb6e681.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span> <span class="variable">CLOSED</span> <span class="operator">=</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span> <span class="variable">OPEN</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] data = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[][] tmpIsVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[][] minIsVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">minStride</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tmpStride</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i][j] == OPEN) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[row][col] == CLOSED) &#123;</span><br><span class="line">            data[row][col] = OPEN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[row][col] = CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        reverse(row, col);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) reverse(row, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) reverse(j, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(validate()) &#123;</span><br><span class="line"><span class="comment">//              printMatrix();</span></span><br><span class="line">                <span class="keyword">if</span>(tmpStride &lt; minStride) &#123;</span><br><span class="line">                    minStride = tmpStride;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        minIsVisited[i] = Arrays.copyOf(tmpIsVisited[i], <span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> count / <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> count % <span class="number">4</span>;</span><br><span class="line"><span class="comment">//      System.out.format(&quot;当前开关是%d %d\n&quot;, row, col);</span></span><br><span class="line"><span class="comment">//      System.out.println(&quot;当前层开关不按&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">        dfs(count + <span class="number">1</span>);</span><br><span class="line">        tmpIsVisited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        change(row, col);</span><br><span class="line"><span class="comment">//      System.out.println(&quot;当前层开关按&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">        tmpStride += <span class="number">1</span>;</span><br><span class="line">        dfs(count + <span class="number">1</span>);</span><br><span class="line">        tmpIsVisited[row][col] = <span class="literal">false</span>;</span><br><span class="line">        change(row, col);</span><br><span class="line">        tmpStride -= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//      System.out.println(&quot;恢复当前层&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                System.out.print(data[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNextLine() &amp;&amp; row &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                data[row][i] = line.charAt(i); </span><br><span class="line">            &#125;</span><br><span class="line">            row++;              </span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        change(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tmpStride += <span class="number">1</span>;</span><br><span class="line">        tmpIsVisited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(minStride);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(minIsVisited[i][j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.format(<span class="string">&quot;%d %d\n&quot;</span>, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing99激光炸弹-前缀和</title>
    <url>/posts/46a3c91c.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/101/">题目</a></h1>
<p>地图上有 N 个目标，用整数 Xi,Yi ,
表示目标在地图上的位置，每个目标都有一个价值 Wi 。</p>
<p><strong>注意</strong>：不同目标可能在同一位置。</p>
<p>现在有一种新型的激光炸弹，可以摧毁一个包含
R×R个位置的正方形内的所有目标。</p>
<p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和
x，y 轴平行。</p>
<p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
<p>## 输入格式</p>
<p>第一行输入正整数 N 和 R
，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。</p>
<p>接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi , ,
，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p>
<p>## 输出格式</p>
<p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p>
<p>## 数据范围</p>
<p><span class="math inline">\(0≤R≤10^9\)</span> <span
class="math inline">\(0&lt;N≤100000\)</span> <span
class="math inline">\(0≤Xi,Yi≤50000\)</span> <span
class="math inline">\(0≤Wi≤10000\)</span></p>
<p>## 输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">0 0 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>## 输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>首先讲解下什么是二维前缀和</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/a1be24141cc56e2e06e0925e75b1802.jpg" /></p>
<p>但是本题的特殊之处在于给的目标是在交叉点上，而上面给的是第几个矩阵</p>
<p>解决方法：平移坐标系，原来在坐标轴上的目标就变成了在坐标轴内的目标，进一步就是变成了和原来一样的第几个小正方形</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/fa457b993c3966a8faa0491504cb5a3.jpg" /></p>
<p>所以先将目标的value填充到对应的方格中，然后计算value的前缀和矩阵，最后利用计算出的前缀和矩阵，通过移动覆盖面积的小方形，以其右下角为基准遍历整个矩阵，计算覆盖面积的最大值</p>
<p><strong>前缀和的灵魂就是将本来时间复杂度<span
class="math inline">\(O(n)\)</span>甚至<span
class="math inline">\(O(n^2)\)</span>的循环遍历求和变成<span
class="math inline">\(O(1)\)</span></strong></p>
<p>注意：</p>
<p>1 题目中一个坐标处可能有多个目标</p>
<p>2 如果火力覆盖面积比最大的5000还大，那就可以不用遍历直接得到答案</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.chrono.MinguoChronology;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> <span class="number">5010</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		r = Math.min(r, <span class="number">5001</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">max_x</span> <span class="operator">=</span> r;</span><br><span class="line">		<span class="type">int</span> <span class="variable">max_y</span> <span class="operator">=</span> r;</span><br><span class="line">		<span class="comment">// 填充一小格的价值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			matrix[x + <span class="number">1</span>][y + <span class="number">1</span>] += scan.nextInt();</span><br><span class="line">			max_x = Math.max(x + <span class="number">1</span>, max_x);</span><br><span class="line">			max_y = Math.max(y + <span class="number">1</span>, max_y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算价值的二维前缀和</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max_x; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= max_y; j++) &#123;</span><br><span class="line">				matrix[i][j] += matrix[i - <span class="number">1</span>][j] + matrix[i][j - <span class="number">1</span>] - matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移动火力覆盖的小方形遍历整个矩阵</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &lt;= max_x; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r; j &lt;= max_y; j++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> matrix[i][j] - matrix[i - r][j] - matrix[i][j - r] + matrix[i - r][j - r];</span><br><span class="line">				<span class="keyword">if</span>(value &gt; maxValue) &#123;</span><br><span class="line">					maxValue = value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(maxValue);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>前缀和</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和基础</title>
    <url>/posts/6ebcf9d0.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/797/">题目</a></h1>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来再输入 m 个询问，每个询问输入一对 l,r , 。</p>
<p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含两个整数 n 和 m 。</p>
<p>第二行包含 n 个整数，表示整数数列。</p>
<p>接下来 m 行，每行包含两个整数 l 和 r ，表示一个询问的区间范围。</p>
<h2 id="输出格式">输出格式</h2>
<p>共 m 行，每行输出一个询问的结果。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤l≤r≤n, 1≤n,m≤100000 −1000≤数列中元素的值≤1000</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p><span class="math inline">\(前缀和s[i] = a[1] + a[2] + …… +
a[i]\)</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			data[i] = scan.nextInt();</span><br><span class="line">			prefixSum[i] = prefixSum[i - <span class="number">1</span>] + data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			System.out.println(prefixSum[right] - prefixSum[left - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>前缀和</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>DP动态规划入门</title>
    <url>/posts/1370e9cf.html</url>
    <content><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="核心思想">核心思想</h2>
<p>为了解决一个“大”问题，将“大”问题分解成两个“小”问题</p>
<p>举个例子：一次可以走一个台阶或者两个台阶，问走到第n个台阶时，一共有多少种走法？要走到第n级台阶，分成两种情况，一种是从n-1级台阶走一步过来，一种是从n-2级台阶走两步过来</p>
<h2 id="状态">状态</h2>
<p>形如dp[i][j] = val的取值，其中i,
j为下标，用于描述、确定状态所需的变量，val为状态值</p>
<h2 id="状态转移">状态转移</h2>
<p>状态与状态之间的转移关系，转移方向决定了迭代或递归方向</p>
<h2
id="常见特征重叠子问题最优子结构">常见特征：重叠子问题，最优子结构</h2>
<h3 id="重叠子问题">重叠子问题：</h3>
<p>斐波那契数为例，用递归计算fib(5)，分解为图示的子问题，其中fib(3)计算了2次，其实只算1次就够了</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/95b4e7867af7488f8ce8837e23c3bfc1.png" /></p>
<h3 id="最优子结构"><strong>最优子结构</strong></h3>
<h2 id="两种编码方法">两种编码方法</h2>
<h3 id="自顶向下与记忆化"><strong>自顶向下与记忆化</strong></h3>
<p>先考虑大问题，再缩小到小问题，递归很直接地体现了这种思路。为避免递归时重复计算子问题，可以在子问题得到解决时，就保存结果，再次需要这个结果时，直接返回保存的结果就行了。这种存储已经解决的子问题的结果的技术称为“记忆化（Memoization）”。
  以斐波那契数为例，记忆化代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> memoize[N];                                  <span class="comment">//保存结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memoize[n] != <span class="number">0</span>) <span class="keyword">return</span> memoize[n]; <span class="comment">//直接返回保存的结果，不再递归</span></span><br><span class="line">    memoize[n]= fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>);       <span class="comment">//递归计算结果，并记忆</span></span><br><span class="line">    <span class="keyword">return</span> memoize[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自下而上与制表递推"><strong>自下而上与制表递推</strong></h3>
<p>先解决子问题，再递推到大问题。通常通过填写表格来完成，编码时用若干for循环语句填表。根据表中的结果，逐步计算出大问题的解决方案。</p>
<p>用制表法计算斐波那契数，维护一个一维表dp[]，记录自下而上的计算结果，更大的数是前面两个数的和。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/bb9b3fee28e94641a908121c07cec9c6.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)  dp[i] = dp[i-<span class="number">1</span>] +dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分析步骤">分析步骤</h1>
<h2 id="确定状态">确定状态</h2>
<p>一般为“到第i个为止，方案数/最小代价/最大价值</p>
<h2 id="确定状态转移方程">确定状态转移方程</h2>
<p>根据状态转移方向决定迭代还是递归</p>
<h2 id="确定最终状态">确定最终状态</h2>
<h1 id="题目一"><a
href="https://www.lanqiao.cn/problems/1536/learning/?page=1&amp;first_category_id=1&amp;problem_id=1536">题目一</a></h1>
<h2 id="题干">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240227160907000.png" /></p>
<h2 id="分析">分析</h2>
<p>状态：dp[i][j]表示第i行，第j列的和的最大值</p>
<p>状态迁移方程：方向从底向上，取当前位置的下一层的左边或右边的最大值与当前位置求和，作为当前位置dp值</p>
<p>最终状态：dp[1][1]</p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 读入三角形里面的数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">				 dp[i][j] = scan.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">				<span class="comment">// 状态转移方程，不过是从下往上</span></span><br><span class="line">				dp[i][j] += Math.max(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目二"><a
href="https://www.lanqiao.cn/problems/3367/learning/?page=1&amp;first_category_id=1&amp;problem_id=3367">题目二</a></h1>
<h2 id="题干-1">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228085943251.png" /></p>
<h2 id="分析-1">分析</h2>
<p>确定状态：dp[i]表示到第i级台阶有多少种方案</p>
<p>确定状态转移方程：从后往前,dp[i] = dp[i - 1] + dp[i - 2]</p>
<p>确定最终状态：dp[N]</p>
<p>注意，题目中如果告诉你结果比较大，java一般需要开long</p>
<h2 id="代码-1">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10e5</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] broken = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXSIZE];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">worse</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			broken[worse] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第0级台阶</span></span><br><span class="line">		broken[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 第一级台阶比较特殊，如果第一级台阶没有坏，则只用一种可能，就是从第0级台阶上来</span></span><br><span class="line">		<span class="keyword">if</span>(broken[<span class="number">1</span>] == <span class="literal">false</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(broken[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">				dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % p;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		for(int i = 1; i &lt;= N; i++) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		System.out.println();</span></span><br><span class="line">		System.out.println(dp[N]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目三"><a
href="https://www.lanqiao.cn/problems/3423/learning/?page=1&amp;first_category_id=1&amp;problem_id=3423">题目三</a></h1>
<h2 id="题干-2">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304094002984.png" /></p>
<h2 id="分析-2">分析</h2>
<h3 id="确定状态-1">确定状态</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4c5353de2efaf91f73998dca65bb934.jpg" /></p>
<p>dp[i]:最后一个桶放在位置i的方案总数</p>
<h3 id="状态转移方程">状态转移方程</h3>
<p>因为dp[i]表示最后一个桶在位置i所具有的方案总数，而要求最近的相邻两个桶之间要相隔k个桶，所以dp[i]等于从最后一个桶在位置1的方案(dp[1])到最后一个桶在位置i
- k - 1的方案数(dp[i - k - 1])的和，即<span class="math inline">\(dp[j]
= \sum_{i = 1}^{j - k - 1}dp[i]\)</span></p>
<h3 id="最终状态">最终状态</h3>
<p>题目要求的是总方案数，由dp数列定义可知不是dp[N]，所以要对dp数组求前缀和，prefix[N]才是答案</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		dp[<span class="number">0</span>] = prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i - k - <span class="number">1</span> &lt; <span class="number">1</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> dp[i] =  prefix[i - k - <span class="number">1</span>];</span><br><span class="line">			prefix[i] = (prefix[i - <span class="number">1</span>] + dp[i]) % p;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(prefix[n]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="入门一题"><a
href="https://www.lanqiao.cn/problems/3503/learning/">入门一题</a></h1>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划基础-混境之地5</title>
    <url>/posts/56b92135.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/3820/learning/?page=1&amp;first_category_id=1&amp;problem_id=3820">题目</a></h1>
<h1 id="分析">分析</h1>
<p>这题最初的想法用dfs解决，但会超时，分析是因为每次递归计算的值没有利用，所以开一个dp[n][m][k]数组，表示从起点开始，在经过点(x,
y)，并且在使用喷气背包的次数为t的情况下，能否到达终点</p>
<p>另外要注意地图的边界是从1开始，不是从0开始</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// dp有三个值：-1表示没有遍历过，0表示从起点,经过点(x, y),在喷气背包使用t次的情况下无法抵达终点，1则相反，表示可以抵达</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sx, sy, fx, fy;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果发现已经抵达终点</span></span><br><span class="line">    	<span class="keyword">if</span>(x == fx &amp;&amp; y == fy) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果发现当前坐标位置已经遍历过，dp思想的核心体现</span></span><br><span class="line">    	<span class="keyword">if</span>(dp[x][y][p] != -<span class="number">1</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> dp[x][y][p];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 上下左右依次遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">    		<span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line">    		<span class="comment">// 判断移动后是否还在地图里</span></span><br><span class="line">    		<span class="keyword">if</span>(!isValid(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="comment">// 如果当前喷气背包没有使用</span></span><br><span class="line">    		<span class="keyword">if</span>(p == <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">// 当前高度比下一个高度高</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span> dfs(nx, ny, <span class="number">0</span>);</span><br><span class="line">    				<span class="comment">// 如果经过当前点可以抵达终点</span></span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					<span class="comment">// 将dp[x][y][p]置为1并且返回1，向上一层传递</span></span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="comment">// 当前高度比下一个高度低但是使用喷气背包后可以抵达</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &lt; map[nx][ny] &amp;&amp; map[x][y] + k &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span>dfs(nx, ny, <span class="number">1</span>);</span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 如果当前喷气背包已经使用</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span> dfs(nx, ny, <span class="number">1</span>);</span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	dp[x][y][p] = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fillArrays</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">    				dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        n = scan.nextInt();</span><br><span class="line">        m = scan.nextInt();</span><br><span class="line">        k = scan.nextInt();</span><br><span class="line">        sx = scan.nextInt();</span><br><span class="line">        sy = scan.nextInt();</span><br><span class="line">        fx = scan.nextInt();</span><br><span class="line">        fy = scan.nextInt();</span><br><span class="line">        fillArrays();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        		map[i][j] = scan.nextInt();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfs(sx, sy, <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥oj-3362-建造房屋</title>
    <url>/posts/a0fa68f9.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/3362/learning/?page=1&amp;first_category_id=1&amp;problem_id=3362">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305151646680.png" /></p>
<h1 id="分析">分析</h1>
<h2 id="确定dp含义">确定dp含义</h2>
<p>dp[ i ] [ j
]表示第<strong>i</strong>条街在建了<strong>j</strong>栋房子情况下的方案数量</p>
<h2 id="状态转移方程">状态转移方程</h2>
<p><span class="math inline">\(dp[i][j + q] = \sum_{q = i - 1}^{k}dp[i -
1][q]，其中j从1到m\)</span></p>
<h2 id="最终状态">最终状态</h2>
<p>dp[ n ][ k ]</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 为什么max要设置成下面两种形式，真的就是往大了开吗</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXK</span> <span class="operator">=</span> <span class="number">2605</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN][MAXK];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 下面这个初始化不知道有什么作用</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最外层for循环计算的是从第一条街道到第n条街道</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="comment">// 中间这层for循环计算的是第i条街道上修建的房子从1到n的情况</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				<span class="comment">// 最里面for循环计算的是前i - 1条街道修建的房屋数量</span></span><br><span class="line">				<span class="comment">// 其中最少每条街道一层房屋，有i-1条街道，所以有i-1条房屋</span></span><br><span class="line">				<span class="comment">// 最多就建到预算花光为止</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i - <span class="number">1</span>; q &lt;= k; q++) &#123;</span><br><span class="line">					dp[i][j + q] += dp[i - <span class="number">1</span>][q];</span><br><span class="line">					dp[i][j + q] %= p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(dp[n][k]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题">问题</h1>
<h2 id="maxn-maxk的设置">MAXN, MAXK的设置</h2>
<h2 id="三重for循环顺序的设置">三重for循环顺序的设置</h2>
<h2 id="初始化dp0这一行">初始化dp[0]这一行</h2>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>2023javaA组填空题一</title>
    <url>/posts/4528259b.html</url>
    <content><![CDATA[<h1 id="填空题真题欧拉函数与快速幂"><a
href="http://oj.ecustacm.cn/problem.php?id=2093">2023填空题真题欧拉函数与快速幂</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>给定a, b，求<span class="math inline">\(1 ≤ x ＜ a^b\)</span>
中有多少个 x 与<span class="math inline">\(a^b\)</span> 互质。
由于答案可能很大，你只需要输出答案对 998244353 取模的结果。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入一行包含两个整数分别表示 a, b，用一个空格分隔。 对于 30%
的评测用例，ab ≤ 106； 对于 70% 的评测用例，a ≤ 106，b ≤ 109； 对于 100%
的评测用例，1 ≤ a ≤ 109，1 ≤ b ≤ 1018 。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行包含一个整数表示答案。</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样例1：</span><br><span class="line">2 5</span><br><span class="line"></span><br><span class="line">样例2：</span><br><span class="line">12 7</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样例1：</span><br><span class="line">16</span><br><span class="line"></span><br><span class="line">样例2：</span><br><span class="line">11943936</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="欧拉函数">欧拉函数</h2>
<h2 id="快速幂">快速幂</h2>
<p>所以要解决上面问题，首先要用快速幂求出临界值，然后用欧拉函数求出所有的质因数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BigInteger</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;998244353&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextBigInteger();</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextBigInteger();</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ab</span> <span class="operator">=</span> quickPower(a, b.subtract(BigInteger.ONE));</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> eulr(a).multiply(ab).mod(MOD);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BigInteger <span class="title function_">quickPower</span><span class="params">(BigInteger base, BigInteger power)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (power.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (power.and(BigInteger.ONE).compareTo(BigInteger.ZERO) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans.multiply(base).mod(MOD);	<span class="comment">//这里提前取余是关键，否则会超时</span></span><br><span class="line">            &#125;</span><br><span class="line">            base = base.multiply(base).mod(MOD);	<span class="comment">//</span></span><br><span class="line">            power = power.shiftRight(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BigInteger <span class="title function_">eulr</span><span class="params">(BigInteger n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>); i.multiply(i).compareTo(n) &lt;= <span class="number">0</span>; i = i.add(BigInteger.ONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.mod(i).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                ans = ans.subtract(ans.divide(i));</span><br><span class="line">                <span class="keyword">while</span>(n.mod(i).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                    n = n.divide(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.compareTo(BigInteger.ONE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans.subtract(ans.divide(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a.compareTo(b):</p>
<p>如果a &gt; b， 返回1</p>
<p>如果a &lt; b, 返回-1</p>
<p>如果a = b, 返回0</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>填空题</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/posts/20c47d09.html</url>
    <content><![CDATA[<h1 id="定义">定义：</h1>
<p><strong>核心思想：利用二进制来加速运算</strong></p>
<p>举例说明</p>
<p>计算 <span class="math inline">\(3^{45}\)</span></p>
<p>首先把指数45转换为二进制：45(10)=101101(2)</p>
<p>接下来我们可以得到下面的等式</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114436346.png" /></p>
<p>因为</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114454727.png" /></p>
<p>所以我们只需要计算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114512200.png" /></p>
<h2 id="代码模板">代码模板</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger <span class="title function_">quick_power</span><span class="params">(BigInteger base, BigInteger power)</span> &#123;	<span class="comment">//base表示底数，power表示指数</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">    <span class="keyword">while</span>(power.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(power.and(BigInteger.ONE).compareTo(BigInteger.ZERO) &lt; <span class="number">0</span>) &#123;	</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	底数与1同或来判断底数的二进制的最后一位是1还是0, </span></span><br><span class="line"><span class="comment">            	任意一个十进制数，如果是偶数，二进制末尾表示是0;如果是奇数，二进制末尾表示1</span></span><br><span class="line"><span class="comment">            	所以与1同或，如果结果是1，说明原来数的末尾是1，原来的数是奇数; 如果结果是0，说明原来末尾是0，原来的数是偶数			*/</span></span><br><span class="line">            ans = ans.multiply(base);	<span class="comment">//如果最后一位是1，那么就要把当前结果累乘到ans中</span></span><br><span class="line">        &#125;</span><br><span class="line">        base = base.multiply(base);		<span class="comment">//由幂的递归可知下一位的base是当前的平方</span></span><br><span class="line">        power = power.shiftRight(<span class="number">1</span>);	<span class="comment">//将指数右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://blog.csdn.net/m0_52072919/article/details/116400820">参考文章</a></p>
<h2 id="举一反三">举一反三</h2>
<h3 id="题目一"><a
href="https://pilotztb.github.io/2024/01/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-Acwing875%E5%BF%AB%E9%80%9F%E5%B9%82/">题目一</a></h3>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing875快速幂</title>
    <url>/posts/6bcd24b7.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/91">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122100217638.png" /></p>
<h1 id="分析">分析</h1>
<p>快速幂，虽然java开BigInteger可以防止爆栈，但是会超时</p>
<p>引理</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122100259455.png" /></p>
<p>因为有上面的引理，所以在每次求快速幂的过程中都可以取余</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		System.out.println(quickPower(a, b, p));</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> BigInteger <span class="title function_">quickPower</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">baseBigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(base));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">powerInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(power));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">pBigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(p));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">ansBigInteger</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">		<span class="keyword">while</span>(powerInteger.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(powerInteger.and(BigInteger.ONE).compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				ansBigInteger = ansBigInteger.multiply(baseBigInteger).mod(pBigInteger);	<span class="comment">//取余1</span></span><br><span class="line">			&#125; </span><br><span class="line">			baseBigInteger = baseBigInteger.multiply(baseBigInteger).mod(pBigInteger);	<span class="comment">//取余2</span></span><br><span class="line">			powerInteger = powerInteger.shiftRight(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ansBigInteger.mod(pBigInteger);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/posts/f60286b9.html</url>
    <content><![CDATA[<h1 id="基本定义">基本定义</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5fbf00fa9b8608561a46bd64ded90d4.png" /></p>
<p>不过一般写程序不用上面的求法，而是用下面的思路与代码</p>
<p>找出n的因子，剔除含有n的因子的数</p>
<h2 id="代码模板">代码模板</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求欧拉函数Φ(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eulr</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n;	<span class="comment">//假设最初的结果就是有n个数，下面要一个一个从这n个数删</span></span><br><span class="line">    <span class="comment">// ans表示的是n的素因子个数</span></span><br><span class="line">    <span class="comment">// n表示的是素因子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;	<span class="comment">//循环结束条件是i * i &lt;= 2，只用检查小于平方根的就行，否则就重复</span></span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;	<span class="comment">//如果这个数是n的因数，就要从ans中删除掉所有i的小于n的倍数</span></span><br><span class="line">            ans -= ans / i;	<span class="comment">// ans / i表示比n小的i的最大倍数，这个倍数从1到ans/i一共有ans/i个，从ans中减去这么多</span></span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;		<span class="comment">//从ans中删除i的倍数后，也要</span></span><br><span class="line">                n  = n / i;		<span class="comment">//这一个语句是为了保证完全消除我们刚才得到的那个i因子。防止重复减</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;	<span class="comment">//若n大于1，则此时的n也是一个除1以外的因子</span></span><br><span class="line">        ans -= ans / n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;		<span class="comment">//从ans中删除i的倍数后，也要</span></span><br><span class="line">    n  = n / i;		<span class="comment">//这一个语句是为了保证完全消除我们刚才得到的那个i因子。防止重复减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;	<span class="comment">//若n大于1，则此时的n也是一个除1以外的因子</span></span><br><span class="line">       ans -= ans / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8e058d7f5186fac3503e8cb9e1d501d.jpg" /></p>
<h2 id="举一反三">举一反三</h2>
<h3 id="题目一"><a
href="https://lx.lanqiao.cn/problem.page?gpid=T752###">题目一</a></h3>
<h3 id="题目二"><a
href="https://www.luogu.com.cn/problem/P2158">题目二</a></h3>
<p><a
href="https://pilotztb.github.io/2024/01/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%B4%9B%E8%B0%B72008SODI%E4%BB%AA%E4%BB%97%E9%98%9F/">题解</a></p>
<h3 id="题目三"><a
href="https://www.acwing.com/problem/content/description/203/">题目三</a></h3>
<p>与上题几乎一样</p>
<h1 id="线性筛法">线性筛法</h1>
<h1 id="参考文章">参考文章</h1>
<p><a
href="https://blog.csdn.net/ydd97/article/details/47805419">参考文章一</a></p>
<p><a
href="https://blog.51cto.com/u_16213636/7620153">参考文章二</a></p>
<p><a
href="https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=SfPFLdFUU2r7JgOwYzjW1MfNZpAvGKgn1QC5rW4ugBC74c2OKvH08wleW3s8HvAl&amp;search_content=%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">更多题库一</a></p>
<p><a
href="https://www.cnblogs.com/windymoon/p/17053198.html">更多题库二</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>数论小结</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷2008SODI仪仗队</title>
    <url>/posts/ccb37efa.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.luogu.com.cn/problem/P2158">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的
<span class="math inline">\(N \times N\)</span>
的方阵，为了保证队伍在行进中整齐划一，C
君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1149.png" /></p>
<p>现在，C 君希望你告诉他队伍整齐时能看到的学生人数。</p>
<h2 id="输入格式">输入格式</h2>
<p>一行，一个正整数 <span class="math inline">\(N\)</span>。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行一个数，即 C 君应看到的学生人数。</p>
<h2 id="样例输入">样例输入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="样例输出">样例输出</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<p>对于 <span class="math inline">\(100 \%\)</span> 的数据，<span
class="math inline">\(1 \le N \le 40000\)</span>。</p>
<h1 id="分析">分析</h1>
<p>要求的就是从原点看，能看到几个点（原点不考虑，就是如果n =
1，那么就只有1个人，就是观察者本身，那么他看不到其他人）</p>
<p>举个例子，如果n=4</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0b7367d6f906eb4d59b68faf776abcb.jpg" /></p>
<p>可以看出是9个</p>
<p>那么怎么推出一般情况呢</p>
<p>首先发现点关于y = x
对称，所以只用研究一半就行，又因为（1，1）这个点比较特殊，所以将(0,
1)(1, 0)(1, 1)这三个点另外看，从i = 2开始分析</p>
<p>发现从i = 2到 i = n - 1,
要能看到，说明没有遮挡，即x与y互质，所以就是求<span
class="math inline">\(\sum_{i = 2}^{n - 1}\sum_{j = 0}^{j = i}[gcd(i, j)
= 1]\)</span>（求和公式从左往右看），而<span
class="math inline">\(\sum_{j = 0}^{j = i}[gcd(i, j) =
1]\)</span>就是<span
class="math inline">\(\varphi(i)\)</span>，所以最终计算结果就是$ 3 + 2
*_{i = 2}^{n - 1}(i)$</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">ansSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">			ansSum += <span class="number">2</span> * eulr(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ansSum += <span class="number">3</span>;</span><br><span class="line">			System.out.println(ansSum);</span><br><span class="line">			scan.close();			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">eulr</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">				ans -= ans / i;</span><br><span class="line">				<span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">					n /= i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			ans -= ans / n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.acwing.com/problem/content/description/203/">类似(或者说一模一样的题目)</a></p>
<p>区别在于两题对于n的定义，上一题n包含观察者本身，这一题则不包含；比如n=1的时候，上一题结果为0，本题则是3</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥oj610-分数</title>
    <url>/posts/7df5f4eb.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/610/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240311101618051.png" /></p>
<h1 id="分析">分析</h1>
<p>首先是等比数列</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/39282fc6987ee321a5936c2ed59552d.jpg" /></p>
<p>然后一个数论知识</p>
<p>较大的数如果比较小的数的两倍大1或者小1，则两者互质。</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.print((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">20</span>) - <span class="number">1</span>);</span><br><span class="line">		System.out.print(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">		System.out.print((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">19</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>模拟-四舍五入打印</title>
    <url>/posts/9afd3e68.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/497/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115064739206.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">80</span><br><span class="line">92</span><br><span class="line">56</span><br><span class="line">74</span><br><span class="line">88</span><br><span class="line">99</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99</span><br><span class="line">10</span><br><span class="line">71.29</span><br></pre></td></tr></table></figure>
<h1
id="分析主要就是java中如何四舍五入打印浮点数">分析：主要就是java中如何四舍五入打印浮点数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123.121323232</span>;</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>)	<span class="comment">//四舍五入打印两位小数，并且要保留最后的0，比如0.80要按0.80打印，不能按0.8打印</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>另外一个隐藏的易错点就是java中两个int型计算还是int，要得到java必须把其中之一强转成double或乘个1.0也成double型</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">highestScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowestScore</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            totalScore += score;</span><br><span class="line">            <span class="keyword">if</span>(score &lt; lowestScore) lowestScore = score;</span><br><span class="line">            <span class="keyword">if</span>(score &gt; highestScore) highestScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(highestScore);</span><br><span class="line">        System.out.println(lowestScore);</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">averageScore</span> <span class="operator">=</span> (<span class="type">double</span>)totalScore / n; </span><br><span class="line">        <span class="type">String</span> <span class="variable">rounded_num</span> <span class="operator">=</span> df.format(averageScore);</span><br><span class="line">        System.out.println(rounded_num);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>模拟-字符串操作</title>
    <url>/posts/5fa32b49.html</url>
    <content><![CDATA[<h1 id="题目一-字符串中大小写转换"><a
href="https://www.lanqiao.cn/problems/1590/learning/">题目一</a>
字符串中大小写转换</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115100356557.png" /></p>
<p>toUpperCase方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">str = str.toUpperCase(); </span><br></pre></td></tr></table></figure>
<h1 id="题目二字符串转字符数组">题目二：字符串转字符数组</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115100623353.png" /></p>
<p>toCharArray</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray()) &#123; <span class="comment">// 修改这里</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 修改这里</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="题目三字符串和数字之前的转换">题目三：字符串和数字之前的转换</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115102119742.png" /></p>
<h2
id="字符串转数字数字的类类型.parse数字的类类型字符串">字符串转数字：数字的类类型.parse数字的类类型(字符串)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure>
<h2
id="数字转字符串string.valueof数字">数字转字符串：String.valueOf(数字)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br></pre></td></tr></table></figure>
<h2
id="判断一个字符在不在字符串中字符串.indexof字符如果不在返回-1">判断一个字符在不在字符串中：字符串.indexOf(字符)，如果不在返回-1</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.indexOf(<span class="string">&#x27;9&#x27;</span>) </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2019</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;2&#x27;</span>) != -<span class="number">1</span>|| </span><br><span class="line">               str.indexOf(<span class="string">&#x27;0&#x27;</span>) != -<span class="number">1</span>|| </span><br><span class="line">               str.indexOf(<span class="string">&#x27;1&#x27;</span>) != -<span class="number">1</span>||</span><br><span class="line">               str.indexOf(<span class="string">&#x27;9&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">            	sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目四-串的处理"><a
href="https://www.lanqiao.cn/problems/287/learning/">题目四</a>
串的处理</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240118103848703.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you and me what cpp2005program</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You And Me What Cpp_2005_program</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3
id="将一个字符串分割成多个子字符串构成字符串数组">将一个字符串分割成多个子字符串构成字符串数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strLiStrings = str.split(<span class="string">&quot;\\s+&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>不同单词，其中不同单词之间的空格不止一个</p>
<h3 id="访问字符串指定位置字符">访问字符串指定位置字符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subString.charAt(i)</span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<h3 id="声明">声明</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure>
<h3 id="在后面加入">在后面加入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.append()</span><br></pre></td></tr></table></figure>
<h3 id="在指定位置插入">在指定位置插入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.insert(i, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除指定位置字符串">删除指定位置字符串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.delete(<span class="number">0</span>, <span class="number">2</span>);  #左闭右开</span><br></pre></td></tr></table></figure>
<h2 id="字符">字符</h2>
<h3 id="大小写转换">大小写转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(subString.charAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="判断字符是否是数字">判断字符是否是数字</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.isDigit(subString.charAt(i))</span><br></pre></td></tr></table></figure>
<h3 id="判断字符是否是字母">判断字符是否是字母</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.isAlphabetic(subString.charAt(i))</span><br></pre></td></tr></table></figure>
<p>代码一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">        String[] strLiStrings = str.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String subString : strLiStrings) &#123;</span><br><span class="line">        	<span class="comment">//声明一个可变字符串</span></span><br><span class="line">        	<span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        	<span class="comment">//首字母大写</span></span><br><span class="line">        	stringBuffer.append(Character.toUpperCase(subString.charAt(<span class="number">0</span>)));</span><br><span class="line">        	<span class="comment">//消除多余的空格</span></span><br><span class="line">        	<span class="type">char</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="type">char</span> <span class="variable">now</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subString.length(); i++) &#123;</span><br><span class="line">        		now = subString.charAt(i);</span><br><span class="line">        		<span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span>(pre == <span class="string">&#x27; &#x27;</span> &amp;&amp; now == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        				<span class="keyword">continue</span>;</span><br><span class="line">        			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        				stringBuffer.append(now);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;	<span class="comment">//if</span></span><br><span class="line">        		pre = now;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">//数字和字符之间加入_</span></span><br><span class="line">        	pre = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	now = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuffer.length(); i++) &#123;</span><br><span class="line">        		now = stringBuffer.charAt(i);</span><br><span class="line">        		<span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span>(Character.isDigit(pre) &amp;&amp; Character.isAlphabetic(now) || Character.isAlphabetic(pre) &amp;&amp; Character.isDigit(now)) &#123;</span><br><span class="line">        				stringBuffer.insert(i, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        			&#125; <span class="comment">//if</span></span><br><span class="line">        		&#125;	<span class="comment">//if</span></span><br><span class="line">        		pre = now;</span><br><span class="line">        	&#125;	<span class="comment">//for</span></span><br><span class="line">        	System.out.print(stringBuffer);</span><br><span class="line">        	System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码二：正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String str[] = s.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            str[i] = str[i].substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + str[i].substring(<span class="number">1</span>);</span><br><span class="line">            str[i] = str[i].replaceAll(<span class="string">&quot;(\\d)([a-zA-Z])&quot;</span>, <span class="string">&quot;$1_$2&quot;</span>);</span><br><span class="line">            str[i] = str[i].replaceAll(<span class="string">&quot;([a-zA-Z])(\\d)&quot;</span>, <span class="string">&quot;$1_$2&quot;</span>);</span><br><span class="line">            System.out.print(str[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目五进制转换"><a
href="https://www.lanqiao.cn/problems/3499/learning/">题目五</a>：进制转换</h1>
<p>题目</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240118114633245.png" /></p>
<h2
id="将十进制数字转换成二进制字符串">将十进制数字转换成二进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(test)</span><br></pre></td></tr></table></figure>
<h2
id="将十进制数字转换成八进制字符串">将十进制数字转换成八进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(test)</span><br></pre></td></tr></table></figure>
<h2
id="将十进制数字转换成十六进制字符串">将十进制数字转换成十六进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(test)</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">test</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">126</span>;</span><br><span class="line">		<span class="keyword">while</span>(count &lt;= <span class="number">2022</span>) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//先判断十进制</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">demicalString</span> <span class="operator">=</span> String.valueOf(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; demicalString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(demicalString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断二进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; binaryString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(binaryString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断八进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; octalString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(octalString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断十六进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hexString.length(); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(Character.isDigit(hexString.charAt(i))) &#123;</span><br><span class="line">					sum += Character.getNumericValue(hexString.charAt(i));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					sum += hexString.charAt(i) - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum == <span class="number">0</span>) &#123;</span><br><span class="line">				ans = test;</span><br><span class="line">				count++; </span><br><span class="line"><span class="comment">//				System.out.format(&quot;%d %d\n&quot;, ans, count);				</span></span><br><span class="line">			&#125;</span><br><span class="line">			test++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目六-字符串的拼接"><a
href="https://www.lanqiao.cn/problems/523/learning/">题目六</a>
字符串的拼接</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119064340539.png" /></p>
<p>输入1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure>
<p>输出1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Right</span><br></pre></td></tr></table></figure>
<p>输入2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-0</span><br></pre></td></tr></table></figure>
<p>输出2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-4 </span><br></pre></td></tr></table></figure>
<h2 id="判断两个字符串内容是否相等">判断两个字符串内容是否相等</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.equals(str2)</span><br></pre></td></tr></table></figure>
<h2
id="将字符串数组用指定字符拼接成一个字符串">将字符串数组用指定字符拼接成一个字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot;-&quot;</span>, strList);</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine(); </span><br><span class="line">        String[] strList = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">yanzhen</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        	yanzhen += strList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.format(&quot;yanzhen = %s\n&quot;, yanzhen);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanzhen.length(); i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">nowNum</span> <span class="operator">=</span> yanzhen.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        	<span class="comment">//System.out.format(&quot;nowNum = %d, i + 1 = %d\n&quot;, nowNum, i + 1);</span></span><br><span class="line">        	sum += nowNum * (i + <span class="number">1</span>);</span><br><span class="line">        	<span class="comment">//System.out.format(&quot;sum = %d\n&quot;, sum);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">11</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        	last = String.valueOf(sum % <span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	last = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        &#125;	<span class="comment">//if</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;last = %s\n&quot;, last);</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;strList[strList.length - 1] = %s\n&quot;, strList[strList.length - 1]);</span></span><br><span class="line">        <span class="keyword">if</span>(strList[strList.length - <span class="number">1</span>].equals(last)) &#123;</span><br><span class="line">        	System.out.print(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	strList[strList.length - <span class="number">1</span>] = last;</span><br><span class="line">        	System.out.println(String.join(<span class="string">&quot;-&quot;</span>, strList));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟-扫雷</title>
    <url>/posts/4e35f674.html</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115083638375.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">0 1 0 0</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 9 2 1</span><br><span class="line">9 4 9 2</span><br><span class="line">1 3 9 2</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="按上一行同一行下一行分类">按上一行，同一行，下一行分类</h2>
<h2
id="每一行要判断前一列和后一列是否存在">每一行要判断前一列和后一列是否存在</h2>
<h1 id="代码">代码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">// 1:无需package</span><br><span class="line">// 2: 类名必须Main, 不可修改</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        //在此输入您的代码...</span><br><span class="line">        int n = scan.nextInt();</span><br><span class="line">        int m = scan.nextInt();</span><br><span class="line">        int[][] data = new int[n][m];</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                data[i][j] = scan.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] assistance = new int[n][m];</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if(data[i][j] == 1) &#123;</span><br><span class="line">                    assistance[i][j] = 9;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果上一行存在</span><br><span class="line">                if(i - 1 &gt;= 0) &#123;</span><br><span class="line">                	//正上方如果有雷</span><br><span class="line">                    if(data[i - 1][j] == 1) &#123;</span><br><span class="line">                        assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果左上方存在且有雷</span><br><span class="line">                    if(j - 1 &gt;= 0 &amp;&amp; data[i - 1][j - 1] == 1) &#123;</span><br><span class="line">                    	assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //右上方存在且有雷</span><br><span class="line">                    if(j + 1 &lt; m &amp;&amp; data[i - 1][j + 1] == 1) &#123;</span><br><span class="line">                    	assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                //对于同一行前一列存在且有雷</span><br><span class="line">                if(j - 1 &gt;= 0 &amp;&amp; data[i][j - 1] == 1) &#123;</span><br><span class="line">                	assistance[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                //对于同一行后一列存在</span><br><span class="line">                if(j + 1 &lt; m &amp;&amp; data[i][j + 1] == 1) &#123;</span><br><span class="line">                	assistance[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                //下一行存在</span><br><span class="line">                if(i + 1 &lt; n) &#123;</span><br><span class="line">                	//正下方有雷</span><br><span class="line">                	if(data[i + 1][j] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                	//左下方存在且有雷</span><br><span class="line">                	if(j - 1 &gt;= 0 &amp;&amp; data[i + 1][j - 1] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                	//右下方存在且有雷</span><br><span class="line">                	if(j + 1 &lt; m &amp;&amp; data[i + 1][j + 1] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                System.out.print(assistance[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>模拟 - 天干地支</title>
    <url>/posts/27c6c117.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/1029/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116080127420.png" /></p>
<span id="more"></span>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gengzi</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2
id="思路一从已知的庚子年1900年出发">思路一：从已知的庚子年1900年出发</h2>
<h3
id="首先分成在1900年前的年份和在1900年后的年份计算l和1900的距离left">首先分成在1900年前的年份和在1900年后的年份，计算l和1900的”距离“left</h3>
<h3 id="对于在1900年前的年份">对于在1900年前的年份</h3>
<h4
id="天干就是在差值模10后加在庚的基础上再模10">天干就是在差值模10后加在庚的基础上再模10</h4>
<h4
id="地支就是在差值模12后加在子的基础上再模12">地支就是在差值模12后加在子的基础上再模12</h4>
<h3 id="对于在1900年前的年份-1">对于在1900年前的年份</h3>
<h4
id="天干就是在差值模10后先将庚加10再减前面的计算后再模10和循环队列的计算方式异曲同工之妙">天干就是在差值模10后，先将庚加10，再减前面的计算后，再模10(和循环队列的计算方式异曲同工之妙)</h4>
<h4
id="地址就是在差值模12后先将子加12再减前面的计算后再模12">地址就是在差值模12后，先将子加12，再减前面的计算后，再模12</h4>
<h3 id="代码一">代码一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] tiangan = &#123;<span class="string">&quot;jia&quot;</span>, <span class="string">&quot;yi&quot;</span>, <span class="string">&quot;bing&quot;</span>, <span class="string">&quot;ding&quot;</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;ji&quot;</span>, <span class="string">&quot;geng&quot;</span>, <span class="string">&quot;xin&quot;</span>, <span class="string">&quot;ren&quot;</span>, <span class="string">&quot;gui&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] dizhi = &#123;<span class="string">&quot;zi&quot;</span>, <span class="string">&quot;chou&quot;</span>, <span class="string">&quot;yin&quot;</span>, <span class="string">&quot;mao&quot;</span>, <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;si&quot;</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;wei&quot;</span>, <span class="string">&quot;shen&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;xu&quot;</span>, <span class="string">&quot;hai&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tianganIndex;</span><br><span class="line">        <span class="type">int</span> dizhiIndex;</span><br><span class="line">        <span class="keyword">if</span>(year &gt;= <span class="number">1900</span>) &#123;</span><br><span class="line">        	left = year - <span class="number">1900</span>;</span><br><span class="line">            tianganIndex = (left % <span class="number">10</span> + <span class="number">6</span>) % <span class="number">10</span>;</span><br><span class="line">            dizhiIndex = left % <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	left = <span class="number">1900</span> - year;</span><br><span class="line">        	tianganIndex = (<span class="number">6</span> - (left % <span class="number">10</span>) + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        	dizhiIndex = (<span class="number">0</span> + <span class="number">12</span> - (left % <span class="number">12</span>)) % <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tianganString</span> <span class="operator">=</span> tiangan[tianganIndex];</span><br><span class="line">        <span class="type">String</span> <span class="variable">dizhiString</span> <span class="operator">=</span> dizhi[dizhiIndex];</span><br><span class="line">        <span class="type">String</span> <span class="variable">nongliString</span> <span class="operator">=</span> tianganString + dizhiString;</span><br><span class="line">        System.out.println(nongliString);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路二">思路二</h2>
<h3
id="关键在找到时间原点既然始终是60一循环那么可以将1200年经过计算是庚申年作为时间原点">关键在找到“时间原点”，既然始终是60一循环，那么可以将1200年（经过计算是庚申年）作为时间原点</h3>
<p>原因是1200年是60的倍数，相当于0</p>
<h3
id="将天干数组从庚开始重新排列地支数组从申开始重新排列">将天干数组从庚开始重新排列，地支数组从申开始重新排列</h3>
<h3
id="直接计算一个年份模10的结果到天干数组里查到对应的下标即可地支同理">直接计算一个年份模10的结果到天干数组里查到对应的下标即可，地支同理</h3>
<h3 id="代码二">代码二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">//最简单的还是给这些天干地支重新排序，然后对年取余输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> year=scanner.nextInt();</span><br><span class="line">        String s1[]=&#123;<span class="string">&quot;geng&quot;</span>,<span class="string">&quot;xin&quot;</span>,<span class="string">&quot;ren&quot;</span>,<span class="string">&quot;gui&quot;</span>,<span class="string">&quot;jia&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;bing&quot;</span>,<span class="string">&quot;ding&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;ji&quot;</span>&#125;;</span><br><span class="line">        String s2[]=&#123;<span class="string">&quot;shen&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;xu&quot;</span>,<span class="string">&quot;hai&quot;</span>,<span class="string">&quot;zi&quot;</span>,<span class="string">&quot;chou&quot;</span>,<span class="string">&quot;yin&quot;</span>,<span class="string">&quot;mao&quot;</span>,<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;si&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;wei&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> tiangan=year % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> dizhi=year % <span class="number">12</span>;</span><br><span class="line">        System.out.println(s1[tiangan]+s2[dizhi]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>三分法</title>
    <url>/posts/7481085d.html</url>
    <content><![CDATA[<h1 id="求一元单峰函数的极值">求一元单峰函数的极值</h1>
<p>二分法使用的场景是单调函数，也就是一次函数。</p>
<p>三分法会将区间分成三份，这个我们都已经知道了。分成三份，自然需要两个端点。这两个端点各有一个值，我们分别叫做m1和m2。我们要求的是函数的最小值，所以我们要想极值逼近。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-6628b0cf182ec681577b9fb23799bc35_720w.webp" /></p>
<p>每次通过比较两个值的大小，缩小三分之一的区间。直到最后区间的范围小于我们设定的阈值为止</p>
<p><strong>三分法</strong>是二分法的变种，他最基本的用途是求<strong>单峰函数</strong>的<strong>极值点</strong>。</p>
<p>以求极大值为例，每次对一个区间<code>[l,r]</code>求三等分点<code>lsec</code>和<code>rsec</code>：</p>
<p>如果<code>f(lsec) &lt; f(rsec)</code>
，说明极大值一定在<code>[lsec,r]</code>内取到，因为如果在<code>[0,lsec)</code>内，那<code>rsec</code>一定处于单调下降的区间内，它的函数值不可能大于<code>lsec</code>的函数值。
于是我们令<code>l=lsec</code>并继续。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-9232f79a4646b65ff2c2715538a28b3f_720w.webp" /></p>
<p>如果<code>f(lsec) &gt; f(rsec)</code>，同理，极大值一定在<code>[l,rsec]</code>内取到，令<code>r=rsec</code>并继续。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-dce8a5a80fd17ba9e4e000baf5c31146_720w.webp" /></p>
<p>这样进行下去，直到<code>l</code>和<code>r</code>的差距小于设定的<code>eps</code>为止。如果求的是极小值而非极大值，只需把上面条件判断处的大于、小于互换。</p>
<h1 id="求二元函数的极致">求二元函数的极致</h1>
<p>三分套三分</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-d3e2755075de272bbb0e76856ab6e231_720w.webp" /></p>
<p>​</p>
<p><a href="https://zhuanlan.zhihu.com/p/100617613">参考文章1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/337752413">参考文章2</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
      </categories>
  </entry>
  <entry>
    <title>多少个星期一</title>
    <url>/posts/5f80bd04.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/611/learning/">题目</a></h1>
<!--more--

![](https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325105631245.png)

# 分析

## java中时间处理

### LocalDate.of(year, month, day)

### toEpochDay()

用于将日期转换为自 1970 年 1 月 1 日起的天数（epoch day），返回一个 long 类型的值

## 如何统计

计算两个时间点之前星期一的数量就是计算出这两个时间点之间的天数后整除7，关键是对<font color = "red">第一天是星期几的判断</font>

利用一个已知是星期一的时间

如果已知时间与第一天的时间间隔是7的倍数，说明第一天是星期一，那么最后要在前面计算的整除结果上加1

如果已知时间与第一天的时间间隔不是7的倍数，说明第一天不是星期一，就不用加

# 题解

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 已知的年月日</span><br><span class="line">        LocalDate dateToday = LocalDate.of(2024, 3, 25);</span><br><span class="line">        LocalDate dateStartDate = LocalDate.of(1901, 1, 1);</span><br><span class="line">        LocalDate dateEndDate = LocalDate.of(2000, 12, 31);</span><br><span class="line">        long dayBetweenTodayAndStart = calculateDaysBetween(dateToday, dateStartDate);</span><br><span class="line">        long dayBetweenStartAndEnd = calculateDaysBetween(dateEndDate, dateStartDate);</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        if(dayBetweenTodayAndStart % 7 == 0) &#123;</span><br><span class="line">        	flag = true;	//flag = true说明当前第一天是星期一</span><br><span class="line">        &#125;</span><br><span class="line">        long mondays = 0;</span><br><span class="line">        if(flag == true) &#123;</span><br><span class="line">        	mondays = dayBetweenStartAndEnd / 7 + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	mondays = dayBetweenStartAndEnd / 7;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mondays);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算两个日期之间相隔的天数</span><br><span class="line">    public static long calculateDaysBetween(LocalDate date1, LocalDate date2) &#123;</span><br><span class="line">        // 获取两个日期对应的毫秒数</span><br><span class="line">        long millis1 = date1.toEpochDay();</span><br><span class="line">        long millis2 = date2.toEpochDay();</span><br><span class="line">        </span><br><span class="line">        // 计算两个日期相隔的天数</span><br><span class="line">        return Math.abs(millis2 - millis1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>填空题</title>
    <url>/posts/758ce69d.html</url>
    <content><![CDATA[<h1 id="知识点考核"><strong>知识点</strong>考核</h1>
<p>10题：不需要算法。在这些题目中，日期、排序比较常见，我们要多练习。</p>
<p>3题：必须用DFS。<strong>DFS是蓝桥杯省赛最常出现的考点，没有之一</strong>。</p>
<h1 id="难度">难度</h1>
<p>极简2题，学过语言就能做。 简单5题，需要经过一定的训练。
中等4题，需要更多训练。 难题2题，训练多了也不一定会。</p>
<h1 id="技巧">技巧</h1>
<p>填空题遇到<strong>字符、大数字、日期</strong>问题，Python是首选，可以直接模拟，不用什么编码技巧</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>日期中连续字符串</title>
    <url>/posts/736ca4c7.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/2096/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240327105210715.png" /></p>
<h1 id="分析">分析</h1>
<p>对于2022[ ][ ][ ][ ]来说，要么前三个连续，要么后三个连续</p>
<h1 id="代码">代码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	static int[] days = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;</span><br><span class="line">	static void fill(int num, int[] data, int start, int end) &#123;</span><br><span class="line">		if(num &gt;= 10) &#123;</span><br><span class="line">			data[start] = num / 10;</span><br><span class="line">			data[end] = num % 10;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			data[start] = 0;</span><br><span class="line">			data[end] = num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static boolean judge(int[] date) &#123;</span><br><span class="line">		if(date[0] + 1 == date[1] &amp;&amp; date[1] + 1 == date[2] || date[1] + 1 == date[2] &amp;&amp; date[2] + 1 == date[3]) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] date = new int[4];</span><br><span class="line">		int count = 0;</span><br><span class="line">		for(int i = 1; i &lt;= 12; i++) &#123;</span><br><span class="line">			fill(i, date, 0, 1);</span><br><span class="line">			for(int j = 1; j &lt;= days[i]; j++) &#123;</span><br><span class="line">				fill(j, date, 2, 3);</span><br><span class="line">				if(judge(date)) &#123;</span><br><span class="line">					//System.out.println(Arrays.toString(date));</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-安全区</title>
    <url>/posts/d779deea.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="http://oj.ecustacm.cn/problem.php?id=1078">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>在一个n<em>n的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。
求出n</em>n个点中有多少个是安全的点，即未被探测的点。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行为两个整数n,m(1&lt;=n&lt;=100,1&lt;=m&lt;=n*n)
接下来m行每行3个整数表示xi,yi,ri（1&lt;=xi,yi,ri&lt;=n）</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一个整数表示答案</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">3 3 1</span><br><span class="line">4 2 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析：</h1>
<h2
id="每得到一个点就遍历所有二维矩阵判断二维矩阵中对应的点与探测点核心距离是否小于探测距离">每得到一个点，就遍历所有二维矩阵，判断二维矩阵中对应的点与探测点核心距离是否小于探测距离</h2>
<h2
id="利用isvisited数组判断是否访问过防止重复计数">利用isVisited数组判断是否访问过，防止重复计数</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.hypot((x1 - x2), (y1 - y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[][] data = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) data[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">yi</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">otherX</span> <span class="operator">=</span> <span class="number">1</span>; otherX &lt;= n; otherX++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">otherY</span> <span class="operator">=</span> <span class="number">1</span>; otherY &lt;= n; otherY++) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">dis</span> <span class="operator">=</span> distance(xi, yi, otherX, otherY);</span><br><span class="line">                    <span class="keyword">if</span>(dis &lt;= (<span class="type">double</span>)ri &amp;&amp; data[otherX][otherY] == <span class="literal">true</span>) &#123;</span><br><span class="line">                        data[otherX][otherY] = <span class="literal">false</span>;</span><br><span class="line">                        totalNum--;</span><br><span class="line">                    &#125;  <span class="comment">//if</span></span><br><span class="line">                &#125;   <span class="comment">//for</span></span><br><span class="line">            &#125;   <span class="comment">//for</span></span><br><span class="line">        &#125;   <span class="comment">//for</span></span><br><span class="line">        System.out.println(totalNum);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-统计方形</title>
    <url>/posts/cc5c249e.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="http://oj.ecustacm.cn/problem.php?id=1079">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形）</p>
<h2 id="输入格式">输入格式</h2>
<p>输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000</p>
<h2 id="输出格式">输出格式</h2>
<p>对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 10</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="首先计算对于n-m的矩形一共有多少个子矩形">首先计算对于n *
m的矩形，一共有多少个子矩形</h2>
<p><span class="math inline">\(从选择边的角度，可以选边长从1到n，一共1 +
2 + …… + n = \frac{(n + 1)(n)}{2}\)</span></p>
<h2 id="接着计算对于n-m的矩形一共有多少个子正方形">接着计算对于n *
m的矩形，一共有多少个子正方形</h2>
<h3
id="从选择边的角度可以选的边的长度从1到minn-m">从选择边的角度，可以选的边的长度从1到min(n,
m)</h3>
<h3
id="正方形的边长每增加1母矩形的长可以放下对应边长的正方形的个数就减少1宽同理">正方形的边长每增加1，母矩形的长可以放下对应边长的正方形的个数就减少1，宽同理</h3>
<h2
id="最后用总矩形数量减去总正方形数量就得到总长方形数量">最后用总矩形数量减去总正方形数量就得到总长方形数量</h2>
<h1 id="第一次写错误">第一次写错误</h1>
<h2
id="计算总矩形数量和总正方形数量必须要开long才放得下">计算总矩形数量和总正方形数量必须要开long才放得下</h2>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(input.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">nSide</span> <span class="operator">=</span> (n + <span class="number">1</span>) * n / <span class="number">2</span>;    <span class="comment">//n方向可以选出的边数，等差求和</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">mSide</span> <span class="operator">=</span> (m + <span class="number">1</span>) * m / <span class="number">2</span>;    <span class="comment">//m方向可以选出的边数，等差求和</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">totalMatrix</span> <span class="operator">=</span> nSide * mSide;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nSqNum</span> <span class="operator">=</span> n;     <span class="comment">//n方向可以放下正方形的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mSqNum</span> <span class="operator">=</span> m;     <span class="comment">//m方向可以放下正方形的数量</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sqNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">sqLength</span> <span class="operator">=</span> <span class="number">1</span>; sqLength &lt;= Math.min(n, m); sqLength++) &#123;   <span class="comment">//子正方形的边长</span></span><br><span class="line">                sqNum += nSqNum * mSqNum;</span><br><span class="line">                nSqNum--;</span><br><span class="line">                mSqNum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">matrixNum</span> <span class="operator">=</span> totalMatrix - sqNum;</span><br><span class="line">            System.out.format(<span class="string">&quot;%d %d\n&quot;</span>, sqNum, matrixNum);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing95-费解的开关</title>
    <url>/posts/329e4ddf.html</url>
    <content><![CDATA[<p><a
href="https://www.acwing.com/problem/content/description/97/">题目</a></p>
<p>你玩过“拉灯”游戏吗？</p>
<p>2525 盏灯排成一个 5×55×5 的方形。</p>
<p>每一个灯都有一个开关，游戏者可以改变它的状态。</p>
<p>每一步，游戏者可以改变某一个灯的状态。</p>
<p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>
<p>我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。</p>
<p>下面这种状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>在改变了最左上角的灯的状态后将变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>再改变它正中间的灯后状态将变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66
步以内使所有的灯都变亮。</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行输入正整数 n�，代表数据中共有 n� 个待解决的游戏初始状态。</p>
<p>以下若干行数据分为 n� 组，每组数据有 55 行，每行 55 个字符。</p>
<p>每组数据描述了一个游戏的初始状态。</p>
<p>各组数据间用一个空行分隔。</p>
<h4 id="输出格式">输出格式</h4>
<p>一共输出 n� 行数据，每行有一个小于等于 66
的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>
<p>对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出
−1−1。</p>
<h4 id="数据范围">数据范围</h4>
<p>0&lt;n≤5000&lt;�≤500</p>
<h4 id="输入样例">输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br><span class="line"></span><br><span class="line">11101</span><br><span class="line">11101</span><br><span class="line">11110</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">01111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>本题关键在于如何枚举</p>
<p>每一行灯的情况由上一行决定，上一行的暗灯由下一行的开关点亮，点亮之后就要改变对应的上下左右其他灯</p>
<p>枚举的是第一行开关闭合与否的情况，与灯的亮暗无关，每一个开关有亮和暗两种情况，5个开关就<span
class="math inline">\(2^5
=32\)</span>种情况，当开关的情况定下来后，第一行的灯的亮暗也就确定了，之后几行的灯的亮暗也跟着确定</p>
<p>举例说明</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c1736fb66ab0f65acd8923abc0e9ff9.jpg"
alt="c1736fb66ab0f65acd8923abc0e9ff9" />
<figcaption
aria-hidden="true">c1736fb66ab0f65acd8923abc0e9ff9</figcaption>
</figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] backUp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMatrix</span><span class="params">(Scanner scan)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			matrix[i] = scan.nextLine().toCharArray();</span><br><span class="line">			backUp[i] = Arrays.copyOf(matrix[i], matrix[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 上</span></span><br><span class="line">		<span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x - <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 左</span></span><br><span class="line">		<span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x, y - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 右</span></span><br><span class="line">		<span class="keyword">if</span>(y + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x, y + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(x + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x + <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 自个</span></span><br><span class="line">		flip(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 一共要有n次读取</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">// 读取每次的初始灯矩阵并保存备份</span></span><br><span class="line">			readMatrix(scan);</span><br><span class="line"><span class="comment">//			System.out.println(&quot;初始化矩阵为：&quot;);</span></span><br><span class="line"><span class="comment">//			for(int j = 0; j &lt; 5; j++) &#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[j]);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">minChange</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">			<span class="comment">// 遍历 32 种可能性</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将第一行的按法调整成对应的5位二进制</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%5s&quot;</span>, Integer.toBinaryString(j)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">//				System.out.format(&quot;第一行的开关状态为：%s\n&quot;, tmpString);</span></span><br><span class="line">				<span class="comment">// 第一行的按完后的状态</span></span><br><span class="line"><span class="comment">//				System.out.print(&quot;第一行现在状态：&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[0]);</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(tmpString.charAt(k) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						changeMatrix(<span class="number">0</span>, k);</span><br><span class="line"><span class="comment">//						System.out.format(&quot;按下开关%d, 第一行现在状态 &quot;, k + 1);</span></span><br><span class="line"><span class="comment">//						System.out.println(matrix[0]);</span></span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//				System.out.println(&quot;开关按完后第一行现在的状态：&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[0]);</span></span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; <span class="number">5</span>; b++) &#123;</span><br><span class="line">						<span class="comment">// 通过这一行确定下一行的开关，再根据这个开关看灯的亮暗</span></span><br><span class="line">						<span class="keyword">if</span>(matrix[a][b] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">							changeMatrix(a + <span class="number">1</span>, b);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="comment">//					System.out.format(&quot;经过第%d行后的状态\n&quot;, a+1);</span></span><br><span class="line"><span class="comment">//					for(int c = 0; c &lt; 5; c++) &#123;</span></span><br><span class="line"><span class="comment">//						System.out.println(matrix[c]);</span></span><br><span class="line"><span class="comment">//					&#125;</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 遍历第5行，看是不是都是1</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(matrix[<span class="number">4</span>][k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">					minChange = Math.min(count, minChange);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 将备份矩阵拷贝回原矩阵</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">					matrix[a] = Arrays.copyOf(backUp[a], backUp[a].length);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//				System.out.println(&quot;backUp数组是：&quot;);</span></span><br><span class="line"><span class="comment">//				for(int a = 0; a &lt; 5; a++) &#123;</span></span><br><span class="line"><span class="comment">//					System.out.println(backUp[a]);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(minChange &lt;= <span class="number">6</span>) System.out.println(minChange);</span><br><span class="line">			<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<p><a href="">深拷贝与浅拷贝</a>，一个大坑，当时折腾了半天</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>中等题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-油漆房子</title>
    <url>/posts/ea1ffadb.html</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240113101111678.png"
alt="image-20240113101111678" />
<figcaption aria-hidden="true">image-20240113101111678</figcaption>
</figure>
<h1 id="分析">分析</h1>
<h2 id="核心思想是枚举">核心思想是枚举</h2>
<h2 id="首先利用set记录每一种颜色">首先利用set记录每一种颜色</h2>
<h2
id="然后依次从set取出一种颜色作为targetcolor">然后依次从set取出一种颜色作为targetColor</h2>
<h3
id="遍历房子如果当前房子的颜色和targetcolor不相同就以当前房子为起点往后长度为k的区间都涂成targetcolor并且需要的天数递增1">遍历房子，如果当前房子的颜色和targetColor不相同，就以当前房子为起点，往后长度为k的区间都涂成targetColor，并且需要的天数递增1</h3>
<h3
id="否则就一直向下遍历直到所有房子遍历完">否则就一直向下遍历直到所有房子遍历完</h3>
<h2 id="java中hashset使用">java中HashSet使用</h2>
<h3 id="创建">创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//HashSet&lt;对象名&gt; 集合名 = new HashSet&lt;Integer&gt;();</span></span><br></pre></td></tr></table></figure>
<h3 id="放入数据">放入数据</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set.add(data);</span><br></pre></td></tr></table></figure>
<h3
id="遍历只能用增强型for循环和迭代器">遍历：只能用增强型for循环和迭代器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Integer&gt; iterator = set.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="type">int</span>[] house = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">//存储所有房子的颜色并记录颜色的种类</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">                house[j] = data;</span><br><span class="line">                set.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minCount</span> <span class="operator">=</span> n;</span><br><span class="line">            <span class="comment">//从集合中选取一种颜色</span></span><br><span class="line">            <span class="keyword">for</span>(Iterator&lt;Integer&gt; iterator = set.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">nowColor</span> <span class="operator">=</span> (Integer)iterator.next();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//遍历房子颜色与当前选取的颜色比较</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; n;) &#123;</span><br><span class="line">                    <span class="comment">//如果当前房子颜色与当前选取的颜色不同</span></span><br><span class="line">                    <span class="keyword">if</span>(house[x] != nowColor) &#123;</span><br><span class="line">                        x = x + k;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        x++;</span><br><span class="line">                    &#125;   <span class="comment">//if</span></span><br><span class="line">                &#125;   <span class="comment">//for</span></span><br><span class="line">                <span class="keyword">if</span>(count &lt; minCount) minCount = count;  <span class="comment">//if</span></span><br><span class="line">            &#125;   <span class="comment">//for</span></span><br><span class="line">            System.out.println(minCount);</span><br><span class="line">        &#125;   <span class="comment">//for</span></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中集合框架的运用</title>
    <url>/posts/22145084.html</url>
    <content><![CDATA[<h1 id="arraylist">ArrayList</h1>
<p>##<a
href="https://www.lanqiao.cn/problems/539/learning/">题目一</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116085923605.png" /></p>
<h3 id="创建">创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3
id="判断一个元素在arraylist中是否存在">判断一个元素在ArrayList中是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.contains(element)</span><br></pre></td></tr></table></figure>
<h3 id="对一个arraylist排序">对一个ArrayList排序</h3>
<h4
id="collections的默认从小到大排序">Collections的默认从小到大排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections</span><br><span class="line">Collections.sort(list)</span><br></pre></td></tr></table></figure>
<h4 id="collections的自定义比较器">Collections的自定义比较器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按降序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历排序后的列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing1208翻硬币</title>
    <url>/posts/f19f614d.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/1210/">题目</a></h1>
<p>小明正在玩一个“翻硬币”的游戏。</p>
<p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o
表示反面（是小写字母，不是零）。</p>
<p>比如，可能情形是：<code>**oo***oooo</code></p>
<p>如果同时翻转左边的两个硬币，则变为：<code>oooo***oooo</code></p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>
<p>我们约定：把翻动相邻的两个硬币叫做一步操作。</p>
<h2 id="输入格式">输入格式</h2>
<p>两行等长的字符串，分别表示初始状态和要达到的目标状态。</p>
<h2 id="输出格式">输出格式</h2>
<p>一个整数，表示最小操作步数</p>
<h2 id="数据范围">数据范围</h2>
<p>输入字符串的长度均不超过100。 数据保证答案一定有解。</p>
<h2 id="输入样例1">输入样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**********</span><br><span class="line">o****o****</span><br></pre></td></tr></table></figure>
<h2 id="输出样例1">输出样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输入样例2">输入样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*o**o***o***</span><br><span class="line">*o***o**o***</span><br></pre></td></tr></table></figure>
<h2 id="输出样例2">输出样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>贪心：如果当前位置不同，那就要翻转当前位置和当前位置的下一位，而当前位置之前的所有位置已经都是调整到和目标一样了</p>
<h1 id="代码">代码</h1>
<h2 id="暴搜超时了">暴搜(超时了)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> StringBuffer stringInitial;</span><br><span class="line">	<span class="keyword">static</span> String stringTarget;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">StringBuffer</span> <span class="variable">stringOperation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> stringLen;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">LEFT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">minSteps</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringInitial.charAt(count) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			stringInitial.setCharAt(count, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stringInitial.setCharAt(count, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">		reverse(count);</span><br><span class="line">		reverse(count + direction);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringInitial.toString().equals(stringTarget)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(stringInitial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == stringLen) &#123;</span><br><span class="line">			<span class="keyword">if</span>(valid() &amp;&amp; steps &lt; minSteps) &#123;</span><br><span class="line">				minSteps = steps;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 翻当前层</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) &#123;	<span class="comment">// 只能翻右边</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps += <span class="number">1</span>;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == stringLen - <span class="number">1</span>) &#123;	<span class="comment">// 只能翻左边</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 两边都可以翻</span></span><br><span class="line">			<span class="comment">// 翻右边</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps--;</span><br><span class="line">			<span class="comment">// 翻左边</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不翻当前层</span></span><br><span class="line">		dfs(count + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		stringInitial = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(tmpString);</span><br><span class="line">		stringTarget = scan.nextLine();</span><br><span class="line">		stringLen = stringInitial.length();</span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		System.out.println(minSteps);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心">贪心</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> StringBuffer stringOperation;</span><br><span class="line">	<span class="keyword">static</span> String stringTarget;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringOperation.charAt(count) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			stringOperation.setCharAt(count, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stringOperation.setCharAt(count, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		stringOperation = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(tmpString);</span><br><span class="line">		stringTarget = scan.nextLine();</span><br><span class="line">		<span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringTarget.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(stringOperation.charAt(i) != stringTarget.charAt(i)) &#123;</span><br><span class="line">				change(i);</span><br><span class="line">				change(i + <span class="number">1</span>);</span><br><span class="line">				steps++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(steps);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>贪心</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥oj1461最少砝码</title>
    <url>/posts/ac42800e.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/1461/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240327111158568.png" /></p>
<h1 id="分析">分析</h1>
<h2 id="贪心动归">贪心+动归</h2>
<ul>
<li>当有1个砝码</li>
</ul>
<ol type="1">
<li><p>可以称出的最大质量为1</p></li>
<li><p>称不出的最小质量为2</p></li>
</ol>
<ul>
<li>当有2个砝码</li>
</ul>
<ol type="1">
<li><p>要想得到在1个砝码时称不出来的质量2，新的砝码质量可以是1、2、3，但是4不行，因为4-1
= 3 &gt; 2</p></li>
<li><p>由贪心的思想，要想得到最大质量区间，新砝码取3。原因如下图</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/62bf166787fec419ee437adc9c6d308.jpg" /></p>
<ul>
<li><p>当有3个砝码</p>
<ol type="1">
<li>有2个砝码时得不到的最小质量是5</li>
<li>要想得到质量区间最大，新砝码要<font color = "red">在尽可能大的前提下满足减去前2个砝码的和后依然能得到5</font>。所以新砝码的最大质量为5(2个砝码时最小得不到得到质量)
+ 4(2个砝码时能得到的最大质量) = 9</li>
</ol></li>
<li><p>贪心</p>
<ol type="1">
<li><p>dp[ i ]：在有i个砝码时能得到的最大质量</p></li>
<li><p>转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + maxFama </span><br><span class="line">maxFama = dp[i] + (dp[i] + 1)</span><br><span class="line">dp[i + 1] = 3 * dp[i] + 1</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h2 id="估计开多大空间">估计开多大空间</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/02a5c2f1fc188bc571c049fe4390d42.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV19m41167NP/?vd_source=a46136aa644c81e751b3b0cc0e17dbe1">讲解视频</a></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">10e6</span>);</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxNum];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">minBoundry</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(minBoundry &lt; target) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">maxFama</span> <span class="operator">=</span> minBoundry + dp[count];</span><br><span class="line">			minBoundry = dp[count] + maxFama + <span class="number">1</span>;</span><br><span class="line">			dp[++count] = minBoundry - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>贪心</category>
        <category>困难</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/posts/2ba40472.html</url>
    <content><![CDATA[<h1 id="第一章-操作系统概述">第一章 操作系统概述</h1>
<span id="more"></span>
<blockquote>
<p>思考：</p>
<ul>
<li>操作系统的功能有哪些？</li>
<li>操作系统有哪些特征？最基本的特征是什么？</li>
<li>什么是批处理系统？单道批处理系统与多道批处理系统的区别？</li>
<li>什么是硬实时任务和软实时任务？</li>
<li>在交互性、及时性以及可靠性方面，分时系统与实时系统有什么区别？</li>
<li>CPU有哪些运行模式？什么事情会导致用户态转为内核态?</li>
<li>什么是特权指令和非特权指令？有哪些常见的特权指令？</li>
<li>发生中断或异常应该如何处理？</li>
<li>系统调用的过程是怎样的？</li>
</ul>
</blockquote>
<h2 id="操作系统的基本概念">1.1 操作系统的基本概念</h2>
<h3 id="操作系统的概念">1.1.1 操作系统的概念</h3>
<p><strong>操作系统</strong>是指控制和管理整个计算机系统的硬件与软件资源，合理的组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。
操作系统是最基本的系统软件。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230422221717441.png" /></p>
<p><strong>主要作用</strong>：对整个计算机系统的软硬件资源进行管理和控制，提高资源的利用率和系统的吞吐量，并对计算机的工作和资源的分配进行合理的组织和调度，为用户和应用程序提供方便访问的接口。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230422221736931.png" /></p>
<p>操作系统位于用户层和硬件层之间，向上提供服务，向下管理资源。</p>
<p>牢记一句话：操作系统是<font color = "red">管理计算机资源</font>的软件</p>
<p>举例：操作系统关心什么不关心什么</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c9312f0b8ca397a9b27095c412389e5.jpg" /></p>
<p>第2题看图就能看出来。解释源程序为什么不是操作系统管理：操作系统关心文件放在哪，不关心这是什么文件</p>
<h3 id="操作系统的特征">1.1.2 操作系统的特征</h3>
<h4
id="并发操作系统最基本特征">并发(<font color = "red">操作系统最基本特征</font>)</h4>
<ul>
<li>并发是指两个或多个事件在同一时间间隔内发生。</li>
<li>操作系统的并行性是指计算机系统中同时存在多个运行的程序。</li>
<li>并发(交替)：同一时间间隔； 并行(同时)：同一时刻</li>
<li>单核处理器使用并发，多核处理器使用并行。</li>
<li>程序并发性体现在两个方面：
<ul>
<li>用户程序与用户程序之间的并发执行</li>
<li>用户程序与操作系统程序之间的并发执行</li>
</ul></li>
</ul>
<h4
id="共享操作系统最基本特征">共享(<font color = "red">操作系统最基本特征</font>)</h4>
<p>资源共享(资源复用)即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ol type="1">
<li>互斥共享方式
<ul>
<li>在一段时间内只允许一个进程访问该资源。</li>
<li>在一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>或<strong>独占资源</strong>。</li>
<li>临界资源：栈、变量和表格。</li>
</ul></li>
<li>同时访问方式
<ul>
<li>另一类资源允许在一段时间内由多个进程"同时"访问。</li>
<li>这里的"同时"是宏观说法，在微观上，这些进程是交替进行访问的。</li>
</ul></li>
</ol>
<p>并发和共享是操作系统两个最基本的特征。</p>
<p>两者之间互为存在的条件：</p>
<ul>
<li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li>
</ul>
<h4 id="虚拟">虚拟</h4>
<p>虚拟是把一个物理上的实体变为若干逻辑上的对应物。用于实现虚拟的技术，称为虚拟技术。</p>
<ul>
<li>利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的
CPU，称为<strong>虚拟处理器</strong>。</li>
<li>采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，把用户感觉到的(但实际不存在的)存储器称为<strong>虚拟存储器</strong>。</li>
<li>采用虚拟设备技术将一台物理 I/O 设备虚拟为多台逻辑上的 I/O
设备，使原来仅允许在一段时间内由一个用户访问的设备变为在一段时间内允许多个用户同时访问的共享设备。</li>
</ul>
<p>操作系统的虚拟技术：</p>
<ol type="1">
<li>时分复用技术：通过减少处理器和 I/O
设备的空闲时间，来提高计算机资源的利用率，如处理器的分时共享；
<ul>
<li>虚拟处理器技术：将一个物理上的处理器虚拟为多台逻辑上的处理器，用户说感觉到的处理器称为虚拟处理器。</li>
<li>虚拟设备技术：通过虚拟设备技术将一台物理上的 I/O
设备虚拟为多台逻辑上的 I/O 设备。</li>
</ul></li>
<li>空分复用技术：利用存储器的空闲空间区域存放和运行其他的多道程序，以此来提高内存的利用率，如虚拟存储器。
<ul>
<li>虚拟磁盘技术：通过虚拟磁盘技术将一台硬盘虚拟为多台虚拟硬盘。</li>
<li>虚拟存储器技术：将内存分成很多个区域，每个区域存放不同进程，提高内存利用率。</li>
</ul></li>
</ol>
<h4 id="异步">异步</h4>
<p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>
<h3 id="操作系统的目标和功能">1.1.3 操作系统的目标和功能</h3>
<p>操作系统应该具有以下几个功能：</p>
<ol type="1">
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
</ol>
<p>同时操作系统可以用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<h4
id="操作系统作为计算机系统资源的管理者">操作系统作为计算机系统资源的管理者</h4>
<ol type="1">
<li><p>处理机管理</p>
<p>处理机的分配和运行都以进程(或线程)为基本单位。</p>
<p>主要功能：<strong>进程控制</strong>、<strong>进程同步</strong>、<strong>进程通信</strong>、<strong>死锁处理</strong>、<strong>处理机调度</strong></p></li>
<li><p>存储器管理</p>
<p>存储器管理是为了给多道程序的运行提供良好环境，方便用户使用及提高内存的利用率。</p>
<p>主要功能：<strong>内存分配与回收</strong>、<strong>地址映射</strong>、<strong>内存保护与共享</strong>、<strong>内存扩充</strong></p></li>
<li><p>文件管理</p>
<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为<strong>文件系统</strong>。</p>
<p>主要功能：<strong>文件存储空间的管理</strong>、<strong>目录管理</strong>、<strong>文件读写管理和保护</strong></p></li>
<li><p>设备管理</p>
<p>设备管理的主要任务是完成用户的 I/O 请求，方便用户使用各种设备。</p>
<p>主要功能：缓冲管理、设备分配、设备处理和虚拟设备</p></li>
</ol>
<h4
id="操作系统作为用户与计算机硬件系统之间的接口">操作系统作为用户与计算机硬件系统之间的接口</h4>
<p>操作系统提供的接口主要分为两类：</p>
<ul>
<li><p>一类是命令接口，用户利用这些操作命令来组织和控制作业的执行。</p></li>
<li><p>另一类是程序接口，编程人员可以用它们来请求操作系统服务。</p></li>
</ul>
<ol type="1">
<li><p>命令接口 两种方式进行作业控制：联机控制方式和脱机控制方式。
按作业控制方式不同，可分为：联机命令接口和脱机命令接口。</p>
<ol type="1">
<li>联机命令接口(交互式命令接口)，适用于分时或实时系统的接口。</li>
<li>脱机命令接口(批处理命令接口)，适用于批处理系统。</li>
</ol></li>
<li><p>程序接口(也叫系统调用)</p>
<ol type="1">
<li><p>程序接口由一组系统调用(也称广义指令)组成。</p></li>
<li><p>是操作系统为应用程序使用内核功能所提供的接口。最常见的是GUI图形窗口</p></li>
<li><p>是操作系统提供给编程人员的接口</p></li>
<li><p>目的是请求系统服务</p></li>
<li><p>只能通过用户程序间接使用</p></li>
</ol>
<p>举例：</p>
<p>题1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5869e055a57aac69774ac19bf12661e.jpg" /></p>
<p>题2 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0edeabcbe2f1b01275328b42fb1ae23.jpg" /></p>
<p>操作系统与用户通信的接口是命令接口和程序接口(系统调用)</p>
<p>A：shell，命令解析器，属于命令接口</p>
<p>B：命令解释器，命令接口</p>
<p>C：广义指令，就是系统调用命令</p>
<p>D：操作系统不提供管理系统缓存的系统调用</p></li>
</ol>
<h4
id="操作系统实现了对计算机资源的扩充">操作系统实现了对计算机资源的扩充</h4>
<p>没有任何软件支持的计算机称为<strong>裸机</strong>。</p>
<p>把覆盖了软件的机器称为<strong>扩充机器或虚拟机</strong>。</p>
<h2 id="操作系统的发展历程">1.2 操作系统的发展历程</h2>
<h3 id="手工操作阶段">1.2.1 手工操作阶段</h3>
<p>此阶段无操作系统，所有的工作都需要人工干预。</p>
<p>两个缺点(人机矛盾)：</p>
<ul>
<li>用户独占全机，所有计算机资源在一段时间内只能被一个用户使用。</li>
<li>CPU 需要等待人工操作，这造成 CPU
和内存资源大部分时间处于空闲状态。</li>
</ul>
<h3 id="批处理操作系统">1.2.2 批处理操作系统</h3>
<h4 id="单道批处理系统">单道批处理系统</h4>
<p>利用脱机输入输出的方式，在监督程序的控制下实现连续工作。</p>
<p>特征：</p>
<ul>
<li>自动性。磁带上的一批作业能自动地逐个运行，无需人工干预。</li>
<li>顺序性。先调入内存的作业先完成。</li>
<li>单道性(封闭性)
。监督程序每次从磁带上只调入一道程序进入内存运行，当程序完成或异常时，才切换后继程序继续运行。</li>
</ul>
<p>优点：解决了人机矛盾和 CPU 与 I/O
设备速度不匹配的问题，提高系统资源的利用率和系统吞吐率。</p>
<p>缺点：每次只能运行一道程序，不能充分利用系统资源。</p>
<h4 id="多道批处理系统">多道批处理系统</h4>
<p>多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU
中交替地运行，这些程序共享系统中的各种软硬件资源。</p>
<p>特点：</p>
<ul>
<li>多道。计算机内存中同时存放多道互相独立的程序。</li>
<li>宏观上并行。同时进入系统的多道程序都处于运行过程中。</li>
<li>微观上串行。内存中的多道程序轮流占有 CPU，交替执行。</li>
</ul>
<p>举例：</p>
<p><font color = "red">多道相对于单道失去了单道的顺序性和封闭性</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/954c6788eddf5997a124a650fd20e97.jpg" /></p>
<p>实现多道程序设计技术需要解决下列问题：</p>
<ul>
<li>如何分配处理器</li>
<li>多道程序的内存分配问题</li>
<li>I/O 设备如何分配</li>
<li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性</li>
</ul>
<p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。</p>
<figure>
<img
src="D:/HuaweiMoveData/Users/piolet/Desktop/2024-Postgraduate-408-main/OperatingSystem/ch1/assets/image-20230422223017021.png"
alt="image-20230422223017021" />
<figcaption aria-hidden="true">image-20230422223017021</figcaption>
</figure>
<p>优点：系统利用率高，多道程序共享计算机资源；系统吞吐量大，CPU
和其他资源保持忙碌状态。</p>
<p>缺点：用户响应的时间较长；没有人机交互功能。</p>
<blockquote>
<p>❗<font color = "red">无论是单道批处理系统还是多道批处理系统，用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互</font>，这对修改和调试程序是极不方便的。</p>
</blockquote>
<p>举例：</p>
<p>题1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/be16b40173415a560a5e4ed02a8a8c2.jpg" /></p>
<p>A：脱机技术，对应知识点是1.1.3操作系统作为用户与计算机硬件之间的接口中的命令接口里的脱机命令接口。用于解决独占设备的问题。</p>
<p>B：虚拟技术，以多道程序设计技术为前提</p>
<p>C：交换技术，以多道程序设计技术为前提</p>
<p>D：同时在主存中运行多个程序，提高利用率</p>
<p>题2 计算利用率</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8b910ec5175b426a160105ad32df12b.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d29ab25e68b0825e80c0489806004cb.jpg" /></p>
<p><font color = "red">(1)计算一个东西的利用率是将这个东西所画的时间/总时间</font></p>
<p><font color = "red">(2)多批次常画图(甘特图)</font></p>
<p><font color = "red">(3)甘特图中不同形状的线表示不同的任务，相同的任务就是相同形状的线</font></p>
<h3 id="分时操作系统">1.2.3 分时操作系统</h3>
<p>分时技术：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。</p>
<p>关于时间片举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1644b9853259045dc285fb122d718ff.jpg" /></p>
<p>分时操作系统：多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。所以分时操作系统追求的目标是<font color = "red">快速响应用户</font></p>
<blockquote>
<p>多道批处理是实现作业自动控制而无需人工干预的系统，分时系统是实现人机交互的系统。</p>
</blockquote>
<p>分时系统的特征：</p>
<ul>
<li>同时性(多路性)：一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li>
<li>交互性：用户能够方便地与系统进行人机对话。</li>
<li>独立性：系统中多个用户可以彼此独立地进行操作，互不干扰。</li>
<li>及时性：用户请求能在很短时间内获得响应。</li>
</ul>
<h3 id="实时操作系统">1.2.4 实时操作系统</h3>
<p>实时系统：系统能够及时地对外部请求作出相应，并在规定的时间处理该事件，让所有实时任务协调一致的运行。</p>
<p>软实时系统：可以允许或容忍偶尔出现某一事件没在规定时间内完成处理。</p>
<p>硬实时系统：任何时刻都要绝对保证某个事件在规定的时刻得到处理和响应。</p>
<p>实时操作系统具有以下特征：（说白了就是<font color = "red">一要快，二要可靠</font>)</p>
<ul>
<li>多路性：系统周期性地采集多路现场的信息，以及同时控制多个对象和执行机构。</li>
<li>独立性：系统在采集信息和控制对象的时候都是互不影响、彼此独立的。</li>
<li>实时性：系统的实时性是严格根据控制对象所规定的截止时间来确定的。</li>
<li>交互性：用户通过和程序直接交互来控制它的运行。</li>
<li>可靠性：实时系统要求高度可靠，因为任何差错都会产生无法预料的灾难性后果。</li>
</ul>
<p>实时操作系统的进程调度通常采用<font color = "red">抢占式的优先级高者优先</font></p>
<h3 id="其他操作系统">1.2.5 其他操作系统</h3>
<p>网络操作系统：网络环境下管理和控制网络资源的操作系统，其建立在网络中不同计算机的单机操作系统之上，为用户提供了使用网络资源的接口。</p>
<p>分布式操作系统：配置在分布式系统上的操作系统，可以直接对分布式系统中的各种资源进行动态分配。分布式操作系统管理若干计算机，使它们协调配合完成同一个任务。</p>
<h3 id="小结">小结</h3>
<p>允许多个用户以交互的方式使用计算机的操作系统，叫<font color = "red">分时操作系统</font></p>
<p>允许多个用户将若干作业提交给计算机系统几种处理的操作系统，叫<font color = "red">批处理操作系统</font></p>
<p>能及时处理由过程控制反馈的数据的操作系统，叫<font color = "red">实时操作系统</font></p>
<h2 id="操作系统运行环境">1.3 操作系统运行环境</h2>
<h3 id="处理器运行模式">1.3.1 处理器运行模式</h3>
<p>CPU
通常执行两种不同性质的程序：一种是<strong>操作系统内核程序</strong>，一种是<strong>用户自编程序</strong>(即应用程序)。</p>
<p>其中内核程序是应用程序的“管理者”，因此内核程序要执行一些特权命令，而应用程序处于安全考虑不能执行这些指令：</p>
<ul>
<li>特权指令：指不允许用户直接使用的指令。</li>
<li>非特权指令：指允许用户直接使用的指令。</li>
</ul>
<p>用户程序调用系统 API
函数称为<strong>系统调用</strong>，一旦发生了系统调用，将暂停用户程序的运行，转而执行内核代码，访问内核空间，这称为<strong>内核模式</strong>(即内核态)。从用户态到核心态是通过<font color = "red">硬件</font>完成。执行的是<font color = "red">“访管”</font>指令</p>
<p>当在用户空间执行应用程序自己的代码时，称为<strong>用户模式</strong>(即用户态)。</p>
<p>举例</p>
<ul>
<li>题1：核心态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1177dc2e6949375861d3ac357a5ebe3.jpg" /></p>
<p>1:批处理的缺点是交互性不足</p>
<p>2：输出/输出需要中断，中断就必须在核心态下执行</p>
<p>3：多道程序设计是为了提高利用率</p>
<p>4：记着就行</p>
<ul>
<li>题2：核心态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/49596ecb3397a0e95148c80257f4df4.jpg" /></p>
<p>ACD都可以通过汇编语言实现，即用户态。而置时钟指令可以这么理解，如果用户可以直接调用，那一个用户可以通过修改自己的时间从而一直占用时间片。</p>
<p><font color = "red">注意区分“调用”和“执行”</font>，用户程序可以调用系统调用指令，但系统调用指令一定执行在核心态</p>
<ul>
<li>题3：用户态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d517ad28b285b211ba4bfbe7f187455.jpg" /></p>
<p>缺页处理和时钟中断都是中断，都在核心态下执行。</p>
<p>进程调度用户更管不着，也在核心态下执行</p>
<p>命令解释属于命令接口，能面对用户</p>
<ul>
<li><font color = "red">题4：用户态指令，注意与上一题区别</font></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/71f3699b7ea98de3d73bb384b8ebb2b.jpg" /></p>
<p>A：系统调用就是操作系统留给用户程序的接口。系统调用发生在用户态，被调用程序在核心态下运行</p>
<p>B：外部中断是用户态到核心态的“门”，发生在用户态，在核心态下完成中断过程</p>
<p>C：进程切换是系统调用发生过程中的事件</p>
<p>D：缺页在用户态产生，然后进入核心态执行缺页中断服务程序/</p>
<ul>
<li>题5：核心态与用户态之间转换</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/dc4c6f5cde3f303d09bf7ea018f139d.jpg" /></p>
<p>A：可能发生除0的异常</p>
<p>B：都告诉你中断了</p>
<p>C：用户态就可以</p>
<p>D：可能会缺页异常</p>
<p>操作系统内核有以下几种功能：</p>
<ul>
<li>资源抽象：屏蔽底层的硬件细节，使应用程序独立于实际使用的物理资源。</li>
<li>资源分配和回收：将抽象资源分配给应用程序，并在适当的时机进行回收。</li>
<li>资源共享：允许进程共享资源，并提供进程同步和互斥机制，以协助多道程序并发执行。</li>
</ul>
<p>操作系统内核还包括四个方面的内容：</p>
<ul>
<li>时钟管理
<ul>
<li>在计算机的各种部件中，时钟是最关键的设备。</li>
<li>时钟的功能：
<ul>
<li>计时：操作系统需要通过时钟管理，向用户提供标准的系统时间。</li>
<li>中断管理：实现进程的切换。</li>
</ul></li>
</ul></li>
<li>中断机制
<ul>
<li>中断机制是操作系统各项操作的基础。</li>
<li>中断机制中，只有一小部分属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</li>
</ul></li>
<li>原语
<ul>
<li>把具有以下特点的程序称为<strong>原语</strong>：
<ul>
<li>处于操作系统的最底层，是最接近硬件的部分。</li>
<li>这些程序的运行具有原子性，其操作只能一气呵成。</li>
<li>这些程序的运行时间都较短，而且调用频繁。</li>
</ul></li>
<li>定义原语的方法：关闭中断，让其所有动作都不可分割地完成后再打开中断。</li>
</ul></li>
<li>系统控制的数据结构及处理
<ul>
<li>系统常见的操作：
<ul>
<li>进程管理。</li>
<li>存储器管理。</li>
<li>设备管理。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="中断和异常的概念">1.3.2 中断和异常的概念</h3>
<p>操作系统内核工作在核心态，而用户程序工作在用户态。</p>
<p><font color = "red">发生中断或异常时，运行用户态的 CPU
会立即进入核心态。</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230316210022128.png" alt="image-20230316210022128" style="zoom:50%;" /></p>
<h4 id="中断外部中断">中断(外部中断)</h4>
<blockquote>
<p>中断是一种由 I/O 外部设备触发的异步事件，它<font color = "red">与 CPU
正在执行的指令无关</font>，中断提供了外设与 CPU
交流的机制，它也是一种重要的输入输出方式。</p>
</blockquote>
<ol type="1">
<li><p>可屏蔽中断</p>
<p>可屏蔽中断是指通过 INTR
线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</p></li>
<li><p>不可屏蔽中断</p>
<p>不可屏蔽中断是指通过 NMI
线发出的中断请求，通常是紧急的硬件故障。</p></li>
</ol>
<h4 id="异常内部异常">异常(内部异常)</h4>
<blockquote>
<p>异常是 CPU 执行当前指令产生的事件，是同步发生的，与 CPU
正在执行的指令密切相关。</p>
</blockquote>
<ol type="1">
<li><p>故障(fault)</p>
<ul>
<li>故障是一种可能恢复的异常事件。</li>
<li>若可以修复，则 CPU 跳转到引起故障的指令继续进行。</li>
<li>若不能修复，则终止当前程序。</li>
</ul></li>
<li><p>陷阱(trap)</p>
<ul>
<li><p>陷阱是一种有意安排的异常事件。</p></li>
<li><p>陷阱指令也称为<strong>访管指令</strong>、<strong>陷入指令</strong>。</p>
<p>举例</p></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9b7e3926ef45b401339cf966cca1456.jpg" /></p>
<p>用户程序运行特权指令会转成操作系统的核心去运行。其中的中断叫访管中断，属于内部中断</p></li>
<li><p>终止(abort)</p>
<ul>
<li>终止是一种无法恢复的异常事件。</li>
</ul></li>
</ol>
<h4
id="中断与异常的处理过程中断处理是操作系统必须提供的功能">中断与异常的处理过程(<font color = "red">中断处理是操作系统必须提供的功能</font>)</h4>
<ol type="1">
<li><p>中断响应过程(<font color = "red">都是由硬件CPU执行</font>)</p>
<ol type="1">
<li><p>关中断</p>
<p>CPU
首先要关中断，禁止在进行中断处理时又去响应新的中断，防止保存的断点、程序状态字、现场信息被破坏。</p></li>
<li><p>保存断点和程序状态字</p>
<p>断点和状态字信息在特殊的寄存器中(PC 和 PSW)，CPU
会将这两个寄存器内容压栈。</p>
<p>其中<font color = "red">PC</font>的内容由<font color = "red">中断隐指令</font>自动保存，<font color = "red">PSW通用寄存器内容</font>由<font color = "red">操作系统</font>保存</p></li>
<li><p>引出中断服务程序</p>
<p>CPU
检测到中断信号后对具体中断源进行识别，以此引出对应的中断服务程序。并将CPU模式修改为内核态</p></li>
</ol></li>
<li><p>中断处理过程(<font color = "red">由软件操作系统完成</font>)</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/767740c0a7e0a2b2d667f428770298d.jpg" alt="767740c0a7e0a2b2d667f428770298d" style="zoom:25%;" /></p>
<ol type="1">
<li>保护现场</li>
<li>执行中断处理程序</li>
<li>恢复现场</li>
</ol>
<p>举例</p>
<ul>
<li>题1：进入中断处理的程序</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ea43341cdce13960f602dca625c1ffb.jpg" /></p>
<p>无论中断程序是用户还是OS程序，进入中断处理的一定是OS程序</p>
<ul>
<li>题2：中断的保存内容</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/66cab669bcc414763c92e7949fac43e.jpg" /></p>
<p>子程序调用只需要保存断点，即该指令的下一条指令的地址</p>
<p>中断处理不仅要保存断点(PC的内容)，还要保存程序状态字寄存器(PSW的内容)</p>
<ul>
<li><p>题3：中断的保存内容</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/a45350a0a4dc169a07783d348554c06.jpg" /></p></li>
<li><p>题4：中断中由操作系统完成的部分</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c09f3f5bd07e81a0d956602379f5d37.jpg" /></p>
<p>答案：B</p>
<p><img
src="D:\MyDownloads\Software\wechatfile\WeChat%20Files\wxid_6hyhf91zyxtg22\FileStorage\Temp\a45350a0a4dc169a07783d348554c06.jpg" /></p>
<p>答案：D</p></li>
</ul></li>
</ol>
<p>​</p>
<h4 id="小结-1">小结</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">产生原因</th>
<th style="text-align: center;">同步/异步</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">中断</td>
<td style="text-align: center;">I/O 设备的请求信号</td>
<td style="text-align: center;">异步</td>
<td>返回下一条指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">故障</td>
<td style="text-align: center;">可能恢复的异常事件</td>
<td style="text-align: center;">同步</td>
<td>可能返回当前指令</td>
</tr>
<tr class="odd">
<td style="text-align: center;">陷阱</td>
<td style="text-align: center;">有意安排的异常事件</td>
<td style="text-align: center;">同步</td>
<td>返回下一条指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">终止</td>
<td style="text-align: center;">无法恢复的异常事件</td>
<td style="text-align: center;">同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<h3 id="系统调用">1.3.3 系统调用</h3>
<p>陷阱是一种有意安排的内部异常事件，这样安排的目的是实现系统调用。</p>
<p>所谓系统调用，是指用户在程序中调用系统所提供的一些子功能，系统调用可视为特殊的公共子程序。</p>
<p>系统调用的功能：</p>
<ul>
<li>设备管理：完成设备的请求和释放，以及设备启动等功能。</li>
<li>文件管理：完成文件的读、写、创建及删除等功能。</li>
<li>进程控制：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<p>用户程序可以执行陷入指令来发起系统调用，请求操作系统提供服务。</p>
<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
<p>举例</p>
<ul>
<li>题1</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6f5f6c7857145603cc107a9ccb9f5e3.jpg" /></p>
<p>1：系统调用需要触发trap指令</p>
<p>2：程序设计无法形成屏蔽中断指令</p>
<p>3：系统调用的概念</p>
<p>4：操作系统的作用</p>
<ul>
<li><p>题2</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9fa388ae4d1221e7a5614c76383717a.jpg" /></p></li>
</ul>
<p>​ 1：断句，对</p>
<p>​ 2：对</p>
<p>​ 3：linux会和windows一样吗？错</p>
<p>​ 4：对</p>
<h3 id="程序的链接与装入">1.3.4 程序的链接与装入</h3>
<p>要使一个程序能在多道程序环境下运行，首先要做的事情是创建进程，而创建进程的首要任务是将程序和数据装入内存。</p>
<p>要将一个用户源程序变为一个可在内存中执行的程序，一般有以下几个步骤：</p>
<ol type="1">
<li><p>编译</p>
<p>由编译程序将用户源代码编译成 CPU
可执行的目标代码，产生了若干个目标模块。</p></li>
<li><p>链接</p>
<p>由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块。</p></li>
<li><p>装入</p>
<p>由装入程序将装入模块装入内存。</p></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/39cce9e3e82a7e9df213b7acc0b171d.jpg" alt="39cce9e3e82a7e9df213b7acc0b171d" style="zoom: 25%;" /></p>
<h4 id="程序的装入地址的变换">程序的装入(地址的变换)</h4>
<ul>
<li><p>绝对装入方式</p>
<p>按照物理内存的位置赋予实际的物理地址。</p></li>
<li><p>静态地址重定位(可重定位装入方式)</p>
<p>静态地址重定位是指在程序开始运行前，程序中指令和数据的各个地址均已完成重定位，此时就已经完成了虚拟地址到内存地址的变换，并且以后不再改变。</p></li>
<li><p>动态地址重定位(动态运行时装入方式)</p>
<p>动态地址重定位方式是在程序执行过程中进行地址变换。</p></li>
</ul>
<h4 id="程序的链接">程序的链接</h4>
<p>源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。</p>
<p>根据链接的时间不同，可把链接分为以下三种:</p>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，不再拆开。</li>
<li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对某些目标模块进行链接。</li>
</ul>
<h3 id="程序运行时的内存映像与地址空间">1.3.5
程序运行时的内存映像与地址空间</h3>
<p>地址空间：指的是一组非负整数地址的集合。</p>
<p>采用虚拟地址的好处：</p>
<ul>
<li>每个进程的虚拟地址空间是独立的，方便操作系统之上的用户编程，在多道程序并发的情况下，防止其他进程的干扰破坏。</li>
<li>所有进程的虚拟地址空间的大小和结构划分是一致的，这简化了操作系统对存储器的管理。</li>
<li>将主存看做外部存储器的缓存副本，根据实际运行需要进行信息的交换，可以节省主存空间。</li>
</ul>
<p>程序运行时的内存映像指的是进程在内存中存放和组织的方式，进程会被映射到一个统一的虚拟地址空间。</p>
<p><img align="right" src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5f826210f563db759a6b5047c946cc4.jpg" style="zoom:25%;" /></p>
<p><strong>只读代码和数据区</strong>：进程虚拟地址从此区域开始，该区域存放进程的只读代码和只读数据。</p>
<p><strong>可读/写数据区</strong>：该区域存放进程的可读可写数据。</p>
<p><strong>运行时堆</strong>：由进程在运行时动态创建，该区域可以动态增长和收缩。</p>
<p><strong>共享库</strong>：该区域用于存放公共的共享库代码和数据。</p>
<p><strong>用户栈</strong>：该区域用来存放局部变量、返回地址、函数调用参数等信息。</p>
<p><strong>操作系统内核区</strong>：该区域是操作系统内核使用的地址空间，包括内核程序、代码、内核栈等信息，这些信息对用户程序不可见。</p>
<h2 id="操作系统的体系结构">1.4 操作系统的体系结构</h2>
<h3 id="分层结构">1.4.1 分层结构</h3>
<p>特性：内核分多层，每层可单向调用更低一层提供的接口。</p>
<p>优点：</p>
<ul>
<li>便于调试和验证，自底向上逐层调试验证。</li>
<li>易扩充和易维护，各层之间调用接口清晰固定。</li>
</ul>
<p>缺点：</p>
<ul>
<li>仅可调用相邻低层，难以合理定义各层的边界。</li>
<li>效率低，不可跨层调用，系统调用执行时间长。</li>
</ul>
<h3 id="模块化">1.4.2 模块化</h3>
<p>特性：将内核划分为多个模块，各模块之间相互协作。</p>
<ul>
<li>内核 = 主模块 + 可加载内核模块</li>
<li>主模块：只负责核心功能。</li>
<li>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核。</li>
</ul>
<p>优点：</p>
<ul>
<li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发。</li>
<li>支持动态加载新的内核模块，增强OS适应性。</li>
<li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>模块间的接口定义未必合理、实用。</li>
<li>模块间相互依赖，更难调试和验证。</li>
</ul>
<h3 id="宏内核大内核">1.4.3 宏内核(大内核)</h3>
<p>特性：所有的系统功能都放在内核里。</p>
<p>优点：性能高，内核内部各种功能都可以直接相互调用。</p>
<p>缺点：</p>
<ul>
<li>内核庞大功能复杂，难以维护。</li>
<li>大内核中某个功能模块出错，就可能导致整个系统崩溃。</li>
</ul>
<h3 id="微内核">1.4.4 微内核</h3>
<p>特性：</p>
<ul>
<li>只把中断、原语、进程通信等最核心的功能放入内核。</li>
<li>进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。</li>
</ul>
<p>优点：</p>
<ul>
<li>内核小功能少、易于维护，内核可靠性高。</li>
<li>内核外的某个功能模块出错不会导致整个系统崩溃。</li>
<li>添加系统服务时不必修改内核</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能低，需要频繁切换用户态和核心态。</li>
<li>用户态下的各功能模块不可以直接相互调用，只能通过内核的“消息传递”来间接通信。</li>
</ul>
<h3 id="外核">1.4.5 外核</h3>
<p>特性：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>
<p>优点：</p>
<ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源。</li>
<li>减少了虚拟硬件资源的“映射层”，提升效率。</li>
</ul>
<p>缺点：</p>
<ul>
<li>降低了系统的一致性。</li>
<li>使系统变得更复杂。</li>
</ul>
<h2 id="操作系统引导">1.5 操作系统引导</h2>
<p>基本输入输出系统BIOS是一种固化到计算机内主板上的一个只读存储器芯片内的一种固件。</p>
<p>常见操作系统的引导过程：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230318174400336.png"
alt="image-20230318174400336" />
<figcaption aria-hidden="true">image-20230318174400336</figcaption>
</figure>
<ul>
<li>引导程序位于硬盘中，且只会将硬盘中存储的操作系统内核加入到内存，其他部分仅在需要时才加入</li>
</ul>
<h2 id="虚拟机">1.6 虚拟机</h2>
<p><strong>基本概念</strong>：虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。</p>
<h4 id="两类虚拟机管理程序vmm的对比">两类虚拟机管理程序(VMM)的对比</h4>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>对物理资源的控制权</td>
<td>直接运行在硬件之上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖于Host OS为其分配物理资源</td>
</tr>
<tr class="even">
<td>资源分配方式</td>
<td>安装Guest
OS时，VMM在原本的硬盘上自行分配存储空间。<br />类似于外核，分配未经抽象的物理硬件。</td>
<td>GuestOS拥有自己的虚拟磁盘，该盘实际上是Host
OS文件系统中的一个大文件。<br />GuestOS分配到的内存是虚拟内存。</td>
</tr>
<tr class="odd">
<td>性能</td>
<td>性能更好</td>
<td>性能更差，需要HostOS作为中介</td>
</tr>
<tr class="even">
<td>可支持的虚拟机数量</td>
<td>更多，不需要和HostOS竞争支援，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，HostOS本身需要使用物理资源，HostOS上运行的其他进程也需要物理资源</td>
</tr>
<tr class="odd">
<td>虚拟机的可迁移性</td>
<td>更差</td>
<td>更好</td>
</tr>
<tr class="even">
<td>运行模式</td>
<td>运行在最高特权级(Ring0)，可以执行最高特权的指令</td>
<td>部分运行在用户态，部分运行在内核态。</td>
</tr>
</tbody>
</table>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/635b663711bb4472dc56a2531e8c621.jpg" /></p>
<p>3有迷惑性。这顶多叫并发不是并行。多核处理器才能实现并行</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.1_内存管理概念</title>
    <url>/posts/24954513.html</url>
    <content><![CDATA[<h2 id="内存相关概念">内存相关概念</h2>
<span id="more"></span>
<p>程序执行前需要先放到内存中才能被CPU处理。内存是为了缓和CPU与外存之间的速度矛盾。</p>
<p>内存地址从0开始，每一个地址对应一个<strong>存储单元</strong>（用于存放数据的最小单元）。</p>
<ul>
<li>若计算机按字节编址，则每个存储单元大小为一字节（1B），即8个二进制位；</li>
<li>若计算机按字编址，且字长为16位，则存储单元大小为一个字长，即16个二进制位。</li>
</ul>
<blockquote>
<ul>
<li><span class="math inline">\(2^{10}\)</span>个字节：1K</li>
<li><span class="math inline">\(2^{20}\)</span>个字节：1M</li>
<li><span class="math inline">\(2^{30}\)</span>个字节：1G</li>
</ul>
</blockquote>
<h2 id="内存管理的基本原理和要求">内存管理的基本原理和要求</h2>
<h3 id="逻辑地址与物理地址">逻辑地址与物理地址</h3>
<p><strong>逻辑地址</strong>：相对于进程的起始地址而言的地址</p>
<p><strong>物理地址</strong>：实际在内存中的地址</p>
<p>在程序中，一般使用的是逻辑地址。</p>
<h3 id="程序的装入和链接">程序的装入和链接</h3>
<p>创建进程时，通常需要将程序和数据装入内存，这一过程通常包含以下几个步骤：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3d23419615362b54619fb523461edb0.jpg" /></p>
<ul>
<li><p><strong>编译</strong>：将高级语言翻译为机器语言，形成一组<strong>目标模块</strong></p></li>
<li><p><strong>链接</strong>：<strong>形成逻辑地址</strong>，将编译后的的目标模块与所需的静态库一起，形成一个完整的<strong>装入模块</strong></p>
<ul>
<li><strong>静态链接</strong>：在程序执行前将各目标模块及其所需库函数组成一个完整的装入模块</li>
<li><strong>装入时动态链接</strong>：在各目标模块装入时，一边装入一边链接</li>
<li><strong>运行时动态链接</strong>：在程序执行到相应目标模块时，才进行链接
<ul>
<li>便于修改和更新</li>
<li>便于实现对目标模块的共享</li>
</ul></li>
</ul></li>
<li><p><strong>装入</strong>：将装入模块装入内存运行（<strong>逻辑地址→物理地址</strong>）</p>
<ul>
<li><p><strong>绝对装入</strong>：若已经知道程序将在内存的哪个位置运行，则编译时就将逻辑地址转换为物理地址</p>
<ul>
<li>灵活性很差，只适用于单道程序环境</li>
</ul></li>
<li><p><strong>静态重定位（可重定位装入）</strong>：对所有的逻辑单元进行重定位，将其转化为物理地址
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b5c809223006bad1a8840dbb9f30363.jpg" /></p>
<ul>
<li>必须要一次全部装入内存（一次分配所需的全部内存）</li>
<li>逻辑地址必须是<strong>连续的</strong></li>
<li>程序运行期间不能再次移动</li>
</ul></li>
<li><p><strong>动态重定位（动态运行时装入）</strong>：设置一个<strong>重定位寄存器</strong>，里面存放程序的起始地址。程序<strong>执行</strong>时，会将逻辑地址与重定位寄存器中的值相加得到物理地址</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/eef9eccf254a2feb0a412f9a1ba117f.jpg" /></p>
<ul>
<li>允许程序在内存中移动</li>
<li>可以分配到不连续的区域中</li>
<li>可以动态的分配内存</li>
</ul></li>
</ul></li>
</ul>
<h3 id="进程的内存映像">进程的内存映像</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ac8621de0e093f57fbe44fab9d624de.jpg" /></p>
<h4 id="代码段">代码段</h4>
<ul>
<li><font color = "red">程序的二进制代码，只读</font></li>
<li>调入内存时就指定大小</li>
</ul>
<h4 id="数据段">数据段</h4>
<ul>
<li>程序运行时处理对象，包括<font color = "yellow">全局变量和静态变量</font></li>
<li>调入内存时就指定大小</li>
</ul>
<h4 id="进程控制段pcb">进程控制段PCB</h4>
<ul>
<li>存放在系统区</li>
</ul>
<h4 id="堆">堆</h4>
<ul>
<li>存放<font color = "yellow">动态分配</font>的变量，<font color = "red">通过调用malloc函数动态向高地址分配空间</font></li>
<li>动态变化</li>
</ul>
<h4 id="栈">栈</h4>
<ul>
<li><font color = "red">实现函数调用</font>,<font color = "yellow">从用户空间最大地址往最低地址方向增长</font></li>
<li>动态变化</li>
</ul>
<h3 id="内存管理的功能">内存管理的功能</h3>
<ul>
<li><strong>内存空间的分配与回收</strong>：主存储器空间的分配与管理</li>
<li><strong>地址转换</strong>：逻辑地址到物理地址</li>
<li><strong>内存空间的扩展</strong>：虚拟化</li>
<li><strong>存储保护</strong>：保护各个作业只能访问自己的内存空间</li>
</ul>
<h3 id="内存保护">内存保护</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/53ab05236ebab34cdcf4c9496850f66.jpg" /></p>
<ul>
<li>设置<strong>上、下限寄存器</strong>，进行<font color = "red">越界检测</font></li>
<li>通过<strong>重定位寄存器</strong>和<strong>界地址寄存器</strong>，进行越界检测。其中重定位寄存器存放<strong>起始物理地址</strong>，界地址寄存器存放<strong>最大逻辑地址</strong>。</li>
</ul>
<h3 id="内存共享">内存共享</h3>
<ul>
<li><strong>可重入代码</strong>：允许多个进程同时访问，但不允许修改</li>
<li>为每个进程配备局部数据区，将可能改变的部分复制进去，修改进程自己的私有数据</li>
</ul>
<h2 id="覆盖与交换">覆盖与交换</h2>
<h3 id="覆盖技术">覆盖技术</h3>
<p>将用户空间分为一个<strong>固定区</strong>和若干<strong>覆盖区</strong>。</p>
<p>常用的部分放入固定区，不常用的段在需要时放入覆盖区，当需要使用时将相应的段从外存调入覆盖区。</p>
<ul>
<li>内存中能够更新的地方只有覆盖区的部分</li>
<li>对用户不透明</li>
</ul>
<h3 id="交换技术">交换技术</h3>
<p>当内存空间紧张时，将内存中的某些进程暂时<strong>换出</strong>到外存，并将外存中某些已经具备运行条件的进程<strong>换入</strong>内存。</p>
<p>PCB是常驻内存的</p>
<p>中级调度（内存调度）就是决定将哪个处于挂起状态的进程重新换入内存。</p>
<ul>
<li>在具有交换功能的操作系统中，磁盘空间通常分为<strong>文件区</strong>和<strong>对换区</strong>
<ul>
<li>文件区存储文件，追求磁盘空间的利用率，对磁盘空间的管理采用离散分配方式</li>
<li>对换区占用空间很小，追求换入换出速度，对磁盘空间的管理采用连续分配方式</li>
</ul></li>
<li>交换通常发生在有较多进程在运行且内存吃紧的时刻</li>
<li>当系统负荷降低时停止交换</li>
<li>一般会优先换出<strong>阻塞进程</strong>以及<strong>底优先级的进程</strong>，同时为了防止出现饥饿现象，有时还要考选进程在内存的驻留时间</li>
</ul>
<h2 id="连续分配管理方式">连续分配管理方式</h2>
<p>连续分配：系统为用户进程分配的必须是一个<strong>连续的内存空间</strong></p>
<h3 id="单一连续分配">单一连续分配</h3>
<p>在单一连续分配方式中，内存被分为系统区和用户区。</p>
<ul>
<li>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；</li>
<li>用户区用于存放用户进程相关数据。</li>
</ul>
<p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>
<ul>
<li>优点：
<ul>
<li>实现简单；</li>
<li>无外部碎片；</li>
<li>可以<strong>采用覆盖技术</strong>扩充内存；</li>
<li>不一定需要采取内存保护（eg: 早期的PC操作系统MS-DOS）</li>
</ul></li>
<li>缺点：
<ul>
<li>只能用于单用户、单任务的操作系统中；</li>
<li>有<strong>内部碎片</strong>；</li>
<li>存储器利用率极低。</li>
</ul></li>
</ul>
<p><font color = "yellow">内部碎片：系统分配给进程的内存空间中，没有被利用到的区域</font></p>
<p><font color = "yellow">外部碎片：内存中的某些空闲分区太小而难以利用</font></p>
<h3 id="固定分区分配">固定分区分配</h3>
<p>将整个用户空间划分为若千个<strong>固定大小</strong>的分区，在每个分区中只装入一道作业。</p>
<ul>
<li>分区大小相等：
<ul>
<li>缺乏灵活性</li>
<li>适合用于用一台计算机控制多个相同对象的场合</li>
</ul></li>
<li>分区大小不等：
<ul>
<li>增加了灵活性，可以满足不同大小的进程需求；</li>
<li>根据常在系统中运行的作业大小情况进行划分
（比如：划分多个小分区、适量中等分区+少量大分区）</li>
</ul></li>
</ul>
<p>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，内容包括对应分区的大小、起始地址、状态(是否已分配)。</p>
<ul>
<li>优点：
<ul>
<li>实现简单；</li>
<li>无外部碎片</li>
</ul></li>
<li>缺点：
<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不<strong>采用覆盖技术</strong>来解决，但这又会降低性能；</li>
<li>会产生内部碎片，内存利用率低。</li>
</ul></li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/22c4ae6f77e46f3fe9fdb8dd0b82696.jpg"
alt="固定分区说明表和内存分配情况" />
<figcaption aria-hidden="true">固定分区说明表和内存分配情况</figcaption>
</figure>
<hr style = "border:2px solid yellow">
<h3 id="动态分区分配可变分区分配">动态分区分配（可变分区分配）</h3>
<p>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此<strong>系统分区的大小和数目是可变的</strong>。</p>
<ol type="1">
<li>使用什么数据结构存储内存的使用情况
<ul>
<li><strong>空闲分区表</strong>：每一个空闲分区对应一个表项，其内容包括空闲分区的起始地址、大小、分区号、状态等信息</li>
<li><strong>空闲分区链</strong>：每一个空闲分区的起始部分和末尾部分分别设置前向指针和后向指针，指向前（后）一个空闲分区，同时在起始部分存储分区大小等信息</li>
</ul></li>
<li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配
<ul>
<li>使用<strong>动态分区分配算法</strong></li>
</ul></li>
<li>如何进行空间的分配与删除
<ul>
<li>使用<strong>空闲分区表</strong>
<ul>
<li><strong>分配</strong>：修改或直接删除相应的空闲分区</li>
<li><strong>回收</strong>：修改或直接新增空闲分区，若存在合并，则删除掉其中一个</li>
</ul></li>
</ul></li>
<li>优缺点
<ul>
<li>优点
<ul>
<li>系统分区的大小和数目是可变的</li>
<li>不会产生内部碎片</li>
</ul></li>
<li>缺点
<ul>
<li>可能产生外部碎片</li>
</ul></li>
</ul></li>
</ol>
<p>可以采用“拼凑”（紧凑）技术来解决外部碎片，即操作系统不断地移动各个分区，使之相邻，拼出更大的空闲分区。</p>
<p>紧凑技术需要<strong>重定位寄存器</strong>的支持</p>
<h3 id="动态分区分配算法">动态分区分配算法</h3>
<p>在存在多个可用的空闲分区时，通过动态分区分配算法来决定使用哪个空闲分区</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ae222d66a3c868b7b624992e9aecae1.jpg" /></p>
<h4 id="首次适应算法first-fit">（1）首次适应算法（First Fit）</h4>
<p>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。相应的，空闲分区以<strong>地址递增</strong>的方式进行排列。</p>
<h4 id="最佳适应算法best-fit">（2）最佳适应算法（Best Fit）</h4>
<p>尽可能优先使用小的空闲分区，找到第一个能满足大小的空闲分区。相应的，空闲分区按照<strong>容量递增</strong>的方式进行排列。</p>
<p>可能会产生很多<strong>外部碎片</strong>。</p>
<h4 id="最坏适应worst-fit">（3）最坏适应（Worst Fit）</h4>
<p>也称为最大适应算法。优先使用大分区，找到第一个能满足大小的空闲分区。相应的，空闲分区按照<strong>容量递减</strong>的方式进行排列。</p>
<p>大的空闲分区不断变小，可能导致后到来的大进程无内存可用。</p>
<h4 id="邻近适应next-fit">（4）邻近适应（Next Fit）</h4>
<p>相当于对首次适应算法的改良，每一次从<strong>上次查找结束的地方</strong>开始继续查找，找到第一个能满足大小的空闲分区。相应的空闲分区在按照<strong>地址递增</strong>存储的同时，可以使用<strong>循环链表</strong>等类似数据结构。</p>
<ul>
<li>首次适应算法相比于临近适应算法开销较大（每次都要从头开始检索）</li>
<li>首次适应每次都从头开始检索，会优先利用低地址部分的小分区，能够给大进程留下更多的大空闲分区</li>
</ul>
<p>四种算法中，首次适应一般效果是最好的</p>
<h2 id="非连续分配管理方式">非连续分配管理方式</h2>
<h3 id="基本分页存储方式">基本分页存储方式</h3>
<h4 id="基本概念">基本概念</h4>
<h5 id="页面和页面大小">页面和页面大小</h5>
<p>进程中块称为页或者页面</p>
<p>内存中块称为页框或页帧</p>
<p>进程要为每个页面分配主存中可用页框，所以页和页框一一对应</p>
<p>页面大小是2的整数幂</p>
<h5 id="地址结构">地址结构</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9f49ef0ea50824263821425f26408b3.jpg" /></p>
<h5 id="页表">页表</h5>
<p>实现从页号到物理块号的地址映射</p>
<p><font color = "yellow">一个进程包含一个页面，一个页面对应一个页表项</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0656c7038c624c864a1e02889d00a9c.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>举例：页表项计算</p>
<p><img
src="D:\MyDownloads\Software\wechatfile\WeChat%20Files\wxid_6hyhf91zyxtg22\FileStorage\Temp\4a1a6ea480adb697d002190344c5a53.jpg" /></p>
<hr style = "border:2px solid yellow">
<h4 id="基本地址变换">基本地址变换</h4>
<p>作用：将逻辑地址转换成内存中物理地址</p>
<h3 id="基本分段存储管理">基本分段存储管理</h3>
<p><strong>进程的地址空间</strong>：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址</p>
<p><strong>内存分配规则</strong>：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但各段之间可以<strong>不相邻</strong>。</p>
<p>分段系统的逻辑地址结构由<strong>段号</strong>（段名）和<strong>段内地址</strong>（段内偏移量）所组成，其中：</p>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>段内地址位数决定了每个段的最大长度是多少</li>
</ul>
<p>引入段式存储主要是为了满足以下的需求：</p>
<ul>
<li>方便编程</li>
<li>分段共享</li>
<li>分段保护</li>
<li>动态链接</li>
<li>动态增长</li>
</ul>
<h4 id="段表">（1）段表</h4>
<p>作用与页表类似，结构包括段号、段长、基址，<strong>每个段表项的长度是相同的</strong>：</p>
<ul>
<li>段号：由于段表项长度相同，可以是隐含的</li>
<li>段长：该段的长度</li>
<li>基址：该段在内存中的起始地址</li>
</ul>
<h4 id="地址变换">（2）地址变换</h4>
<ol type="1">
<li>根据逻辑地址得到段号、段内地址</li>
<li>判断段号是否越界（段号应当小于段表长度M）</li>
<li>查询段表，得到对应的段表项（段表项地址 = 段表始址 + 段号 *
段表项长度）</li>
<li>判断段内地址是否超过段长</li>
<li>计算得到物理地址（物理地址 = 段基址 + 段内地址）</li>
<li>访问目标内存单元</li>
</ol>
<h4 id="分段和分页管理的区别">（3）分段和分页管理的区别</h4>
<ul>
<li>分页管理
<ul>
<li>页是信息的物理单位</li>
<li>分页的主要目的是为了实现离散分配，提高内存利用率，<strong>不会产生外部碎片，只有少量的内部碎片</strong></li>
<li>分页仅仅是系统管理上的需要，完全是系统行为，对用户是<strong>不可见的</strong></li>
<li>分页的用户进程地址空间是<strong>一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</li>
</ul></li>
<li>分段管理
<ul>
<li>段是信息的逻辑单位</li>
<li>分段的主要目的是更好地满足用户需求，<strong>会产生外部碎片</strong></li>
<li>一个段通常包含着一组属于一个逻辑模块的信息</li>
<li>分段对用户是<strong>可见的</strong>，用户编程时需要显式地给出段名</li>
<li>分段的用户进程地址空间是<strong>二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li>
<li>分段更容易实现信息的共享和保护</li>
</ul></li>
</ul>
<h3 id="段页式管理方式">3、段页式管理方式</h3>
<ul>
<li>将进程按逻辑模块分段</li>
<li>再将各段分页（如每个页面4KB）</li>
<li>再将内存空间分为天小相同的内存块</li>
<li>运行进程前将各页面分别装入各内存块中</li>
</ul>
<p>段页式管理方式的逻辑地址由段号、页号和页内偏移量组成，其中</p>
<ul>
<li>段号的位数决定了每个进程最多可以分几段</li>
<li>页号的位数决定了每个段最大由多少页</li>
<li>页内偏移量决定了页面的大小和内存块的大小</li>
</ul>
<h4 id="数据结构">数据结构</h4>
<p><strong>段表</strong>：段表项包括段号（隐含）、页表长度、页表存放块号（页表起始地址）</p>
<p><strong>页表</strong>：页表项包含页号（隐含）、页面存放的内存块号</p>
<h4 id="地址转化过程">地址转化过程</h4>
<ol type="1">
<li>根据<strong>逻辑地址</strong>得到<strong>段号S</strong>、<strong>页号P</strong>和<strong>页内偏移量W</strong></li>
<li>判断段号是否越界（段号S应当小于段表长度M）</li>
<li>查询段表，找到相应的段表项（段表项地址 = 段表始址F + 段号S *
段表项长度）</li>
<li>检查页号是否越界（页号应当小于页表长度）</li>
<li>根据<strong>页表存放块号</strong>和<strong>页号</strong>找到对应的<strong>页表项</strong></li>
<li>根据<strong>内存块号</strong>和<strong>页内偏移量</strong>得到<strong>物理地址</strong></li>
</ol>
<p>总计三次访问内存</p>
<p>同样可以引入快表，并以段号和页号作为查询关键字，若快表命中，则可以直接得到物理地址，仅需一次访存。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.2处理机调度</title>
    <url>/posts/20ce47b7.html</url>
    <content><![CDATA[<h1 id="处理机调度">处理机调度</h1>
<span id="more"></span>
<h2 id="调度的概念">调度的概念</h2>
<h4 id="基本概念">基本概念</h4>
<p>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<blockquote>
<p>区别<strong>进程调度</strong>和<strong>上下文切换</strong>。</p>
<ul>
<li>进程调度是一种资源分配的行为，包括了调度程序的决策和上下文切换；</li>
<li>上下文切换时调度的实现手段，执行调度程序的决策。</li>
</ul>
</blockquote>
<h4 id="三种调度层次">三种调度层次</h4>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/IMG_1821.JPG" alt="IMG_1821" style="zoom:30%;" /></p>
<ol type="1">
<li><p>高级调度(作业调度)</p>
<p><font color = "red">调度的对象是外存中等待的作业</font>，</p>
<p><font color = "red">行为是将作业由外存调度到内存中</font>。</p>
<p>按照一定的原则从外存上处于后备队列的作业中挑选一个或多个，给它们分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它们获得竞争处理机的权利。</p>
<p>一个作业只会有一次调入和一次调出，两次的时间差就是作业执行完毕所花费的时间，所以这种调度的频率是最低的。</p>
<blockquote>
<p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p>
</blockquote></li>
<li><p>中级调度(内存调度)</p>
<p><font color = "red">该调度的对象是暂时不能运行的进程</font>，</p>
<p><font color = "red">行为是将目标进程的相关数据在内存和外存间移动。</font></p>
<p>引入中级调度的目的是提高内存利用率和系统吞吐量。</p>
<p>中级调度实际上是存储器管理中的对换功能。</p>
<blockquote>
<p>七状态模型：引入挂起状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/IMG_1823.JPG" alt="IMG_1823" style="zoom:30%;" /></p>
</blockquote></li>
<li><p>低级调度(进程调度)</p>
<p><font color = "red">调度的对象是进程(或内核级线程)，</font></p>
<p><font color = "red">行为是决定将处理器资源先分配给哪个进程。</font></p>
<p>进程调度是最基本的一种调度，是发生频率最高的调度，多道批处理、分时和实时系统中，都要实现进程调度。</p></li>
</ol>
<h4 id="三级调度的联系"><font color = "red">三级调度的联系</font></h4>
<ol type="1">
<li>作业调度为进程活动做准备，进程调度使进程正常活动起来。</li>
<li>中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li>
<li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li>
<li>进程调度是最基本的，不可或缺。</li>
</ol>
<h2 id="调度的时机">调度的时机</h2>
<h4 id="调度可以发生的场合">调度可以发生的场合</h4>
<ol type="1">
<li>创建一个新进程之后。</li>
<li>进程退出后。</li>
<li>进程时间片用尽。</li>
<li>可抢占式系统中进程进入就绪队列。</li>
<li>阻塞发生时。</li>
<li>I/O中断发生时。</li>
</ol>
<h4
id="调度不能发生的场合"><font color = "red">调度不能发生的场合</font></h4>
<ol type="1">
<li>中断处理过程中。</li>
<li>原语执行过程中。</li>
<li>进程在操作系统内核临界区中。</li>
</ol>
<h2 id="调度的方式">调度的方式</h2>
<h4 id="非抢占式调度">非抢占式调度</h4>
<p>在非抢占式调度中，操作系统选择一个进程并让其运行，直到其发生阻塞或者完成任务释放资源为止。</p>
<ol type="1">
<li>调度发生的时机：
<ol type="1">
<li><font color = "red">进程运行完毕</font>，放弃处理器的使用权。</li>
<li>进程发生某种事件而无法继续运行，放弃处理器使用权。(<font color = "red">就是出错了</font>)</li>
<li>进程发生阻塞需要等待继续运行的条件，放弃处理器使用权。(<font color = "red">就是还有资源没有准备好</font>)</li>
</ol></li>
<li>非抢占式调度的优点：
<ol type="1">
<li>调度算法设计更简单，调度成本更低。</li>
<li>高吞吐的调度策略。</li>
</ol></li>
</ol>
<blockquote>
<p>调度行为本身，是一个白白消耗系统资源的行为，因为调度程序占用处理器资源这一行为对作业的完成是没有任何贡献的。抢占式调度会触发更多次的调度，因而系统整体的吞吐量会变低。</p>
<p>非抢占式调度适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p>
</blockquote>
<h4 id="抢占式调度">抢占式调度</h4>
<p>抢占式调度算法中，系统可以根据某种调度的原则，暂停一个进程的执行并将处理器资源分给另一个进程。</p>
<ol type="1">
<li>抢占遵循的常用原则：
<ol type="1">
<li>优先级。优先级高的进程可以抢占优先级低的进程，这个抢占行为可以发生在进程调度的时机上。</li>
<li>短进程优先。请求处理器时间短的进程，可以抢占请求时间长的进程。</li>
<li>时间片轮转原则。每个进程依次占用处理器资源，一个进程耗尽当前分配的时间片后，其他就绪进程可以在进程调度发生时抢占。</li>
</ol></li>
<li>抢占式调度的优点：
<ol type="1">
<li>抢占式调度方法，可以防止一个进程长时间独占处理器的恶意行为。</li>
<li>与非抢占式调度方法相比，处理器利用率更高。</li>
<li>抢占式调度的等待时间和响应时间更短，用户体验好，有利于实时系统和分时系统。</li>
<li>每次中断后都需要考虑调度，这使得操作系统更加灵活。</li>
<li>操作系统确保所有正在运行的进程的处理器使用率相同，改善了平均响应时间。</li>
</ol></li>
</ol>
<h2 id="调度算法的目标">调度算法的目标</h2>
<h4 id="操作系统的使用场景">操作系统的使用场景</h4>
<ol type="1">
<li>批处理系统：非抢占式调度策略和不把响应时间作为首要考虑目标的抢占式调度算法都是可以考虑的。这些调度算法减少了调度频率，从而提升了性能。</li>
<li>个人电脑上的操作系统：用户需要快速得到响应，因此应该优先考虑抢占式的、响应时间短的调度算法。</li>
<li>有时限的系统(例如股票交易系统、航天器自动控制系统等)：为了保证任务在规定时间内完成，往往考虑抢占式的调度算法，即当一个高优先进程进入就绪队列后，系统会优先调度高优先级进程运行。</li>
</ol>
<h4 id="调度算法的指标">调度算法的指标</h4>
<ol type="1">
<li><p>公平：相似的进程应该得到相似的服务。</p></li>
<li><p>资源利用率：为了提高计算机的资源利用率，应该尽可能让计算机的各种资源都处于忙碌状态。计算公式：
<span class="math display">\[
CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲时间}
\]</span></p></li>
<li><p>平衡性：平衡指处理器密集型作业和I/O密集型作业的调度平衡，为了保证计算机的各个资源都尽可能处于忙碌状态，需要平衡地调度这两种类型地作业。</p></li>
<li><p><font color = "red">周转时间(长出计算题)</font>：周转时间指一个作业从被提交开始，知道作业完成为止所消耗的时间，其中包括了作业等待高级调度的时间、作业在就绪队列等待的时间以及作业的运行和I/O耗时。</p>
<p>作业的周转时间短意味着用户可以更快地拿到结果，从操作系统的角度考虑，会希望平均周转时间最短，因为这能直接反映出操作系统更高的效率。</p>
<ol type="1">
<li><font color = "red">周转时间<span
class="math inline">\(T\)</span></font>：作业从被提交开始，到完成消耗的时间。<span
class="math inline">\(T=t_{finish}-t_{arrive}\)</span></li>
<li><font color = "red">平均周转时间<span
class="math inline">\(\overline{T}\)</span></font>：多个作业周转时间的平均值。<span
class="math inline">\(\overline{T}=(T_1+T_2+\cdots+T_n)/n\)</span></li>
<li>带权周转时间<span
class="math inline">\(W\)</span>：一个作业的周转时间<span
class="math inline">\(T\)</span>和改作业实际运行时间之比。<span
class="math inline">\(W=\frac{T}{t_s}\)</span></li>
<li>平均带权周转时间<span
class="math inline">\(\overline{W}\)</span>：多个作业带权周转时间的平均值。<span
class="math inline">\(\overline{W}=(W_1+W_2+\cdots+W_n)/n\)</span></li>
</ol></li>
<li><p>系统吞吐率：吞吐率指单位时间内完成的作业数，收到运行作业长度的影响。</p></li>
<li><p>响应时间：用户提交请求开始，直到系统首次对该作业做出响应所花费的时间。</p></li>
<li><p>等待时间：等待时间指一个进程在队列中等待各种资源的时间。<span
class="math inline">\(等待时间=周转时间-运行时间\)</span>。</p></li>
</ol>
<h2 id="调度的实现">调度的实现</h2>
<h4 id="调度的主要任务">调度的主要任务</h4>
<ol type="1">
<li>保存处理器的现场信息。</li>
<li>按照进程调度算法确定下一个被分配处理器的进程。</li>
<li>将处理器资源分配给进程。</li>
</ol>
<h4 id="进程调度机制">进程调度机制</h4>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/IMG_1849.JPG" alt="IMG_1849" style="zoom: 25%;" /></p>
<ol type="1">
<li><p>排队器</p>
<p>在实现进程调度的系统中，根据不同进程的不同状态，维护着多个进程队列。</p>
<p>排队器的作用，就是在进程状态转换为就绪态时，将其插入就绪队列中。</p></li>
<li><p>分派器</p>
<p>根据进程调度程序所选择的进程，将其从就绪队列取出并将处理器资源分配给该进程。</p></li>
<li><p>上下文切换器</p>
<p>在分配处理器给新进程时，需要进行上下文切换。</p></li>
</ol>
<blockquote>
<p>在上下文切换时，需要执行大量load和store指令，以保存寄存器的内容，因此会花费比较多的时间。</p>
</blockquote>
<h4 id="闲逛进程">闲逛进程</h4>
<p>闲逛进程是一种没有明确工作，用于解决调度中可能发生的特殊情况的进程。</p>
<p>闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出处理机。</p>
<p>闲逛进程不需要CPU之外的资源，它不会被阻塞。</p>
<blockquote>
<p>Unix操作系统下PID为0的进程就是闲逛进程。</p>
</blockquote>
<h4 id="两种线程的调度">两种线程的调度</h4>
<ol type="1">
<li>用户级线程调度：由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</li>
<li>内核级线程调度：内核选定一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li>
</ol>
<blockquote>
<p>用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；</p>
<p>内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。</p>
</blockquote>
<h2 id="典型调度算法">典型调度算法</h2>
<h4 id="先来先服务fcfs调度算法">先来先服务(FCFS)调度算法</h4>
<p>FCFS调度算法是一种最简单的调度算法，也称先进先出算法(FIFO)，它既可用于作业调度，又可用于进程调度。</p>
<p>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p>
<p>在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到运行完成或因某种原因而阻塞时才释放处理机。</p>
<blockquote>
<p>优点：逻辑简单，对长作业比较有利，有利于CPU繁忙型作业。</p>
<p>缺点：效率差，无法实现人机交互，未考虑到不同进程间的差异性，更加偏向处理器密集型进程和长进程。</p>
</blockquote>
<blockquote>
<p>❓为什么FCFS算法偏向长进程和处理器密集型进程？</p>
<p>💡长进程排队并使用处理器直到作业完成或阻塞，可以使用处理器更长时间；I/O密集型进程碰到I/O操作时会陷入阻塞而重新排队，而处理器密集型进程碰到的阻塞少，排队次数少，等待时间也会少。</p>
</blockquote>
<p>CPU繁忙型一般会占用较长时间的CPU时间，所以不会频繁</p>
<h4 id="短作业优先sjf调度算法">短作业优先(SJF)调度算法</h4>
<p>短作业优先调度算法是指对短作业优先调度的算法。</p>
<p>短作业优先(SJF)调度算法从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p>
<p>短进程优先(SPF)调度算法从就绪队列中选择一个估计运行时间最短的进程，将处理器分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p>
<blockquote>
<p>优点：</p>
<ul>
<li>较FCFS而言，性能有了提升。</li>
<li>SPF的平均等待时间和平均周转时间是<strong>最优</strong>的。</li>
</ul>
<blockquote>
<p>🚫实际上SPF/SJF是十分理想的调度算法，但现实中难以实现：</p>
<ol type="1">
<li>进程难以准确预估运行所需时间。</li>
<li>程序可以谎报运行所需时间而恶意竞争处理器使用权。</li>
</ol>
</blockquote>
<p>缺点：</p>
<ul>
<li>算法需要进程预估其运行时间。</li>
<li>这个算法是偏向短进程的。</li>
<li>这个算法仅仅通过进程耗时的长短来定义进程优先级，未考虑进程间的差异性。</li>
</ul>
</blockquote>
<p>根据<strong>是否可以抢占</strong>，短进程调度算法分为以下两种：</p>
<ol type="1">
<li>非抢占式短进程优先调度算法：调度时，会选择当前就绪队列中要求处理器时间最少的进程，为其分配处理器。该进程运行期间，不会被抢占，直到进程主动放弃处理器。</li>
<li>抢占式短进程优先调度算法：调度时，会选择当前就绪队列中要求处理器时间最少的进程，为其分配处理器。如果在该进程运行过程中，就绪队列中出现了要求时间更短的进程，则这个要求时间更短的进程会抢占处理器资源，当前运行的进程状态会由执行态变为就绪态。</li>
</ol>
<p>举例：</p>
<ol type="1">
<li><p><font color = "red">进程的周转时间 = 进程的完成时间 -
进程的抵达时间</font></p></li>
<li><p><font color = "red">非抢占的短进程优先的优先级：抵达时间&gt;进程耗时,</font></p>
<p>首先先抵达的进程先执行，如果有两个进程同时得到了获得处理器的机会，耗时短的进程先执行</p></li>
<li><p><font color = "red">抢占的短进程优先级：进程耗时&gt;抵达时间</font></p>
<p>不论抵达时间，只要这个进程时间短就先执行</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/dbfd083e610ddbb34929309ca567d60.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5c4a3c08db4b55f3c2de414783211ef.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/64870fda32d57ebc765f6390a4f90e1.jpg" /></p>
<h4 id="优先级调度算法psa">优先级调度算法(PSA)</h4>
<p>优先级调度算法既可用于作业调度又可用于进程调度。</p>
<p>在该算法下，作业的优先级由外界赋予，系统只需要根据外界赋予的优先级来进行调度即可。</p>
<p><strong>根据是否可以抢占，优先级调度算法可以分为以下两种：</strong></p>
<ul>
<li>非抢占式优先级调度算法
<ul>
<li>必须等待当前进程运行完才会执行下一个进程，不论下一个进程优先级有多高。</li>
</ul></li>
<li>抢占式优先级调度算法
<ul>
<li>如果出现比当前运行的进程优先级更高的进程，立刻将当前进程转为就绪态，更高优先级的进程抢占处理器。</li>
</ul></li>
</ul>
<p><strong>根据优先级是否可以动态变化，分为以下两种：</strong></p>
<ul>
<li><p>静态优先级</p>
<ul>
<li>指各个进程的优先级在调度程序运行之初就已经确定，整个运行期间不会改变。</li>
</ul>
<blockquote>
<p>设计优先级的依据：</p>
<ol type="1">
<li><font color = "red">系统进程的优先级一般高于用户进程的优先级</font></li>
<li><font color = "red">I/O密集型进程高于处理器密集型进程</font></li>
<li><font color = "red">对资源要求少的进程优先级高于对资源要求多的进程</font></li>
<li>用户自定义的优先级</li>
</ol>
</blockquote></li>
<li><p>动态优先级</p>
<ul>
<li>指在调度程序运行的过程中，各个进程的优先级是动态变化的。<font color = "red">进程执行时间越长，优先权越低；进程等待时间越长，优先权越高</font></li>
</ul></li>
</ul>
<h4 id="高响应比优先调度算法hrrn">高响应比优先调度算法(HRRN)</h4>
<p>高响应比优先调度算法，可以适用于作业调度、进程调度。</p>
<p>该算法根据公式来确定进程的优先级。公式如下： <span
class="math display">\[
优先级=\frac{等待时间+要求服务时间}{要求服务时间}
\]</span>
由于等待时间是变化的，所以优先级也会动态变化，随着进程的等待时间增加，进程的优先级就会变高，更容易被调度。</p>
<blockquote>
<ol type="1">
<li>作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，类似于SJF</li>
<li>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，类似与FCFS</li>
<li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机，克服了“饥饿”现象。</li>
</ol>
</blockquote>
<p>注：</p>
<p>（1）<font color = "red">什么是饥饿：在操作系统理论中，饥饿指的是一个进程长期得不到运行，而处于长期等待的状态</font></p>
<p>（2）当时间片过大时，相当于任何一个程序都可以在这个时间片里运行完毕，那么就变成了先来先服务的调度</p>
<h4 id="时间片轮转调度算法rr">时间片轮转调度算法(RR)</h4>
<p>时间片轮转调度算法主要适用于分时系统。</p>
<p>在这种算法中，<font color = "red">系统将所有就绪进程按FCFS策略排成一个就绪队列</font>，调度程序总是选择就绪队列中的第一个进程执行，但仅能运行一个时间片。在使用完一个时间片后，即使进程没有运行完成，也必须释放处理机给<font color = "red">下一个就绪进程</font>，而被剥夺的进程返回到<font color = "red">就绪队列</font>的队尾重新排队，等候再次运行。67</p>
<blockquote>
<ul>
<li>RR算法的调度时机：
<ul>
<li>一个时间片耗尽，在时钟中断发生时，调度程序调度下一个就绪进程上处理器运行，将当前进程放回到就绪队列末尾。</li>
<li>一个时间片未耗尽，但进程已完成工作，或因其他原因放弃处理器资源，调度程序会选择下一个就绪程序进行进程调度。</li>
</ul></li>
</ul>
</blockquote>
<p>时间片轮转调度算法是为了<font color = "red">多个用户能及时干预系统</font></p>
<h4 id="多级队列调度算法">多级队列调度算法</h4>
<p>多级队列调度算法，可以适用于进程调度。</p>
<p>该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可实施不同的调度算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/793f755b3054eb78e1b2948eebd5ed4.jpg" alt="793f755b3054eb78e1b2948eebd5ed4" style="zoom: 33%;" /></p>
<h4 id="多级反馈队列调度算法">多级反馈队列调度算法</h4>
<p>多级反馈队列调度算法，可以适用于进程调度，这种调度算法能够较好地满足<font color = "red">各类进程</font>对于处理器资源的需求，是公认较好的一种调度算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/b9ac193e8711a395b6df2befc9e3663.jpg" alt="b9ac193e8711a395b6df2befc9e3663" style="zoom:33%;" /></p>
<p>多级反馈队列调度算法的实现思想如下：</p>
<ol type="1">
<li>设置多个就绪队列，并<font color = "red">为每个队列赋予不同的优先级。</font></li>
<li>赋予各个队列的进程运行时间片的大小各不相同。<font color = "red">在优先级越高的队列中，每个进程的时间片就越小。</font></li>
<li><font color = "red">每个队列都采用先来先服务(FCFS)算法。</font>当一个作业的进程被创建并分配资源后，先将其加入第一个队列的末尾，依据FCFS算法等待分配时间片。</li>
<li>按照<font color = "red">队列优先级调度</font>。如果当前使用处理器资源的进程来自第i级队列，而此时第一级队列中进入了新的就绪进程，那么会立即进行抢占式进程调度，并将此时正在运行的程序返回i级队列队尾。</li>
</ol>
<p>多级反馈队列调度算法如何满足各类用户：</p>
<ul>
<li>终端型用户：多为交互作业，所需时间较少，大多数在第一级队列中就能快速完成，而第一级队列具有最高的优先级，这样使得任务的周转时间短。</li>
<li>短批处理作业用户：作业长度稍长，在前几级队列中就可以完成，周转时间较短。</li>
<li>长批处理作业用户：作业长度长，但是也会在前几级队列中等待并获得时间片，执行部分程序，不会长时间得不到执行。</li>
</ul>
<h4 id="调度算法对比"><font color = "red">调度算法对比</font></h4>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先来先服务(FCFS)</td>
<td>优点：逻辑简单<br />缺点：完全不考虑进程特点<br />利于：长进程、处理器密集进程(也叫CPU繁忙型）<br />不利于：短进程、I/O密集型进程</td>
</tr>
<tr class="even">
<td>短进程优先(SJF)</td>
<td>优点：拥有最优的平均等待时间和平均周转时间<br />缺点：进程预计运行时间难以计算<br />利于：短进程（比如I/O繁忙型）<br />不利于：长进程</td>
</tr>
<tr class="odd">
<td>优先级(PSA)</td>
<td>通过设置进程优先级以区分进程特点<br />利于：高优先级进程<br />不利于：低优先级进程</td>
</tr>
<tr class="even">
<td>高响应比优先(HRRN)</td>
<td>优先级动态变化，利于短进程但可以消除饥饿<br />利于：短进程<br />不利于：长进程</td>
</tr>
<tr class="odd">
<td>时间片轮转(RR)</td>
<td>公平的将处理器分配给每个进程</td>
</tr>
<tr class="even">
<td>多级反馈队列</td>
<td>能较好满足各类进程对处理器的需求<br />长进程、I/O密集型进程随着运行会逐步下沉到低优先级队列</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 22%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>是否可抢占</th>
<th>是否会导致饥饿</th>
<th>算法考虑因素</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先来先服务</td>
<td>否</td>
<td>否</td>
<td>等待时间(进程到达时间)</td>
</tr>
<tr class="even">
<td>短进程优先</td>
<td>均可</td>
<td>是</td>
<td>进程预计运行时间</td>
</tr>
<tr class="odd">
<td>优先级</td>
<td>均可</td>
<td>是</td>
<td>进程优先级</td>
</tr>
<tr class="even">
<td>高响应比优先</td>
<td>均可</td>
<td>否</td>
<td>进程预计运行时间+等待时间</td>
</tr>
<tr class="odd">
<td>时间片轮转</td>
<td>是</td>
<td>否</td>
<td>所有进程公平分时使用处理器</td>
</tr>
<tr class="even">
<td>多级反馈队列</td>
<td>是</td>
<td>否</td>
<td>FCFS+时间片轮转算法</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<p>题1：计算进程周转时间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6d4604f3006df742125a89fcbcf881e.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3ef6bb6f71e0d115a852c155ffb9209.jpg" /></p>
<p>题2：不同调度算法对比：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c315caa8b32cecf15360fe0bfa7bcfc.jpg" /></p>
<p>分析：</p>
<p>CPU繁忙型：类似与长作业，需要占用CPU较长时间，而很少I/O</p>
<p>I/O繁忙型：频繁访问I/O端口，频繁放弃CPU，所以占用CPU时间不长，而一旦放弃就必须重新排队等待调度</p>
<p>时间片轮转调度：无论对于长作业还是短作业分配的时间片都一样，所以几乎没区别</p>
<p>先来先服务：适合CPU繁忙型，不适合I/O繁忙型</p>
<p>短作业优先：适合I/O繁忙型</p>
<p>优先级调度：根据优先级，而优先级与时间无必然关系</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.1_进程与线程</title>
    <url>/posts/1edbbd5b.html</url>
    <content><![CDATA[<h2 id="进程的概念组成和特征">进程的概念、组成和特征</h2>
<span id="more"></span>
<h3 id="进程的概念">进程的概念</h3>
<p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p>
<p><a
href="https://www.youtube.com/watch?v=VR9e-IjJRUY">视频讲解：可视化进程</a></p>
<p><a
href="https://www.youtube.com/watch?v=ttXxSJdqEGY">视频讲解：从一个程序执行过程进一步理解进程，包括代码段和数据段</a></p>
<h3 id="进程的组成">进程的组成</h3>
<p>一个进程实体（进程映像）由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。</p>
<p>进程是<strong>动态</strong>的，进程实体是<strong>静态</strong>的。进程实体反映了进程在某一时刻的状态。</p>
<h4 id="pcb">PCB</h4>
<p>数据结构<strong>PCB</strong> ( Process Control
Block)，即<strong>进程控制块</strong>。操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。</p>
<p><strong>PCB是进程唯一的标识！</strong></p>
<p>PCB中存储了包括PID，UID（进程所属用户ID），进程运行情况等相关信息</p>
<p>当进程结束后，系统会回收PCB。</p>
<h4 id="程序段和数据段">程序段和数据段</h4>
<p>程序段：程序所包含的指令</p>
<p>数据段：程序产生的数据（如各种变量）</p>
<h3 id="进程的特征">进程的特征</h3>
<h4 id="动态性">动态性</h4>
<p>进程是程序的一次执行过程，是动态地产生、变化和消亡的。</p>
<p><strong>动态性是进程最基本的特征。</strong></p>
<h4 id="并发性">并发性</h4>
<p>内存中有多个进程实体，各进程可并发执行</p>
<h4 id="独立性">独立性</h4>
<p>进程是能<strong>独立运行</strong>、<strong>独立获得资源</strong>、<strong>独立接受调度</strong>的基本单位。</p>
<h4 id="异步性">异步性</h4>
<p>各进程按各自独立的、不可预知的速度向前推进，
操作系统要提供“<strong>进程同步机制</strong>”来解决异步问题。</p>
<h4 id="结构性">结构性</h4>
<p>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。</p>
<h2 id="进程的状态与转换">进程的状态与转换</h2>
<p><a
href="https://www.youtube.com/watch?v=pTku55MF51A">视频讲解：进程就绪态和阻塞态</a></p>
<p><a
href="https://www.youtube.com/watch?v=rt_eeKrJRnM">视频讲解：进程终止态</a></p>
<p><a
href="https://www.youtube.com/watch?v=vxxXQRGuHIA">视频讲解：进程五种状态转换</a></p>
<h3 id="进程的状态">进程的状态</h3>
<h4 id="创建态">创建态</h4>
<p>进程正在被创建。包括建立空白PCB，由系统为进程分配资源等。</p>
<h4 id="就绪态">就绪态</h4>
<p>进程获得了<strong>除了处理机外的一切资源</strong>。一旦获得了处理机资源就可以立刻开始运行，系统中处于就绪态的进程可以有<strong>很多个</strong>，通常将它们排成一个队列，称为<strong>就绪队列</strong>。</p>
<h4 id="运行态">运行态</h4>
<p>进程正在处理机上运行。单处理机情况下每个时刻最多只有一个进程在运行态。</p>
<h4 id="阻塞态等待态">阻塞态（等待态）</h4>
<p>进程请求等待某个事件发生，在该事件完成前，即使处理机资源空闲，该进程也不能运行。例如请求了系统调用或者是等待某些资源。</p>
<h4 id="中止态">中止态</h4>
<p>进程正在结束。系统先将进程置为结束态，之后再进行资源的释放和回收等工作。</p>
<p>如果是多核CPU，可以存在多个运行态的进程</p>
<p>运行态、阻塞态和就绪态是进程的三种基本状态</p>
<h3 id="进程状态的转换">进程状态的转换</h3>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230320213843363.png" alt="image-20230320213843363" style="zoom: 67%;" /></p>
<ul>
<li>两个不能
<ul>
<li>不能直接由阻塞态到运行态</li>
<li>不能直接由就绪态到阻塞态</li>
</ul></li>
<li>转变模式
<ul>
<li>运行态到阻塞态一般是<strong>主动的</strong>行为</li>
<li>阻塞态到就绪态是<strong>被动的</strong>行为</li>
</ul></li>
</ul>
<hr style = "border:2px solid yellow">
<ul>
<li>题目1：进程的状态转换</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ec2246c148c45bd030bd97a1c9f960d.jpg" /></p>
<p>I/O操作完成之前进程在等待结果，状态为阻塞态，完成后进程等待事件就绪，是就绪态</p>
<ul>
<li><p>题目2：进程状态与处理器效率关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/db58a8fdb97644d35090bb664a2c144.jpg" /></p>
<p>进程的就绪数目越多，争夺CPU的进程就越多，但只要就绪队列不为空，CPU就一直保持繁忙，而当CPU不忙效率才下降</p></li>
</ul>
<hr style = "border:2px solid yellow">
<h3 id="进程的组织方式">进程的组织方式</h3>
<p>链式方式：将同一状态的PCB连接到同一个队列中；</p>
<p>索引方式：将同一状态的PCB放在一个索引表当中。</p>
<h2 id="进程控制">进程控制</h2>
<p>进程控制是使用<strong>原语</strong>来实现的。</p>
<p>原语是指执行期间<strong>不允许中断</strong>的程序段，是一个不可分割的基本单位。</p>
<p>通过“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”实现了原语的<strong>原子性</strong>。</p>
<h3 id="进程的创建">进程的创建</h3>
<h4 id="创建原语">创建原语</h4>
<ol type="1">
<li>申请空白PCB</li>
<li>为进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列（<strong>创建态→就绪态</strong>）</li>
</ol>
<h4 id="引起进程创建的事件">引起进程创建的事件</h4>
<ul>
<li>用户登录</li>
<li>作业调度（<em>有新的作业将要运行</em>）</li>
<li>提供服务</li>
<li>应用请求（<em>用户进程主动请求创建子进程</em>）</li>
</ul>
<h3 id="进程的终止">进程的终止</h3>
<h4 id="撤消原语">撤消原语</h4>
<ol type="1">
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立刻剥夺CPU，将CPU分配给其他进程</li>
<li>中止其所有子进程</li>
<li>将该进程所有资源归还给父进程或是操作系统</li>
<li>删除PCB</li>
</ol>
<h4 id="引起进程中止的事件">引起进程中止的事件</h4>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/40012cbcd9efe70c899cdcdef15dbf8.jpg" /></p>
<p>A：对</p>
<p>B：虚拟地址空间不可共享</p>
<p>C：每个进程PCB都不一样</p>
<p>D：对</p>
<hr style = "border:2px solid yellow">
<h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3>
<p>阻塞原语和唤醒原语必须成对使用</p>
<h4 id="阻塞原语">阻塞原语</h4>
<ol type="1">
<li>找到要阻塞进程对应的PCB</li>
<li>保护进程运行现场，将进程设置为<strong>阻塞态</strong>，暂时停止进程运行</li>
<li>将PCB插入对应事件的等待队列</li>
</ol>
<h4 id="引发阻塞的事件">引发阻塞的事件</h4>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待合作的其他进程完成工作</li>
</ul>
<h4 id="唤醒原语">唤醒原语</h4>
<ol type="1">
<li>在事件队列中找到对应的PCB</li>
<li>将PCB从等待队列移除，设置为<strong>就绪态</strong></li>
<li>将PCB插入就绪队列，等待被唤醒</li>
</ol>
<h4 id="引发唤醒的事件">引发唤醒的事件</h4>
<ul>
<li>等待的事件发生</li>
</ul>
<h3 id="进程的切换">进程的切换</h3>
<h4 id="切换原语">切换原语</h4>
<ol type="1">
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB回复进程所需的运行环境</li>
</ol>
<p><em>运行环境</em>：进程运行中的临时变量等<a
href="https://www.youtube.com/watch?v=hQmxQKYQu3w">视频讲解：运行环境</a></p>
<h4 id="引起切换的事件">引起切换的事件</h4>
<ul>
<li>当前进程时间片到</li>
<li>更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程中止</li>
</ul>
<p><font color = "red">原语公共点</font></p>
<ol type="1">
<li>更新PCB中信息</li>
<li>将PCB插入合适队列</li>
<li>分配/回收资源</li>
</ol>
<h2 id="进程通信">进程通信</h2>
<p><a
href="https://www.youtube.com/watch?v=UrYPPbAwVs4">视频讲解：进程通信需要操作系统支持的原因</a></p>
<h3 id="共享存储">共享存储</h3>
<p><a
href="https://www.youtube.com/watch?v=jMkUtIGY_IU">视频讲解：共享存储</a></p>
<ul>
<li>两个进程对共享空间的访问必须是<strong>互斥</strong>的。</li>
<li>操作系统只提供<strong>共享空间</strong>和<strong>同步互斥工具</strong>（如P，V操作）。</li>
</ul>
<p>两种方式：基于数据结构的共享、基于存储区的共享</p>
<h4 id="基于数据结构的共享">基于数据结构的共享</h4>
<ul>
<li>只能共享<strong>固定的</strong>数据结构</li>
<li>速度慢，是一种低级的共享方式</li>
</ul>
<blockquote>
<p>可以理解为低级全局变量</p>
</blockquote>
<h4 id="基于存储区的共享">基于存储区的共享</h4>
<ul>
<li>共享方式和大小由进程自己决定</li>
<li>速度快，是一种高级的共享方式</li>
</ul>
<h3 id="管道通信">管道通信</h3>
<p><a
href="https://www.youtube.com/watch?v=JF9EUQVgAvM">视频讲解：管道通信</a></p>
<p>管道实际上是一个固定大小的缓冲区</p>
<ul>
<li>管道通信只能实现<strong>半双工通信</strong>，想实现双向通信需要两个管道</li>
<li>各个进程对管道的访问也需要是互斥的</li>
<li>管道中没有写满（读空）时，<strong>不能</strong>向管道中再写（读）数据，<font color = "red">会被阻塞</font></li>
<li>从管道中读取数据是<strong>一次性的</strong>，数据一旦被读取就会从管道中抛弃
<ul>
<li>一次只能有一个读进程</li>
<li>但是可以有多个写进程</li>
</ul></li>
</ul>
<h3 id="消息传递">消息传递</h3>
<p><a
href="https://www.youtube.com/watch?v=s2j-GROUdrE">视频讲解：消息传递</a></p>
<p>进程间的数据交换以格式化消息（message）为单位。</p>
<p>通过<strong>发送消息/接收消息</strong>两个<strong>原语</strong>进行数据交换</p>
<p>两种方式：直接通信方式、间接通信方式</p>
<h4 id="直接通信方式">直接通信方式</h4>
<p>发送进程直接将消息发送到接收进程的消息缓冲队列中</p>
<h4 id="间接通信方式">间接通信方式</h4>
<p>发送进程将消息发送到某个中间实体，一般称为_信箱_，接收端从中间实体接收消息</p>
<p><a href="https://www.youtube.com/watch?v=ZFmXecXwBsU">勘误</a></p>
<hr style = "border:2px solid yellow">
<p>举例：两个进程交换数据的方法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/f1d09b035f046d79b0f831b99fe7e47.jpg" /></p>
<hr style = "border:2px solid yellow">
<h2 id="线程的概念和特点">线程的概念和特点</h2>
<h3 id="线程的概念">线程的概念</h3>
<p>线程是程序执行的最小单元，是进程中的一个实体，是系统独立调度与分派的基本单位。</p>
<p>线程是程序执行的最小单元，是调度的基本单位</p>
<p>进程是资源分配的最小单元</p>
<h3 id="线程的特点">线程的特点</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425143521850.png" /></p>
<ul>
<li><strong>调度</strong>：线程作为独立调度的基本单位，进程内的线程调度不会引起进程切换，开销变小</li>
<li><strong>并发性</strong>：更好
<ul>
<li>进程之间可以并发运行</li>
<li>同一进程内的线程可以并发运行</li>
<li>不同进程间的线程可以并发执行</li>
</ul></li>
<li><strong>占有资源</strong>：线程几乎不占有资源</li>
<li><strong>独立性</strong>
<ul>
<li>进程拥有独立的地址空间和资源</li>
<li>同一进程内的线程共享地址空间和资源</li>
</ul></li>
<li><strong>系统开销</strong>：当进行进程内线程的切换时，开销远小于进程</li>
<li><strong>支持多处理机系统</strong>：可以将多个线程分配给多个处理机运行</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<ul>
<li>题1：线程的特点</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0b5d2ab9f223f73ad7895a61b2cbf01.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：线程是处理机调度的基本单位，所以可以独立执行程序</p>
<p>B：线程没有自己独立的地址空间，而是共享所属进程的空间</p>
<p>C：进程能创建多个线程</p>
<p>D：由于共享内存空间，同一进程中的线程间通信无需使用系统调用函数</p>
<ul>
<li><p>题2：线程与进程的关系</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8318aad027c911753bdacbf7849eed8.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul>
<p>​ B,D：进程是资源分配的单位，内核级线程是处理器调度和分派的单位</p>
<p>​
A:假如有一个内核进程，映射到用户级后有多个线程，那么这些线程之间切换不需要内核级切换进程，也就不需要内核支持</p>
<hr style = "border:2px solid yellow">
<h3 id="线程的实现方式">线程的实现方式</h3>
<h4
id="线程库支持的线程用户级线程-user-level-thread-ult">线程库支持的线程（用户级线程
User-Level Thread, ULT)</h4>
<p><a
href="https://www.youtube.com/watch?v=2JgV_Uc6DZg">视频讲解：用户级线程</a></p>
<ul>
<li><p>线程切换由<strong>应用程序</strong>负责，在<strong>用户态</strong>下即可完成</p></li>
<li><p>线程表存储在用户空间，系统内核意识不到线程的存在</p></li>
<li><p><strong>调度</strong></p>
<ul>
<li><p>操作系统为进程分配时间片</p></li>
<li><p>用户的调度程序再讲时间片分给线程</p></li>
</ul></li>
<li><p>优点</p>
<ul>
<li>线程的切换在用户态即可完成，<strong>开销小、效率高</strong></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>当一个线程被阻塞后，其他线程都会被阻塞，<strong>并发度不高</strong></li>
</ul></li>
</ul>
<h4
id="内核支持的线程内核级线程-kernel-level-thread">内核支持的线程（内核级线程
Kernel-Level Thread）</h4>
<p><a
href="https://www.youtube.com/watch?v=Ylu-HTAx64w">视频讲解：内核级线程</a></p>
<ul>
<li><p>内核级线程的管理工作由<strong>操作系统内核</strong>完成</p></li>
<li><p>内核的切换需要在<strong>内核态</strong>下实现</p></li>
<li><p>线程表存储在内核空间，内核态线程是操作系统内核能够看到的</p></li>
<li><p><strong>调度</strong></p>
<ul>
<li>操作系统以线程为调度单位</li>
</ul></li>
<li><p>优点</p>
<ul>
<li>一个线程被阻塞后，其他线程继续运行，<strong>并发性强</strong></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>线程的切换需要内核态，<strong>成本高、开销大</strong></li>
</ul></li>
</ul>
<hr style = "border:2px solid yellow">
<ul>
<li><p>题目1：内核级线程</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/46854313a7e4af4851f1e445e0db765.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：内核级线程切换相当于进程切换，所以系统开销大</p>
<p>B：内核线程不会堵死，用户线程会</p>
<p>C：内核线程之所以叫内核线程就是因为运行在内核，那么对应的进程也在内核</p>
<p>D：同B</p></li>
<li><p>题目2：用户级线程和内核级线程关系</p></li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/bd0bb7af457b98ed22973d46e642137.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：没学到</p>
<p>B：用户级线程调度实际上调度对象是进程，所以需要内核参与</p>
<p>C：用户级线程实际上不存在，所以任何操作系统都能运行</p>
<p>D：同B</p>
<hr style = "border:2px solid yellow">
<h3 id="多线程模型">多线程模型</h3>
<p><a
href="https://www.youtube.com/watch?v=lvCgJ_W19c0">视频讲解：多线程模型</a></p>
<h4 id="一对一模式">一对一模式</h4>
<p>一个用户级线程映射一个内核级线程（一个UTL一个TCB）</p>
<ul>
<li><p>并发能力强</p></li>
<li><p>开销大</p></li>
</ul>
<h4 id="多对一模式">多对一模式</h4>
<p>将多个用户级线程映射到一个内核级线程，等同于用户级线程（多个UTL一个TCB）</p>
<ul>
<li><p>效率高</p></li>
<li><p>并发能力弱；多个线程不能并行的运行在多处理机上</p></li>
</ul>
<h4 id="多对多模式">多对多模式</h4>
<p>将n个用户级线程映射到m个内核级线程上（m &lt;= n）</p>
<h3 id="线程的资源共享">线程的资源共享</h3>
<ul>
<li><strong>共享</strong>
<ul>
<li>进程的虚拟地址空间</li>
</ul></li>
<li><strong>独立</strong></li>
<li>栈</li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=GQ08vKVgY2Y">视频讲解：对于用户级线程和内核级线程之间通俗易懂的区分理解</a></p>
<p>用户级线程是代码逻辑的载体</p>
<p>内核级线程是运行机会的载体</p>
<h2 id="线程的控制">线程的控制</h2>
<h3 id="线程的状态转换">线程的状态转换</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e6d1dffd0f032fad3344ef0d3f3f09a.png" /></p>
<h3 id="线程的组织与控制">线程的组织与控制</h3>
<p><a
href="https://www.youtube.com/watch?v=PRgkXeFsueM">视频讲解：线程的组织与控制</a></p>
<p>将TCB组织成线程表进行管理</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/73fa1304e03b0f97ed8423bd341c965.png" /></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.2处理机调度</title>
    <url>/posts/20ce47b7.html</url>
    <content><![CDATA[<h2 id="调度的概念层次">调度的概念、层次</h2>
<span id="more"></span>
<h3 id="调度的概念">调度的概念</h3>
<p>在处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<p><strong>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</strong></p>
<h3 id="调度的层次">调度的层次</h3>
<p><a
href="https://www.youtube.com/watch?v=pTGz9jJv560">视频讲解：三种调度层次</a></p>
<h4 id="作业调度高级调度">作业调度（高级调度）</h4>
<p>按照一定原则从外村上处于后备队列的作业中选择一个（或多个），给它分配内存等必要资源，并<strong>建立相应的进程（建立PCB）</strong>，以使它获得<strong>竞争处理机资源的权利</strong>。</p>
<p>作业调度是外存和内存之间的调度。每个作业只调入一次、调出一次。作业调度时建立相应的PCB；作业调出时撤销相应的PCB。</p>
<h4 id="内存调度中级调度">内存调度（中级调度）</h4>
<p>可以将暂时不能运行的进程调入外存等待。这些进程会进入“<strong>挂起状态</strong>”，其PCB仍然<strong>常驻在内存</strong>，被放入到挂起队列中。其目的是<strong>提高内存利用率和系统吞吐量</strong>。</p>
<p><strong>通过中级调度来决定将哪个处于挂起状态的进程重新调入内存中</strong>。</p>
<h4 id="进程调度低级调度">进程调度（低级调度）</h4>
<p>按照某种方法和策略从就绪队列中选择一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>。其<strong>频率很高</strong>，一般几十毫秒一次。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">调度发生在</th>
<th style="text-align: center;">进程状态变化</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">高级调度</td>
<td style="text-align: center;">外存→内存（面向作业）</td>
<td style="text-align: center;">无→创建态→就绪态</td>
</tr>
<tr class="even">
<td style="text-align: center;">中级调度</td>
<td style="text-align: center;">外存→内存（面向进程）</td>
<td style="text-align: center;">挂起态→就绪态（阻塞挂起→阻塞态）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">低级调度</td>
<td style="text-align: center;">内存→CPU</td>
<td style="text-align: center;">就绪态→挂起态</td>
</tr>
</tbody>
</table>
<h2 id="调度的时机切换与过程">调度的时机、切换与过程</h2>
<h3 id="调度器调度程序">调度器/调度程序</h3>
<p>就绪态与运行态之间的相互切换由调度程序引起并决定。</p>
<ul>
<li><p>让谁运行：调度程序</p></li>
<li><p>运行多久：时间片大小</p></li>
</ul>
<h3 id="进程调度的时机">进程调度的时机</h3>
<p><a
href="https://www.youtube.com/watch?v=LV5eOKoPZAg">视频讲解：进程调度的时机</a></p>
<h4 id="需要进行进程调度的情况">需要进行进程调度的情况</h4>
<ul>
<li><p>当前进程<strong>主动</strong>放弃处理机资源</p>
<ul>
<li><p>进程正常中止</p></li>
<li><p>进程出现异常终止</p></li>
<li><p>进程主动请求阻塞</p></li>
</ul></li>
<li><p>当前进程<strong>被动</strong>放弃处理机资源</p>
<ul>
<li><p>分配的时间片用完</p></li>
<li><p>有更紧急的事件要处理（如I/O中断）</p></li>
<li><p>有更高优先级的进程进入就绪队列</p></li>
</ul></li>
</ul>
<h4 id="不能进行进程调度与切换的情况">不能进行进程调度与切换的情况</h4>
<ul>
<li><p>在处理中断的过程中</p></li>
<li><p>进程处于<strong>操作系统内核程序临界区</strong>中(<a
href="https://www.youtube.com/watch?v=sYQWdEkMfLI">视频讲解：</a>)</p></li>
<li><p>在进行原子操作的过程中（<strong>原语</strong>）。</p></li>
</ul>
<p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要<strong>互斥地</strong>访问临界资源。</p>
<p><strong>临界区</strong>：访问临界资源的那段代码。</p>
<p><strong>内核程序临界区</strong>：一般是用于访问<strong>内核数据结构</strong>的，例如进程的就绪队列。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<h4 id="非剥夺调度方式非抢占方式">非剥夺调度方式（非抢占方式）</h4>
<p>只允许进程主动放弃处理机资源。即便有更高优先级的任务到达，也要等待当前进程主动终止或进入阻塞态。</p>
<ul>
<li><p>实现简单，系统开销小</p></li>
<li><p>无法及时处理紧急任务</p></li>
</ul>
<h4 id="剥夺调度方式抢占方式">剥夺调度方式（抢占方式）</h4>
<p>当有更重要的任务需要使用处理机时，立即暂停当前正在执行的进程，将处理机资源给更紧迫的任务。</p>
<ul>
<li><p>可以优先处理更紧急的任务</p></li>
<li><p>可以让各进程按照时间片轮流执行</p></li>
<li><p>适用于分时操作系统、实时操作系统</p></li>
</ul>
<h3 id="进程的切换与过程">进程的切换与过程</h3>
<h4 id="狭义的进程调度与进程切换">狭义的进程调度与进程切换</h4>
<p><strong>狭义的进程调度</strong>：从就绪队列中<strong>选中一个要运行的进程</strong>。这个进程可以是刚刚被暂停执行的进程，也可以是<strong>另一个进程</strong>，后者就需要<strong>进程切换</strong>。</p>
<p><strong>进程切换</strong>：一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p><strong>广义的进程调度</strong>包含了选择进程和进程切换两个步骤。</p>
<h4 id="进程切换中实现了什么">进程切换中实现了什么</h4>
<ul>
<li><p>对原来进程的各种数据进行保存</p></li>
<li><p>对新的进程进行各种数据的恢复</p></li>
</ul>
<p><strong>进程的切换是有代价的</strong>，过于频繁的进行进程的调度、切换会使得操作系统的效率降低。</p>
<h3 id="闲逛进程">闲逛进程</h3>
<p>用于占位</p>
<ul>
<li><p>优先级最低</p></li>
<li><p>是0地址指令，在指令周期末尾检查中断</p></li>
</ul>
<h2 id="进程调度的基本准则">进程调度的基本准则</h2>
<h3 id="cpu利用率">CPU利用率</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425164409300.png" /></p>
<p>设备利用率同理</p>
<h3 id="系统吞吐量">系统吞吐量</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165100390.png" /></p>
<h3 id="周转时间">周转时间</h3>
<p>周转时间，是指从<strong>作业提交给系统开始</strong>，到<strong>作业完成</strong>这段时间的时间间隔。包括作业等待、在就绪队列中排队、在处理机上运行、进行输入/输出操作所所花费时间的总和。</p>
<p><a
href="https://www.youtube.com/watch?v=ieKNXj3rNvY">视频讲解：理解带权周转时间</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165120693.png" /></p>
<ul>
<li><p>带权周转时间必然≥1</p></li>
<li><p>带权周转时间越小越好</p></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165344124.png" /></p>
<h3 id="等待时间">等待时间</h3>
<p>等待时间，指的是进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业等待I/O设备的时间进程也在被服务，不计入等待时间。</p>
<p>还要加上作业在外存后备队列中等待被调度的时间。</p>
<h3 id="响应时间">响应时间</h3>
<p>响应时间，指从用户<strong>提交请求</strong>到<strong>首次响应</strong>所用的时间。</p>
<hr style = "border:2px solid yellow">
<p>举例：计算平均周转时间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d9f720a0b78ee940bbcef234991fcb6.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6fc3041edc7f61329731803a114b288.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Kz421f7SF/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="典型的调度算法">典型的调度算法</h2>
<p><strong>饥饿</strong>：某个进程/作业长期得不到服务</p>
<h3
id="先来先服务调度算法fcfsfirst-come-first-serve">先来先服务调度算法（FCFS，First
Come First Serve)</h3>
<h4 id="算法思想">算法思想</h4>
<p>主要从“公平”的角度考虑</p>
<h4 id="作业规则">作业规则</h4>
<p>按照作业/进程到达的先后顺序进行服务，即<strong>等待时间</strong>越久的进程/作业越优先得到服务</p>
<h4 id="用于作业进程调度">用于作业/进程调度</h4>
<p>用于作业调度时，考虑的是哪个作业<strong>先到达后备队列</strong>；</p>
<p>用于进程调度时，考虑的是哪个进程<strong>先到达就绪队列</strong></p>
<h4 id="是否可抢占">是否可抢占</h4>
<p>非抢占式算法</p>
<h4 id="优缺点">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>公平</p></li>
<li><p>算法实现简单</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>排在长作业后的短作业需要等待很长的时间，<strong>带权周转时间</strong>很大</li>
</ul></li>
</ul>
<p>即：<strong><em>FCFS对长作业有利，对短作业不利</em></strong></p>
<p><a href="">视频讲解：缺点的感性理解，带权时间大</a></p>
<h4 id="是否会导致饥饿">是否会导致饥饿</h4>
<p>不会</p>
<h3
id="短作业优先调度算法sjfshortest-job-first">短作业优先调度算法（SJF，Shortest
Job First)</h3>
<h4 id="算法思想-1">算法思想</h4>
<p>追求最少的<strong>平均等待时间</strong>，最少的<strong>平均周转时间</strong>、最少的<strong>平均带权周转时间</strong></p>
<h4 id="算法规则">算法规则</h4>
<p>最短的作业/进程优先得到服务</p>
<h4 id="用于作业进程调度-1">用于作业/进程调度</h4>
<p>既可用于作业调度，也可用于进程调度。用于进程调度时称为<strong>短进程优先（SPF,
Shortest Process First）算法</strong></p>
<h4 id="是否可抢占-1">是否可抢占</h4>
<p>SJF和SPF是非抢占式的算法，同时也有抢占式的<strong>最短剩余时间优先</strong>调度算法（SRTN，Shortest
Reamaining Time First Next）</p>
<p>调度的点：</p>
<ol type="1">
<li>就绪队列改变需要进行调度</li>
<li>进程完成时</li>
</ol>
<h4 id="优缺点-1">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li>“最短的”平均等待时间、平均周转时间</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>不公平</p></li>
<li><p>对短作业有利，对长作业不利</p></li>
<li><p>可能产生饥饿现象</p></li>
<li><p>作业/进程的运行时间是由用户提供的，不一定能做到真正的短作业优先</p></li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-1">是否会导致饥饿</h4>
<p>会</p>
<ol type="1">
<li><p>题目中未特别说明，短作业/进程优先算法默认是<strong>非抢占式</strong>的</p></li>
<li><p>SJF调度算法的平均等待时间、平均周转时间最少 ❌</p></li>
<li><p>在所有进程<strong>同时到达</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少
✔</p></li>
<li><p><strong>抢占式的</strong>短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少
✔</p></li>
<li><p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法(如FCFS)，SJF依然可以获得<strong>较少</strong>的平均等待时间、平均周转时间</p></li>
<li><p>如果选择题中遇到
“SJF算法的平均等待时间、平均周转时间<strong>最</strong>少”
的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p></li>
</ol>
<h3 id="高响应比优先">高响应比优先</h3>
<h4 id="算法思想-2">算法思想</h4>
<p>要综合考虑作业/进程的等待时间和要求服务的时间</p>
<h4 id="算法规则-1">算法规则</h4>
<p>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务</p>
<p>响应比=等待时间+要求服务时间要求服务时间响应比=要求服务时间等待时间+要求服务时间</p>
<h4 id="是否可抢占-2">是否可抢占</h4>
<p>非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
<h4 id="优缺点-2">优缺点</h4>
<ul>
<li><p>综合考虑了等待时间和运行时间（要求服务时间）</p>
<ul>
<li><p>等待时间相同时，要求服务时间短的优先</p></li>
<li><p>要求服务时间相同时，等待时间长的优先</p></li>
</ul></li>
<li><p>对于长作业而言，等待时间越长响应比越高，避免了饥饿问题</p></li>
</ul>
<h4 id="是否会导致饥饿-2">是否会导致饥饿</h4>
<p>不会</p>
<h3
id="时间片轮转调度算法rrround-robin">时间片轮转调度算法（RR，Round-Robin）</h3>
<h4 id="算法思想-3">算法思想</h4>
<p>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</p>
<h4 id="算法规则-2">算法规则</h4>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。若进程未在一个时间片内执行完，
则剥夺处理机，将进程放到就绪队列队尾重新排队。</p>
<h4 id="用于作业进程调度-2">用于作业/进程调度</h4>
<p>用于<strong>进程调度</strong>（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p>
<h4 id="是否可抢占-3">是否可抢占</h4>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用
权，因此时间片轮转调度算法<strong>属于抢占式的算法</strong>。由时钟装置发出时钟中断来通知CPU时间片已到。</p>
<h4 id="优缺点-3">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>公平</p></li>
<li><p>响应快</p></li>
<li><p>适用于分时操作系统</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>高频率的进程调度会有一定的开销</p></li>
<li><p>不能区分任务的紧急程度</p></li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-3">是否会导致饥饿</h4>
<p>不会</p>
<p>时间片太大：每个进程在一个时间片内完成，退化成先来先服务调度算法，增大进程响应时间</p>
<p>时间片太小：频繁的进程切换会造成较大的系统开销，导致实际用于进程执行的时间减少</p>
<h3 id="优先级调度算法">优先级调度算法</h3>
<h4 id="算法思想-4">算法思想</h4>
<p>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据<strong>任务的紧急程度</strong>来决定处理顺序。</p>
<h4 id="算法规则-3">算法规则</h4>
<p>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。</p>
<h4 id="用于作业进程调度-3">用于作业/进程调度</h4>
<p>既可用于作业调度，也可用于进程调度，还可用于I/O调度中。</p>
<h4 id="是否可抢占-4">是否可抢占</h4>
<ul>
<li><p>非剥夺式优先级调度算法：在进程主动放弃处理机时进行调度（非抢占的）</p></li>
<li><p>剥夺式优先级调度算法：还需要在就绪队列变化时，检查是否会发生抢占（抢占的）</p></li>
</ul>
<h4 id="优缺点-4">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>用优先级区分紧急程度、重要程度</p></li>
<li><p>适用于实时操作系统</p></li>
<li><p>可以灵活的调整各种作业、进程的偏好程度</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>若不断地有高优先级进程到来，可能会导致饥饿</li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-4">是否会导致饥饿</h4>
<p>会</p>
<p>静态优先级：进程创建时确定优先级，一直不变</p>
<p>动态优先级：创建进程时有一个初始值，之后视情况动态的调整优先级</p>
<ul>
<li><p>系统进程优先级高于用户进程</p></li>
<li><p>前台进程优先级高于后台进程</p></li>
<li><p>操作系统更偏好I/O型进程</p></li>
</ul>
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<h4 id="算法规则-4">算法规则：</h4>
<ul>
<li><p>将进程划分为多个队列，例如系统进程、交互式进程、批处理进程......</p></li>
<li><p>进程创建成功后插入到某个队列中</p></li>
<li><p><strong>队列之间</strong></p>
<ul>
<li><p>固定优先级：高优先级队列空时低优先级才能被调度</p></li>
<li><p>时间片划分：各自分配不同百分比的时间片</p></li>
</ul></li>
<li><p><strong>队列内部</strong>：不同的队列可以采取不同的调度策略</p></li>
</ul>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<h4 id="算法思想-5">算法思想</h4>
<p>对其他调度算法的折中权衡</p>
<h4 id="算法规则-5">算法规则</h4>
<ol type="1">
<li><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p></li>
<li><p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</p></li>
<li><p>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p></li>
</ol>
<h4 id="用于作业进程调度-4">用于作业/进程调度</h4>
<p>用于进程调度</p>
<h4 id="是否可抢占-5">是否可抢占</h4>
<p><strong>抢占式的算法</strong>。在k级队列的进程运行过程中，若更上级的队列
(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
<h4 id="优缺点-5">优缺点</h4>
<ul>
<li><p>对各类型进程相对公平（FCFS的优点）；</p></li>
<li><p>每个新到达的进程都可以很快就得到响应（RR的优点）；</p></li>
<li><p>短进程只用较少的时间就可完成非（SPF的优点）；</p></li>
<li><p>不必实现估计进程的运行时间（避免用户作假）；</p></li>
<li><p>可以灵活的调整对各类进程的偏好程度</p></li>
</ul>
<h4 id="是否会导致饥饿-5">是否会导致饥饿</h4>
<p>会</p>
<h2 id="上下文及其切换机制">上下文及其切换机制</h2>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F404566827-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MclRScjG6Fe8bjSwneh%2Fuploads%2Fgit-blob-416341e56f1924562a41de7f421bb4b298c221e0%2F%E4%B8%8A%E4%B8%8B%E6%96%87.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=8accd47a8d6b1dddb73fc221783b4b9048eaea55f1dd8086de7d9a46444bf743"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>红色部分</strong>是进程/线程切换时需要保存/恢复的上下文</p>
<h3 id="进程的上下文切换">进程的上下文切换</h3>
<p>进程切换导致的地址空间代价巨大：</p>
<ul>
<li><p>保存/恢复页表寄存器</p></li>
<li><p>TLB全部失效</p></li>
<li><p>Cache全部失效，有可能需要Cache写回</p></li>
<li><p>新进程运行初期可能缺页率高，需要I/O操作</p></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.4死锁</title>
    <url>/posts/fd66707b.html</url>
    <content><![CDATA[<h2 id="死锁的概念">死锁的概念</h2>
<span id="more"></span>
<h3 id="死锁的定义">死锁的定义</h3>
<p>在并发环境下，各进程因竞争资源而造成的一种<strong>相互等待对方手里的资源</strong>，导致这些进程均阻塞。若没有外力干涉，这些进程都无法继续前进。</p>
<p><strong>死锁</strong>：<font color = "red">互相等待对方手里的资源，导致各进程都阻塞</font>，无法前进的现象</p>
<p><strong>饥饿</strong>：由于长期得不到资源，<font color = "red">某进程一直得不到处理机</font>的现象</p>
<p><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象</p>
<hr style = "border:2px solid yellow">
<p>举例：资源的极限分配</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9d187b29f91f2e86a2b8d95923006f6.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<p>死锁的产生，以下四个条件缺一不可：</p>
<ol type="1">
<li><strong>互斥条件</strong>：只有对互斥资源的争抢才可能导致死锁；</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，<strong>不能由其他进程强行夺走</strong>，只能主动释放；</li>
<li><strong>请求和保持条件</strong>：进程<strong>已经占用了至少一个资源</strong>，同时又提出了新的资源请求，而所<strong>请求的资源被其他进程所占用</strong>，此时请求被阻塞，但是该进程<strong>仍然保持已有的资源不放</strong>；</li>
<li><strong>循环等待条件</strong>：存在一种进程循环等待资源的现象，循环中的每一个进程已获得的资源同时被下一个进程所需求。</li>
</ol>
<p>概括：</p>
<p><font color = "yellow">1.
简称死不放手</font>拿到就不会轻易吐出来，哪怕自己需要的目前还达不到，已经拥有的也不会放弃</p>
<p><font color = "yellow">2.
简称肥水不往外流</font>一条循环等待链这个用完给下一个用</p>
<p>发生死锁时一定有循环等待，但发生循环等待时未必会死锁。</p>
<p>如果系统中还有其他同类型资源，则不会发生死锁；如果系统中每种资源只有一个，则将会发生死锁。</p>
<p>综上，可以有以下结论：</p>
<h4 id="死锁产生的原因">死锁产生的原因</h4>
<ol type="1">
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
</ol>
<h4 id="死锁的处理策略">死锁的处理策略</h4>
<ol type="1">
<li>死锁预防</li>
<li>避免死锁</li>
<li>死锁的检测及解除</li>
</ol>
<h2 id="死锁预防">死锁预防</h2>
<p>预防死锁的发生只需要<strong>破坏四个必要条件之一</strong>即可。</p>
<h3 id="破坏互斥条件">破坏互斥条件</h3>
<p>把只能互斥访问的资源变为共享资源。例如使用SPOOLing技术使得设备可以逻辑上共享。但是一般不常用。</p>
<h3 id="破坏不剥夺条件">破坏不剥夺条件</h3>
<p>一、当某个进程请求新的资源而得不到时，立刻释放其已有资源，以待后面再次申请；</p>
<p>二、为进程设置不同的优先级，当某个进程需要的资源被其他进程占用时，可以由操作系统协作将想要的资源强行剥夺。</p>
<h4 id="缺点">缺点：</h4>
<ul>
<li>实现起来较为复杂；</li>
<li>这种方式会造成前一阶段工作的失效，因此仅适用于易保存和恢复的资源，例如CPU；</li>
<li>反复申请和释放资源会造成较大的系统开销；</li>
<li>若采用方案一，可能导致饥饿（某个进程一直被迫放弃已有的资源）。</li>
</ul>
<h3 id="破坏请求和保持条件">破坏请求和保持条件</h3>
<p>采用<strong>静态分配方法</strong>，在运行前一次性申请所需的全部资源，在未获得全部资源前进程不投入运行。一旦投入运行，这些资源一直归此进程所有。</p>
<h4 id="缺点-1">缺点：</h4>
<ul>
<li>对于使用时间很短的资源会造成资源浪费，资源利用率低；</li>
<li>有可能导致某些进程饥饿。</li>
</ul>
<h3 id="破坏循环等待条件">破坏循环等待条件</h3>
<p>采用<strong>顺序资源分配法</strong>，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<h4 id="缺点-2">缺点：</h4>
<ul>
<li>不方便增加新的系统资源，有可能需要全部重新分配序号；</li>
<li>进程实际使用资源的顺序可能与序号不一致，会造成资源浪费；</li>
<li>必须依次申请资源，编程麻烦。</li>
</ul>
<h2 id="死锁避免">死锁避免</h2>
<h3
id="安全序列不安全状态死锁的联系">安全序列、不安全状态、死锁的联系</h3>
<p><strong>安全序列</strong>：如果系统按照这种序列分配资源，则每个进程都能顺利完成。</p>
<p><strong>安全状态</strong>：只要能找出一个安全序列，系统就是安全状态。安全序列可能有多个。</p>
<p><strong>不安全状态</strong>：如果分配了资源之后，系统中<strong>找不出任何一个安全序列</strong>，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。</p>
<p>如果有进程<strong>提前归还</strong>了一些资源，系统也有可能重新回到<strong>安全状态</strong>。</p>
<h4 id="与死锁的联系">与死锁的联系</h4>
<ul>
<li>系统如果处于安全状态，则一定不会发生死锁；</li>
<li>系统如果处于不安全状态，则可能会发生死锁；</li>
<li>因此，可以通过提前判断是否会进入不安全状态来决定是否答应分配请求。</li>
</ul>
<h3 id="银行家算法">银行家算法</h3>
<h4 id="银行家算法的数据结构">银行家算法的数据结构</h4>
<ul>
<li>系统可用资源向量<code>Available[m]</code>：表示系统中每种资源的可用数量，该值随着资源分配与回收情况的变动而动态变化。<font color = "yellow">如果<code>Available[j] = K</code>，则说明在这个时刻，系统中有K个资源<span
class="math inline">\(R_j\)</span>可用。</font></li>
<li>最大需求矩阵<code>Max[n][m]</code>：表示系统中n个进程中每个进程对m类资源的最多可能请求数量。<font color = "yellow">如果<code>Max[i][j] = K</code>，则说明进程<span
class="math inline">\(P_i\)</span>在运行过程中需要资源<span
class="math inline">\(R_j\)</span>的最大数量是K个。</font></li>
<li>分配矩阵<code>Allocation[n][m]</code>
：表示当前每个进程占有的各类资源数量。<font color = "yellow">如果<code>Allocation[i][j] = K</code>，这说明进程<span
class="math inline">\(P_i\)</span>已经被分配了K个资源<span
class="math inline">\(R_j\)</span>。</font></li>
<li>需求矩阵<code>Need[n][m]</code>：表示进程完成任务需要的每种资源的数量。<font color = "yellow">如果<code>Need[i][j] = K</code>，则说明进程<span
class="math inline">\(P_i\)</span>还需要K个资源<span
class="math inline">\(R_j\)</span>来完成任务。</font></li>
</ul>
<p>上述三个矩阵存在以下恒等式：<font color = "yellow"><code>Need[i][j] = Max[i][j] - Allocation[i][j]</code></font></p>
<h4 id="银行家算法的思想">银行家算法的思想</h4>
<p>设<span class="math inline">\(Request_i\)</span>为进程<span
class="math inline">\(P_i\)</span>的请求向量，<font color = "yellow">如果<span
class="math inline">\(Request_i[j]=K\)</span>，则说明进程<span
class="math inline">\(P_i\)</span>需要<span
class="math inline">\(K\)</span>个<span
class="math inline">\(R_j\)</span>类型的资源</font>。当<span
class="math inline">\(P_i\)</span>请求一个资源时，系统进行以下检查：</p>
<ol type="1">
<li><p>如果<span class="math inline">\(Request_i\leq
Need[i][j]\)</span>，则进入步骤2；否则请求失败，因为进程所需要的资源数量已经超过了它所申报的最大需求数量；</p></li>
<li><p>如果<span class="math inline">\(Request_i\leq
Available[j]\)</span>，则进入步骤3；否则说明系统还没有足够的资源储备，进程<span
class="math inline">\(P_i\)</span>必须等待；</p></li>
<li><p>系统试图，并更新以下数据结构中的值：</p>
<p>概括：<font color = "yellow">(1)对应可用资源的数量减少
(2)分配的对应资源的数量增加 (3)还需要对应的资源减少</font> <span
class="math display">\[
Available[j]=Available[j]-Request_i[j]\\
Allocation[i][j]=Allocation[i][j]+Request_i[j]\\
Need[i][j] = need[i][j]-Request_i[j]
\]</span></p></li>
<li><p>系统通过安全性算法检查为该进程分配资源后，是否仍处于安全状态。如果系统是安全的，资源就被正式分配给进程<span
class="math inline">\(P_i\)</span>；否则，撤销分配，系统回退到原来的资源分配状态，并让进程<span
class="math inline">\(P_i\)</span>继续等待。</p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例： Available=(3, 3, 2)，判断系统的安全性</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">进程</th>
<th style="text-align: center;">最大需求</th>
<th style="text-align: center;">已分配</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P0</td>
<td style="text-align: center;">(7, 5, 3)</td>
<td style="text-align: center;">(0, 1, 0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">P1</td>
<td style="text-align: center;">(3, 2, 2)</td>
<td style="text-align: center;">(2, 0, 0)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P2</td>
<td style="text-align: center;">(9, 0, 2)</td>
<td style="text-align: center;">(3, 0, 2)</td>
</tr>
<tr class="even">
<td style="text-align: center;">P3</td>
<td style="text-align: center;">(2, 2, 2)</td>
<td style="text-align: center;">(2, 1, 1)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P4</td>
<td style="text-align: center;">(4, 3, 3)</td>
<td style="text-align: center;">(0, 0, 2)</td>
</tr>
</tbody>
</table>
<p>由上可知，</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409103846600.png" /></p>
<p>接下来，将Available与Need各行进行比较，找到Need中比Available小的一行（对应元素都要小），将该进程加入安全序列，释放该进程的资源，得到新的矩阵和Available。</p>
<p>例如，将进程P1的资源释放，则得到：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409103927537.png" /></p>
<p>接下来重复以上步骤即可。</p>
<hr style = "border:2px solid yellow">
<h2 id="死锁的检测和解除">死锁的检测和解除</h2>
<p>为了能对系统是否已发生了死锁进行检测，必须：</p>
<ol type="1">
<li>用某种数据结构来保存资源的请求和分配信息；</li>
<li>提供一种算法， 利用上述信息来检测系统是否已进入死锁状态。</li>
</ol>
<h3 id="资源分配图">资源分配图</h3>
<h4 id="结构">结构：</h4>
<ul>
<li>两种结点
<ul>
<li>进程结点：对应一个进程</li>
<li>资源结点：对应<strong>一类</strong>资源（可能有多个）</li>
</ul></li>
<li>两种边
<ul>
<li>进程结点 --&gt; 资源结点：进程对资源的申请（每条边代表一个）</li>
<li>资源节点 --&gt;
进程结点：已经为进程分配了资源（每条边代表一个）</li>
</ul></li>
<li><strong>环路</strong>
<ul>
<li>若出现环路，意味着满足了循环等待条件，可能存在死锁</li>
<li>若不存在环路，破坏了循环等待条件，必定不存在死锁</li>
</ul></li>
</ul>
<h3 id="死锁定理">死锁定理</h3>
<ol type="1">
<li>在资源分配图中，找到既不阻塞也不是孤点的进程
Pi，消去他所有的请求边和分配边；</li>
<li>再找到下一个可以消去所有请求和分配的进程；</li>
<li>若能消去图中的所有边，则称该图是<strong>可完全简化</strong>的。</li>
</ol>
<p><a
href="https://www.bilibili.com/video/BV1eT4y1F7Yx/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><strong>死锁定理：</strong></p>
<p>系统会发生死锁的条件是<strong>当且仅当系统状态的资源分配图是不可完全简化的</strong>。</p>
<p>死锁定理<strong>不需要</strong>全部的进程运行所需资源信息。</p>
<h3 id="死锁的解除">死锁的解除</h3>
<p><strong>在化简资源分配图后，还有边连接的进程就是死锁进程</strong>。对于死锁的进程，需要解除死锁。</p>
<ol type="1">
<li><strong>资源剥夺法</strong>：挂起某些死锁进程（暂存到外存上），抢占其资源并分配给其他死锁的进程。需要注意防止被挂起进程产生饥饿；</li>
<li><strong>撤销进程法（终止进程法）</strong>：强制撤销部分甚至全部死锁进程并释放其资源。优点是实现简单，缺点是会导致进程之前的努力全部木大；</li>
<li><strong>进程回退法</strong>：让一个或多个进程回退到可以避免死锁的地步。需要系统记录进程的历史信息并设置还原点。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.3同步与互斥</title>
    <url>/posts/b30fed39.html</url>
    <content><![CDATA[<h1 id="进程同步">进程同步</h1>
<span id="more"></span>
<h2 id="进程同步的基本概念">进程同步的基本概念</h2>
<p>进程同步的任务是采取有效措施来管理多个进程的运行，避免进程不受控制地争夺系统资源而导致混乱局面的出现——每个进程的运行结果存在不可再现性，以及程序的执行存在不确定性。</p>
<p>举例</p>
<p>题1：为什么需要进程同步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/52688d13cae644c1b6933db5f00727f.jpg" /></p>
<p>选C：</p>
<p>因为进程同步的是管理多个程序运行，而这些进程都是异步的</p>
<p>题2：进程之间的关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4262ad18f0462b3266be5527e1d9164.jpg" /></p>
<p>进程B必须在A写入后才能读取，体现互斥（进程之间争夺互斥资源产生的制约）</p>
<p>进程B和A存在数据交换，体现同步（进程之间需要交换信息和，相互等待而产生的制约）</p>
<h2 id="临界资源与临界区">临界资源与临界区</h2>
<h4 id="临界资源">临界资源</h4>
<p>同一时刻只能由一个进程使用的资源称为临界资源。</p>
<h4 id="临界区">临界区</h4>
<p>程序中访问临界资源的那一部分代码称为临界区。</p>
<p>举例：临界区的定义</p>
<p>一个系统中共有5个并发进程涉及某个相同的变量A，变量A的相关临界区是由<font color = "red">5</font>个临界区构成</p>
<p>进程的运行是异步并发的，为了避免与推进顺序有关的错误，进程必须互斥访问临界区，来获得临界资源的使用权。</p>
<p>对临界资源的访问的正确使用，可把临界资源的访问过程分为4个部分：</p>
<ol type="1">
<li>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>临界区。进程中访问临界资源的那段代码，又称临界段。</li>
<li>退出区。将正在访问临界区的标志清除。</li>
<li>剩余区。代码中的其余部分。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    进入区;</span><br><span class="line">    临界区;</span><br><span class="line">    退出区;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<hr style = "border:2px solid yellow;">
<p>题1：临界区和临界资源的判断</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9a235df8ff1b692ca5d0da913b7ccc1.jpg" /></p>
<p>临界资源是互斥共享，一次只能给一个进程使用</p>
<hr style = "border:2px solid yellow;">
<p>题2：临界资源与互斥</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0d5463069e1401cbaffa89d9cf7a9b0.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1v1421D74W/?spm_id_from=333.1007.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<ol type="1">
<li>共享资源,是共享资源就要互斥，不是就不用</li>
<li>不同进程之间互不影响</li>
</ol>
<hr style = "border:2px solid yellow;">
<h2 id="同步与互斥">同步与互斥</h2>
<p>进程同步机制的主要任务是<font color = "red">协调几个相互协作的进程的执行顺序</font>，使并发执行的进程能够<font color = "red">共享系统资源</font>，并按照一定的规则相互制约，保证程序按序执行。</p>
<h4 id="互斥关系">互斥关系</h4>
<p>互斥关系，又称进程的<strong>间接相互制约关系(程序-资源-程序模式)</strong>。当一个进程进入临界区使用临界资源时，另
一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<h4 id="同步关系">同步关系</h4>
<p>同步关系，又称进程的<strong>直接相互制约关系(程序-程序模式)</strong>。指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p>
<blockquote>
<p>💡在多道程序环境中，由于互斥和同步这两种制约关系的存在，进程在执行过程中，是否能获得处理器以及以何种速度向前推进，并不由进程本身控制，这也就是进程的异步性。这可能导致进程以不正确的顺序访问共享资源，也可能造成进程每次的运行结果不一致。这些错误往往与时间有关，因此称为“时间相关的错误”。为了防止此类错误，必须协调进程的执行顺序，确保它们按顺序执行。</p>
</blockquote>
<h2 id="同步互斥机制设计准则">同步/互斥机制设计准则</h2>
<h4 id="空闲让进必须实现">空闲让进(必须实现)</h4>
<p><font color = "yellow">允许访问空闲临界资源</font></p>
<h4 id="忙则等待必须实现">忙则等待(必须实现)</h4>
<p><font color = "yellow">两个进程不能同时进入临界区</font></p>
<h4 id="有限等待必须实现">有限等待(必须实现)</h4>
<p><font color = "yellow">进程进入临界区等待时间有限</font></p>
<h4
id="让权等待可以不实现比如peterson方法">让权等待(可以不实现，比如Peterson方法)</h4>
<p><font color = "yellow">不能进入临界区的进程立即放弃CPU</font></p>
<hr style = "border:2px solid yellow;">
<p>举例：对同步/互斥设计准则的理解</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/27c6a73cf98872fb9c87ae7911af464.jpg" /></p>
<p>解析：</p>
<p>1：体现了忙则等待</p>
<p>2：体现了空闲让进</p>
<p>3：体现了有限等待</p>
<p>4：体现了让权等待</p>
<hr style = "border:2px solid yellow;">
<h2 id="实现临界区互斥的基本方法">实现临界区互斥的基本方法</h2>
<h3 id="软件同步机制">软件同步机制</h3>
<p>有以下几种软件方法可以实现临界区的互斥：</p>
<ol type="1">
<li>设置共享变量<code>turn</code>，让进程轮流进入临界区(单标志法)，轮到的进程能进入临界区</li>
<li>用整形数组<code>flag</code>进行标记(双标志法)，进程检查其余进程是否希望进入临界区，若没有其他进程希望进入临界区，则该进程能进入临界区</li>
<li>将前两种方式结合起来使用的<code>Peterson算法</code></li>
</ol>
<h4 id="单标志法">单标志法</h4>
<p>考虑在程序中设置一个共享的整形变量标志<code>turn</code>，表示程序进入临界区的权限，可以取值为0或1。</p>
<p>当<code>turn</code>取值为0时，进程<span
class="math inline">\(P_0\)</span>可以进入临界区；取值为1时，进程<span
class="math inline">\(P_1\)</span>可以进入临界区。</p>
<p>当进程<span
class="math inline">\(P_0\)</span>退出临界区时，将<code>turn</code>置为1；当进程<span
class="math inline">\(P_1\)</span>退出临界区时，将<code>turn</code>置为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程P0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//若turn等于本进程编号，准入</span></span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">0</span>);<span class="comment">//一直循环到turn=0</span></span><br><span class="line">    临界区;<span class="comment">//调用共享变量的代码</span></span><br><span class="line">    turn = <span class="number">1</span>;<span class="comment">//准许对方进入临界区</span></span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//若turn等于本进程编号，准入</span></span><br><span class="line">    <span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">    临界区;</span><br><span class="line">    turn = <span class="number">0</span>;<span class="comment">//准许对方进入临界区</span></span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法只适用于进程交替进入临界区的情况，违背了<strong>空闲让进</strong>准则。(因为如果空闲，且又没有turn=0或1的进程，会陷入死循环)</p>
<h4 id="双标志先检查法">双标志先检查法</h4>
<p>双标志先检查法将共享变量<code>turn</code>改为整型数组<code>flag[2]</code>，进程<span
class="math inline">\(P_i\)</span>在进入临界区前，将<code>flag[i]</code>置为1，表示其正在使用临界资源，退出后将<code>flag[i]</code>置为0，表示其已经退出临界区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag[j]);		<span class="comment">//检查对方进程是否在使用临界资源</span></span><br><span class="line">    flag[i] = <span class="number">1</span>;		<span class="comment">//表示本进程已进入临界区</span></span><br><span class="line">    临界区;</span><br><span class="line">    flag[i] = <span class="number">0</span>;		<span class="comment">//表示本进程已退出临界区</span></span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双标志先检查法相对于单标志法，满足了空闲让进的准则，但是不能保证进程对临界资源的互斥使用，违背了<strong>忙则等待</strong>准则。</p>
<h4 id="双标志后检查法">双标志后检查法</h4>
<p>双标志后检查法调整了赋值语句<code>flag[i] = 1</code>和<code>while</code>所在的标志检测语句的顺序，先设置标志，再进行准入检测，避免了两个进程同时进入临界区的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    flag[i] = <span class="number">1</span>;	<span class="comment">//先将本进程flag修改为1，表示需要使用临界资源</span></span><br><span class="line">    <span class="keyword">while</span>(flag[j]);	<span class="comment">//等待其他进程使用临界资源完毕</span></span><br><span class="line">    临界区;</span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双标志后检查法能保证不同进程不能同时进入临界区，但是违背了<strong>有限等待</strong>准则。</p>
<p>两个进程几乎同时都想进入临界区时，它们分别将自己的标志值<code>flag</code>设置为1，并且同时检测对方的状态，发现对方也要进入临界区时，<font color = "red">双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</font></p>
<h4 id="peterson算法">Peterson算法</h4>
<p>Peterson算法将单标志法和双标志后检查法结合起来</p>
<p>既<font color = "red">设置<code>flag</code>标志，用于表明进程是否希望进入临界区，</font></p>
<p>又<font color = "red">设置共享变量<code>turn</code>，用于规定进程进入临界区的顺序。</font></p>
<p>在进入临界区前，进程<span
class="math inline">\(P_i\)</span>既检查另一个进程<span
class="math inline">\(P_j\)</span>的标志<code>flag[j]</code>，又检查共享变量<code>turn</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    flag[i] = <span class="number">1</span>;		<span class="comment">//flag[i]置为1，表示本进程希望进入临界区</span></span><br><span class="line">    turn = j;			<span class="comment">//将turn设置为对方编号(礼让)</span></span><br><span class="line">    <span class="keyword">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class="line">    <span class="comment">//只要flag[j]为0(进程j无意进入临界区)</span></span><br><span class="line">    <span class="comment">//或turn为i(轮到进程i)就可以进入临界区</span></span><br><span class="line">    临界区;</span><br><span class="line">    flag[i] = <span class="number">0</span>;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Peterson算法满足互斥、空闲让进、有限等待。</p>
<details>
<summary>
互斥条件：
</summary>
假设进程P<sub>i</sub>和进程P<sub>j</sub>都通过了进入区，而没有达到剩余区，由于<code>flag[i]=flag[j]=1</code>，<code>turn=i</code>且<code>turn=j</code>，i和j不相等，两个进程无法同时进入临界区，实现了对临界资源的互斥使用。
</details>
<details>
<summary>
空闲让进条件：
</summary>
假设进程P<sub>j</sub>不打算进入临界区，那么<code>flag[j]=0</code>，进程P<sub>i</sub>能直接跳出<code>while(flag[j]&amp;&amp;flag==j)</code>语句的循环过程，不会造成单标志法的"有空不让进"的局面。<br>
又假设进程P<sub>i</sub>、P<sub>j</sub>都希望进入临界区，那么turn就发挥作用了，轮到哪个进程，哪个进程就能进入临界区。
</details>
<details>
<summary>
有限等待条件：
</summary>
假设进程P<sub>j</sub>在临界区内，而进程P<sub>i</sub>因执行while循环而等待，<code>turn</code>已经被进程P<sub>i</sub>设置为j，而在P<sub>j</sub>退出临界区后，会把<code>flag[i]</code>设置为0。所以在P<sub>j</sub>退出临界区后，P<sub>i</sub>必然能进入临界区。<br>
临界区代码的执行时间一般是有限的，故Peterson算法满足有限等待。
</details>
<p>Peterson算法的缺点在于只能处理两个进程之间的临界区问题，但是实际问题通常不止两个并发进程，因此需要信号量机制和管程机制。此外，Peterson算法同样不满足让权等待。</p>
<h4 id="四种软件同步机制方法对比">四种软件同步机制方法对比</h4>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 55%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>简述</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单标志法</td>
<td>引入<code>turn</code>，循环检查直到<code>turn=本进程编号</code></td>
<td>只能交替进入，违背“空闲让进”</td>
</tr>
<tr class="even">
<td>双标志<b>先</b>检查法</td>
<td>引入<code>flag[2]</code>，先检查对方是否进入临界区</td>
<td>会同时进入，违背“忙则等待”</td>
</tr>
<tr class="odd">
<td>双标志<b>后</b>检查法</td>
<td>引入<code>flag[2]</code>，先设置自身<code>flag</code>，再检查</td>
<td>同时希望进入时违背“有限等待”</td>
</tr>
<tr class="even">
<td>Peterson算法</td>
<td>引入<code>turn</code>和<code>flag[2]</code>，进入临界区前检查两次</td>
<td>违背让权等待，不适用于多进程</td>
</tr>
</tbody>
</table>
<p>举例：Peterson算法的考察</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d8d62bc5a9e286b9f02538a34b01ad2.jpg" /></p>
<hr style = "border: 2px solid yellow;">
<h3 id="硬件同步机制">硬件同步机制</h3>
<h4 id="关中断方法">关中断方法</h4>
<blockquote>
<p>在单核环境中，多个进程不能并行执行，但调度器可以安排多个进程在处理器上穿插运行，避免造成竞争风险。</p>
</blockquote>
<p>可以通过关中断方法来解决临界区问题，如果在进入临界区之前禁用中断，并在退出临界区后重新启用，那么运行临界区代码的进程就不能被中断，确保在任何时候只有一个进程在执行临界区。如果一个进程在执行过程中需要进入临界区，它可以禁用中断并执行临界区代码，从而满足空闲让进要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    关中断;</span><br><span class="line">    临界区;</span><br><span class="line">    开中断;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关中断是实现互斥最简单的方法之一。</p>
<p>缺点：</p>
<ul>
<li>滥用关中断权会产生严重的后果，只适用于操作系统的内核进程，不适用于用户进程。</li>
<li>并发环境中关中断会限制程序交替运行，导致处理器时间被浪费，影响系统执行效率。</li>
<li>对多处理器环境不适用，除非对所有处理器统一关中断，否则，在一个处理器上关中断不能阻止进程在其他处理器上绕过中断指令，执行相同的临界区代码。</li>
</ul>
<h4 id="硬件指令代码">硬件指令代码</h4>
<blockquote>
<p>在处理临界区问题时，可以把<code>flag</code>看作一把锁，“锁开”对应进入，“锁关”对应等待，初始状态为“锁开”。</p>
<p>每个希望进入临界区的进程必须先测试锁的开与关，若“锁关”，则进程必须等待，若“锁开”，则进程必须立即对其锁定，防止其他进程进入临界区。</p>
<p>显然，为了防止几个进程同时测试一把锁的开与关，测试和解锁的操作必须是连续的原子操作，不能单独进行。</p>
</blockquote>
<h5
id="tsltestandsetlock指令"><strong>TSL(TestAndSetLock)指令</strong></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boolean <span class="title function_">TSL</span> <span class="params">(boolean *lock)</span> &#123;</span><br><span class="line">    boolean old = *lock;</span><br><span class="line">    *lock = TRUE;		<span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lock</code>变量的值为<code>FALSE</code>对应未上锁，<code>lock</code>变量的值为<code>TRUE</code>则对应上锁，<code>TSL</code>函数的返回值与<code>lock</code>变量的值相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> <span class="title function_">TSL</span><span class="params">(&amp;lock)</span>;</span><br><span class="line">   	临界区;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125;<span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>
<p>当<code>lock</code>变量的值为<code>FALSE</code>时，<code>TSL</code>函数才会返回<code>FALSE</code>，进程可以离开<code>while</code>循环体，并进入临界区，同时将<code>lock</code>变量的值设为<code>TRUE</code>。</p>
<p><code>TSL</code>指令满足<strong>空闲让进</strong>：当临界区空闲，<code>lock</code>变量的值一定为<code>FALSE</code>，<code>TSL</code>函数也会返回<code>FALSE</code>，由于<code>TSL</code>是硬件原子指令，其执行由硬件实现，一气呵成，不会有多个进程同时访问lock变量，必然只存在一个进程可以顺利离开<code>while</code>循环体。</p>
<h5 id="swap指令"><strong>Swap指令</strong></h5>
<p>该指令又称<strong>exchange指令</strong>，用于交换a和b中的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(boolean *a, boolean *b)</span> &#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每个临界资源，<code>Swap</code>指令为其设置一个全局布尔变量<code>lock</code>，其初值为<code>FALSE</code>。</p>
<p>在每个进程中还会设置一个局部布尔变量<code>key</code>，其初值为<code>TRUE</code>。</p>
<p>有进程在临界区时，重复交换和检查过程，直到临界区里的进程退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    key = TRUE;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Swap(&amp;lock, &amp;key);</span><br><span class="line">    &#125; <span class="keyword">while</span> (key != FALSE);</span><br><span class="line">    临界区;</span><br><span class="line">    lock = FALSE;</span><br><span class="line">    剩余区;</span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>
<p>实现临界区互斥的硬件方法的优点：</p>
<ul>
<li>可以保证共享变量的完整性和正确性，且简单有效。</li>
<li>可以使用于以共享内存方法通信的多处理器环境，并支持运行任意数量的进程。</li>
<li>可用于复杂的多临界区并发问题，可以为每个临界区定义相应的变量。</li>
</ul>
<p>实现临界区互斥的硬件方法的缺点：</p>
<ul>
<li>不满足<strong>让权等待</strong>，会发生“忙等”，不能有效利用处理器时间。</li>
<li>可能导致“饥饿”，存在一种小概率事件，因为轮转是随机的，可能有进程在每一次分配CPU的时候都得不到调度，在临界区外无限期等待。</li>
<li>可能导致死锁。</li>
<li>难以应用于复杂的多进程同步问题。</li>
</ul>
<h4
id="关中断方法和硬件指令方法的对比">关中断方法和硬件指令方法的对比</h4>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 39%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>简述</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>关中断方法</td>
<td>进入临界区前关中断，退出再开中断</td>
<td>只能运行在内核态，且会降低效率</td>
</tr>
<tr class="even">
<td>TSL指令、Swap指令</td>
<td>测试和解锁成为连续的原子操作</td>
<td>违背让权等待，可能导致死锁、饥饿</td>
</tr>
</tbody>
</table>
<h2 id="互斥锁">互斥锁</h2>
<p>解决临界区最简单的工具就是<strong>互斥锁</strong>。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。</p>
<p>函数<code>acquire()</code>获得锁，函数<code>release()</code>释放锁。</p>
<p>每个互斥锁有一个布尔变量<code>available</code>，表示锁是否可用。如果锁是可以用的，调用<code>acquire()</code>会成功，且锁不再可用。当一个进程视图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!available)</span><br><span class="line">        ;						<span class="comment">//忙等待</span></span><br><span class="line">    available = <span class="literal">false</span>;			<span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release() &#123;</span><br><span class="line">    available = <span class="literal">true</span>;			<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>acquire()</code>和<code>release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p>
<p>互斥锁常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<h2 id="信号量">信号量</h2>
<blockquote>
<p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语<code>wait(S)</code>和<code>signal(S)</code>访问，也称作“P操作”和“V操作”。</p>
</blockquote>
<p>信号量用于为一组合作进程提供可靠的支持，其基本原理是在几个进程之间使用简单的信号来实现同步。在这个过程中，一个进程可以被阻塞在某个特定位置，直到它收到一个特殊的信号，方可继续运行。</p>
<p><font color = "red"><code>P(S)</code>表示申请一个资源S，若资源不够则阻塞等待,若资源够就分配资源，同时信号量-1；</font></p>
<p><font color = "red"><code>V(S)</code>表示释放一个资源S，信号量+1;
若有进程在等待该资源，则唤醒一个进程。唤醒后的进程进入就绪态，不能直接转换成运行态</font></p>
<h3 id="信号量的类型">信号量的类型</h3>
<h4 id="整型信号量">整型信号量</h4>
<p>整型信号量把信号量定义为一个用于表示资源数目的整数S，对于S的访问，只能通过原语实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);</span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S) &#123;</span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在整型信号量机制中的<code>wait</code>操作，只要信号量<span
class="math inline">\(S\le0\)</span>，就会不断测试。因此，该机制并未遵循<strong>“让权等待”</strong>的准则，而是使进程处于“忙等”的状态。</p>
<h4 id="记录型信号量">记录型信号量</h4>
<p>记录型信号量是一种不存在“忙等”现象的进程同步机制。</p>
<p>除了需要一个用于代表资源数目的整型变量<code>value</code>外，再增加一个进程链表<code>L</code>，用于链接所有等待该资源的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录型信号量结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>相应的<code>wait(S)</code>和<code>signal(S)</code>的操作如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123;		<span class="comment">//相当于申请资源</span></span><br><span class="line">    S.value--;					<span class="comment">//表示进程请求一个该类资源</span></span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>) &#123;			<span class="comment">//如果S&lt;0，表示该类资源已经分配完毕</span></span><br><span class="line">        add this process to S.L;</span><br><span class="line">        block(S.L);				<span class="comment">//自我阻塞，放弃处理机，并插入该类资源的等待队列S.L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123;		<span class="comment">//相等于释放资源</span></span><br><span class="line">	S.value++;					<span class="comment">//使系统中可供分配的该类资源数增1</span></span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;			<span class="comment">//若+1后仍是S.value &lt;= 0，则表示仍有等待该资源的进程被阻塞</span></span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P);				<span class="comment">//因此需要调用wakeup原语，将S.L中的第一个等待进程唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="互斥量">互斥量</h4>
<p>互斥量在记录型信号量的基础上，规定信号量的值只能为0或1，且加锁和解锁必须在同一个进程进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span><span class="number">0</span>, <span class="number">1</span>&#125; s;			<span class="comment">//枚举类型，s的值只能为0或1</span></span><br><span class="line">    queueType blocked_process_queue;		<span class="comment">//用于记录被阻塞进程的队列</span></span><br><span class="line">&#125;Mutex;</span><br></pre></td></tr></table></figure>
<p><font color = "red">能且仅能通过以下三个操作对互斥量进行访问：</font></p>
<ol type="1">
<li><p><font color = "red">初始化<code>semaphore</code>结构体</font>。此时<code>Mutex.s</code>的值不再表示系统中的资源数量，而是表示某个临界区在此时能否访问。若s为0，表示不能访问；若s为1，表示可以访问。</p></li>
<li><p><font color = "red">可以通过P原语实现对<code>Mutex.s</code>的减一</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore Mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Mutex.s == <span class="number">1</span>)</span><br><span class="line">        Mutex.s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        阻塞该进程并将其放入阻塞队列中;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color = "red">可以通过V原语实现对<code>Mutex.s</code>的加一</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore Mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Mutex.blocked_process_queue.empty())</span><br><span class="line">        Mutex.s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        从阻塞队列中选择并唤醒一个进程;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>举例：</p>
<hr style = "border:2px solid yellow">
<p>题1：信号量与进程数之间关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ab2cc7968b751cd4e4f29634741e51b.jpg" /></p>
<p>互斥量</p>
<p>互斥量初值一般为1，表示临界区只允许1个进程进入，从而实现互斥</p>
<p>互斥量等于0时，表示临界区已有1个进程进入，临界区外无等待进程</p>
<p>互斥量小于0时，表示临界区中有1个进程，临界区外等待的进程数量等于互斥量的绝对值</p>
<p>资源量</p>
<p>资源量初值可以是任何数，表示可用的资源数</p>
<p>资源量小于0，表示所有进程已用完，等待的进程数就是资源量的绝对值</p>
<hr style = "border: 2px solid yellow;">
<p>题2：信号量与进程联系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f4954fbcadca68b0f7dd56f3afa1e72.jpg" /></p>
<p>解：每次允许2个，所以信号量初始值为2，同时有3个进程，所以可能有1个进程在临界区等待，所以最小值是1。所以答案是A</p>
<hr style = "border: 2px solid yellow;">
<p>题3：信号量与进程之间关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/40a765c00740c3b6e1f3f07504be624.jpg" /></p>
<p>分析：</p>
<p>唤醒另一个进程，但只是唤醒，说明这个进程要么在临界区，要么在临界区外等待，所以信号量的值小于等于0</p>
<hr style="border: 2px solid yellow;">
<p>题4：不同同步机制的比较</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331160825.jpg" />]
解析</p>
<details>
<summary>
A：Peterson方法
</summary>
<pre><code>while(1) &#123;
    turn = j;    // 表示谦让给对方
    flag[i] = true;    // 表示自己希望进入
    while(turn == j && flag[j] == true)    // 对方也希望进入并且自己还把机会谦让给对方了
    // 临界区
    flag[i] = false;
    // 剩余区
&#125;</code></pre>
Peterson方法可以实现<br> 空闲让进<br> 忙则等待<br> 有限等待<br>
但不能实现让权等待，因为是while循环就算无法获取临界资源也会占用CPU
</details>
<details>
<summary>
B:swap指令
</summary>
<pre><code>void swap(boolean *a, boolean *b) &#123;
        boolean tmp = *a;
        *a = *b;
        *b = tmp;
&#125;</code></pre>
对于每个临界资源，<code>Swap</code>指令为其设置一个全局布尔变量<code>lock</code>，其初值为<code>FALSE</code>。<br>
在每个进程中还会设置一个局部布尔变量<code>key</code>，其初值为<code>TRUE</code>。<br>
有进程在临界区时，重复交换和检查过程，直到临界区里的进程退出<br>
<pre><code>do &#123;
    key = true;
    do &#123;
        swap(&lock, &key);
    &#125;while(key == true);
    // 临界区
    lock = false;
    // 剩余区
&#125;while(true);</code></pre>
swap可以实现空闲让进<br>
但是swap不能实现让权等待，因为swap其实是硬件实现，所以会一鼓作气执行完，这就意味着不会中断，那么就不能实现让权等待
</details>
<details>
<summary>
C: 信号量方法
</summary>
<pre><code>typedef struct &#123;
    int value;  //表示资源的数量
    struct process *L;  //一个链表，用来链接所有等待当前资源的进程
&#125;semaphore;
void wait(semaphore S) &#123;
    S.value--;  //表示申请一个资源
    if(S.value < 0)&#123; //如果进程已经使用完了
        将这个进程加到当前信号量S相应的阻塞队列中
        block(S.L); //自我阻塞，放弃处理机，并且加入对应资源的阻塞队列中
    &#125;   
&#125;
void signal(semaphore S) &#123;
    S.value++;  //表示对应资源可以申请的数量增加1
    if(S.value <= 0) &#123;  // 如果当前资源依然在被需求，仍有等待该进程的资源被阻塞
        将S.L中第一个被阻塞的进程移除
        wakeup(S.L) //唤醒S.L中第一个被阻塞的进程。与上面移除对应，从阻塞态转变为就绪态
    &#125;
&#125;</code></pre>
信号量是同时满足了同步/阻塞的四种要求
</details>
<details>
<summary>
D: TSL指令
</summary>
<pre><code>boolean TSL(boolean *lock)&#123;
    boolean old = *lock;
    *lock = true;
    return old;
&#125;
do &#123;
    while(TSL(&lock));  //判断当前临界资源是否可以使用
    临界区
    lock = false;
    剩余区
&#125;(true)</code></pre>
TSL也可以满足闲则让进，但和B的swap一样,TSL也是由机器代码实现，所以一口气执行完，所以不会中途退出，也就不能满足让权等待
</details>
<hr style = "border:2px solid yellow;">
<h3 id="信号量的应用">信号量的应用</h3>
<h4 id="利用信号量实现进程互斥">利用信号量实现进程互斥</h4>
<p>使用互斥量实现两个进程<span class="math inline">\(P_A\)</span>和<span
class="math inline">\(P_B\)</span>的互斥。当<span
class="math inline">\(P_A\)</span>和<span
class="math inline">\(P_B\)</span>需要互斥访问某一临界资源时，每个进程在访问临界区前需对互斥量<code>mutex</code>执行P操作，在退出临界区后需对互斥量<code>mutex</code>执行V操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">//互斥量的初始值为1</span></span><br><span class="line">Process_A &#123;</span><br><span class="line">    <span class="keyword">while</span>(ture) &#123;</span><br><span class="line">        P(mutex);		<span class="comment">//加锁</span></span><br><span class="line">        访问临界区;</span><br><span class="line">        V(mutex);		<span class="comment">//解锁</span></span><br><span class="line">        剩余区;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process_B &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex);		<span class="comment">//加锁</span></span><br><span class="line">        访问临界区;</span><br><span class="line">        V(mutex);		<span class="comment">//解锁</span></span><br><span class="line">        剩余区;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用信号量实现进程同步">利用信号量实现进程同步</h4>
<p>使用信号量来实现两个进程<span
class="math inline">\(P_A\)</span>和<span
class="math inline">\(P_B\)</span>的同步。假设<span
class="math inline">\(P_A\)</span>和<span
class="math inline">\(P_B\)</span>要协同修改一个文件，<span
class="math inline">\(P_A\)</span>进程先修改，之后<span
class="math inline">\(P_B\)</span>进程继续修改，则在两个进程中分别执行P/V操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;			<span class="comment">//同步信号量的初始值为0</span></span><br><span class="line">Process_A &#123;</span><br><span class="line">    修改文件;</span><br><span class="line">    V(S);				<span class="comment">//表示修改完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process_B &#123;</span><br><span class="line">    P(S);				<span class="comment">//判断是否修改完成</span></span><br><span class="line">    修改文件;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡<font color = "red">同步与互斥的关系总结：</font></p>
<ul>
<li>同步是协作关系：多个协作进程在工作中相互等待或通信的制约关系。</li>
<li>互斥是竞争关系：当一个进程进入临界区访问临界资源时，另一进程必须等待，当访问临界资源的进程退出临界区后，另一个进程才被允许访问该临界资源。</li>
<li>进程互斥是进程同步的一种特殊情况，互斥的目的也是让多个进程协调推进。</li>
<li>互斥信号量的初始值一般为1。同步信号量的初始值则随机</li>
</ul>
</blockquote>
<h4 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h4>
<p>使用信号量实现多个进程间的前驱关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/IMG_2182 - 副本.JPG" alt="IMG_2182 - 副本" style="zoom:33%;" /></p>
<p>如图，为保证<span class="math inline">\(S_1\rightarrow
S_2，S_1\rightarrow
S_3\)</span>的前驱关系，应分别设置信号量<code>a1, a2</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=<span class="number">0</span>;			<span class="comment">//初始化信号量</span></span><br><span class="line">S1() &#123;</span><br><span class="line">	...;</span><br><span class="line">    V(a1); V(a2);						<span class="comment">//S1已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S2() &#123;</span><br><span class="line">    P(a1);								<span class="comment">//检查S1是否运行完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(b1); V(b2);						<span class="comment">//S2已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S3() &#123;</span><br><span class="line">    P(a2);								<span class="comment">//检查S1是否运行完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(c);								<span class="comment">//S3已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S4() &#123;</span><br><span class="line">    P(b1);								<span class="comment">//检查S2是否运行完成</span></span><br><span class="line">    ...;</span><br><span class="line">    V(d);								<span class="comment">//S4已经运行完成</span></span><br><span class="line">&#125;</span><br><span class="line">S5() &#123;</span><br><span class="line">    P(b2);								<span class="comment">//检查S2是否运行完成</span></span><br><span class="line">    ...;	</span><br><span class="line">    V(e);								<span class="comment">//S2已经运行完成</span></span><br><span class="line">&#125;		</span><br><span class="line">S6() &#123;</span><br><span class="line">    P(c);								<span class="comment">//检查S3是否运行完成</span></span><br><span class="line">    P(d);								<span class="comment">//检查S4是否运行完成</span></span><br><span class="line">    P(e);								<span class="comment">//检查S5是否运行完成</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：信号量的使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/742d6f24bec32f2ab468dfd8bb3048f.jpg" /></p>
<hr style = "border: 2px solid yellow">
<h2 id="经典同步问题">经典同步问题</h2>
<h3 id="生产者-消费者问题">生产者-消费者问题</h3>
<p>生产者-消费者问题是对合作进程中内部关系的抽象化。</p>
<blockquote>
<p><strong>问题描述：</strong></p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
</blockquote>
<p><img src="D:/HuaweiMoveData/Users/piolet/Desktop/2024-Postgraduate-408-main/OperatingSystem/ch2/assets/image-20230528224555889.png" alt="image-20230528224555889" style="zoom: 67%;" /></p>
<blockquote>
<p><strong>问题分析：</strong></p>
<ol type="1">
<li><font color = "red">关系分析</font>。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</li>
<li>整理思路。只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</li>
<li><font color = "red">信号量设置</font>。信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问缓冲池，<font color = "red">互斥信号量初值为1</font>；信号量<code>full</code>用于记录当前缓冲池中的“满”缓冲区数，初值为0。信号量<code>empty</code>用于记录当前缓冲池中的“空”缓冲区数，初值为n。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者-消费者问题的代码实现</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//mutex：临界区互斥信号量	empty：空闲缓冲区		full：生产者进程</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">procedure</span><span class="params">()</span> &#123;					<span class="comment">//生产者进程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        生产一个新的产品;</span><br><span class="line">        P(empty);					<span class="comment">//要用什么，P一下，获取空缓冲区单元</span></span><br><span class="line">        P(mutex);					<span class="comment">//互斥夹紧，进入临界区</span></span><br><span class="line">        将产品放入空闲缓冲区;	</span><br><span class="line">        V(mutex);					<span class="comment">//互斥夹紧，离开临界区，释放互斥信号量</span></span><br><span class="line">        V(full);					<span class="comment">//提供什么，V一下，满缓冲区数加1</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;					<span class="comment">//消费者进程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(full);					<span class="comment">//获取满缓冲区单元</span></span><br><span class="line">        P(mutex);					<span class="comment">//进入临界区</span></span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);					<span class="comment">//离开临界区，释放互斥信号量</span></span><br><span class="line">        V(empty);					<span class="comment">//空缓冲区数加1</span></span><br><span class="line">        消费该产品;</span><br><span class="line">    &#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量<code>mutex</code>保证同一时刻只能有一个进程对缓冲区进行操作。</p>
<blockquote>
<p>💡注意：</p>
<ul>
<li>P操作的顺序很重要，<code>P(empty/full)</code>必须在<code>P(mutex)</code>之前，不能颠倒。</li>
<li>V操作的顺序允许颠倒。</li>
</ul>
</blockquote>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<p>哲学家进餐问题是进程同步的一个典型问题。</p>
<blockquote>
<p>问题描述：</p>
<p>一张圆桌边上坐着5</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-6fdb4a2f77bcd5a201454af1fdb3335e_720w.webp" alt="img" style="zoom:67%;" /></p>
<blockquote>
<p>问题分析：</p>
<ul>
<li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。
<ul>
<li>解决方法：
<ol type="1">
<li>让他们同时拿两根筷子。</li>
<li>对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li>
</ol></li>
</ul></li>
<li>信号量设置。定义互斥信号量数组<code>chopstick[5] = &#123;1, 1, 1, 1, 1&#125;</code>，用于对5个筷子的互斥访问。哲学家按顺序编号为<code>0 ~ 4</code>，哲学家$
i <span class="math inline">\(左边筷子编号为\)</span> i <span
class="math inline">\(，哲学家右边筷子的编号为\)</span> (i + 1)$ %
5。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;		<span class="comment">//定义信号量数组并初始化</span></span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(chopstick[i]);				<span class="comment">//取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);		<span class="comment">//取右边筷子</span></span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);				<span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);		<span class="comment">//放回右边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>❗该算法存在以下问题：</p>
<ul>
<li>当5名哲学家都想要进餐并分别拿起左边的筷子时(都恰好执行完<code>wait(chopstick[i])</code>)筷子已被拿光，等到他们再想拿右边的筷子时(执行<code>wait(chopstick[(i+1)%5])</code>)就全被阻塞，因此出现了死锁。</li>
</ul>
<p>💡可以施加一些限制条件，以防止死锁发生：</p>
<ul>
<li>至多允许4名哲学家同时进餐；(破坏“循环等待”条件)</li>
<li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子；(破坏“请求和保持”条件)</li>
<li>对哲学家进行编号，要求奇数号哲学家先拿左边的筷子，然后拿右边筷子，偶数号哲学家相反。(破坏“
循环等待”条件)</li>
</ul>
</blockquote>
<p>假设采用第二种限制条件制定正确规则：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;			<span class="comment">//初始化信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;								<span class="comment">//设置取筷子的信号量</span></span><br><span class="line">Pi() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(mutex);						<span class="comment">//在取筷子前获得互斥量</span></span><br><span class="line">        P(chopstick[i]);				<span class="comment">//取左边筷子</span></span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);		<span class="comment">//取右边筷子</span></span><br><span class="line">        V(mutex);						<span class="comment">//释放取筷子的信号量</span></span><br><span class="line">        eat;</span><br><span class="line">        V(chopstick[i]);				<span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);		<span class="comment">//放回右边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者写者问题">读者—写者问题</h3>
<p>读者—写者问题是对数据对象的访问模型。</p>
<blockquote>
<p>问题描述：</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ol type="1">
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任意一个写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ol>
</blockquote>
<h4 id="读者优先">读者优先</h4>
<p>在该算法中，读进程具有优先权，其访问临界区时，只要有一个读进程在读，读进程就能继续获得对临界区的控制权，但可能会导致写进程饥饿。</p>
<blockquote>
<p>算法描述：</p>
<ul>
<li>当一个读进程正在读取文件时，写进程必须等待。</li>
<li>在写进程等待时，随后的读进程仍可以进入临界区读取。</li>
<li>只有在没有读进程在读取的情况下，写进程才可以写入。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>;			<span class="comment">//定义readcount的互斥信号量，初始值为1</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;			<span class="comment">//定义用于写的互斥信号量，初始值为1</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>; 				<span class="comment">//用于记录当前读者数量，初始值为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(rmutex);		<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止他人访问</span></span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            P(wmutex);		<span class="comment">//(同步)如果自己是第一个读者，禁止写者写</span></span><br><span class="line">        readcount++;		<span class="comment">//读者数量+1</span></span><br><span class="line">        V(rmutex);		<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许他人访问</span></span><br><span class="line">        </span><br><span class="line">        进行读操作;</span><br><span class="line">        </span><br><span class="line">        P(rmutex);		<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止他人访问</span></span><br><span class="line">        readcount--;		<span class="comment">//读者数量-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>)</span><br><span class="line">            V(wmutex);		<span class="comment">//(同步)如果自己是最后一个读者，允许写者写</span></span><br><span class="line">        V(rmutex);		<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许他人访问</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(wmutex);			<span class="comment">//(写互斥)对wmutex执行P操作，防止他人访问文件</span></span><br><span class="line">        进行写操作;</span><br><span class="line">        V(wmutex);			<span class="comment">//(写互斥)对wmutex执行V操作，允许他人访问文件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写者优先">写者优先</h4>
<p>在该算法中，写进程具有优先权，如果有写进程希望访问临界区，就会禁止新的读进程进入临界区，解决了写进程饥饿问题。</p>
<blockquote>
<p>算法描述：</p>
<ul>
<li>当一个读进程在读取时，写进程不能进入临界区。</li>
<li>当一个写进程表示希望进行写入时，随后的读进程不得进入临界区读取。</li>
<li>只有当所有的写进程都离开临界区后，读进程才可以进入临界区读取。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>;				<span class="comment">//定义readcount的互斥信号量，初始值为1</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;				<span class="comment">//定义writecount的互斥信号量，初始值为1</span></span><br><span class="line">semaphore read_write = <span class="number">1</span>;			<span class="comment">//用于在读取时检测是否有写者的互斥信号量，初始值为1</span></span><br><span class="line">semaphore write_read = <span class="number">1</span>;			<span class="comment">//用于在写入时防止他人进入的互斥信号量，初始值为1</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;			<span class="comment">//用于记录当前读者数量，初始值为0</span></span><br><span class="line"><span class="type">int</span> writecount = <span class="number">0</span>;			<span class="comment">//用于记录当前写者数量，初始值为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(read_write);			<span class="comment">//(读写互斥)在读取时检测是否有写者，如有写者则等待</span></span><br><span class="line">        P(rmutex);				<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止其他读者访问</span></span><br><span class="line">        readcount++;		<span class="comment">//读者数量+1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>)</span><br><span class="line">            P(write_read);		<span class="comment">//(读写互斥)如果自己是第一个读者，禁止写者写</span></span><br><span class="line">        V(rmutex);			<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许其他读者访问</span></span><br><span class="line">        V(read_write);		<span class="comment">//(读写互斥)允许其他读者或写者访问文件</span></span><br><span class="line">        </span><br><span class="line">        进行读操作;</span><br><span class="line">        </span><br><span class="line">        P(rmutex);			<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止其他读者访问</span></span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>)</span><br><span class="line">            V(write_read);			<span class="comment">//(读写互斥)如果自己是最后一个读者，允许他人读写</span></span><br><span class="line">        readcount--;		<span class="comment">//读者数量-1</span></span><br><span class="line">        V(rmutex);			<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许其他读者访问</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(wmutex);					<span class="comment">//(写互斥)对wmutex执行P操作，防止其他写者访问writecount</span></span><br><span class="line">        writecount++;		<span class="comment">//写者数量+1</span></span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">1</span>)</span><br><span class="line">            P(read_write);			<span class="comment">//(读写互斥)如果自己是第一个写者，禁止读者读</span></span><br><span class="line">        V(wmutex);					<span class="comment">//(写互斥)对wmutex执行V操作，允许其他写者访问writecount</span></span><br><span class="line">        P(write_read);				<span class="comment">//(读写互斥)若没有读者或写者在访问文件，则可写入</span></span><br><span class="line">        </span><br><span class="line">        进行写操作;</span><br><span class="line">        </span><br><span class="line">        V(write_read);				<span class="comment">//(读写互斥)写操作完成，允许其他读者或写者访问文件</span></span><br><span class="line">        P(wmutex);					<span class="comment">//(写互斥)对wmutex执行P操作，防止其他写者访问writecount</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">1</span>)</span><br><span class="line">            V(read_write);			<span class="comment">//(读写互斥)如果自己是最后一个写者，允许读者读</span></span><br><span class="line">        writecount--;		<span class="comment">//写者数量-1</span></span><br><span class="line">        V(wmutex);					<span class="comment">//(写互斥)对wmutex执行V操作，允许其他写者访问writecount</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写公平">读写公平</h4>
<p>读写公平算法不偏袒读者或写者中的任何一方，仅根据读写请求的到达顺序来赋予读写的权利。</p>
<blockquote>
<p>算法描述：</p>
<ul>
<li>当没有读进程或写进程时，允许读进程或写进程进入。</li>
<li>当一个读进程试图读取时，若有写者正在等待写操作或进行写操作时，应等待其完成写操作后，才能开始读操作。</li>
<li>同理，当一个写进程试图写入时，若有读者正在等待或进行读操作时，也需要进行等待。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>;			<span class="comment">//定义readcount的互斥信号量，初始值为1</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;			<span class="comment">//定义用于写的互斥信号量，初始值为1</span></span><br><span class="line">semaphore read_write = <span class="number">1</span>; 		<span class="comment">//用于在读取时检测是否有写者的互斥信号量，初始值为1</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;				<span class="comment">//用于记录当前读者数量，初始值为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(read_write);			<span class="comment">//(读写互斥)在读取时检测是否有写者，如有写者则等待</span></span><br><span class="line">        P(rmutex);				<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止他人访问</span></span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>)</span><br><span class="line">            P(wmutex);			<span class="comment">//(同步)如果自己是第一个读者，禁止写者写</span></span><br><span class="line">        readcount++;			<span class="comment">//读者数量+1</span></span><br><span class="line">        V(rmutex);				<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许他人访问</span></span><br><span class="line">        V(read_write);			<span class="comment">//(读写互斥)允许其他读者或写者访问文件</span></span><br><span class="line">        </span><br><span class="line">        进行读操作;</span><br><span class="line">        </span><br><span class="line">        P(rmutex);				<span class="comment">//(readcount操作互斥)对rmutex执行P操作，防止他人访问</span></span><br><span class="line">        readcount--;			<span class="comment">//读者数量-1</span></span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>)</span><br><span class="line">            V(wmutex);			<span class="comment">//(同步)如果自己是最后一个读者，允许写者写</span></span><br><span class="line">        V(rmutex);				<span class="comment">//(readcount操作互斥)对rmutex执行V操作，允许他人访问</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        P(read_write);			<span class="comment">//(读写互斥)检测是否有读者或写者，如有则等待</span></span><br><span class="line">        P(wmutex);				<span class="comment">//(写互斥)对wmutex执行P操作，防止他人访问文件</span></span><br><span class="line">        </span><br><span class="line">        进行写操作;</span><br><span class="line">        </span><br><span class="line">        V(wmutex);				<span class="comment">//(写互斥)对wmutex执行V操作，允许他人访问文件</span></span><br><span class="line">        V(read_write);			<span class="comment">//(读写互斥)允许其他读者或写者访问文件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="吸烟者问题">吸烟者问题</h3>
<blockquote>
<p>问题描述：</p>
<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个吸烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料：<strong>烟草、纸和胶水</strong>。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复。</p>
</blockquote>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230606225659418.png"
alt="image-20230606225659418" />
<figcaption aria-hidden="true">image-20230606225659418</figcaption>
</figure>
<blockquote>
<p>问题分析：</p>
<ul>
<li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥。</li>
<li>整理思路。显然这里有四个进程。供应者作为生产者向三个抽烟者提供材料。</li>
<li>信号量设置。信号量<code>offer1</code>、<code>offer2</code>、<code>offer3</code>分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量<code>finish</code>用于互斥进行抽烟动作</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;						<span class="comment">//存储随机数</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;				<span class="comment">//定义信号量对应烟草和纸组合的资源</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;				<span class="comment">//定义信号量对应烟草和胶水组合的资源</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;				<span class="comment">//定义信号量对应纸和胶水组合的资源</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;				<span class="comment">//定义信号量表示抽烟是否完成</span></span><br><span class="line"></span><br><span class="line">process <span class="title function_">P1</span><span class="params">()</span> &#123;			<span class="comment">//供应者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        num = num % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) </span><br><span class="line">            V(offer1);				<span class="comment">//提供烟草和纸</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            V(offer2);				<span class="comment">//提供烟草和胶水</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(offer3);				<span class="comment">//提供纸和胶水</span></span><br><span class="line">        </span><br><span class="line">        任意两种材料放在桌上;</span><br><span class="line">        </span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="title function_">P2</span><span class="params">()</span> &#123;		<span class="comment">//拥有烟草者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        拿纸和胶水，卷成烟，抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="title function_">P3</span><span class="params">()</span> &#123;		<span class="comment">//拥有纸者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        拿烟草和胶水，卷成烟，抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="title function_">P4</span><span class="params">()</span> &#123;		<span class="comment">//拥有胶水者</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        拿烟草和纸，卷成烟，抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="管程">管程</h2>
<h3 id="管程的定义">管程的定义</h3>
<p>管程既能实现互斥也能实现同步</p>
<hr style = "border:2px solid yellow;">
<p>举例：管程的定义与特点考察</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/693515d869526eefdd1662014da3c60.jpg" /></p>
<p>解析：</p>
<p>A：管程既能实现互斥也能实现同步</p>
<hr style = "border:2px solid yellow;">
<p>引入管程的<strong>目的</strong>：</p>
<ul>
<li>集中管理分散于不同进程的临界区。</li>
<li>防止进程违反同步操作。</li>
<li>便于用高级语言编写程序、检查程序的正确性。</li>
</ul>
<p>管程是一个软件模块，由一些公共变量及其描述和所有访问这些变量的进程组成。进程对共享资源的请求、释放和其他操作必须通过同一个管程来实现。当多个进程请求访问同一资源时，会根据资源的情况接收或拒绝，<font color = "red">确保每次只有一个进程进入临界区，有效实现进程互斥。</font></p>
<p>管程的语法描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Monitor monitor_name &#123;	<span class="comment">//管程名</span></span><br><span class="line">	share variable declarations;			<span class="comment">//共享变量说明</span></span><br><span class="line">    cond declarations;			<span class="comment">//条件变量说明</span></span><br><span class="line"></span><br><span class="line">public:				<span class="comment">//能被进程调用的过程</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">P1</span><span class="params">(...)</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">P2</span><span class="params">(...)</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">P3</span><span class="params">(...)</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;		<span class="comment">//管程主体</span></span><br><span class="line">        initialization code;			<span class="comment">//初始化代码</span></span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管程包含了面向对象的思想，将<font color = "red">表达共享资源的数据结构和对其进行操作</font>的进程封装在一个对象中，并封装了同步操作，从而对进程隐藏同步的细节，简化了调用同步功能的接口。</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230606233539715.png" alt="image-20230606233539715" style="zoom: 80%;" /></p>
<p>管程由<strong>程序的名称</strong>、<strong>程序本地的共享数据结构</strong>、<strong>一组对数据结构进行操作的程序</strong>、<strong>一条初始化本地共享数据的语句</strong>组成。</p>
<p>举例：管程组成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f46ac2ec4358b3a0d85e60f9e826369.jpg" /></p>
<p><font color = "red">管程只对自己负责</font></p>
<hr style = "border: 2px solid orange;">
<p>管程具有以下特性：</p>
<ul>
<li>共享性。管程可以被系统中的不同进程以互斥方式访问，是一种共享资源。</li>
<li>安全性。管程的过程只能访问属于本管程的局部变量，甚至不能访问其局部变量以外的变量。</li>
<li>互斥性。进程对管程的访问是互斥的。<font color = "red">一个管程中只能有一个活动进程。</font></li>
<li>封装性。管程中的过程只能使用管程中的数据结构，同时，管程中的数据结构都是私有的，也只能在管程中使用，进程可以通过调用管程中的过程来使用临界资源。</li>
</ul>
<h3 id="条件变量">条件变量</h3>
<p>条件变量是管程内的一种全局数据结构。</p>
<p>当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，<font color = "red">将阻塞原因定义为条件变量<code>condition</code>。</font></p>
<blockquote>
<p>条件变量与P/V操作的区别：</p>
<p>条件变量作为一种共享数据结构，进程在调用管程时，如遇到阻塞/唤醒条件时，会自行调用相应原语，将自己插入到对应的等待队列中(或从中释放)，避免对管程的持续占用，实现管程的有序排队使用。</p>
</blockquote>
<p>条件变量对管程中的所有过程是全局性的，对条件变量x的操作如下：</p>
<ol type="1">
<li><code>x.wait()</code>
：若调用管程的进程<font color = "red">由于条件x而需要被阻塞或暂停，则释放管程，挂起调用进程并插入到条件x的等待队列中</font>，直到另一个进程向条件变量执行了<code>x.signal()</code>操作。</li>
<li><code>x.signal()</code>：当调用管程的进程注意到条件x已经改变，调用对应的<code>x.signal()</code>操作。<font color = "red">如果存在某个进程由于<code>x.wait()</code>操作被挂起，则将其释放</font>；如果没有其他进程被阻塞，则不做任何操作。</li>
<li><code>x.queue()</code>：如果<font color = "red">至少有一个进程由于条件变量而被挂起</font>，就返回<code>TRUE</code>，否则返回<code>FALSE</code>。</li>
</ol>
<p>条件变量的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">monitor Demo &#123;</span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    condition x;				<span class="comment">//定义一个条件变量x</span></span><br><span class="line">    init_code() &#123;...&#125;</span><br><span class="line">    take_away() &#123;</span><br><span class="line">        <span class="keyword">if</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">            x.wait();			<span class="comment">//资源不够，在条件变量x上阻塞等待</span></span><br><span class="line">        资源足够，分配资源，做一系列相应处理;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    give_back() &#123;</span><br><span class="line">        归还资源，做一系列相应处理;</span><br><span class="line">        <span class="keyword">if</span> (有进程在等待)</span><br><span class="line">            x.signal();			<span class="comment">//唤醒一个阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>条件变量和信号量的对比：</p>
<p><strong>相似点：</strong>条件变量的<code>wait</code>/<code>signal</code>操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒。</p>
<p><strong>不同点：</strong></p>
<p>条件变量是<strong>没有值</strong>的，仅实现了<strong>排队等待</strong>功能；</p>
而信号量是<strong>有值</strong>的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。
<hr style = "border:2px solid yellow;">
</blockquote>
<p>举例：</p>
<p>题1：管程中wait和信号量中V操作区别与联系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f271da63da1219c133a381104d17dc8.jpg" /></p>
<p>解析</p>
<p>信号量机制中的V操作一定会改变信号量S的值：S = S + 1</p>
<p>管程中signal操作是针对某个条件变量，若不存在因该条件而阻塞的进程，则signal不会产生任何影响</p>
<hr style = "border:2px solid yellow;">
<p>题2：条件变量中各个操作的使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f836844501930974768b9a92cdf47c7.jpg" /></p>
<p>解析：</p>
<p>若进程A执行x.wait()操作，则进程A会被阻塞，并挂到条件变量x的阻塞队列上。如果进程B执行x.signal()，会唤醒x对应阻塞队列的队首进程，进程B不受影响</p>
<hr style = "border:2px solid yellow;">
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>1.1计算机系统层次结构</title>
    <url>/posts/15a679ce.html</url>
    <content><![CDATA[<h1 id="计算机系统层次结构">计算机系统层次结构</h1>
<span id="more"></span>
<h2 id="计算机硬件的组成">计算机硬件的组成</h2>
<h3 id="冯诺依曼计算机">冯·诺依曼计算机</h3>
<p>将指令以代码的形式存入主存储器中，之后按照顺序依次执行，直到程序执行结束。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image.png"
alt="冯诺依曼计算机" />
<figcaption aria-hidden="true">冯诺依曼计算机</figcaption>
</figure>
<p>冯诺依曼计算机</p>
<h4 id="特点">特点：</h4>
<ol type="1">
<li>计算机硬件系统由<strong>运算器</strong>、<strong>存储器</strong>、<strong>控制器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>5大部件组成；</li>
<li>指令和数据以同等地位存于存储器内，并可<strong>按地址寻访</strong>；</li>
<li>指令和数据均用二进制代码表示；</li>
<li>指令由<strong>操作码</strong>和<strong>地址码</strong>组成
<ul>
<li>操作码用来表示操作的性质；</li>
<li>地址码用来表示操作数在存储器中的位置；</li>
</ul></li>
<li>指令在存储器内按顺序存放。通常指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序；</li>
<li>早期的冯诺依曼机<strong>以运算器为中心</strong>，输入/输出设备通过运算器与存储器传送数据。</li>
</ol>
<hr style = "border:2px solid yellow">
<p>冯诺伊曼机基本工作方式是<font color = "red">控制流驱动</font>
<font color = "red">按地址访问并顺序执行指令</font>是冯诺依曼机工作方式的基本特点</p>
<p><font color = "red">如何区分指令和数据：</font></p>
<ul>
<li><font color = "yellow">通过不同的时间段来区分指令和数据</font>，即在取指令阶段（或取指微程序）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。</li>
<li><font color = "yellow">通过地址来源区分</font>，由<span
class="math inline">\(PC\)</span>提供存储单元地址的取出的是指令，由指令地址码部分取出（提供存储单元地址或在指令中给出立即数）的是操作数。</li>
</ul>
<hr style = "border:2px solid yellow">
<h3 id="现代计算机的组织结构">现代计算机的组织结构</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(1).png"
alt="以存储器为核心" />
<figcaption aria-hidden="true">以存储器为核心</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(2).png"
alt="计算机的功能部件" />
<figcaption aria-hidden="true">计算机的功能部件</figcaption>
</figure>
<h3 id="计算机的功能部件">计算机的功能部件</h3>
<h4 id="存储器">存储器</h4>
<p>存储器<font color = "yellow">包括主存储器（主存、内存储器）和辅助存储器（辅存、外存储器）</font>。</p>
<p><font color = "yellow">主存的组成如图所示：</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(3).png" /></p>
<ul>
<li><strong>存储体</strong>：存放二进制信息；</li>
<li><strong>地址寄存器（MAR，Memory Adders
Register）</strong>：存放访存地址，经过地址译码后找到相应的存储单元；
<font color = "red">MAR的位数表示地址码的长度</font></li>
<li><strong>数据寄存器（MDR，Memory Data
Register）</strong>：暂存要从存储器中读或写的信息。
MDR的位数表示每个存储单元的位数，<font color = "red">也叫存储字长</font></li>
</ul>
<p><font color = "yellow">主存的作用</font>:程序运行时的主要位置，包括所需的数据</p>
<p><font color = "red">敲重点：MAR和MDR之间关系的理解</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f20c126f0cfa928b3fe8e269131e8ad.jpg" /></p>
<p>主存储器是由若干<strong>存储单元</strong>构成的，每个存储单元包含若干<strong>存储元件</strong>，每一个存储元件可以存储一位二进制代码0或1。因此每一个存储单元可以存储一串二进制码。这串二进制码称为<strong>存储字</strong>，它的位数称为<strong>存储字长</strong>，实际上就是存储单元中存储元件的个数。</p>
<p>例如，一个存储单元中有8个存储元件，则其存储字长为8位（bit），也可以称为1字节（B，Byte）。</p>
<p><font color = "red">MAR有n位(有n位地址) = 有 <span
class="math inline">\(2^n\)</span> 个存储单元 。</font></p>
<blockquote>
<p>MAR和MDR虽然是存储器一部分，但现在也存在于CPU</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>题1：寄存器和高速缓冲寄存器Cache都集成在CPU上，<font color = "red">离CPU越近速度越快</font>，所以存取速度上<font color = "yellow">寄存器&gt;Cache&gt;内存。</font></p>
<hr style = "border:2px solid yellow">
<p>题2：计算机位数相关的计算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3a43b967fb511d8b24df8bffb92d5a3.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/befbcc95fbbba16d5e58b2bcc9492bf.jpg" /></p>
<hr style = "border:2px solid yellow">
<h4 id="运算器">运算器</h4>
<p>用于处理计算机的算术运算和逻辑运算。运算器包括：</p>
<ul>
<li><strong>算术逻辑单元</strong>（ALU）（<em>核心</em>）</li>
<li>累加器（ACC）</li>
<li>乘商寄存器（MQ）</li>
<li>操作计数器（X）</li>
<li>变址寄存器（IX）</li>
<li>基址寄存器（BR）</li>
<li>程序状态寄存器（PSW）</li>
</ul>
<h4 id="控制器">控制器</h4>
<p>控制计算机各部件运行。包括：</p>
<ul>
<li><strong>控制单元</strong>（CU）</li>
<li><strong>指令寄存器（IR）</strong>：存放当前执行指令的地址</li>
<li><strong>程序计数器（PC）</strong>：自动加1以得到下一条指令的地址</li>
</ul>
<h2 id="计算机的工作过程">1.2.2 计算机的工作过程</h2>
<p>简单版本：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(4).png" /></p>
<p>先定义下面会用到的变量含义：</p>
<p>M：主存中某存储单元 OP(IR)：取操作码 Ad(IR)：取地址码</p>
<h3 id="取指令">取指令</h3>
<ol type="1">
<li>PC --&gt;
MAR：将指令的地址从PC（程序计数器）传至<strong>地址寄存器</strong></li>
<li>M(MAR) --&gt;
MDR：根据地址从存储体（或地址寄存器）中取到指令，并传至<strong>数据寄存器</strong></li>
<li>(MDR) --&gt; IR：将得到的指令传给<strong>指令寄存器</strong></li>
</ol>
<h3 id="分析指令">分析指令</h3>
<ol type="1">
<li>OP(IR) --&gt;
CU：CU（控制单元）分析IR（指令寄存器）中的指令，并做出操作</li>
</ol>
<h3 id="执行指令">执行指令</h3>
<ol type="1">
<li>Ad(IR) --&gt;
MAR：IR(指令寄存器)将地址码给<strong>地址寄存器</strong></li>
<li>M(MAR) --&gt;
MDR：地址寄存器找到数据，存至<strong>数据寄存器</strong></li>
<li>(MDR) --&gt; ACC：数据寄存器将数据传至<strong>累加器</strong></li>
</ol>
<p><font color = "red">CPU通过指令周期的不同阶段来区分指令和数据</font></p>
<p>详细版本：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/e9e73f2d230eba9698155818f817b31.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：CPU结构</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4136cbd3f8fce2909214cefef7a9613.jpg" /></p>
<p>解析：地址译码器是主存里面的</p>
<hr style = "border:2px solid yellow">
<h2 id="计算机的层次结构">1.2.3 计算机的层次结构</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(5).png" /></p>
<ul>
<li>M4：用编译程序<strong>翻译</strong>成机器语言程序</li>
<li>M3：用汇编程序<strong>汇编</strong>成机器语言程序</li>
<li>M2：用机器语言<strong>解释</strong>操作系统</li>
<li>M1：用微指令<strong>解释</strong>机器指令</li>
<li>M0：由硬件<strong>直接执行</strong>微指令</li>
<li><strong>翻译程序</strong>：源程序→机器语言
<ul>
<li><strong>编译</strong>（C++、Java）
<ul>
<li>高级语言→机器语言</li>
<li>通篇翻译</li>
<li>仅需执行一次</li>
</ul></li>
<li><strong>解释</strong>（python、JS）
<ul>
<li>高级语言→机器语言</li>
<li>翻译一句执行一句</li>
<li>每次执行都需要翻译</li>
</ul></li>
<li><strong>汇编</strong>
<ul>
<li>汇编语言→机器语言</li>
</ul></li>
</ul></li>
<li>硬件和软件之间互相依存，协同发展</li>
<li>两者间没有严格的界限</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：上下层关系</p>
<p><font color = "red">1.
上层实现对下层功能的拓展，下层是上层的基础。</font></p>
<p><font color = "red">2.
上下层可以分割，仅有下层没有上层也可以</font></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>1.2计算机的性能指标</title>
    <url>/posts/68a1692.html</url>
    <content><![CDATA[<h2 id="主要性能指标">主要性能指标</h2>
<span id="more"></span>
<h3 id="主存容量">主存容量</h3>
<p>总容量=存储单元个数∗存储字长(bit)<a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>=存储单元个数∗存储字长/8(byte, B)<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<ul>
<li>MAR的位数：反应存储单元的个数，即 <span
class="math inline">\(2^n\)</span> 个存储单元（n为位数）；</li>
<li>MDR的位数：等于<strong>存储字长</strong>。</li>
</ul>
<p>例：主存容量为64K*32位，即MAR位数为16位，MDR位数为32位。</p>
<blockquote>
<p><span class="math inline">\(2^{10}\)</span>:K</p>
<p><span class="math inline">\(2^{20}\)</span>:M</p>
<p><span class="math inline">\(2^{30}\)</span>:G</p>
<p><span class="math inline">\(2^{40}\)</span>:T</p>
</blockquote>
<h3 id="机器字长">机器字长</h3>
<p>计算机进行<strong>一次整数运算</strong>所能处理的二进制数据的位数。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：微机的位数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4436fc5684497295cd8d0cb939c22ac.jpg" /></p>
<hr style = "border:2px solid yellow;">
<p>题2：机器字长与字节的关系：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f700e1c37ecc9f0bc4087189a84c812.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="cpu时钟周期和主频">CPU时钟周期和主频</h3>
<p><strong>CPU时钟周期</strong>：<font color = "red">CPU中最小的时间单位，每个动作至少需要一个时钟周期。</font></p>
<p><strong>主频（CPU时钟频率）</strong>：机器内部主时钟的频率，主频越高，计算机运行速度越快。</p>
<p><span class="math inline">\(CPU时钟周期 = \frac{1}{主频}\)</span></p>
<h3 id="cpi">CPI</h3>
<p><strong>CPI（Clock cycle Per
Instruction）</strong>：执行一条指令所需的时钟周期数。</p>
<p>指令执行的时间 = CPI ∗ CPU时钟周期</p>
<hr style = "border:2px solid yellow">
<p>举例：影响CPI的因素</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d9d27a51c62f5f8b58019a3c56bac6f.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="cpu执行时间">CPU执行时间</h3>
<p>CPU执行时间，即整个程序的执行时间。</p>
<p><span class="math inline">\(CPU执行时间 = (平均CPI * 指令条数) *
CPU时钟周期 = \frac{CPU时钟周期数}{主频}\)</span></p>
<h3 id="mipsmflopsgflops和tflops">MIPS、MFLOPS、GFLOPS和TFLOPS</h3>
<p><strong>MIPS (Million Instructions Per
Second)</strong>：每秒执行多少百万条指令。</p>
<p><span class="math inline">\(MIPS = \frac{指令条数}{执行时间 * 10^6} =
\frac{主频}{CPI}\)</span></p>
<p><strong>MFLOPS ( Mega Floating point Operations Per
Second)</strong>：每秒执行多少百万次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409095304737.png" /></p>
<p><strong>GFLOPS ( Giga Floating point Operations Per
Second)</strong>：每秒执行多 少十亿次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408095051254.png" /></p>
<p><strong>TFLOPS (Tera Floating -point Operations Per
Second)</strong>：每秒执行多少 万亿次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408095057575.png" /></p>
<h2 id="其他相关术语">其他相关术语</h2>
<h3 id="吞吐量和响应时间">吞吐量和响应时间</h3>
<p><strong>吞吐量</strong>：系统在单位时间内处理请求的容量，<font color = "red">常用作评价计算机系统性能的综合参数之一</font></p>
<p><strong>响应时间</strong>：从用户发出请求到系统响应请求并得到结果的时间，包括CPU运行时间和等待时间。</p>
<h3 id="数据通路带宽">数据通路带宽</h3>
<p>数据总线一次能并行传输数据的位数。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>单位是位<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>单位是字节,1字节=8位<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.1_进位计数制与相互转换</title>
    <url>/posts/10ea6e78.html</url>
    <content><![CDATA[<h3 id="进位计数法">进位计数法</h3>
<span id="more"></span>
<p><strong>基数</strong>：每个数位所要用到的不同符号的个数（二进制就是2个、8进制就是8个、十进制就是10个...）。</p>
<p>基数越大，<strong>位数</strong>越小，运算情况越多。</p>
<p>位权：依据进制所决定的一个常数（二级制就是2，十进制就是10...）</p>
<p>N位r进制的数所能表示的<strong>数字个数</strong>为：<span
class="math inline">\(r^N\)</span>个</p>
<h3 id="进制转换">进制转换</h3>
<h4 id="一任意进制----十进制">（一）、任意进制 --&gt; 十进制</h4>
<p>用相应位上的数乘以位权即可。</p>
<blockquote>
<p>二进制：101.1 --&gt; <span class="math inline">\(1 \times 2^2 + 0
\times 2^1 + 1 \times 2^0 + 1 \times 2^{-1} = 5.5\)</span></p>
<p>八进制：5.4 --&gt; <span class="math inline">\(5 \times 8^0 + 4
\times 8^{-1} = 5.5\)</span></p>
<p>十六进制：5.8 --&gt; <span class="math inline">\(5 \times 16^0 + 8
\times 16^{-1} = 5.5\)</span></p>
</blockquote>
<h4 id="二十进制----任意进制">（二）、十进制 --&gt; 任意进制</h4>
<p>例：将十进制123.6875转化为二进制</p>
<h4 id="除基取余法整数">除基取余法（整数）</h4>
<p>对整数部分的处理使用短除法，并从下向上，得1111011</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(7).png" /></p>
<h4 id="乘基取整法小数">乘基取整法（小数）</h4>
<p>小数部分采用乘基取整的思路，如下所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415115021673.png" /></p>
<p>一般十进制<strong>无法精确化为</strong>二进制小数，取一定精度即可。</p>
<h4 id="二-2n-进制之间的转换">（二）、 <span
class="math inline">\(2^n\)</span> 进制之间的转换</h4>
<p>每n位一组，进行对应的转换即可。</p>
<p>例1：将3C2.68H转化为二进制</p>
<p>3C2.68H = 1111000010.01101B</p>
<p>例2：将1111000010.01101B转化为八进制</p>
<p>1111000010.01101B = (1702.32)8</p>
<h2 id="bcd码">BCD码</h2>
<p>BCD（Binary-Coded
Decimal），<strong>使用二进制表示的十进制数</strong>。即使用四位二进制数表示一位十进制数，使得十进制与二进制之间的转换得以快速进行。</p>
<h3 id="码">8421码</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">0011</td>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">0110</td>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">1001</td>
</tr>
</tbody>
</table>
<p><font color = "red">使用8421码进行运算时，若结果大于等于10，需要<strong>加6修正</strong>（加0110）</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dece78159862e668a33d5f2fa4d45e7.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="余三码">余三码</h3>
<p>将8421码的每一位加3（即加0011B）得到。</p>
<h3 id="码-1">2421码</h3>
<p>将最高位的权值改为2，特点是大于5的四位二进制码最高位是1，小于5的是0.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">0011</td>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1011</td>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">1101</td>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">1111</td>
</tr>
</tbody>
</table>
<h2 id="字符与字符串">字符与字符串</h2>
<h3 id="ascii码">ASCII码</h3>
<ul>
<li><font color = "red">32~126位称为可印刷字符</font></li>
<li><font color = "red">A-Z，a-z是连续的，但是Z和a之间不连续</font></li>
<li><font color = "red">以字节的形式存储</font></li>
</ul>
<hr style = "border:2px solid yellow">
<blockquote>
<p>例：已知'A'的ASCII码码值是65，H存放在某存储单元M中，求M中存放的值</p>
<p>65+(8-1)=72</p>
<p>72 = 0100 1000</p>
</blockquote>
<hr style = "border:2px solid yellow">
<h3 id="字符串">字符串</h3>
<p>字符串：IF A&gt;B THEN READ(C) ，每个存储单元存放4B</p>
<p><strong>大端模式</strong>：存储单元内<font color = "red"><strong>先存储高位字节</strong>、<strong>后存储低位字节</strong></font>的顺序</p>
<p><strong>大端方式是正常的</strong></p>
<table>
<thead>
<tr class="header">
<th>I</th>
<th>F</th>
<th>空格</th>
<th>A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;</td>
<td>B</td>
<td>空格</td>
<td>T</td>
</tr>
<tr class="even">
<td>H</td>
<td>E</td>
<td>N</td>
<td>空格</td>
</tr>
<tr class="odd">
<td>R</td>
<td>E</td>
<td>A</td>
<td>D</td>
</tr>
<tr class="even">
<td>(</td>
<td>C</td>
<td>)</td>
<td>空格</td>
</tr>
</tbody>
</table>
<p><strong>小端模式</strong>：存储单元内<strong>先存储低位字节</strong>、<strong>后存储高位字节</strong>的顺序</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>空格</th>
<th>F</th>
<th>I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>空格</td>
<td>B</td>
<td>&gt;</td>
</tr>
<tr class="even">
<td>空格</td>
<td>N</td>
<td>E</td>
<td>H</td>
</tr>
<tr class="odd">
<td>D</td>
<td>A</td>
<td>E</td>
<td>R</td>
</tr>
<tr class="even">
<td>空格</td>
<td>)</td>
<td>C</td>
<td>(</td>
</tr>
</tbody>
</table>
<h3 id="汉字编码">汉字编码</h3>
<p>包括输入的<strong>输入编码</strong>，计算机内部处理的<strong>汉字内码</strong>和输出的<strong>汉字字形码</strong>三种。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(8).png" /></p>
<h2 id="校验码">校验码</h2>
<p><strong>码距</strong>：任意两个合法码字之间不同的二进制的位数。</p>
<ul>
<li>码距大于等于2时，开始具有检错能力</li>
<li>码距越大，纠错、检错能力越强</li>
</ul>
<h3 id="奇偶校验码">奇偶校验码</h3>
<p>添加一个校验位，校验位的取值满足以下规定：</p>
<p>奇校验：这串序列1的个数如果为偶数则在前面加个1，使1的个数变成奇数，否则加0。<font color = "yellow">将1的个数凑成偶数</font>
偶校验：这串序列1的个数如果为奇数则在前面加个1，使1的个数变成偶数，否则加0。<font color = "yellow">将1的个数凑成奇数</font></p>
<hr style = "border:2px solid yellow">
<p>举例： 1111 奇校验就是 11111 偶校验就是 01111 1110 奇校验就是 01110
偶校验就是 11110</p>
<p>特性是检测一位错，无法纠错。</p>
<hr style = "border:2px solid yellow">
<h3 id="海明校验码">海明校验码</h3>
<p><a
href="https://www.cnblogs.com/godoforange/p/12003676.html">参考博客</a></p>
<p><a
href="https://www.bilibili.com/video/BV1EJ4m1H7nz/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h3 id="循环冗余校验码">循环冗余校验码</h3>
<p>循环冗余校验码包括K位数据位和R位校验位。</p>
<p>例：已知生成多项式<span class="math inline">\(G(x) = x^3 + x^2 +
1\)</span> ，信息码为101001，求对应的CRC码</p>
<h4
id="确定kr及生成多项式对应的二进制码">确定K、R及生成多项式对应的二进制码</h4>
<p>K = 7</p>
<p>R = 生成多项式的最高次幂 = 3</p>
<p>则，CRC码的位数 = K + R = 10</p>
<p>生成多项式的各次幂的系数就是对应的二进制码：1101（<em>没有x，故第二位为0</em>）</p>
<h4 id="移位">移位</h4>
<p>将信息码<strong>左移R位</strong>，低位补0</p>
<p>101001000</p>
<h4 id="模2相除">模2相除</h4>
<p>将左移后的信息码除以生成多项式的二进制码。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/37b6eeec26fec40b961c6fa1c197585.png" /></p>
<p><font color = "yellow">二进制除法是两两异或，不是相减！</font></p>
<p>最后的<strong>余数</strong>就是校验位</p>
<p>因此，CRC码 = 101001 001</p>
<p><a
href="https://www.bilibili.com/video/BV1G1421d7JA/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h4 id="检错">4、检错</h4>
<p>对于CRC码再次用生成多项式的二进制码进行<strong>模2除法</strong>，余数应为000。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.2_定点数的表示与运算</title>
    <url>/posts/e06682df.html</url>
    <content><![CDATA[<h2 id="定点数的表示">定点数的表示</h2>
<span id="more"></span>
<h3 id="无符号数和有符号数">无符号数和有符号数</h3>
<h4 id="无符号数"><strong>无符号数</strong>：</h4>
<p>整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的<strong>绝对值</strong>。</p>
<p>n位无符号数的表示范围是<span class="math inline">\(0 \sim2^n -
1\)</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0aebb4140cbbd50e56019031b3e20ce.jpg" style="zoom: 50%;" /></p>
<h4 id="有符号数">有符号数</h4>
<ul>
<li><p><strong>真值</strong>：该数字的实际值，包含正负；</p></li>
<li><p><strong>机器数</strong>：用数字表示正负号的二进制数</p></li>
<li><p><strong>定点小数</strong>：<font color = "red">约定符号位后面就是小数点</font></p>
<ul>
<li>+0.75D = 0.11B</li>
<li>-0.75D =1.11B</li>
</ul></li>
<li><p><strong>定点整数</strong>：<font color = "red">约定小数点在数值的最后</font></p>
<ul>
<li>+3D = 011.B</li>
<li>-3D = 111.B</li>
</ul></li>
<li><p>定点整数和定点小数区别和联系</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3b93aab2a8038ff1a900ffe55c2852a.jpg" style="zoom: 50%;" /></p></li>
</ul>
<h3 id="原码补码反码移码">原码、补码、反码、移码</h3>
<h4 id="原码">原码</h4>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/848000f06f9bab43c0caf5c3442d2f1.jpg" style="zoom: 50%;" /></p>
<h4 id="补码">补码</h4>
<p><font color = "yellow">补码数值位不能解读为位权，而应该先转换为原码</font></p>
<p><font color = "red">补码的-128无法转换成原码</font></p>
<p>求一个数的相反数的补码的另类小技巧</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/fb6ab00f2f1d51ce4ff8cc08d4ccb56.jpg" /></p>
<h4 id="不同码之间相互转换">不同码之间相互转换</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421190235043.png" /></p>
<h2 id="定点数的运算">定点数的运算</h2>
<h3 id="定点数的移位运算">定点数的移位运算</h3>
<h4 id="算术移位">算术移位</h4>
<h5 id="原码-1">原码</h5>
<p><a
href="https://www.bilibili.com/video/BV1ju4m1F7LR/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">原码视频讲解</a></p>
<p>符号位保持不变，仅对数值位进行移位。</p>
<p>右移:高位补0，低位舍弃。若舍弃的位=0，则相当于-2;若舍弃的位0，则会丢失精度</p>
<p>左移:低位补0，高位舍弃。若舍弃的位=0，则相当于x2:若舍弃的位0，则会出现严重误差</p>
<p><a
href="https://www.bilibili.com/video/BV13J4m1H7JZ/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解为什么右移能实现除以2</a></p>
<h5 id="反码">反码</h5>
<p><font color = "yellow">正数与原码相同，负数补1</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421205101972.png" /></p>
<hr style = "border:2px solid yellow">
<h5 id="补码-1">补码</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421212010461.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1GF4m1P7NR/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">补码的左右移视频讲解</a></p>
<p><font color = "yellow">正数与原码相同</font></p>
<p><font color = "yellow">负数右移，高位出现空位，高位与反码相同，所以补1</font></p>
<p><font color = "yellow">负数左移，低位出现空位，低位与原码相同，所以补0</font></p>
<h5 id="不同码移位">不同码移位</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421210532352.png" /></p>
<p><a href="">视频讲解：如何通过移位实现乘法</a></p>
<h4 id="逻辑移位">逻辑移位</h4>
<p><font color = "red">都补0</font></p>
<p><a
href="https://www.bilibili.com/video/BV1tE421M7ff/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：逻辑移位在RGB颜色表示中的应用</a></p>
<h4 id="循环移位">循环移位</h4>
<p><a
href="https://www.bilibili.com/video/BV1hz421k7o6/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：循环移位</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f4f2c08cbf25c629cf98b343c2420b9.png" /></p>
<h3 id="加减法">加减法</h3>
<p><font color  = "yellow">全部转换得到补码后相加，其中减法就是转换成相反数的的补码后再相加</font>（无论有符号数还是无符号数，都转成补码）</p>
<hr style = "border:2px solid yellow">
<p>举例：
<img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/1210195b519767f284585841a64be1c.jpg" style="zoom: 33%;" /></p>
<hr style = "border:2px solid yellow">
<h3 id="溢出的概念和判断方式">溢出的概念和判断方式</h3>
<ul>
<li>大于机器所能表示的最大正数称为<strong>上溢</strong>；</li>
<li>小于机器所能表示的最小负数称为<strong>下溢</strong>。</li>
<li>当两个符号<strong>相同</strong>的数<strong>相加</strong>或者两个符号<strong>相异</strong>的数<strong>相减</strong>时才会发生溢出。</li>
</ul>
<p>对溢出的判断有几种方式：</p>
<h4 id="采用一位符号位">采用一位符号位</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423055959832.png" /></p>
<h4
id="采用一位符号位根据数据位进位情况判断溢出">采用一位符号位根据数据位进位情况判断溢出</h4>
<p>即“模2补码”。</p>
<p>设符号位的进位 CS，最高数位的进位 C1，则当 CS 和 C1
不同时发生溢出。</p>
<h4 id="采用双符号位">采用双符号位</h4>
<p>即“模4补码”。</p>
<p>正数符号位为00，负数符号位为11。</p>
<p>记两个符号位分别为 S1 和 S2，则 V = S1 ⊕
S2，若V=0，无溢出；V=1，有溢出。</p>
<p>00：正数无溢出</p>
<p>01：正数有溢出</p>
<p>11：负数无溢出</p>
<p>10：负数有溢出</p>
<p>模4补码存储时仍然为一个符号位，因为正确的表示两位符号位必然是相同的</p>
<p>当送入ALU时，才将原来的符号位同时送入ALU的双符号位中</p>
<h3 id="定点数的乘法运算">定点数的乘法运算</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c5e7a3ddf5eee94a722539bd7a34175.png" /></p>
<h4 id="原码一位乘法">原码一位乘法</h4>
<p><a
href="https://www.bilibili.com/video/BV1qE421K7BK/?spm_id_from=333.999.0.0">视频讲解：计算机原码一位乘法原理</a></p>
<p><a
href="https://www.bilibili.com/video/BV1Xz421679q/?spm_id_from=333.999.0.0">视频讲解：实操手工模拟计算机原码一位乘法运算</a></p>
<h4 id="补码一位乘法">补码一位乘法</h4>
<p><a
href="https://www.youtube.com/watch?v=SAFbPZ4H2dQ">视频讲解：计算机补码一位乘法原理</a></p>
<p>乘数增加了一个辅助位，原来表示数值的有n位，表示符号的有1位，现在增加了一个辅助位，变成n+2位。</p>
<p>被乘数和存储结果的也增加1位，所以用双符号位</p>
<p><font color = "red">1. 双符号位</font></p>
<p><font color = "red">2. 算术右移</font></p>
<p><font color = "red">3. 三种选择</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423233748320.png" /></p>
<p><a href="">视频讲解：实操手工模拟计算机补码一位乘法运算</a></p>
<h3 id="定点数除法运算">定点数除法运算</h3>
<h4 id="原码恢复余数法">原码恢复余数法</h4>
<p><a
href="https://www.youtube.com/watch?v=d3lWTapHFs4">视频讲解：原码恢复余数法</a></p>
<p><a
href="https://www.bilibili.com/video/BV1am421s74C/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：手工模拟原码恢复余数法</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423160942750.png" /></p>
<h4 id="原码加减交替法">原码加减交替法</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240424173514275.png" /></p>
<p><a href="">视频讲解：手工模拟原码除法之加减交替法</a></p>
<h4 id="补码加减交替法">补码加减交替法</h4>
<h2 id="整数型及类型转换">整数型及类型转换</h2>
<ul>
<li><p>长整数变为短整数：0x000286a1 --&gt; 0x86a1（截断高位）</p></li>
<li><p>短整数变为长整数：<strong>符号扩展</strong></p></li>
<li><p>有符号数变为无符号数：0xef1f（真值-3421） --&gt;
0xef1f（真值61215）<font color = "red">不改变数据内容，改变解释方式</font></p></li>
</ul>
<h2 id="数据的存储和排列">数据的存储和排列</h2>
<h3 id="大小端模式">大小端模式</h3>
<p>都是对于多字节数据</p>
<ul>
<li><p><strong>大端</strong>：类似正常阅读方式</p></li>
<li><p><strong>小端</strong>：倒过来</p></li>
</ul>
<h3 id="边界对齐">边界对齐</h3>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.3_浮点数的表示和运算</title>
    <url>/posts/9b0b5055.html</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<span id="more"></span>
<h3 id="大端存储与小端存储">大端存储与小端存储</h3>
<p><a
href="https://www.bilibili.com/video/BV1xC4113747/?spm_id_from=333.999.0.0">视频讲解：大端与小端</a></p>
<p>边界对齐</p>
<p><a
href="https://www.bilibili.com/video/BV1rF4m1P7mM/?spm_id_from=333.999.0.0">视频讲解：边界对齐</a></p>
<p>如何将字地址转换成与之对应的字节地址</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5b5e6e4dc2fdfeefde9626c6676916b.jpg" /></p>
<h2 id="浮点数的表示">浮点数的表示</h2>
<h3 id="浮点数的表示-1">浮点数的表示</h3>
<p><a
href="https://www.bilibili.com/video/BV1st421j7RQ/?spm_id_from=333.999.0.0">视频讲解：浮点数表示</a></p>
<p>浮点数通常表示为：</p>
<p>$ N = r^E * M$</p>
<ul>
<li>r：阶码的底，通常为2</li>
<li>E：<strong>阶码</strong>，反映浮点数的表示范围和小数点的实际位置，用<strong>补码或移码</strong>表示</li>
<li>M：<strong>尾数</strong>，其位数反映了小数的精度，用<strong>原码或补码</strong>表示</li>
</ul>
<blockquote>
<p>例：阶码和尾数都用补码表示，求a、b的真值</p>
<ul>
<li>a = 0,01; 1.1001</li>
<li>b = 0,01; 0.01001</li>
</ul>
<p>a：</p>
<ul>
<li>阶码0,01对应真值+1</li>
<li>尾数1.1001(补码)对应真值(先转换成原码)-0.0111</li>
<li>故 a=-0.111(B)(上面二进制小数点右移1位) = <span
class="math inline">\(-\frac{7}{8}\)</span></li>
</ul>
<p>b：</p>
<ul>
<li>阶码对应真值+1</li>
<li>尾数0.01001对应真值+0.01001</li>
<li>故 b=0.1001=<span class="math inline">\(\frac{9}{16}\)</span></li>
</ul>
</blockquote>
<h3 id="浮点数的规格化">浮点数的规格化</h3>
<p><a
href="https://www.bilibili.com/video/BV11u4m1F7gQ/?spm_id_from=333.999.0.0">视频讲解：浮点数规格化</a></p>
<p>规定尾数的最高位必须是一个有效值。</p>
<p><strong>左规</strong>：当浮点数运算的结果为非规格化时要进行规格化处理，将<font color = "red">尾数左移一位，阶码减1
( 基数为2时)</font>：</p>
<hr style = "border:2px solid yellow">
<p>举例：
<img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/06fd8146622a1827a81f5e657cea78f.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<p><strong>右规</strong>：当浮点数运算的结果尾数出现溢出(双符号位为01或10)时，将<font color = "red">尾数右移一位，阶码加1
(基数为2时)</font></p>
<blockquote>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422070143607.png" /></p>
</blockquote>
<h3 id="规格化数的特点">规格化数的特点</h3>
<h4 id="如何判断需要规格化">如何判断需要规格化</h4>
<p><font color = "yellow">1. 原码位数最高位必须是1</font></p>
<p><font color = "yellow">2. 补码尾数最高位必须和尾数符号相反</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/de3c63bb5369dbe0536bb24b31f925d.jpg" /></p>
<hr style = "border:2px solid yellow">
<h4 id="规格化的小数所能表示范围">规格化的小数所能表示范围</h4>
<p>原码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074440544.png" /></p>
<p>补码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074452583.png" /></p>
<p>上溢和下溢</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074712134.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/92426731dcfb987b1187617cd2ad0c2.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="ieee754-标准">IEEE754 标准</h3>
<h4 id="移码的2种求法">移码的2种求法</h4>
<p><font color = "yellow">移码的求法1：移码 = 真值 + 偏置值
，通常偏置值取常数 <span class="math inline">\(2^{n -
1}\)</span></font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422083436691.png" /></p>
<hr style = "border:2px solid yellow">
<p><font color = "yellow">移码的求法2：说白了就是将符号位取反</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421193207355.png" style="zoom:50%;" /></p>
<blockquote>
<p>注：<font color = "red">移码只能表示整数，不能表示小数</font></p>
</blockquote>
<h4 id="ieee754标准下的浮点数表示">IEEE754标准下的浮点数表示</h4>
<p><a
href="https://www.bilibili.com/video/BV1Zm421x7UD/?spm_id_from=333.999.0.0">视频讲解：IEEE754标准下的移码</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423071008688.png" /></p>
<p>尾数前隐含一位1</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">数阶</th>
<th style="text-align: center;">阶码</th>
<th style="text-align: center;">尾数数值</th>
<th style="text-align: center;">总位数</th>
<th style="text-align: center;">偏置值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">短浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">7FH（127）</td>
</tr>
<tr class="even">
<td style="text-align: center;">长浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">3FFH（1023）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">临时浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">3FFFH</td>
</tr>
</tbody>
</table>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423065106995.png" /></p>
<p>对于短浮点数而言，<strong>偏置值取127</strong>，此时阶码（移码）的表示范围为<strong>-126~127</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">真值</th>
<th style="text-align: center;">补码</th>
<th style="text-align: center;">移码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">-128</td>
<td style="text-align: center;">1000 0000</td>
<td style="text-align: center;">1111 1111</td>
</tr>
<tr class="even">
<td style="text-align: center;">-127</td>
<td style="text-align: center;">1000 0001</td>
<td style="text-align: center;">0000 0000</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-126</td>
<td style="text-align: center;">1000 0010</td>
<td style="text-align: center;">0000 0001</td>
</tr>
<tr class="even">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0000 0000</td>
<td style="text-align: center;">0111 1111</td>
</tr>
<tr class="even">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
</tr>
<tr class="odd">
<td style="text-align: center;">127</td>
<td style="text-align: center;">0111 1111</td>
<td style="text-align: center;">1111 1110</td>
</tr>
</tbody>
</table>
<p>-128和-127的作用：</p>
<p>E=0且 M=0，则真值为0；</p>
<p>E=0且 E≠0 M≠0，为非规格化数，真值 = (-1)^S ×0.M×2^(-126)；</p>
<p>E=255且 E≠0 M≠0，真值为‘NaN’（非数值）；</p>
<p>E=255且 E=0 M=0，真值为正或负无穷。</p>
<hr style = "border:2px solid yellow">
<p>例1：十进制小数转单精度浮点数</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/af766190e0070c5504a7528d5b4c821.jpg" style="zoom:50%;" /></p>
<p>例2：单精度浮点数转十进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/60fc6faf0ce444809c6004dab570fc8.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<h2 id="浮点数的运算">浮点数的运算</h2>
<h3 id="加减运算">加减运算</h3>
<p><strong>步骤</strong>：</p>
<ol type="1">
<li><p>对阶</p></li>
<li><p>尾数加减</p></li>
<li><p>规格化</p></li>
<li><p>舍入</p></li>
<li><p>判溢出</p></li>
</ol>
<blockquote>
<p>例：已知十进制数�=−5256<em>X</em>=−2565、�=+591024<em>Y</em>=+102459，按机器补码浮点运算规则计算X-Y，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位</p>
</blockquote>
<blockquote>
<p>5�=101�,1256=2−8�=−101×2−8=−0.101×2−5�=−0.101×2−101</p>
<ul>
<li><p>阶码</p>
<ul>
<li><p>-101，补码为：1011</p></li>
<li><p>阶符取两位、阶码取三位：11011</p></li>
</ul></li>
<li><p>尾数</p>
<ul>
<li><p>-0.101，补码为1.011</p></li>
<li><p>数符取两位，尾数取九位：11.011000000</p></li>
</ul></li>
<li><p>可得X：11011；11.011000000</p></li>
</ul>
<p>同理：59�=111011�,11024=2−10�=+111011×2−10=+0.111011×2−4�=+0.111011×2−100</p>
<ul>
<li><p>阶码</p>
<ul>
<li><p>-100，补码为1100</p></li>
<li><p>阶符取两位、阶码取三位：11100</p></li>
</ul></li>
<li><p>尾数</p>
<ul>
<li><p>+0.111011，补码为0.111011</p></li>
<li><p>数符取两位，尾数取九位：00.111011000</p></li>
</ul></li>
</ul>
</blockquote>
<h4 id="对阶">（1）对阶</h4>
<p>使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1。</p>
<blockquote>
<p>[Δ�]补=11011−11100=11011+00100=11111[Δ<em>E</em>]补=11011−11100=11011+00100=11111</p>
<p>11111为-1的补码，故 Δ�=−1Δ<em>E</em>=−1 ，X的阶码比Y的阶码小1</p>
<p>阶码每加1，尾数右移一位，则有新的X：11100；11.101100000（右移之后前面补1）</p>
<p>此时， �=−0.0101×2−100<em>X</em>=−0.0101×2−100</p>
</blockquote>
<h4 id="尾数相加减">（2）尾数相加减</h4>
<blockquote>
<p>首先有 -Y= 11100；11.000101000</p>
<p>尾数相加，得：</p>
<p>11.101100000+11.00010100010.11000100011.101100000+11.00010100010.110001000</p>
<p>相当于提取公因式</p>
</blockquote>
<h4 id="规格化">（3）规格化</h4>
<blockquote>
<p>由于上一步发生了溢出，因此需要右规</p>
<p>尾数右移一位，阶码加1，得：X-Y=11101；11.011000100</p>
</blockquote>
<h4 id="舍入">（4）舍入</h4>
<p><strong>“0”舍“1”入法</strong>：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，
则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。</p>
<p><strong>恒置“1”法</strong>：尾数右移时，不论丢掉的最高数值位是“1”还是“0”，
都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</p>
<p>无舍入</p>
<h4 id="判断溢出">（5）判断溢出</h4>
<p>未发生溢出</p>
<p>结果真值为 2−3×(−0.1001111)22−3×(−0.1001111)2</p>
<h3 id="强制类型转换">2、强制类型转换</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">16位机器</th>
<th style="text-align: center;">32位机器</th>
<th style="text-align: center;">64位机器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">char</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;">short</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="even">
<td style="text-align: center;">long</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">64</td>
</tr>
<tr class="odd">
<td style="text-align: center;">long long</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
</tr>
<tr class="even">
<td style="text-align: center;">float</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="odd">
<td style="text-align: center;">double</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
</tr>
</tbody>
</table>
<p>char --&gt; int --&gt; long --&gt; double 以及 float --&gt;
double，不会损失精度。</p>
<p>对于32位系统：</p>
<ul>
<li><p>int：表示整数，范围为 −231∼231−1−231∼231−1，有效数字32位</p></li>
<li><p>float：表示整数及小数，范围
±[2−126∼2127×(2−2−23)]±[2−126∼2127×(2−2−23)]
，有效数字23+1=24位</p></li>
<li><p>int --&gt; float：可能损失精度（有效数字比float多）</p></li>
<li><p>float --&gt;
int：可能<strong>溢出</strong>（超出int表示范围）及损失精度（小数部分）</p></li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.4_算数逻辑单元（ALU）</title>
    <url>/posts/cef77967.html</url>
    <content><![CDATA[<h1 id="算数逻辑单元alu">算数逻辑单元（ALU）</h1>
<span id="more"></span>
<p><a
href="https://www.bilibili.com/video/BV1pD421H7mr/?spm_id_from=333.999.0.0">视频讲解：ALU简单介绍</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7843cf0508bb476543d2c1c547f52cd.png" /></p>
<h2 id="串行加法器和并行加法器">串行加法器和并行加法器</h2>
<h3 id="一位全加器">一位全加器</h3>
<p><a
href="https://www.bilibili.com/video/BV1DE421L729/?spm_id_from=333.999.0.0">视频讲解：对于一位全加器的基本介绍</a></p>
<h3 id="并行加法器">并行加法器</h3>
<h4 id="串行进位的并行加法器">串行进位的并行加法器</h4>
<p>把n个全加器串接起来，就可进行两个n位数的相加。</p>
<h4 id="并行进位的并行加法器">并行进位的并行加法器</h4>
<p><a
href="https://www.bilibili.com/video/BV1uT421C7FB/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：并行进位的并行加法器的简单介绍</a></p>
<h2 id="补码加减法运算器">补码加/减法运算器</h2>
<h3 id="加法器原理">加法器原理</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/2495851f0916f05bab3abe06c9c3d2c.png" /></p>
<p>例1：A=1000，B=0111，Cin=0</p>
<p>则：F=1111，Cout=0</p>
<p>例2：A=1000，B=0111，Cin=1</p>
<p>则：F=0000，Cout=1</p>
<h3 id="补码加减器">补码加减器</h3>
<p><a
href="https://www.bilibili.com/video/BV1mm41127Qw/?spm_id_from=333.999.0.0">视频讲解：补码加减器的设计</a></p>
<p><strong>补码加减法原理</strong>：</p>
<p>X+Y：直接按位相加</p>
<p>X-Y：</p>
<ol type="1">
<li><p>Y全部按位取反，末位+1</p></li>
<li><p>减法变加法</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7af15bf708439501c0acf81000143b8.png" /></p>
<p><strong>Sub信号的作用</strong></p>
<ul>
<li><p>控制多路选择器的输出</p></li>
<li><p>若计算减法时，1同时输入到Cin，用作补码取反后的+1</p></li>
</ul>
<blockquote>
<p>例：4bit补码，X=-8，Y=7</p>
<p><span class="math inline">\(\text{X}*{补} = 1000\)</span>，<span
class="math inline">\(\text{Y}*{补} = 0111\)</span></p>
<p>X+Y：直接输出：1111B（补）=-1D</p>
<p>X-Y：1000+（1000+1）=0001B（补）（产生溢出）</p>
</blockquote>
<p><strong>这一电路同样适用于无符号数的加减法</strong>，原理完全一致，<font color = "red">但是判断溢出标准不同</font></p>
<p><font color = "yellow">计算机中是不会判断什么有符号无符号数，它设计出的硬件都是按0/1做运算，是人都结果做出了不同的解释</font></p>
<h2 id="标志位">标志位</h2>
<h3 id="有符号数">有符号数</h3>
<h4 id="of溢出标志位">OF：溢出标志位</h4>
<ul>
<li><p>最高位产生的进位与次高位产生的进位异或</p></li>
<li><p><strong>判断有符号数的溢出</strong>，<font color = "yellow">对无符号数没有意义</font></p></li>
</ul>
<h4 id="sf符号标志位">SF：符号标志位</h4>
<ul>
<li>取运算结果的最高位</li>
</ul>
<blockquote>
<p>例：4bit补码，X=-8，Y=7</p>
<p>X补=1000，Y补=0111</p>
<p>X+Y</p>
<p>直接输出：1111B（补）=-1D</p>
<p>OF=0 ⊕ 0=0：没有溢出</p>
<p>SF=1：结果是负数</p>
<p>X-Y</p>
<p>1000+(1000+1)=0001B</p>
<p>OF=1 ⊕ 0=1：产生了溢出</p>
<p>SF=0：结果是正数</p>
</blockquote>
<h3 id="无符号数">无符号数</h3>
<h4 id="zf零标志位">ZF：零标志位</h4>
<ul>
<li>运算结果全部为零</li>
</ul>
<h4 id="cf进位标志">CF：进位标志</h4>
<ul>
<li><p>最高位的进位信号与sub进行异或</p></li>
<li><p>为1代表发生了借位，产生溢出</p></li>
<li><p><strong>判断无符号数的溢出</strong></p></li>
</ul>
<blockquote>
<p>例：4bit原码，无符号数X=3，Y=4</p>
<p>X=0011B，Y=0100B</p>
<p>X+Y</p>
<p>直接输出：0111B（原）=7D</p>
<p>ZF：0</p>
<p>CF：0 ⊕ 0=0</p>
<p>X-Y</p>
<p>0011+(1011+1)=1111B（原）</p>
<p>ZF：0</p>
<p>CF：0 ⊕ 1=1（产生了借位溢出）</p>
</blockquote>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第一部分_指令讲解</title>
    <url>/posts/a9d0efb2.html</url>
    <content><![CDATA[<h1 id="add-sub">add， sub</h1>
<span id="more"></span>
<p>这一类进位是直接扔掉</p>
<h1 id="muldiv">mul，div</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240426112624542.png" /></p>
<p><a
href="https://www.youtube.com/watch?v=4DJLf9CcL1o">总结：视频讲解</a></p>
<h1 id="左右移">左右移</h1>
<p>记住左右移就可以了，下面这个了解即可</p>
<p><a
href="https://www.youtube.com/watch?v=DOsO44x0ZZM">视频讲解：循环左移和左移区别</a></p>
<h1 id="交换">交换</h1>
<p><a
href="https://www.youtube.com/watch?v=CEdLcWrOtMw">视频讲解</a></p>
<h1 id="取反">取反</h1>
<p><a
href="https://www.youtube.com/watch?v=j7LAWs8ZwvA">视频讲解</a></p>
<h1 id="强转">强转</h1>
<p><a
href="https://www.youtube.com/watch?v=ZSv3Wb5tCfo">视频讲解</a></p>
<h1 id="中断">中断</h1>
<p>大意就是运行到终端指令后跳转到另一个地址执行这个地址指向的代码</p>
<p><a
href="https://www.youtube.com/watch?v=TlMCO0tEY6s">视频讲解</a></p>
<h1 id="cmp">CMP</h1>
<p>CMP AX, BX</p>
<p>AX - BX</p>
<p>如果AX &lt; BX， 借位， CF = 1</p>
<p>如果AX &gt; BX，不用借位， CF = 0</p>
<p>如果AX = BX，ZF = 1</p>
<p><a
href="https://www.youtube.com/watch?v=zgTDIypy7II">视频讲解</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第三部分_高级函数</title>
    <url>/posts/d5498d98.html</url>
    <content><![CDATA[<h1 id="循环loop">循环loop</h1>
<span id="more"></span>
<p>先CX -
1，然后判断CX是否为0，如果不是0跳转到之前设置的LABEL出，如果是0继续向下执行</p>
<hr style = "border:2px solid yellow">
<p>举例：等差数列求和，第一项是1，公差是2，一共有5项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:</span><br><span class="line">    MOV CX, 4</span><br><span class="line">    MOV AX, 1  </span><br><span class="line">    MOV BX, 1</span><br><span class="line">    LABEL: </span><br><span class="line">        ADD BX, 2 </span><br><span class="line">        ADD AX, BX </span><br><span class="line">        LOOP LABEL   </span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h1 id="汇编中函数的封装">汇编中函数的封装</h1>
<h2 id="call和ret">CALL和RET</h2>
<p>CALL相当于压栈，压入的是IP,这个IP是CALL的下一个语句的IP，否则就死循环了</p>
<p>RET相当于弹栈，弹出的是IP</p>
<p><a href="https://youtube.com/watch?v=P-ppy8iRcEY">视频讲解</a></p>
<h2 id="call-far-和-retf">CALL FAR 和 RETF</h2>
<p>相对于上面同时压/弹CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=MdKNEJp09L8">视频讲解</a></p>
<p><a
href="https://www.youtube.com/watch?v=9Nyugxx2_gw">视频讲解：单独使用RET会陷入死循环</a></p>
<p><a
href="https://www.youtube.com/watch?v=OSla3HtKmeQ">视频讲解：单独使用CALL程序会跳转后顺序执行</a></p>
<p>一个段的大小是16字节，从物理地址 = 段地址 * 16 +
偏移地址就可以看出来</p>
<h1 id="offset">OFFSET</h1>
<p>取偏移地址</p>
<hr style = "border:2px solid yellow">
<p>举例：将s处一条指令复制到s0</p>
<p><a
href="https://www.youtube.com/watch?v=rV23Eewgdu8">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h1 id="jmp">JMP</h1>
<h2 id="短跳转和长跳转">短跳转和长跳转</h2>
<p>短跳转只修改IP，且只存储相对距离（从JMP的下一条指令开始计算）</p>
<p>长跳转修改CS和IP，同时存储目标跳转的CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=OwuuAYreMho">视频讲解</a></p>
<h2 id="word-ptr-和-dword-ptr">word ptr 和 dword ptr</h2>
<p>word ptr读1个字，所以作为IP</p>
<p>dword ptr 读2个字，所以作为CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=6-PeurxPXMs">视频讲解</a></p>
<h1 id="数组">数组</h1>
<ol type="1">
<li><p>arr[2]:这个表示先找到arr对应地址，再在这个地址基础上加2个字节，而不是表示找arr数字第三个元素</p></li>
<li><p>虽然ASSUME DS:DATA表示将DATA段映射到DS寄存器，但是如果没有MOV AX,
DATA MOV DS,
AX依然无效。因为此时DS寄存器里的值和代码段DATA不一样</p></li>
<li><p>可以在一个数组前添上1个标号表示这个数组（相当于变量名）ARR DB
01H, 02H, 03H ARR就是标号</p>
<p><a
href="https://www.youtube.com/watch?v=C70HwHfBURc">视频讲解</a></p></li>
</ol>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第二部分_寄存器</title>
    <url>/posts/8e5029c4.html</url>
    <content><![CDATA[<h1 id="逻辑地址和物理地址">逻辑地址和物理地址</h1>
<span id="more"></span>
<p>物理地址 = 逻辑地址 * 16 + 偏移地址</p>
<p>如果有[]，默认情况下相当于将[]里面的地址加到DS上，形成物理地址</p>
<p><a
href="https://www.youtube.com/watch?v=Ayyrrxe8e7M">视频讲解</a></p>
<h1 id="csip寄存器和jmp指令">CS、IP寄存器和JMP指令</h1>
<p>CS、IP表示代码要执行的位置的指针，其中CS是段地址，IP是偏移地址</p>
<p><a
href="https://www.youtube.com/watch?v=k8HAgmXat8w">视频讲解</a></p>
<p>JMP 1000, 0：表示将CS修改为1000H， IP修改为0000H</p>
<p>JMP BX：表示CS不变，IP修改为BX里所包含的值</p>
<p><a
href="https://www.youtube.com/watch?v=Xgmz731YnUQ">视频讲解</a></p>
<h1 id="sssp寄存器和pushpop">SS、SP寄存器和PUSH，POP</h1>
<p>栈的下面地址大，上面地址小</p>
<p>SP始终指向栈顶元素</p>
<p>PUSH是先存元素，然后SP减2</p>
<p>POP是先读元素，然后SP加2</p>
<p><a
href="https://www.youtube.com/watch?v=rjnNvXgbMiY">视频讲解</a></p>
<h1 id="不同寻址方式">不同寻址方式</h1>
<p>带方括号表示里面的值作为偏移地址</p>
<p>不带方括号就是直接取里面的值</p>
<p><a
href="https://www.youtube.com/watch?v=m2ZV6Z8pi2E">视频讲解</a></p>
<h1 id="di和si寄存器">DI和SI寄存器</h1>
<p>[BX + AX] 错</p>
<p>[BX + DI] 对</p>
<p>[BX + SI + DI] 错，SI和DI只能出现1个</p>
<h1 id="bp寄存器">BP寄存器</h1>
<p>BP寄存器默认段地址是SS</p>
<p>BX与BP只能出现1个</p>
<p><a
href="https://www.youtube.com/watch?v=xconC5zUGOY">视频讲解</a></p>
<h1 id="标志寄存器">标志寄存器</h1>
<p><a
href="https://www.bilibili.com/video/BV1uT421C7rz/?spm_id_from=333.999.0.0">视频讲解：关于溢出和进位区别</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第四章_基本汇编语言程序设计_1</title>
    <url>/posts/a122e292.html</url>
    <content><![CDATA[<h1 id="顺序程序设计">顺序程序设计</h1>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>利用学号查学生的数学成绩表</p>
<p>算法分析：首先在数据段中建立一个成绩表TABLE，在表中各学生的成绩按照学号从小到大的顺序存放。要查的学号存放在变量NUM中，查表的结果放在变量MATH中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TITLE   TABLE LOOKUP</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT</span><br><span class="line">    TABLE DB 81,78,90,64,85,76,93,82,57,80</span><br><span class="line">          DB 73,62,87,77,74,86,95,91,82,71</span><br><span class="line">    NUM   DB 8</span><br><span class="line">    MATH  DB ?</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">    DW 20H DUP(0)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">COSEG   SEGMENT</span><br><span class="line">    ASSUME CS:COSEG, DS:DATA, SS:STACK1</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    MOV BX, OFFSET TABLE    ; BX指向表首址</span><br><span class="line">    XOR AH, AH</span><br><span class="line">    MOV AL, NUM             ; 找第8个学生，但是下标是7</span><br><span class="line">    DEC AL</span><br><span class="line">    ADD BX, AX              ; BX加上学号指向要查的成绩</span><br><span class="line">    MOV AL, [BX]            ; 查到成绩送AL</span><br><span class="line">    MOV MATH, AL            ; 存结果</span><br><span class="line">    MOV AH, 4CH             ; 返回DOS</span><br><span class="line">    INT 21H</span><br><span class="line">COSEG   ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a href="">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h1 id="分支程序设计">分支程序设计</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240426074513737.png" /></p>
<h2 id="转移指令">转移指令</h2>
<p>格式: JMP 目标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:</span><br><span class="line">JMP TARGET</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line">TARGET:</span><br><span class="line">    ...........</span><br><span class="line">    :</span><br></pre></td></tr></table></figure>
<h2
id="用比较测试指令条件转移指令实现分支">用比较/测试指令+条件转移指令实现分支</h2>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章_汇编语言程序格式_1</title>
    <url>/posts/c5c98601.html</url>
    <content><![CDATA[<h1 id="完整段定义的伪操作">完整段定义的伪操作</h1>
<span id="more"></span>
<p>8086/8088在管理内存时，需要按照逻辑段进行划分，不同的逻辑段可以用来存放不同目的的数据。在程序中使用四个段寄存器CS,DS,ES和SS来访问它们。</p>
<h2 id="段定义伪指令">段定义伪指令</h2>
<p>一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名   SEGMENT   [定位类型] [组合类型] [‘类别名&#x27;]</span><br><span class="line">             …...</span><br><span class="line">             ... ...         本段语句序列</span><br><span class="line">             … ...</span><br><span class="line">段名    END</span><br></pre></td></tr></table></figure>
<h3 id="定位类型">定位类型</h3>
<p>定位类型用于决定段的起始边界，即<font color = "red">第一个可存放数据的位置（不是段基址）</font></p>
<h4 id="page">PAGE</h4>
<p>表示该段从一个页面的边界开始</p>
<p>由于<font color = "red">一个页面为256个字节，并且页面编号从0开始</font>，因此，PAGE定位类型的段起始地址的最后8位二进制数一定为0，即以00H结尾的地址。</p>
<h4 id="para">PARA</h4>
<p>表示该段从一个小节的边界开始</p>
<p><font color = "red">如果用户未选定位类型，则缺省为PARA。</font></p>
<h4 id="word">WORD</h4>
<p>表示该段从一个偶数字节地址开始，即段起始单元地址的最后一位二进制数一定是0。</p>
<h4 id="byte">BYTE</h4>
<p>表示该段起始单元地址可以是任一地址值。</p>
<blockquote>
<p>注意：定位类型为PAGE和PARA时，段起始地址与段基址相同。定位类型为WORD和BYTE时，段起始地址与段基址可能不同。</p>
</blockquote>
<h3 id="组合类型">组合类型</h3>
<p>用来指定段与段之间的连接关系和定位</p>
<h4 id="none">NONE</h4>
<p>若未指定组合类型，表示本段与其它段无连接关系。在装入内存时，本段有自己的物理段，因此有自己的段基址。</p>
<h4 id="public">PUBLIC</h4>
<p>在满足定位类型的前提下，将不同模块的同名段邻接在一起，形成一个新的逻辑段，共用一个段基址。段内的所有偏移量调整为相对于新逻辑段段基址的偏移量</p>
<h4 id="common">COMMON</h4>
<p>产生一个覆盖段。在多个模块连接时，把该段与其它也用COMMON说明的同名段置成相同的段基址，这样就达到了共享同一存储区。共享存储区的长度由同名段中最大的段确定。</p>
<h4 id="stack">STACK</h4>
<p>把所有同名段连接成一个连续段，且系统自动对SS段寄存器初始化为该连续段的段基址。并初始化堆栈指针SP。</p>
<p><font color = "red">
用户程序中应至少有一个段用STACK说明，否则需要用户程序自己初始化SS和SP。</font></p>
<h4 id="at表达式">AT表达式</h4>
<p>表示本段可定位在表达式所指示的小节边界上。表达式的值也就是段基值。</p>
<h4 id="memory">MEMORY</h4>
<p>表示本段在存储器中应定位在所有其它段这之后的最高地址上。如果有多个用MEMORY说明的段，则只处理第一个用MEMORY说明的段。其余的被视为COMMON</p>
<h3 id="类别名">类别名</h3>
<p>类别名为某一个段或几个相同类型段设定的类型名称。系统在进行连接处理时，把<font color = "red">类别名相同的段存放在相邻的存储区</font>，但段的划分与使用仍按原来的设定。</p>
<blockquote>
<p>在定义一个段时，段名是必须有的项，而定位类型、组合类型和类别名三个参数是可选项。各个参数之间用空格分隔。<font color = "red">各参数之间的顺序不能改变。</font></p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STACK1   SEGMENT PARA STACK &#x27;STACK0&#x27;</span><br><span class="line">         .....</span><br><span class="line">STACK1   ENDS</span><br><span class="line"></span><br><span class="line">DATA1    SEGMENT PARA &#x27;DATA&#x27;</span><br><span class="line">         ......</span><br><span class="line">DATA1    ENDS</span><br><span class="line"></span><br><span class="line">STACK2   SEGMENT PARA &#x27;STACK0&#x27;</span><br><span class="line">         ......</span><br><span class="line">STACK2   ENDS</span><br><span class="line"></span><br><span class="line">CODE     SEGMENT PARA MEMORY</span><br><span class="line">         ASSUME CS:CODE, DS:DATA1, SS:STACK1</span><br><span class="line">MAIN:</span><br><span class="line">         ......</span><br><span class="line">         ......</span><br><span class="line">CODE     ENDS</span><br><span class="line"></span><br><span class="line">         END MAIN</span><br><span class="line"></span><br><span class="line">DATA2    SEGMENT BYTE &#x27;DATA&#x27;</span><br><span class="line">         ......</span><br><span class="line">DATA2    ENDS</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1HE421u7pw/?spm_id_from=333.1007.top_right_bar_window_history.content.click">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="段寻址伪指令">段寻址伪指令</h2>
<p>段寻址伪指令ASSUME的作用是告诉汇编程序,在处理源程序时，<font color = "yellow">定义的段与哪个寄存器关联</font>。并不设置各个段寄存器的具体内容，段寄存器的值是在程序运行时设定的。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240410064410369.png" /></p>
<p><font color = "yellow">问题：这个怎么在emu8086中看？</font></p>
<blockquote>
<p>注：可以使用关键字NOTHING将前面的设置删除。</p>
<p>ASSUME ES:NOTHING ;删除前面对ES与某个定义段的关联 ASSUME NOTHING
;删除全部4个段寄存器的设置</p>
</blockquote>
<h2 id="段寄存器的装入">段寄存器的装入</h2>
<h3 id="ds和es的装入">DS和ES的装入</h3>
<p><font color = "red">没有声明就无法装入</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d6c268d1985627b4718651b066ef308.jpg" /></p>
<blockquote>
<pre><code>为了改正上述程序中的错误，可以在变量DBYTE2前加一个段前缀说明即可。即：
MOV  ES:DBYTE2[2],  AL</code></pre>
</blockquote>
<p><a
href="https://www.bilibili.com/video/BV1Pt421N7L1/?spm_id_from=333.1007.top_right_bar_window_dynamic.content.click&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><font color = "red">初步小结：貌似既需要用ASSMUE指定段分配到哪个段寄存器里面，也要将段的首地址分配到段寄存器里面？</font></p>
<h3 id="ss的装入">SS的装入</h3>
<p><a href="">视频讲解</a></p>
<h4 id="法一">法一：</h4>
<p><font color = "yellow">1. 组合类型使用STACK参数</font></p>
<p><font color = "yellow">2. ASSUME语句与SS关联</font></p>
<p><font color = "yellow">3.
栈顶指针SP初始化为最大值（根据声明的堆栈段大小决定)</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240418232229883.png" /></p>
<hr style = "border:2px solid yellow">
<h4 id="法二">法二</h4>
<p>类似前面数据段装入，需要额外定义一个变量top</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240418234105426.png" /></p>
<p>堆栈操作都是按字操作</p>
<h2
id="当前位置计数器与定位伪指令orgorigin">当前位置计数器$与定位伪指令ORG(Origin)</h2>
<h3 id="当前位置计数器">当前位置计数器$</h3>
<p><font color = "yellow">$表示当前指针地址</font></p>
<h3 id="定位伪指令org">定位伪指令ORG</h3>
<h4 id="格式">格式</h4>
<p>ORG 数值表达式</p>
<h4 id="作用">作用</h4>
<p>将数值表达式的值赋给当前位置计数器。<font color = "yellow">ORG相当于移动当前位置指针</font>。<font color = "red">赋给它的值必须是正值</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA1    SEGMENT</span><br><span class="line">    ORG 30H</span><br><span class="line">    DB1 DB 12H,34H   ; DB1在DATA1段内的偏移量为30H</span><br><span class="line">    ORG $+20H        ; 保留20H个字节单元，其后再存放&#x27;ABCD....</span><br><span class="line">    STRING DB ‘ABCDEFGHI’</span><br><span class="line">    COUT EQU $-STRING ; 计算STRING的长度</span><br><span class="line">    DB2 DW $          ; 取$的偏移量，类似变量的用法</span><br><span class="line">    ; DB3 DB $         ; 此语句错误!</span><br><span class="line">DATA1 ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE</span><br><span class="line">    ORG 10H</span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    ; ...</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mt42177ns/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="从程序返回操作系统的方法">从程序返回操作系统的方法</h2>
<h3 id="使用dos系统功能调用实现返回">使用DOS系统功能调用实现返回</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，4CH</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>
<h2 id="程序基本结构">程序基本结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例3-11】求字存储单元中两个数之差，结果存入下一个相邻的字单元中。</span><br><span class="line">NAME  EXAMPLE</span><br><span class="line">DATA   SEGMENT</span><br><span class="line">BUF    DW 3483H,4596H</span><br><span class="line">RES    DW  ? 	</span><br><span class="line">DATA   ENDS</span><br><span class="line">STACK  SEGMENT STACK ‘STACK’</span><br><span class="line">       STA  DW 100 DUP(?)</span><br><span class="line">STACK  ENDS</span><br><span class="line">CODE   SEGMENT</span><br><span class="line">       ASSUME CS:CODE.DS:DATA</span><br><span class="line"> START:MOV AX,DATA              </span><br><span class="line">       MOV DS,AX </span><br><span class="line">       MOV AX,BUF</span><br><span class="line">       SUB AX,BUF+2</span><br><span class="line">       MOV RES,AX </span><br><span class="line">       MOV AH,4CH</span><br><span class="line">      INT  21H                                 </span><br><span class="line">CODE  ENDS</span><br><span class="line">END   START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1GD421n7p8/?spm_id_from=333.999.0.0">视频讲解</a></p>
<p><font color = "yellow">一个段的名字就是一个段的标号，就是这个段的首地址。是个常亮</font></p>
<p><font color = "yellow">取变量，变量名字出现在指令中，表示取变量中内容</font></p>
<h1 id="dos-功能子程序调用">DOS 功能子程序调用</h1>
<h2 id="带显示的键盘输入1号功能">带显示的键盘输入（1号功能）</h2>
<p><a
href="https://www.bilibili.com/video/BV1EF4m1A7j9/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><font color = "red">将字符的ASCII码送入AL寄存器，并在屏幕上显示该字符</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，01H</span><br><span class="line">INT     21H  </span><br></pre></td></tr></table></figure>
<h2 id="不带显示的键盘输入8号功能">不带显示的键盘输入（8号功能）</h2>
<p>除了不显示字符其他和1号功能一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，8</span><br><span class="line">INT    21H</span><br></pre></td></tr></table></figure>
<h2 id="字符显示2号功能">字符显示（2号功能）</h2>
<p>打印单个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DL, &#x27;A&#x27;</span><br><span class="line">MOV AH, 02H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>
<p>打印单个字符还好，什么叫数字转ASCII码值？还有2位数需要转字符串循环输出</p>
<p>数字转ASCII码方法：数字+‘0’即可</p>
<h2 id="字符串输入0ah号功能">字符串输入（0AH号功能）</h2>
<p>缓冲区第一个字节是可输入的最大字符数+1</p>
<p>第二个字节是系统在调用该功能时，自动填入的本次调用时实际输入的字符个数，<font color = "yellow">实际应用时初始化时常设置为0</font></p>
<p>从第三个字节开始存放输入字符的ASCII码，当用户输入回车键时，结束输入，并<font color = "red">将回车键的ASCII码（0DH）作为最后一个字符送入缓冲区。但它不计入实际输入字符个数</font></p>
<p>参考代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    CHAR_BUF DB 31H, DB 0, DB 31H DUP(&#x27;$&#x27;)</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:        </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    ; 显示字符串</span><br><span class="line">    MOV DX, OFFSET CHAR_BUF</span><br><span class="line">    MOV AH, 0AH</span><br><span class="line">    INT 21H</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H                   </span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1rt421w7Dv/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h2 id="字符串显示9号功能">字符串显示（9号功能）</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    CHAR_BUF DB &#x27;This is a test&#x27;, 0AH, 0DH, &#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:        </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    MOV DX, OFFSET CHAR_BUF</span><br><span class="line">    MOV AH, 9H</span><br><span class="line">    INT 21H</span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH         ; 功能号：退出程序</span><br><span class="line">    INT 21H             ; 调用 DOS 中断 21H</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>0AH表示换行，将光标移到下一行开头。</li>
<li>0DH表示回车，将光标移到当前行开头。</li>
</ul>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章_汇编语言程序格式_2</title>
    <url>/posts/5c9b3e6f.html</url>
    <content><![CDATA[<h1 id="汇编语言程序的开发">汇编语言程序的开发</h1>
<span id="more"></span>
<h2 id="语句类型">语句类型</h2>
<p>指令语句：完成一定操作功能，能够翻译成机器代码</p>
<p>指示语句：提供有关信息，并不能翻译成机器代码</p>
<h3 id="定义数据段部分">定义数据段部分</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">DATA ENDS</span><br></pre></td></tr></table></figure>
<h3 id="定义代码段">定义代码段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE, DS:DATA</span><br><span class="line">CODE ENDS</span><br></pre></td></tr></table></figure>
<h3 id="定义源程序">定义源程序</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START:</span><br><span class="line">    MOV AX,DATA</span><br><span class="line">    MOV DS,AX </span><br><span class="line">    INT 21H </span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p>完整代码组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT      ; 段定义开始（DATA段）</span><br><span class="line">    BUF1 DB 34H   ; 第1个加数</span><br><span class="line">    BUF2 DB 2AH   ; 第2个加数</span><br><span class="line">    SUM  DB 1     ; 准备用来存放和数的单元</span><br><span class="line">DATA ENDS         ; 段定义结束（DATA段）</span><br><span class="line"></span><br><span class="line">CODE SEGMENT      ; 段定义开始（CODE段）</span><br><span class="line">    ASSUME CS:CODE, DS:DATA  ; 规定DATA、CODE分别为数据段和代码段</span><br><span class="line">START:    </span><br><span class="line">    MOV AX,DATA</span><br><span class="line">    MOV DS,AX       ; 将数据段的起始地址显式加载到DS寄存器中</span><br><span class="line">    MOV AL,BUF1     ; 取第1个加数</span><br><span class="line">    ADD AL,BUF2     ; 和第2个加数相加</span><br><span class="line">    MOV SUM,AL      ; 存放结果</span><br><span class="line">    MOV AH,4CH      ; 设置DOS功能号</span><br><span class="line">    INT 21H         ; 返回DOS状态</span><br><span class="line">CODE ENDS         ; 段定义结束（CODE段）</span><br><span class="line"></span><br><span class="line">END START         ; 整个源程序结束</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释： MOV AX,DATA MOV DS,AX 为什么不能直接 MOV DS, DATA</p>
<p>因为在汇编语言中，<code>DATA</code>
只是一个符号，代表着数据段的起始地址，而不是一个立即数。段寄存器（如
<code>DS</code>）只能接受立即数作为其操作数，而不是一个符号。</p>
</blockquote>
<h1 id="参数变量和标号">参数、变量和标号</h1>
<h2 id="符号定义语句伪指令">符号定义语句伪指令</h2>
<h3 id="等值语句">等值语句</h3>
<p>语句格式：符号名 EQU 表达式</p>
<p><font color = "red">上面的替换是前替后</font></p>
<p>功能：用符号名来表示EQU右边的表达式。后面的程序中一旦出现该符号名，汇编程序将把它替换成该表达式。</p>
<hr style = "border:2px solid yellow;">
<p>1.常数或数值表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUNT  EQU  5</span><br><span class="line">NUM    EQU  COUNT+5</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow;">
<p>2.地址表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR1  EQU  DS：[BP+14]</span><br></pre></td></tr></table></figure>
<p><font color = "red">上面说叫在DS数据段中以BP作基址寻址的一个存储单元。这句话是什么意思</font></p>
<hr style = "border:2px solid yellow;">
<p>3.变量、寄存器名或指令助记符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREG  EQU  CX；在后面的程序使用CREG就是使用CX</span><br><span class="line">CBD   EQU  DAA；DAA为十进制调整指令。  </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow;">
<p><font color = "red">敲重点：在同一源程序中，同一符号不能用EQU定义多次。！！！</font></p>
<h3 id="等号语句">等号语句</h3>
<p>格式：符号名=表达式</p>
<p><font color = "red">敲重点</font></p>
<ol type="1">
<li>等号语句与等值语句具有相同的作用。但等号语句可以对一个符号进行<font color = "yellow">多次定义</font>。</li>
<li>等值语句与等号语句都不会为符号分配存储单元。因此所定义的符号<font color = "yellow">没有段、偏移量和类型等属性</font>。</li>
</ol>
<h3 id="解除定义伪指令purge">解除定义伪指令PURGE</h3>
<p>功能：解除指定符号的定义</p>
<hr style = "border:2px solid yellow">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y1 EQU 7</span><br><span class="line">PURGE Y1</span><br><span class="line">Y1 EQU 128 </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="数据定义伪指令">数据定义伪指令</h2>
<h3 id="常数">常数</h3>
<ol type="1">
<li><p>十进制缺省</p></li>
<li><p>实数</p>
<p>整数部分 • 小数部分E ±指数部分</p>
<p>举例：<font color = "red">2.134 E +10这个到底怎么读？</font></p></li>
<li><p>字符串常数</p>
<ol type="1">
<li><p>单引号或者双引号都可以</p></li>
<li><p>以各个字符的ASCII码值存储在内存。</p></li>
</ol></li>
</ol>
<h3 id="变量">变量</h3>
<h4 id="变量的定义与预置">变量的定义与预置</h4>
<ol type="1">
<li>命名</li>
<li>预制存储单元(伪指令
DB、DW、DD、DQ和DT等)，<font color = "yellow">含义是一次分配出多少存储单元</font></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403205729101.png" /></p>
<hr style = "border:2px solid yellow">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VAR_DATA SEGMENT</span><br><span class="line">    DATA1 DB 12H    ; 定义 DATA1，包含一个字节的数据 12H</span><br><span class="line">    DATA2 DB 20H,30H    ; 定义 DATA2，包含两个字节的数据 20H 和 30H</span><br><span class="line">    DATA3 DW 5678H    ; 定义 DATA3，包含一个字的数据 5678H</span><br><span class="line">VAR_DATA ENDS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 1.
<font color = "yellow">汇编中声明的变量名也是有地址的（类比C语言中指针的指针）</font></p>
<ol start="2" type="1">
<li>DATA2可以理解成1个数组，这个数组中有2个字节，分别是20H和30H</li>
</ol>
</blockquote>
<hr style = "border:2px solid yellow">
<h4 id="变量的属性">变量的属性</h4>
<h5 id="段属性">段属性</h5>
<p>它表示变量存放在哪一个逻辑段中。</p>
<p>例如上面例子中的变量DATA1、DATA2和DATA3三个变量都存放在VAR-DATA逻辑段中。</p>
<h5 id="偏移量属性offset">偏移量属性（OFFSET)</h5>
<p>它表示变量所在位置与段起始点之间的字节数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c23e5f70c94e2ef26fa21f012b57b36.jpg" /></p>
<p>如上述例子中，变量DATA1的偏移量为0，DATA2为1，DATA3为3。</p>
<h5 id="类型属性">类型属性</h5>
<p>​
它表示变量占用存储单元的字节数。其中DB伪指令定义的变量为字节，DW定义的变量为字，DD定义的为双字（4字节），DQ定义的为4字，DT定义的为5字。</p>
<h4 id="变量赋值表达式">变量赋值表达式</h4>
<h5 id="数值表达式">数值表达式</h5>
<p>例如：DATA1 DB 32，30H
DATA1的内容为32（20H），DATA1+1单元内容为30H.</p>
<h5 id="表达式">？表达式</h5>
<p>不带引号的问号“？”表示可以预置任意内容。</p>
<p>例如：DA-BYTE DB ？，？，？
表示让汇编程序分配三个字节存储单元。这些存储单元的内容的值为任意值。</p>
<p><font color = "yellow">但是在emu8086中无法使用，所以直接写作DA-BYTE
DB 3</font></p>
<h5 id="字符串表达式">字符串表达式</h5>
<h6 id="db">DB</h6>
<p>对于DB伪指令，<font color = "red">字符串为用引号括起来的不超过255个字符</font>。给<font color = "red">每一个字符分配一个字节单元</font>。字符串按<font color = "red">从左到右映射为从低到高存放</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING1 DB ‘ABCDEF’</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160235825.png" /></p>
<hr style = "border:2px solid yellow">
<h6 id="dw">DW</h6>
<p>DW伪指令可以给两个字符组成的字符串分配两个字节存储单元。</p>
<p>两个字符的存放顺序是前一个字符放在高地址，后一字符放低地址单元。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING2 DW ‘AB’, ‘CD’, ’EF’</p>
<p><font color = "yellow">为什么41H比42H高?</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160632184.png" /></p>
<hr style = "border:2px solid yellow">
<h6 id="dd">DD</h6>
<p>给两个字符组成的字符串分配4个字节单元。（就是会强制多分配）</p>
<p>两个字符存放在较低地址的两个字节单元中。存放顺序与DW伪指令相同，而较高的两个字节单元都存放0。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING3 DD ‘AB’, ‘CD’</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160957395.png" /></p>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：DW和DD伪指令<font color = "red">不能用两个以上</font>字符构成的字符串赋初值，否则将出错。</p>
</blockquote>
<h5 id="dup表达式">DUP表达式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406161058532.png" /></p>
<p>表达式1是重复的次数，表达式2是重复的内容。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_A  DB   10H  DUP(?)	; 分配16个字节单元(10H = 16D)</span><br><span class="line">DATA_B  DB   20H  DUP(&#x27;AB&#x27;)	; 分配20H*2=40H个 字节，其内容为重复字符串‘AB’</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：DUP的嵌套使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e31ed9ea0bf3d693348d30b48bf55fd.jpg" /></p>
</blockquote>
<h4 id="变量的使用">变量的使用</h4>
<h5 id="在指令语句中引用">在指令语句中引用</h5>
<h6 id="直接引用变量名">直接引用变量名</h6>
<p>在指令语句中<font color = "red">直接引用变量名</font>就是对其<font color = "red">存储单元的内容</font>进行存取</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DA1 DB 0FEH    ; 将 0FEH 存储在 DA1 中</span><br><span class="line">DA2 DW 52ACH    ; 将 52ACH 存储在 DA2 中</span><br><span class="line">...</span><br><span class="line">MOV AL, DA1    ; 将 DA1 中的数据 (0FEH) 传送到 AL 中, 而不是DA1的地址，这一点很重要</span><br><span class="line">MOV BX, DA2    ; 将 DA2 中的数据 (52ACH) 传送到 BX 中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h6 id="变量名出现在编制寻址">变量名出现在编制寻址</h6>
<p><font color = "red">变量名作为地址</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">DA3  DB  10H  DUP(?)</span><br><span class="line">DA4  DW  10H  DUP（1）</span><br><span class="line">MOV  DA3[SI]，AL		; 将AL的内容送入从DA3 开始再偏移(SI)的存储单元中</span><br><span class="line">ADD  DX，DA4[BX][DI]	; 将从DA4开始再偏移(BX)+(DI)的字存储单元的内容与DX的内容相加，结果送回DX中。</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>总结：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/20c432cdfa1474bf62d93726ec4d20b.jpg" /></p>
<h5 id="在伪指令语句中引用">在伪指令语句中引用</h5>
<p>之前声明的变量名赋给新变量名，新变量得到的是原变量的偏移地址（新变量大小是1个字）或偏移地址+段地址（新变量大小是2个字）</p>
<hr style = "border:2px solid yellow">
<p>举例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     设上述语句所在段的段基值为0915H，NUM的偏移量为0004H</span><br><span class="line">NUM DB 75H    ; 将 75H 存储在 NUM 中</span><br><span class="line">ARRAY DW 20H DUP(0)    ; 定义一个大小为 20 的字数组，每个单元里有4个存储单元。并全部初始化为 0</span><br><span class="line">ADR1 DW NUM    ; 将 NUM 的偏移地址存储在 ADR1 中</span><br><span class="line">ADR2 DD NUM    ; 将 NUM 的偏移地址和段地址存储在 ADR2 中</span><br><span class="line">ADR3 DW ARRAY[2]    ; 将 ARRAY 的第 2 个元素的偏移地址存储在 ADR3 中</span><br></pre></td></tr></table></figure></p>
<p>详细解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARRAY DW 20H DUP(0) </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8650cfe09bfbdf274d894e08bfeebd7.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR1 DW NUM</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240406191100.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR2 DD NUM   </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6bd40a9707c89b23590adf30d332ed8.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR3 DW ARRAY[2]    </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/984d428c1d26418fce2c518d930b656.jpg" /></p>
<p><font color = "red">注意ARRAY[ 1 ]和ARRAY + 1的区别</font></p>
<p><font color = "yellow">居然不是从0开始数？</font></p>
<hr style = "border:2px solid yellow">
<h2 id="标号">标号</h2>
<p>定义：标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地，即作转移指令的操作数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8ef02dbc46243bd657be08fc6f42a5e.jpg" /></p>
<p>属性</p>
<p>（1）段属性（SEG）</p>
<p>表示该标号所代表的地址在哪个逻辑段中，即段基值。</p>
<p>（2）偏移量属性（OFFSET）</p>
<p>它表示该标号所代表的地址在段内与段起点间的字节数，即地址的偏移量。</p>
<p><font color = "yellow">（3）距离属性（也叫类型属性）</font></p>
<p>它表示该标号可以被段内还是段间的指令调用。</p>
<ol type="1">
<li><p>NEAR（近）：该标号<font color = "yellow">只能作段内转移</font>，也就是说只能是与该标号所指指令同在一个逻辑段的转移指令和调用指令才能使用它。<font color = "yellow">缺省的情况下都默认是NEAR</font>
如 SUB1：MOV AX，30H (也可以显式声明：标号名 LABEL NEAR)</p></li>
<li><p>FAR（远）：该标号可以被非本段的转移和调用指令使用。需要显式指明。格式为：
标号名 LABEL FAR</p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB1_FAR    LABEL    FAR</span><br><span class="line">SUB1:  MOV  AX,30H</span><br></pre></td></tr></table></figure>
<p>SUB1_FAR与SUB1两个标号具有相同的段属性和偏移量属性，即相同的逻辑地址。被转移指令或调用指令访问时，是指同一个入口地址，但SUB1-FAR可以被其它段的指令调用。</p>
<hr style = "border:2px solid yellow">
<h1 id="表达式与运算符">表达式与运算符</h1>
<h2 id="算术运算符">算术运算符</h2>
<ol type="1">
<li><p>运算符“+”和“-”也可作单目运算符，表示数的正负。</p></li>
<li><p>使用“+”、“-”、“＊”、和“/”运算符时，参加运算的数和运算结果都是整数。</p></li>
<li><p>“/”运算为取商的整数部分，而“MOD”运算取除法运算的余数。</p></li>
<li><p>"SHR"和"SHL"为逻辑移位运算符</p>
<blockquote>
<p>注意：移位运算符与移位指令区别在于， <font color = "red">
移位运算符的操作对象是某一具体的数（常数），而移位指令是对一个寄存器或存储单元</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>移位运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NUM=11011011B</span><br><span class="line">…</span><br><span class="line">MOV   AX, NUM SHL 1</span><br><span class="line">MOV   BX, NUM SHR 2</span><br><span class="line">ADD   DX, NUM SHR 6</span><br></pre></td></tr></table></figure>
<p>移位指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHL AX 1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
</blockquote></li>
<li><p>下标运算符“[ ]”具有相加的作用</p>
<p>作用：将表达式1与表达式2的值相加后形成一个存储器操作数的地址。</p>
<p><font color = "yellow">下面这两个语句等效</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX, DA_WORD[20H]</span><br><span class="line">MOV   AX, DA_WORD+20H</span><br></pre></td></tr></table></figure>
<p><font color = "red">敲重点,
MOV中什么时候是取地址里所保存变量的值，什么时候是取地址</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409063256494.png" /></p>
<p><font color = "yellow">总结：寄存器之间如果是[]连接就是取地址里的值，如果是+连接就是取地址</font></p></li>
</ol>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>逻辑运算符有NOT、AND、OR和XOR等四个，它们执行的都是按位逻辑运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AX, NOT 0F0H   =&gt; MOV  AX, 0FF0FH</span><br><span class="line">MOV  AL, NOT 0F0H   =&gt; MOV  AL, 0FH</span><br><span class="line">MOV  BL, 55H AND 0F0H =&gt; MOV  BL, 50H</span><br><span class="line">MOV  BH, 55H OR 0F0H  =&gt; MOV  BH, 0F5H</span><br><span class="line">MOV  CL, 55H XOR 0F0H =&gt; MOV  CL, 0A5H</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符">关系运算符</h2>
<p>关系运算符包括：EQ（等于）、NE（不等于）、LT（小于）、
LE（小于等于）、GT（大于）、 GE（大于等于）</p>
<ol type="1">
<li>关系运算符用于比较两个表达式的大小。关系运算符比较的两个表达式<font color = "yellow">必须同为常数或同一逻辑段中的变量</font></li>
<li>如果是<font color = "yellow">常量</font>的比较，则按<font color = "yellow">无符号数</font>进行比较；如果是<font color = "yellow">变量</font>的比较，则比较它们的<font color = "yellow">偏移量</font>的大小。</li>
<li>关系运算符得到结果<font color = "yellow">如果是true，将所有位改为1</font>，相反全部改为0</li>
</ol>
<h2 id="数值返回运算符">数值返回运算符</h2>
<h3 id="seg运算符">SEG运算符</h3>
<p>取变量或标号所在段的段基值。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409064348465.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="offset运算符">OFFSET运算符</h3>
<p>该运算符的作用是取变量或标号在段内的偏移量。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409065001320.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="type运算符">TYPE运算符</h3>
<p>该运算符的作用为取变量或标号的类型属性，并用数字形式来表示。<font color = "yellow">对变量来说就是取它的字节长度。</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409225139483.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V1    DB    &#x27;ABCDE&#x27;</span><br><span class="line">V2    DW   1234H, 5678H</span><br><span class="line">V3    DD    V2   ; 存放V2的段基值和偏移量</span><br><span class="line">       ……</span><br><span class="line">       MOV   AL, TYPE V1</span><br><span class="line">       MOV   CL, TYPE V2</span><br><span class="line">       MOV   CH, TYPE V3</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL，01H</span><br><span class="line">MOV  CL，02H</span><br><span class="line">MOV  CH，04H</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="length运算符">LENGTH运算符</h3>
<p>该运算符<font color = "red">只能加在变量的前面，且只能管最外层</font>。比如如果变量是用重复数据操作符DUP说明的，则返回外层DUP给定的值。如果没有用DUP说明，则返回值总是1。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1  DB   10H DUP(0)</span><br><span class="line">K2  DB   10H, 20H, 30H, 40H</span><br><span class="line">K3  DW   20H DUP(0, 1, 2 DUP(0))</span><br><span class="line">K4  DB   &#x27;ABCDEFGH&#x27;</span><br><span class="line">……..</span><br><span class="line">MOV   AL, LENGTH K1; (AL)=10H</span><br><span class="line">MOV   BL, LENGTH K2; (BL)=1</span><br><span class="line">MOV   CX, LENGTH K3; (CX)=20H</span><br><span class="line">MOV   DX, LENGTH K4; (DX)=1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="size运算符">SIZE运算符</h3>
<p>该运算符<font color = "red">只能作用于变量</font>，SIZE取值<font color = "yellow">等于LENGTH和TYPE两个运算符返回值的乘积</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1  DB   10H DUP(0)</span><br><span class="line">K2  DB   10H, 20H, 30H, 40H</span><br><span class="line">K3  DW   20H DUP(0, 1, 2 DUP(0))</span><br><span class="line">K4  DB   &#x27;ABCDEFGH&#x27;</span><br><span class="line">……..</span><br><span class="line">MOV   AL, SIZE K1 ; (AL)=10H</span><br><span class="line">MOV   BL, SIZE K2 ; (BL)=1</span><br><span class="line">MOV   CL, SIZE K3 ; (CL)=20H*2=40H</span><br><span class="line">MOV   DL, SIZE K4 ; (DL)=1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="属性修改运算符">属性修改运算符</h2>
<h3 id="ptr运算符">PTR运算符</h3>
<p><font color = "red">临时修改，类似于C语言强转</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DA_BYTE    DB   20H DUP(0)</span><br><span class="line">DA_WORD    DW   30H DUP(0)</span><br><span class="line">      ……</span><br><span class="line">MOV   AX, WORD PTR DA_BYTE[10]</span><br><span class="line">ADD   BYTE PTR DA_WORD[20], BL	; DA_WORD本来大小是一个字大小，强转成1个字节大小</span><br><span class="line">INC   BYTE PTR [BX]</span><br><span class="line">SUB   WORD PTR [SI], 100</span><br><span class="line">JMP   FAR PTR SUB1 ; 指明SUB1不是本段中的地址</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="highlow运算符">HIGH/LOW运算符</h3>
<p><font color = "red">将一个数据分离出高字节和低字节。</font></p>
<p>如果表达式为一个常量，则将其分离成高8位和低8位；如果表达式是一个地址（段基值或偏移量）时，则分离出它的高字节和低字节。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">CONST EQU 0ABCDH</span><br><span class="line">DA1 DB 10H DUP(0)</span><br><span class="line">DA2 DW 20H DUP(0)</span><br><span class="line">DATA ENDS</span><br><span class="line">      …….</span><br><span class="line">MOV AH, HIGH CONST</span><br><span class="line">MOV AL, LOW CONST</span><br><span class="line">MOV BH, HIGH (OFFSET DA1)</span><br><span class="line">MOV BL, LOW (OFFSET DA2)</span><br><span class="line">MOV CH, HIGH (SEG DA1)</span><br><span class="line">MOV CL, LOW (SEG DA2)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH, 0ABH</span><br><span class="line">MOV AL, 0CDH</span><br><span class="line">MOV BH, 00H</span><br><span class="line">MOV BL, 10H</span><br><span class="line">MOV CH, 09H</span><br><span class="line">MOV CL, 26H</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：<font color = "red">HIGH/LOW运算符不能用来分离一个变量、寄存器或存储器单元的高字节与低字节。</font></p>
</blockquote>
<h3 id="this运算符">THIS运算符</h3>
<p>THIS运算符一般与等值运算符EQU连用，用来定义一个变量或标号的类型属性。所定义的变量或标号的段基值和偏移量与紧跟其后的变量或标号相同。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_BYTE  EQU THIS BYTE</span><br><span class="line">DATA_WORD  DW 10 DUP(0)</span><br><span class="line">          ……</span><br><span class="line">          MOV AX, DATA_WORD</span><br><span class="line">          MOV BL, DATA_BYTE</span><br><span class="line">          …...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = "yellow">问题：什么意思？</font></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四部分_实战代码</title>
    <url>/posts/1e229983.html</url>
    <content><![CDATA[<h1 id="输出hello-world">输出hello world</h1>
<span id="more"></span>
<h1 id="求数组最值">求数组最值</h1>
<h1 id="字符串大小写转换">字符串大小写转换</h1>
<h1 id="数组求和">数组求和</h1>
<h1 id="数组赋值">数组赋值</h1>
<h1 id="数组反转">数组反转</h1>
<h1 id="动态规划">动态规划</h1>
<h1 id="二重循环">二重循环</h1>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
</search>
