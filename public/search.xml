<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Deepfake中的transformer应用</title>
    <url>/posts/b018e611.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>Deepfake基础知识</title>
    <url>/posts/1cd3f9de.html</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<h2 id="deepfake伪造">Deepfake伪造</h2>
<h3 id="图像生成">图像生成</h3>
<h4 id="dcgan">DCGan</h4>
<p>核心原理就是在鉴别器中采用L2损失函数替代原本的对数损失函数，一定程度上提高了GAN
模型稳定性和图像伪造的效果</p>
<h4 id="progan">ProGAN</h4>
<p>同时在生成器网络和鉴别器网络中稳定地增加网络层：训练时，以低像素图像为起始数据，通过不断在模型中添加网络层对图像细节进行完善</p>
<h4 id="singan">SinGAN</h4>
<p>以在一张图像或者一张包含噪声的图作为输入的情况下，生成新图像</p>
<h3 id="图像篡改">图像篡改</h3>
<h4 id="deepfake">Deepfake</h4>
<p>采用两对编码器-解码器网络，但在训练时两个编码器共享参数，分别训练两个解码器。测试时将原脸A输入编码器，再连接B的解码器，解码即可完成将B的脸换为A
的脸</p>
<h4 id="faceswap-gan">Faceswap-gan</h4>
<p>在Faceswap 的基础上引入对抗损失函数和感知损失，并与GAN
结合达到了人脸交换的目的</p>
<h4 id="face2face">Face2Face</h4>
<p>根据图像的光度一致性原理对原视频和目标视频的表情进行追踪，然后通过目标检索的方法对面部属性进行精准匹配，
最后将数据进行扭曲后完成交换元素的无缝衔接</p>
<h2 id="deepfake-检测研究">Deepfake 检测研究</h2>
<h3 id="一个端到端的deepfake-检测系统">一个端到端的Deepfake
检测系统</h3>
<p>引入了<strong>强化</strong>学习的思想，先用其他数据集在InceptionV3
网络上进行预训练，然后用预训练过的模型对Deepfake
数据集进行训练和测试，该方法很大程度上在提高了模型检测效率和检测效果</p>
<h3
id="此外基于xception-网络注意力机制模块以及transformer-模型的深度伪造检测方法也可达到较高的准确率">此外，基于Xception
网络、注意力机制模块以及Transformer
模型的深度伪造检测方法也可达到较高的准确率</h3>
<h3
id="采用多个网络来提取图像不同角度的特征联合检测图像真伪">采用多个网络来提取图像不同角度的特征联合检测图像真伪</h3>
<h3 id="多流网络检测算法">多流网络检测算法</h3>
<p>将人脸分割成多块，分别发送到不同的Resnet18，最后连接一个全连接（Fully
Connected layer，FC）层输出检测结果</p>
<h3 id="双流检测方法">双流检测方法</h3>
<p>使用卷积神经网络学习图像边界特征并结合图像所具有的隐写噪声的特点，综合鉴别图像的真伪性</p>
<h3
id="研究一种预处理方法以提高deepfake-检测性能">研究一种预处理方法以提高Deepfake
检测性能。</h3>
<h4
id="提取图像像素域中三个颜色通道上的共生矩阵作为模型输入基于深度cnn-框架进行训练测试">提取图像像素域中三个颜色通道上的共生矩阵作为模型输入，基于深度CNN
框架进行训练测试</h4>
<h4
id="采用离散傅里叶变换获得每张图像的功率谱特征然后对其求平均得到图像的频谱图最后使用简单分类器完成伪造图像取证">采用离散傅里叶变换获得每张图像的功率谱特征，然后对其求平均得到图像的频谱图，最后使用简单分类器完成伪造图像取证</h4>
<h4
id="利用haar-小波变换对视频中提取的帧做预处理通过真伪图像的边缘差异进行deepfake-检测">利用Haar
小波变换对视频中提取的帧做预处理，通过真伪图像的边缘差异进行Deepfake
检测。</h4>
<h3 id="基于生物特征">基于生物特征</h3>
<h2 id="本实验">本实验</h2>
<p>研究基于自编码器的Deepfake 检测方法</p>
<p>提取了图像在空间域的高频信息图作为模型输入，并且在编码器网络中引入“Squeeze-and-Excitation”网络块，加强模型的特征提取能力，从而提高鉴别真伪图像的准确率。</p>
<p>采用双流网络结构分别提取图像空间域的高频特征和图像频谱图特征，并对提取的特征进行融合，使得模型在能够综合图像空间域和频域的特征做出决策，提高模型的整体检测效果。</p>
<p>通过消融实验证明提取图像高频信息、添加注意力机制和多模特征融合对于Deepfake
检测的有效性</p>
<h1 id="相关理论">相关理论</h1>
<h2 id="自动编码器">自动编码器</h2>
<p>可以通过自编码器，将大量图像数据输入编码器，提取主要特征，然后通过解码器对原图进行恢复</p>
<p>在特征信息越少的情况下，重构信息越准确，那么表示自编码器的性能越好。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122133625915.png" /></p>
<h2 id="注意力机制">注意力机制</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122133757419.png" /></p>
<h2 id="多模特征融合">多模特征融合</h2>
<p>通过融合图像的全局特征(颜色直方图)和局部特征(Bag-OfFeature
模型)的表示图像，然后，将融合后的特征作为分类器的输入数据，使得
识别率得到显著提高。</p>
<p>早期融合方法只需要对单一模型进行训练</p>
<p>晚期的融合方法是对各模块单独训练首先根据输入的模态生成与之相对应的模型，然后设计一种融合机制对不同模型得到的结果进行集成，常用的融合机制有投票选举法，平均方法，基于信道噪声和信号方差的加权方法以及设计并训练一个融合模型等。</p>
<h2 id="deepfake-算法">Deepfake 算法</h2>
<h3 id="一种是基于生成对抗网络gan">一种是基于生成对抗网络GAN</h3>
<p>由一个生成器网络（Generator，G）和一个鉴别器网络
(Discrimistor，D)组成</p>
<p>首先，生成器可将潜在空间中的噪声生成图像，然后将其和真实图像混合输入鉴别器进行分类</p>
<p>鉴别器网络本质是一个二分类模型，主要作用就是鉴别真实图像和伪造图像</p>
<p>训练时，生成器和判别器迭代优化，不断更新模型参数，直到达到纳什平衡</p>
<h3 id="一种是基于自动编码器网络">一种是基于自动编码器网络</h3>
<p>Deepfake
核心就是一个经过特殊训练的自编码器，用监督学习训练一个神经网络提取人脸的表情特征，然后通过训练后的神经网络还原成其他人的脸</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122134258140.png" /></p>
<p>“如上图，在训练时，需要两组编码器-解码器网络，两个编码器网络共享一个编码器权重，而分别对应不同的解码器，这样编码器能
同时对A 和B
两人的共有面部特征进行提取(主要为表情特征)，而解码器能对其进行重构，恢复各自脸部图片。”</p>
<p>大白话：公用一个编码器，对应不同解码器</p>
<p>在图像生成时，如果需要将图片中A 的脸替换为B 的脸，可将数据集A
作为输入，得到表情特征，然后输入到解码器B 中 进行解码，即可得到具有A
表情的B 人脸。</p>
<h1
id="基于自编码器的深度伪造图像检测">基于自编码器的深度伪造图像检测</h1>
<h2 id="主要思路">主要思路</h2>
<p>首先提取图像高频信息</p>
<p>紧接着通过自编码器网络提取图像深层特征，并且在编码器网络中引入“Squeeze-and-Excitation”网络块以提取更多有效特征；</p>
<p>最后采用三层全连接网络做分类。</p>
<h2 id="补充">补充</h2>
<h3 id="什么是图像的高频信息">什么是图像的高频信息？</h3>
<p>图像的高频信息就是图像边缘变化明显的地方，图像的低频信息就是图像的内部变化缓慢的地方</p>
<p>用高斯滤波计算出低频信息后，用原图-低频就得到高频，就向下图那个像拓印的图</p>
<p>计算低频信息的方法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123102946170.png" /></p>
<h2 id="模型框架">模型框架</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122134638328.png" /></p>
<h2 id="预处理阶段">预处理阶段</h2>
<p>高斯滤波是一种线性的平滑滤波，在计算过程中，卷积核的大小是固定的，以计算像素位置为原点，周围的点用正态分布函数分配对应权重，最后通过计算加权平均值即可得到最终值</p>
<p>所以在预处理过程中，<strong>先用高斯滤波获取输入图像低频信息图，然后将原图像与低频信息图做差以保留高频信息</strong></p>
<h2 id="自编码器网络">自编码器网络</h2>
<p>本文编码器中引用了Squeeze-and-Excitation（SE-Block），其核心思想是：网络根据损失函
数学习获得通道特征的权重值，根据其对任务的有效性分配一定的权重</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122135313488.png" /></p>
<p>在特征提取阶段，采用一个自编码器网络对高频信息图进行特征提取，同时，在编码器中添加“Squeeze-and-Excitation”模块，该模块
能够根据不同通道特征对检测任务的重要性进行合理提取，保证特征提取的有效性；</p>
<p>在图像分类阶段，本文分类器由三个全连接层组成。在检测过程中，由编码器直接对图像高频信息图编码后输入全连接层，即可输出图像的真伪</p>
<h1
id="基于多模特征融合的深度伪造图像检测">基于多模特征融合的深度伪造图像检测</h1>
<p>首先对图像进行预处理，保留图像高频信息，并且对通过傅里叶变换获取图像的频谱图；接着通过双流网络来提取预处理图像的特征并进行融合；最后将融合后的特征图作为分类器（三层全连接）的输入进行分类。</p>
<h2 id="模型框架-1">模型框架</h2>
<p>采用双流自动编码器网络结构作为主干网络。</p>
<p>通过融合图像在空间域和频域的特征进行Deepfake
检测预处理阶段，分别采用高斯滤波和傅里叶变换提取图像的高频信息图和图像的频谱图</p>
<p>在特征提取和融合阶段，首先，通过两个编码器分别提取图像在空间域和频域的特征，然后
对编码器提取的特征图进行融合，最后添加最大池化层对融合特征降采样</p>
<p>在图像分类阶段，采用三层全连接网络结构。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122140350046.png" /></p>
<h2 id="预处理">预处理</h2>
<p>与在空间域中提取的特征图相比，图像的某些特征在频域中更为突出，特别是图像的重复性和频率特征可以通过傅里叶变换来分析</p>
<p>在图像空间域一般很难检测出图像的全局纹理信息，但在图像的频域内检测相对容易，而Deepfake
图像往往在纹理上存在一定的缺陷</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122142004817.png" /></p>
<p>图像傅里叶变换过程</p>
<p>1.将原图转换为灰度图； 2.进行傅里叶变换；
3.将图像变换的源点移动到频域矩阵中心； 4.对傅里叶变换结果进行对数变换；
5.对中心化后的结果进行对数变换。</p>
<p>图像傅里叶变换后，其高频信息聚集在中间，低频信息分布在四角。</p>
<p>为了把能量集中起来以方便滤波器的使用，利用二维傅里叶变换的平移性质对频谱进行中心化。所以要对频谱中心化后的效果，就是低频在中间，高频在四周，</p>
<p>最后将中心化后的图像作为自动编码器网络的输入</p>
<h2 id="特征提取与融合">特征提取与融合</h2>
<p>采用双流网络结构进行特征提取</p>
<p>首先，预处理得到的高频图和频谱图作为模型输入；</p>
<p>其次，一个自编码器用来提取像素域高频图特征，</p>
<p>另一个自编码器用来提取频谱图特征，并且对提取的空间域和频域特征进行融合；最后，融合特征经过一层最大池化层后输入分类器。</p>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>理论基础</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>FaceXray论文阅读</title>
    <url>/posts/f01673d4.html</url>
    <content><![CDATA[<h1 id="face-x-ray实验">Face X-ray实验</h1>
<h1 id="流程图及公式">1 流程图及公式</h1>
<h2 id="流程图">1 流程图</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108210731.png" /></p>
<h2 id="公式1-混合">2 公式1 混合</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108210822.png" /></p>
<h2 id="点积不是矩阵乘法">2.1 点积不是矩阵乘法</h2>
<h2 id="if是前脸">2.2 IF是前脸</h2>
<h2 id="ib是背景">2.3 IB是背景</h2>
<h2 id="m-是划定被操纵区域的面具每个像素点的值被限制在01">2.4 M
是划定被操纵区域的面具，每个像素点的值被限制在0~1</h2>
<h2 id="混合前要colortransfor">2.5 混合前要colortransfor！</h2>
<h2 id="公式2">3 公式2</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231108211101.png"
alt="微信截图_20231108211101" />
<figcaption aria-hidden="true">微信截图_20231108211101</figcaption>
</figure>
<h1 id="具体实验步骤">具体实验步骤</h1>
<p>使用HRNet网络</p>
<p>将来自所有四种不同分辨率的表示拼接到相同大小的 64x64</p>
<p>经过一个输出通道为 1x1 卷积层</p>
<p>一个输出大小为 256x256 的双线性上采样层</p>
<p>一个 sigmoid 函数。</p>
<p>训练过程</p>
<p>batch_size设置为32</p>
<p>总迭代轮数设置为200,000</p>
<p>热启动</p>
<p>前50,000次迭代用ImgNet训练HRNet（可以直接找现成的权重）</p>
<p>后150,000微调，用bi数据集</p>
<p>学习率一开始设置成0.002，使用Adam优化器，在最后的 50,000
次迭代中线性衰减为 0。</p>
<p>For the fully convolutional neural network NNb in our framework, we
adopt the recent ad- vanced neural network architecture, i.e., HRNet
[42, 43], and then concatenate representations from all four different
resolutions to the same size 64 ⇥ 64, followed by a 1 ⇥ 1 convolutional
layer with one output channel, a bilinear up- sampling layer with 256 ⇥
256 output size and a sigmoid function. In the training process, the
batch size is set to 32 and the total number of iterations is set to
200, 000. To ease the training process of our framework, we warm start
the re- maining layers with fixed ImageNet pre-trained HRNet for the
first 50, 000 iterations and then finetune all layers to- gether for the
rest 150, 000 iterations. The learning rate is set as 0.0002 using Adam
[20] optimizer at first and then is linearly decayed to 0 for the last
50, 000 iterations.</p>
<h1 id="具体步骤">2 具体步骤</h1>
<h1 id="json文件读取">json文件读取</h1>
<p>首先要产生BI数据集</p>
<p>将数据集保存到json文件中，json文件是以字典形式存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pre_computed_landmarks.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    self.landmarks_record_dic = json.load(f)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> self.landmarks_record_dic.items():</span><br><span class="line">        landmarks_record_dic[k] = np.array(v)</span><br></pre></td></tr></table></figure>
<h1 id="图片读取与存取">图片读取与存取</h1>
<h2 id="利用skimage中io读取图片">利用skimage中io读取图片</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line">face_img = io.imread(background_face_path)</span><br></pre></td></tr></table></figure>
<p><code>skimage.io.imread</code> 返回的 NumPy 数组的默认格式是
HWC（Height, Width,
Channels），即图像的高度、宽度和通道信息，通道顺序是RGB</p>
<p>以张量形式读取图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_image</span><br></pre></td></tr></table></figure>
<h1 id="图片对象与数组对象的转换">图片对象与数组对象的转换</h1>
<h2 id="numpy">numpy</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">face_img = np.array(face_img)</span><br></pre></td></tr></table></figure>
<h2 id="pil">PIL</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment"># 将数组对象读取成图片</span></span><br><span class="line">face_img = Image.fromarray(face_img)</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<h1
id="增加图片多样性或者叫图片增广">增加图片多样性（或者叫图片增广）</h1>
<h2 id="上采样">上采样</h2>
<h3 id="最近邻插值">最近邻插值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img.resize((aug_size, aug_size), Image.NEAREST)</span><br></pre></td></tr></table></figure>
<h3 id="双线性插值">双线性插值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img.resize((aug_size, aug_size), Image.BILINEAR)</span><br></pre></td></tr></table></figure>
<h2 id="图片压缩">图片压缩</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随意生成压缩尺寸 使用 OpenCV 中的 cv2.IMWRITE_JPEG_QUALITY 常量来指定 JPEG 图像的编码质量参数，并将其与具体的质量值 quality 组成一个列表 encode_param。</span></span><br><span class="line">encode_param = [<span class="built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY), quality]</span><br><span class="line"><span class="comment"># 使用 OpenCV 的 cv2.imencode 函数将图像编码为指定格式（这里是 PNG 格式）。函数的参数包括要保存的图像格式、图像数据和编码参数。结果是一个包含两个元素的元组，其中第一个元素表示是否成功编码，第二个元素是包含编码后的二进制数据的 NumPy 数组。</span></span><br><span class="line">face_img_encode = cv2.imencode(<span class="string">&#x27;.png&#x27;</span>, face_img, encode_param)[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 使用 OpenCV 的 cv2.imdecode 函数，该函数接受两个参数：编码后的二进制数据（face_img_encode）和读取图像的标志（这里是 cv2.IMREAD_COLOR，表示以彩色图像的方式读取）。</span></span><br><span class="line">face_img = cv2.imdecode(face_img_encode, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="图片裁剪就是切片">图片裁剪：就是切片</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = face_img[<span class="number">60</span>:<span class="number">317</span>, <span class="number">30</span>:<span class="number">287</span>, :]</span><br><span class="line">mask = mask[<span class="number">60</span>:<span class="number">317</span>, <span class="number">30</span>:<span class="number">287</span>, :]</span><br></pre></td></tr></table></figure>
<h2 id="图像反转">图像反转</h2>
<h3 id="水平翻转">水平翻转</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = np.flip(face_img, <span class="number">1</span>)</span><br><span class="line">mask = np.flip(mask, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="垂直翻转">垂直翻转</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">face_img = np.flip(face_img, <span class="number">0</span>)</span><br><span class="line">mask = np.flip(mask, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1
id="定义计算人脸图片的68个数据点也可以封装成一个类">定义计算人脸图片的68个数据点（也可以封装成一个类）</h1>
<p>核心</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读入图片，一般用cv2的库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> dlib</span><br><span class="line">img = cv2.imread(img_path)</span><br><span class="line"><span class="comment"># 加载模型文件</span></span><br><span class="line">predictor = dlib.shape_predictor(<span class="string">&#x27;shape_predictor_68_face_landmarks.dat&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义人脸检测器</span></span><br><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line"><span class="comment"># 检测人脸, 其中1可以理解位定义的计算开销,用faces是因为可能检测到不止一个脸</span></span><br><span class="line">faces = detector(img, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 遍历每一个检测到的人脸</span></span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> faces:</span><br><span class="line">    <span class="comment"># 获得68个人脸数据点</span></span><br><span class="line">    landmarks = predictor(img, face)</span><br></pre></td></tr></table></figure>
<p>如果想将读取的68个人脸数据点保存成如下格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;000_0000.png&quot;: [[56, 143], [57, 168], [61, 192], [67, 216], [76, 238], [93, 257], [112, 273], [133, 288], [156, 291], [178, 287], [198, 271], [219, 256], [236, 237], [246, 216], [250, 192], [252, 167], [252, 142], [69, 131], [84, 123], [102, 123], [119, 126], [137, 132], [178, 130], [195, 122], [213, 119], [230, 119], [244, 126], [158, 149], [158, 168], [158, 186], [159, 205], [140, 211], [148, 214], [158, 219], [168, 214], [176, 210], [91, 150], [102, 143], [116, 144], [127, 154], [115, 156], [101, 156], [188, 152], [199, 142], [213, 141], [224, 148], [214, 153], [201, 154], [117, 232], [134, 229], [148, 228], [158, 231], [168, 228], [181, 229], [195, 232], [182, 246], [169, 253], [158, 254], [147, 254], [132, 247], [125, 234], [147, 238], [158, 239], [168, 237], [188, 234], [168, 237], [158, 239], [147, 238]], &quot;001_0000.png&quot;: [[56, 143], [57, 168], [61, 192], [67, 216], [76, 238], [93, 257], [112, 273], [133, 288], [156, 291], [178, 287], [198, 271], [219, 256], [236, 237], [246, 216], [250, 192], [252, 167], [252, 142], [69, 131], [84, 123], [102, 123], [119, 126], [137, 132], [178, 130], [195, 122], [213, 119], [230, 119], [244, 126], [158, 149], [158, 168], [158, 186], [159, 205], [140, 211], [148, 214], [158, 219], [168, 214], [176, 210], [91, 150], [102, 143], [116, 144], [127, 154], [115, 156], [101, 156], [188, 152], [199, 142], [213, 141], [224, 148], [214, 153], [201, 154], [117, 232], [134, 229], [148, 228], [158, 231], [168, 228], [181, 229], [195, 232], [182, 246], [169, 253], [158, 254], [147, 254], [132, 247], [125, 234], [147, 238], [158, 239], [168, 237], [188, 234], [168, 237], [158, 239], [147, 238]]&#125;</span><br><span class="line">结构</span><br><span class="line">(字典)&#123;&quot;图片路径&quot;:[[x, y](每个点坐标),[]](68个数据点), &quot;&quot;:[[],[],……], …… &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">landmarks_dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, face <span class="keyword">in</span> <span class="built_in">enumerate</span>(faces):</span><br><span class="line">    landmarks = predictor(img, face)</span><br><span class="line">    <span class="comment"># 提前声明二维列表</span></span><br><span class="line">    landmarks_list = [[i.x, i.y] <span class="keyword">for</span> i <span class="keyword">in</span> landmarks.parts()]</span><br><span class="line">    landmark_dic[<span class="string">&quot;pic_path&quot;</span>] = landmarks_list</span><br></pre></td></tr></table></figure>
<h1 id="定义生成bi数据集的类">定义生成BI数据集的类</h1>
<h2 id="初始化">初始化</h2>
<h3 id="读取json文件到内存字典中">读取json文件到内存字典中</h3>
<p>json文件中key是图片路径，value是68个数据点</p>
<p>如何计算：</p>
<h3 id="定义只包含图片路径的列表">定义只包含图片路径的列表</h3>
<h3 id="定义生成遮罩时的仿射变换">定义生成遮罩时的仿射变换</h3>
<h2
id="生成一个数据点包括backgroundfaceforegroundface类型fake-or-real-mask">生成一个“数据点”，包括backgroundface，foregroundface，类型（fake
or real）， mask</h2>
<h3
id="从图片路径列表中随机选择一个图片的路径">从图片路径列表中随机选择一个图片的路径</h3>
<h3 id="按50随机生成图片类型fake-or-real">按50%随机生成图片类型（fake or
real）</h3>
<h3
id="如果是fake生成混合后的图片并利用公式2将得到的mask转换成facexray">如果是fake，生成混合后的图片并利用公式2将得到的mask转换成FaceXray</h3>
<h4
id="根据给定的backgroundface路径读取图片对象和对应的68个数据点">根据给定的backgroundface路径读取图片对象和对应的68个数据点</h4>
<h4
id="在数据集中搜索相似的脸作为前脸">在数据集中搜索相似的脸作为前脸</h4>
<p>先随机选取1000个图片路径，并且剔除和backgroundface来自同一个视频（数据集里保存在同一个文件夹下的）</p>
<p>通过计算两张图片的68个数据点的欧氏距离来判断相似度，找到欧式距离最小的那个作为frontface</p>
<h4
id="根据backgroundface和其landmark生成4种mask">根据backgroundface和其landmark生成4种mask</h4>
<p>将mask进行仿射变换，随机腐蚀和膨胀来增强mask的多样性<a
href="https://blog.csdn.net/alw_123/article/details/83868878">可以参考这篇文章</a></p>
<h4
id="混合前对foregroundface进行颜色变换以适应backgroundface">混合前对foregroundface进行颜色变换以适应backgroundface</h4>
<h4
id="将maskforegroundface和backgroundface混合">将mask，foregroundface和backgroundface混合</h4>
<h3
id="如果是real直接读取图片并且生成mask的灰度图">如果是real，直接读取图片，并且生成mask的灰度图</h3>
<p>注：所有图片的大小都是317 * 717</p>
<p>最终生成bi数据集的结构</p>
<p>影响：MyGetBIDataset 271行save_bi_dataset</p>
<p>bi_dataset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| —— true</span><br><span class="line">|   | —— face</span><br><span class="line">|   |   | —— 1.png</span><br><span class="line">|   |   | —— 2.png</span><br><span class="line">|	| —— mask</span><br><span class="line">|   |   | —— 1.png</span><br><span class="line">|   |   | —— 2.png</span><br><span class="line">|   | —— fake</span><br></pre></td></tr></table></figure>
<p>获得当时数据集最后格式的方法：切片+解包</p>
<p>比如对于your/file/000/background_face.jpg，要获取000/background_face.jpg，用如下写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">background_face_path = <span class="string">&quot;your/file/000/background_face.jpg&quot;</span></span><br><span class="line"><span class="comment"># 拆分路径为目录和文件名</span></span><br><span class="line">final_two = os.path.join(*<span class="built_in">list</span>(background_face_path.split(<span class="string">&#x27;/&#x27;</span>))[-<span class="number">2</span>::])</span><br><span class="line"><span class="built_in">print</span>(final_two)</span><br></pre></td></tr></table></figure>
<p>命名的时候用是第几张图片命名</p>
<p>如何优雅地用一行代码计算一个文件夹里所有文件的数量</p>
<p>利用列表推导式和匿名函数实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count_files = <span class="keyword">lambda</span> folder_path : <span class="built_in">len</span>([f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(foler_path) <span class="keyword">if</span> os.path.isfile(os.path.join(folder_path, f))])</span><br></pre></td></tr></table></figure>
<p>computer_landmarksbug修复</p>
<p>用try-except</p>
<p>直接往文件里面写</p>
<p>处理错误</p>
<p>定义保存错误信息的文件位置</p>
<p>配置错误函数</p>
<p>将错误写入错误函数指向的文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.basicConfig(filename=<span class="string">&quot;ErrorLogs&quot;</span>, level=logging.ERROR)</span><br><span class="line">    <span class="comment"># logging.basicConfig: 这是一个配置基础日志系统的函数，用于配置日志记录的基本设置。在这里，它指定了将日志写入文件，而不是默认的控制台输出 </span></span><br><span class="line">    <span class="comment"># filename=GETBIERRORLOG: 这部分指定了日志文件的路径和名称。 GETBIERRORLOG 是一个变量，它应该在这一行代码之前定义，并包含了日志文件的完整路径。</span></span><br><span class="line">    <span class="comment"># level=logging.ERROR: 这设置了日志记录的级别。在这里，设置为ERROR，表示只记录错误级别的日志消息，包括错误和更严重的消息。这有助于筛选并专注于捕捉代码中的潜在问题。</span></span><br><span class="line">    logging.error(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 将错误信息写入上面配置的错误函数指向的文件</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1
id="定义数据集dataset封装成一个类">定义数据集dataset（封装成一个类）</h1>
<p>需要写入h5文件</p>
<p>h5文件里面要包含些什么？</p>
<h1 id="hrnet网络的使用">HRNet网络的使用</h1>
<p>HRNet网络介绍</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240128070003428.png" /></p>
<p>从官方下载HRNet的网络</p>
<p>其中加载预训练模型的位置</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240128063426079.png" /></p>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">common params for NETWORK</span><br></pre></td></tr></table></figure>
<p>default作用说明里有这句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义模型配置,_C.MODEL:</span><br></pre></td></tr></table></figure>
<p>在default搜索_C.MODEL,发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.PRETRAINED = &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>修改为之前下载的预训练函数位置</p>
<p>default.py中输出种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.NUM_CLASSES = 2</span><br></pre></td></tr></table></figure>
<p>default.py中修改传入的图片大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.MODEL.IMAGE_SIZE</span><br></pre></td></tr></table></figure>
<p>修改传入的图片种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.DATA_FORMAT = &#x27;png&#x27;</span><br></pre></td></tr></table></figure>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATASET related params</span><br></pre></td></tr></table></figure>
<p>传入的图片种类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.DATA_FORMAT = &#x27;png&#x27;</span><br></pre></td></tr></table></figure>
<p>数据集根路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.DATASET.ROOT = &#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>default中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># train</span><br></pre></td></tr></table></figure>
<p>迭代轮数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.END_EPOCH = 150000</span><br></pre></td></tr></table></figure></p>
<p>batch_size设置为32</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.LR = 0.002</span><br></pre></td></tr></table></figure>
<p>总迭代轮数设置为200,000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.END_EPOCH = 200000</span><br></pre></td></tr></table></figure>
<p>学习率一开始设置成0.002</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.LR = 0.002</span><br></pre></td></tr></table></figure>
<p>使用Adam优化器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_C.TRAIN.OPTIMIZER = &#x27;adam&#x27;</span><br></pre></td></tr></table></figure>
<p>在最后的 50,000 次迭代中线性衰减为 0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>在tools/train.py中找到data_loader</p>
<p>lib/core/function.py中定义了训练函数</p>
<p>我还是有点懵，这到底怎么传文件啊</p>
<p>我现在就是按它哪个要求修改了分类的参数，但还是迷糊</p>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>论文笔记：Beyond the Prior Forgery Knowledge Mining</title>
    <url>/posts/fdcdf70e.html</url>
    <content><![CDATA[<h1 id="abstract">Abstract</h1>
<h2 id="以前方法存在的问题">以前方法存在的问题：</h2>
<p>都只是为了捕获特定的伪造线索，比如噪声(noise patterns),
混合边界(blending boundaries)和频率(frequency
artifacts),导致容易陷入局部最优，从而降低鲁棒性和泛化能力</p>
<h2 id="创新点">创新点</h2>
<p>提出CFM框架，原文which can be flexibly assembled with various
backbones to boost their generalization and robustness
performance，那么是一种模块吗？</p>
<h3
id="cfm框架组成先把原文放在这看后面怎么说">CFM框架组成(先把原文放在这，看后面怎么说)</h3>
<h4
id="首先构建了一个细粒度的三元组并通过先验知识不可知的数据增强来抑制特定的伪造痕迹">首先构建了一个细粒度的三元组，并通过先验知识不可知的数据增强来抑制特定的伪造痕迹</h4>
<p>Specifically, we first build a fine-grained triplet and suppress
specific forgery traces through prior knowledge-agnostic data
augmentation</p>
<h4
id="随后我们提出了一个细粒度的关系学习原型通过实例和局部相似感知损失来挖掘伪造中的关键信息">随后，我们提出了一个细粒度的关系学习原型，通过实例和局部相似感知损失来挖掘伪造中的关键信息</h4>
<p>Subsequently, we propose a fine-grained relation learning prototype
to mine critical information in forgeries through instance and local
similarity-aware losses</p>
<h4
id="此外我们设计了一种新颖的渐进式学习控制器来引导模型专注于主要特征组件使其能够以从粗到精的方式学习关键伪造特征">此外，我们设计了一种新颖的渐进式学习控制器来引导模型专注于主要特征组件，使其能够以从粗到精的方式学习关键伪造特征</h4>
<p>Moreover, we design a novel progressive learning controller to guide
the model to focus on principal feature components, enabling it to learn
critical forgery features in a coarse-to-fine manner</p>
<h1 id="introduction">INTRODUCTION</h1>
<h2 id="研究背景">研究背景：</h2>
<p>以常见的4种伪造手段Deepfakes , Face2Face ,FaceSwap and
NeuralTextures为代表的深度伪造技术不断发展，并且越来越多现成的伪造软件被开发被人利用，导致了严重的金融欺诈，假新闻和身份假冒。</p>
<h2 id="早期检测">早期检测</h2>
<p>生物信息，比如眨眼，头部位置不一致和面部扭曲伪影，效果差</p>
<p>基于深度学习的检测，泛化性差</p>
<p>基于深度学习与捕获先验已知的特征，对图像失真的鲁棒性差</p>
<h2 id="目标">目标</h2>
<p>抗过拟合的同时挖掘出尽可能多的伪造线索</p>
<h2 id="实现">实现</h2>
<h3 id="数据集准备">数据集准备</h3>
<p>利用先验知识不可知的数据增强来防止模型陷入局部最优，并驱动模型学习更广义的伪造知识;</p>
<h3 id="学习框架">学习框架</h3>
<p>引入细粒度三元关系学习方案，使模型能够学习更多的固有特征表示</p>
<h3 id="正则化方案">正则化方案</h3>
<p>用PLC正则化</p>
<h3 id="目标函数">目标函数</h3>
<p>实例相似度感知损失和局部相似度感知损失来同时学习全局关键特征和局部细微伪影</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240214092733347.png"
alt="基于EfficientNet-B4的不同线索提取器的注意图" />
<figcaption
aria-hidden="true">基于EfficientNet-B4的不同线索提取器的注意图</figcaption>
</figure>
<p>上图每个部分图像第一列是不同形式伪造的图片</p>
<p>提取特征的主干网络都是EfficientNet-B4(可以换成线性transformer试试)</p>
<p>第二列是用普通卷积层提取出的基本伪造特征</p>
<p>第三列是用低频提取出的噪声线索</p>
<p>第四列是用本文提出的CFM框架提取出的关键伪造线索</p>
<p>a部分的图像并没有经过任何变换，b部分的图像经过了下采样，c部分的图像加入了高斯噪声，对比可以看出根据基础线索（估计即使边界）和根据频率线索的检测都受到了干扰</p>
<h1 id="related-work">RELATED WORK</h1>
<h2 id="a.-prior-knowledge-based-face-forgery-detection">A. Prior
Knowledge-Based Face Forgery Detection</h2>
<p>缺点：抗扰动性差</p>
<h2 id="b.-face-forgery-detection-via-representation-learning">B. Face
Forgery Detection via Representation Learning</h2>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>GANprintR论文阅读</title>
    <url>/posts/bc3980f0.html</url>
    <content><![CDATA[<h1 id="abstract">Abstract</h1>
<p>1 提出利用自编码器移除GAN指纹</p>
<p>2 创建了一个新数据集、</p>
<h1 id="introduction">Introduction</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/db8bd2513df8ed711a4a707eae81d12.jpg"
alt="db8bd2513df8ed711a4a707eae81d12" />
<figcaption
aria-hidden="true">db8bd2513df8ed711a4a707eae81d12</figcaption>
</figure>
<p>FAR:False Acceptance Rate"，即误接受率,在二元分类问题中，"False
Acceptance"
意味着将一个负例（非目标类别）错误地分类为正例（目标类别)</p>
<p>FRR:False Rejection
Rate"，即误拒绝率,表示在应该被接受的情况下，系统错误地拒绝的比率。</p>
<p>DET Curve:在 DET Curve 上，横轴通常表示 FAR（False Acceptance
Rate），纵轴表示 FRR（False Rejection
Rate）。曲线上的每个点对应于系统在不同的阈值下的性能。</p>
<p># Related Work</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/61600cdd836ce17fc87c792a6b81551.jpg" /></p>
<h1 id="proposed-approch">Proposed Approch</h1>
<h2 id="gan指纹是什么">GAN指纹是什么</h2>
<p>GAN指纹指图像中GAN's architect，就是所有与真实图像不相关的东西</p>
<h2 id="如何消除">如何消除</h2>
<p>先在真实图像上训练一个卷积神经网络，然后将GAN图像传入，output的就是去除GAN指纹的图像</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1d3e51f96e99ba43706ba6eb072ae5a.jpg" /></p>
<h1 id="experiment-setup">Experiment Setup</h1>
<h2 id="预处理">预处理</h2>
<p>通过68个人脸数据点中的眼睛确定人脸位置并且最大程度裁剪掉背景保留人脸</p>
<h2 id="检测器的选择">检测器的选择</h2>
]]></content>
      <categories>
        <category>Deepfake</category>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>python基本数据结构，条件语句，循环语句</title>
    <url>/posts/2865530f.html</url>
    <content><![CDATA[<h1
id="exercise1print取消换行和格式化字符串">exercise1：print取消换行和格式化字符串</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   编写代码完成一个名片显示,要求使用取消换行和格式化操作符</span><br><span class="line">   </span><br><span class="line">   ================</span><br><span class="line">   姓名：张三</span><br><span class="line">   QQ:1234567</span><br><span class="line">   手机号：1234567</span><br><span class="line">   公司地址：北京市</span><br><span class="line">   =================</span><br></pre></td></tr></table></figure>
<h2 id="answer">Answer</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;================&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">qq = <span class="string">&quot;1234567&quot;</span></span><br><span class="line">phone = <span class="string">&quot;1234567&quot;</span></span><br><span class="line">address = <span class="string">&quot;北京市&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;姓名：<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;QQ:<span class="subst">&#123;qq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;手机号:<span class="subst">&#123;phone&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;公司地址：<span class="subst">&#123;address&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;================&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="输出效果">输出效果</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114160151131.png"
alt="image-20240114160151131" />
<figcaption aria-hidden="true">image-20240114160151131</figcaption>
</figure>
<h1 id="基本数据结构">基本数据结构</h1>
<h2 id="list">list</h2>
<h3 id="定义">定义</h3>
<h4 id="相当于其他语言的数组">相当于其他语言的数组</h4>
<h4 id="可以存储不同类型的多个值">可以存储<span
style="color:red">不同类型</span>的多个值</h4>
<h3 id="append">append</h3>
<h2 id="字典">字典</h2>
<h2 id="元祖">元祖</h2>
<h2 id="集合">集合</h2>
<h3 id="创建方式">创建方式</h3>
<h4 id="set函数">set()函数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res = set([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure>
<h4 id="创建">{}创建</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">res2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="逻辑运算符and-or-not">逻辑运算符：and, or, not</h1>
<h1 id="exercise2键盘输入与if语句1">exercise2：键盘输入与if语句1</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   要求，从键盘获取自己的年龄，判断是否大于等于18，如果条件成立输出成年了,反之,未成年</span><br></pre></td></tr></table></figure>
<h2 id="answer-1">Answer</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(age) &gt;= <span class="number">18</span>:	<span class="comment">#注意需要强转</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成年了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114162357070.png"
alt="image-20240114162357070" />
<figcaption aria-hidden="true">image-20240114162357070</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114162414785.png"
alt="image-20240114162414785" />
<figcaption aria-hidden="true">image-20240114162414785</figcaption>
</figure>
<h1 id="exercise3键盘输入与if语句2">exercise3：键盘输入与if语句2</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">#if...elif案例</span><br><span class="line">#根据考试的成绩，判断学生的等级</span><br><span class="line">#案例:通过键盘录入的方式获取学生的成绩</span><br></pre></td></tr></table></figure>
<h2 id="answer-2">Answer</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">score = <span class="built_in">input</span>(<span class="string">&quot;请输入学生成绩&quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(score)</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">90</span> <span class="keyword">and</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">80</span> <span class="keyword">and</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &lt; <span class="number">70</span> <span class="keyword">and</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="输出-1">输出</h2>
<figure>
<img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\image-20240114162831600.png"
alt="image-20240114162831600" />
<figcaption aria-hidden="true">image-20240114162831600</figcaption>
</figure>
<h1 id="循环语句">循环语句</h1>
<h2 id="while...else">while...else</h2>
<h3 id="逻辑">逻辑：</h3>
<p>在条件语句（判断表达式）为false，执行else中的语句2</p>
<h2 id="for...else">for...else</h2>
<h2 id="enumerate枚举函数">enumerate()枚举函数</h2>
<h3 id="定义-1">定义</h3>
<h4
id="将一个可遍历的数据对象字符串列表元祖组合为一个索引序列可以同时获取下标和元素值">将一个可遍历的数据对象(字符串,列表,元祖)组合为一个索引序列,可以同时获取下标和元素值</h4>
<h4
id="enumarate序列起始下标-不指定起始下标默认从0开始指定下标使用最新的后面的自动增长">enumarate(序列,起始下标)
不指定起始下标,默认从0开始,指定下标使用最新的,后面的自动增长</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x, y in <span class="title function_">enumerate</span><span class="params">(name, <span class="number">5</span>)</span>:	#x表示对应下标，y表示对应下标的值</span><br><span class="line">    print(x, y)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 h</span><br><span class="line">6 e</span><br><span class="line">7 l</span><br><span class="line">8 l</span><br><span class="line">9 o</span><br><span class="line">10  </span><br><span class="line">11 w</span><br><span class="line">12 o</span><br><span class="line">13 r</span><br><span class="line">14 l</span><br><span class="line">15 d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>python数据类型常见操作</title>
    <url>/posts/1f6e1eb2.html</url>
    <content><![CDATA[<h1 id="三种与类型有关的运算id-type-isinstance">三种与类型有关的运算id,
type, isinstance</h1>
<h2 id="id变量名-获取变量内存地址">id(变量名) 获取变量内存地址</h2>
<h2 id="type变量名获取变量类型">type(变量名)获取变量类型</h2>
<h2
id="isinstance变量名预测的数据类型获取变量类型">isinstance(变量名,预测的数据类型)获取变量类型</h2>
<p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(isintance(string, <span class="built_in">str</span>))</span><br><span class="line">lis = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(lis, <span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115202423457.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115202434956.png" /></p>
<p>type(变量名)获取变量的数据类型,它不会认为子类和父类是相同的数据类型
isinstance(变量名,预测的数据类型)预测变量是什么类型,它会认为子类和父类是相同</p>
<span id="more"></span>
<h1 id="number常用的模块">Number常用的模块</h1>
<h2 id="mathimport-math">math（import math)</h2>
<h3 id="求绝对值">求绝对值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(math.fabs(-<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="向上取整-math.ceil3.1">向上取整 math.ceil(3.1)</h3>
<h3 id="向下取整-math.floor3.9">向下取整 math.floor(3.9)</h3>
<h3 id="求平方-math.pow2-3">求平方 math.pow(2, 3)</h3>
<h3
id="同时求整数部分和小数部分-math.modf12.999">同时求整数部分和小数部分
math.modf(12.999)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(math.modf(<span class="number">12.9999</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115203322220.png" /></p>
<h3 id="求正弦-math.sin3">求正弦 math.sin(3)</h3>
<h2 id="randomimport-random">random(import random)</h2>
<h3 id="生成0-1-之间随机数-random.random">生成0 ~1 之间随机数
random.random()</h3>
<h3
id="生成指定范围的随机数左闭右开-random.randrange1-100">生成指定范围的随机数(左闭右开)
random.randrange(1, 100)</h3>
<h3
id="生成指定范围的一个整数左闭右闭-random.randint0-10">生成指定范围的一个整数(左闭右闭)
random.randint(0, 10)</h3>
<h3 id="返回随机一个元素-random.choice">返回随机一个元素
random.choice()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;小芳&quot;</span>]</span><br><span class="line">name = random.choice(lis)</span><br></pre></td></tr></table></figure>
<h3 id="随机打乱序列里面元素">随机打乱序列里面元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="string">&#x27;一个水杯&#x27;</span>,<span class="string">&#x27;一台电脑&#x27;</span>,<span class="string">&#x27;一支笔&#x27;</span>,<span class="string">&#x27;一副眼镜&#x27;</span>,<span class="string">&#x27;一件风衣&#x27;</span>]</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br></pre></td></tr></table></figure>
<h3 id="随机获取部分元素">随机获取部分元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">res = random.sample(<span class="built_in">str</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(r,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2
id="切片语法格式开始值结束值步长">切片(语法格式:[开始值:结束值:步长])</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从最后一个开始从后两个两个往前</span></span><br><span class="line">name = <span class="string">&#x27;lishi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name[::-<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115211210214.png" /></p>
<h2 id="查">查</h2>
<h3
id="find检测子字符串是否包含在母字符串中如果是返回开始元素的索引值否则返回-1">find：检测子字符串是否包含在母字符串中，如果是返回开始元素的索引值，否则返回-1</h3>
<h3
id="index跟find方法一样只不过如果str不在mystr中直接报错">index：跟find方法一样，只不过如果str不在myStr中，直接报错</h3>
<h3
id="count返回子字符串在start和end的母字符串中出现的次数">count：返回子字符串在start和end的母字符串中出现的次数</h3>
<h3
id="isalpha判断一个字符串是不是全是字母">isalpha：判断一个字符串是不是全是字母</h3>
<h3
id="isdigit判断一个字符串是不是全是数字">isdigit：判断一个字符串是不是全是数字</h3>
<h2 id="改">改</h2>
<h3
id="replace把母字符串中str1旧元素替换为str2新元素如果指定了count则替换不超过count次">replace：把母字符串中str1(旧元素)替换为str2(新元素)，如果指定了count，则替换不超过count次</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212050487.png" /></p>
<p>但是string并没有修改</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212158499.png" /></p>
<h3
id="split-分割以str为分隔符切片母字符串-返回的是列表分割后的每一个元素作为列表中的元素string">split：
分割，以str为分隔符切片母字符串,
返回的是列表（分割后的每一个元素作为列表中的元素（String）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;hello, world, python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string.split(<span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115212508540.png" /></p>
<h3
id="join用指定字符将列表中元素连接成一个字符串其中指定字符串加在列表中元素后面">join：用指定字符将列表中元素连接成一个字符串，其中指定字符串加在列表中元素后面</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115220547267.png" /></p>
<h3 id="获得字母的ascii码">获得字母的ASCII码</h3>
<h4
id="ord用来返回一个字母的ascii码">ord()用来返回一个字母的ASCII码</h4>
<h4 id="chr相当于逆运算">chr()相当于逆运算</h4>
<h3 id="空格">空格</h3>
<h5 id="lstrip删除字符串左空格">.lstrip()删除字符串左空格</h5>
<h5 id="rstrip删除字符串右空格">.rstrip()删除字符串右空格</h5>
<h5 id="strip删除两端空格">.strip()删除两端空格</h5>
<h4 id="对齐">对齐</h4>
<h5
id="ljustwidth左对齐并用空格填充到长度为width">.ljust(width)：左对齐并用空格填充到长度为width</h5>
<h5
id="rjustwidth右对齐并用空格填充到长度为width">.rjust(width)：右对齐并用空格填充到长度为width</h5>
<h5
id="centerwidth居中并用空格填充到长度为width">.center(width)：居中并用空格填充到长度为width</h5>
<h1 id="列表">列表</h1>
<h2 id="增">增</h2>
<h3 id="append在末尾插入">append(在末尾插入)</h3>
<h3
id="insert在指定位置插入这个指定位置是插入后这个元素在新列表中的位置">insert(在指定位置插入，这个指定位置是插入后这个元素在新列表中的位置)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240120134509890.png" /></p>
<h2 id="删">删</h2>
<h3 id="del根据下标删除">del(根据下标删除)</h3>
<h3 id="pop删除最后一个元素">pop(删除最后一个元素)</h3>
<h3 id="remove根据元素的值删除">remove根据元素的值删除</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">international = [<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;韩国&#x27;</span>,<span class="string">&#x27;日本&#x27;</span>,<span class="string">&#x27;美国&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> international[<span class="number">2</span>]</span><br><span class="line">international.pop()</span><br><span class="line">international.remove(<span class="string">&#x27;韩国&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(international)</span><br></pre></td></tr></table></figure>
<h2 id="查-1">查</h2>
<h3 id="in判断一个元素在不在列表中">in(判断一个元素在不在列表中)</h3>
<h3
id="count计算一个元素在列表中个数">count(计算一个元素在列表中个数)</h3>
<h3 id="index得到列表中一个元素下标">index(得到列表中一个元素下标)</h3>
<h2 id="改直接通过下标修改">改：直接通过下标修改</h2>
<h2
id="求一个列表中最大值和最小值maxlist和minlist">求一个列表中最大值和最小值：max(list)和min(list)</h2>
<h2 id="exercise1">exercise1</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习：</span><br><span class="line">   一个学校，有3个办公室，现在有8个老师[&#x27;张学友&#x27;,&#x27;刘德华&#x27;,&#x27;黎明&#x27;,&#x27;郭富城&#x27;,&#x27;王菲&#x27;,&#x27;张柏芝&#x27;,&#x27;张韶涵&#x27;,&#x27;杨颖&#x27;]等待分配工位，请编写程序，完成随机分配</span><br><span class="line">要求：</span><br><span class="line">   办公室的编号，人数  具体是谁</span><br></pre></td></tr></table></figure>
<p>Answer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">name = [<span class="string">&#x27;张学友&#x27;</span>,<span class="string">&#x27;刘德华&#x27;</span>,<span class="string">&#x27;黎明&#x27;</span>,<span class="string">&#x27;郭富城&#x27;</span>,<span class="string">&#x27;王菲&#x27;</span>,<span class="string">&#x27;张柏芝&#x27;</span>,<span class="string">&#x27;张韶涵&#x27;</span>,<span class="string">&#x27;杨颖&#x27;</span>]</span><br><span class="line">room = [[], [], []]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    indexPeople = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(name) - <span class="number">1</span>)</span><br><span class="line">    indexRoom = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    room[indexRoom].append(name[indexPeople])</span><br><span class="line">    <span class="keyword">del</span> name[indexPeople]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;办公室编号: <span class="subst">&#123;i&#125;</span>\t 人员组成: &quot;</span>, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(room[i])):</span><br><span class="line">        <span class="built_in">print</span>(room[i][j], end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115222037480.png" /></p>
<h1 id="元组">元组</h1>
<h1 id="字典">字典</h1>
<h2 id="创建">创建</h2>
<h3 id="直接用创建空字典">直接用{}创建空字典</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找">查找</h2>
<h3
id="通过键查询值直接将键作为下标">通过键查询值：直接将键作为“下标”</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115222904851.png" /></p>
<h3 id="get函数">get函数</h3>
<p>不确定字典中是否存在某一个键而又想获取它的值，可以使用get(),设置默认值，如果不存在就返回默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_info = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三丰&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">30</span>,<span class="string">&#x27;no&#x27;</span>:<span class="number">110</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_info.get(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;不存在&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115223257313.png" /></p>
<h2 id="修改">修改</h2>
<h3
id="修改元素的值直接通过查找到的键来修改">修改元素的值：直接通过查找到的键来修改</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典变量名[对应键名] = 新的值</span></span><br><span class="line">stu_info = &#123;<span class="string">&#x27;no&#x27;</span>:<span class="number">110</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line">stu_info[<span class="string">&#x27;age&#x27;</span>] = <span class="number">18</span></span><br></pre></td></tr></table></figure>
<h3
id="添加元素变量名键-数据如果对应的键不存在会自动创建">添加元素：变量名["键"]
= 数据(如果对应的键不存在会自动创建)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_info[<span class="string">&#x27;mobile&#x27;</span>] = <span class="number">13248301214</span></span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<h3
id="删除指定键的元素或整个字典del">删除指定键的元素或整个字典：del</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> dic	<span class="comment"># 整个字典从内存中释放</span></span><br></pre></td></tr></table></figure>
<h3 id="清空整个字典">清空整个字典</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic.clear()	<span class="comment"># 字典内容被清空，字典依然存在</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历">遍历</h2>
<h3 id="获取字典中键值对的数量len">获取字典中键值对的数量：len</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(dic) </span><br></pre></td></tr></table></figure>
<h3
id="keys获取字典中由键组成的列表">.keys()：获取字典中由键组成的列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allKeys = dic.keys()</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> allKeys:</span><br><span class="line">    <span class="built_in">print</span>(elem, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="values获取字典中由值组成的列表">.values()：获取字典中由值组成的列表</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allValues = dic.values()</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> allValues:</span><br><span class="line">    <span class="built_in">print</span>(elem, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="items返回一个包含所有键-值元祖的列表">items()：返回一个包含所有(键
值)元祖的列表</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115223520574.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
<h1 id="集合">集合</h1>
<h2 id="创建-1">创建</h2>
<h3 id="set-函数创建-里面可以是字典列表元组">set( )函数创建，(
)里面可以是字典，列表，元组</h3>
<h3 id="大括号创建">大括号创建</h3>
<h2 id="集合运算">集合运算</h2>
<h3 id="交">交 &amp;</h3>
<h3 id="并">并 |</h3>
<h3 id="差--">差 -</h3>
<h1 id="生成器">生成器</h1>
<h2 id="创建-2">创建</h2>
<h3 id="列表推导式">列表推导式、</h3>
<p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_list = [expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>expression</code>: 定义列表元素的表达式。</li>
<li><code>item</code>: 迭代变量，表示来自 iterable 的当前元素。</li>
<li><code>iterable</code>: 可迭代对象，例如列表、元组、字符串等。</li>
<li><code>condition</code>（可选）: 过滤条件，用于筛选元素。</li>
</ul>
<p>expression中的变量和item中一致i，expression表示的是最终的返回值</p>
<p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122193656603.png" /></p>
<h3 id="生成器-1">生成器</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(generator)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122193922577.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122194006578.png" /></p>
<p>生成器每次返回的是一个算法,每使用一次next函数就可以获取一个元素值,
直到最后一个元素值,</p>
<p>也可以直接用for</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator():</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<h2 id="yield">yield</h2>
<p>举例：构造斐波那契数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">febo</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">generator = febo(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p>yield关键字类似于return关键字,每次迭代遇到yield返回后面的一个元素,
下次再迭代时候,从上一次yield结束位置后面继续执行</p>
<h1 id="迭代器">迭代器</h1>
<h2 id="迭代对象">迭代对象</h2>
<p>一类：str list tuple dict set 二类：生成器</p>
<p>这些可以直接作用与for循环的对象的统称 ----》迭代对象 ： Iterable</p>
<h2 id="迭代器-1">迭代器</h2>
<p>可以被next()函数调用并且不断的返回下一个值的对象----》迭代器
Iterator</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>有序遍历文件夹</title>
    <url>/posts/41f2a6b9.html</url>
    <content><![CDATA[<p>按数字从小到大遍历文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> root, _, images <span class="keyword">in</span> tqdm(<span class="built_in">sorted</span>(os.walk(src_path)))</span><br></pre></td></tr></table></figure>
<p>按数字从小到大遍历文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="built_in">sorted</span>(images, key=<span class="keyword">lambda</span> x : <span class="built_in">int</span>(os.path.splitext(x)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>sorted()中</p>
<p>images作用：待排序的列表</p>
<p>key表示sorted中用于排序的规则</p>
<p>匿名函数：lambda x : int(os.path.splitext(x)[0])</p>
]]></content>
      <categories>
        <category>python</category>
        <category>有用脚本</category>
      </categories>
  </entry>
  <entry>
    <title>第一周和第二周作业</title>
    <url>/posts/a41b37e2.html</url>
    <content><![CDATA[<h1 id="第一周作业">第一周作业</h1>
<h2 id="exercise1考察随机数的获取">exercise1：考察随机数的获取</h2>
<p>循环实现班级随机抽奖,假设有10排,每排10个同学,输出结果如下:
第7排,1列同学中奖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">循环实现班级随机抽奖,假设有10排,每排10个同学,输出结果如下:</span></span><br><span class="line"><span class="string">第7排,1列同学中奖</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">row = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">col = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;row&#125;</span>, <span class="subst">&#123;col&#125;</span>列同学中奖&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="第二周作业">第二周作业</h1>
<h2 id="exercise1考察列表中常用操作">exercise1：考察列表中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">编程实现对一个元素全为数字的列表，求最大值、最小值.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">99</span>,<span class="number">23</span>,-<span class="number">1</span>,<span class="number">199</span>,<span class="number">888</span>]</span><br><span class="line"><span class="built_in">list</span>.sort()</span><br><span class="line">maxNum = <span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line">minNum = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;max = <span class="subst">&#123;maxNum&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;minNum&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;max = <span class="subst">&#123;<span class="built_in">max</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;min = <span class="subst">&#123;<span class="built_in">min</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise2join的用法">exercise2：join的用法</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">完成一个路径的组装</span></span><br><span class="line"><span class="string">先提示用户多次输入路径，最后显示一个完整的路径，比如/home/python/ftp/share</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">strList = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    substr = <span class="built_in">input</span>(<span class="string">&quot;请输入文件夹名称&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(substr != <span class="string">&#x27;exit&#x27;</span>):</span><br><span class="line">        strList.append(substr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">char = <span class="string">&#x27;/&#x27;</span></span><br><span class="line">path = char.join(strList)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span> + path)</span><br></pre></td></tr></table></figure>
<h2
id="exercise3考察字符串中常用操作">exercise3：考察字符串中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 3.统计用户通过键盘输入的字母，数字，空格的个数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">countAlp = <span class="number">0</span></span><br><span class="line">countNum = <span class="number">0</span></span><br><span class="line">countBlank = <span class="number">0</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一段话&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>[i].isalpha():</span><br><span class="line">        countAlp += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>[i].isnumeric():</span><br><span class="line">        countNum += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">        countBlank += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;alphabet is <span class="subst">&#123;countAlp&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;number is <span class="subst">&#123;countNum&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;blank is <span class="subst">&#123;countBlank&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise4考察字典中常用操作">exercise4：考察字典中常用操作</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 5.编写程序，完成以下要求：</span></span><br><span class="line"><span class="string">#	统计字符串中，各个字符的个数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入一段话：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    dic[char] = <span class="built_in">str</span>.count(char)</span><br><span class="line"></span><br><span class="line">items = dic.items()</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> items:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>:<span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="exercise5">exercise5：</h2>
<h3 id="生成指定范围随机数">生成指定范围随机数</h3>
<h3 id="字符串的拼接">字符串的拼接</h3>
<p>字符串拼接就必须全部转换成字符串</p>
<h3 id="获得字母的ascii码">获得字母的ASCII码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 6.随机生成一个六位数的验证码（包含数字和字符）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">string = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    choose_num_or_char = random.randrange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> choose_num_or_char == <span class="number">0</span>: <span class="comment"># 生成数字</span></span><br><span class="line">        add = random.randrange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        string += <span class="built_in">str</span>(add)</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment"># 生成字母</span></span><br><span class="line">        add = random.randrange(<span class="number">1</span>, <span class="number">26</span>)</span><br><span class="line">        add = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + add - <span class="number">1</span>)</span><br><span class="line">        string += add</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure>
<h2 id="exercise6">exercise6：</h2>
<h3 id="字符串空格的操作">字符串空格的操作</h3>
<h3 id="字符串起始位置的查询">字符串起始位置的查询</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#7.查找列表元素，移除每个元素的空格，</span></span><br><span class="line"><span class="string">并查找以a 或A开头 并且以c 结尾的所有元素。</span></span><br><span class="line"><span class="string">li = [&quot;alex&quot;, &quot; aric&quot;, &quot;Alex&quot;, &quot;Tony&quot;, &quot;rain&quot;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">li = [<span class="string">&quot;alex&quot;</span>, <span class="string">&quot; aric&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Tony&quot;</span>, <span class="string">&quot;rain&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line">target = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> li:</span><br><span class="line">    item = item.strip()</span><br><span class="line">    <span class="keyword">if</span> (item.startswith(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">or</span> item.startswith(<span class="string">&#x27;A&#x27;</span>)) <span class="keyword">and</span> item.endswith(<span class="string">&#x27;c&#x27;</span>):</span><br><span class="line">        target.append(item)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="built_in">print</span>(target)</span><br></pre></td></tr></table></figure>
<h2 id="exercise7">exercise7</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">9. 分页显示内容</span></span><br><span class="line"><span class="string">a. 通过for循环创建301条数据，数据类型不限，如：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user1　　　email-1　　　pwd1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">user2　　　email-2　　　pwd2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.........</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">b.提示用户 请输入要查看的页码，当用户输入指定页码时，显示指定数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　- 每页显示10条数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　- 用户输入页码是非十进制数字，则提示输入内容格式错误</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRandomStr</span>(<span class="params">length</span>):</span><br><span class="line">    string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        choose_num_or_char = random.randrange(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> choose_num_or_char == <span class="number">0</span>: <span class="comment"># 生成数字</span></span><br><span class="line">            add = random.randrange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            string += <span class="built_in">str</span>(add)</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 生成字母</span></span><br><span class="line">            add = random.randrange(<span class="number">1</span>, <span class="number">26</span>)</span><br><span class="line">            add = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + add - <span class="number">1</span>)</span><br><span class="line">            string += add</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line">records = []</span><br><span class="line">record_per_page = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">301</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">        records.append(record_per_page)</span><br><span class="line">        record_per_page = []</span><br><span class="line">    information = &#123;&#125;</span><br><span class="line">    information[<span class="string">&quot;user&quot;</span>] = getRandomStr(<span class="number">6</span>)</span><br><span class="line">    information[<span class="string">&quot;email&quot;</span>] = getRandomStr(<span class="number">10</span>) + <span class="string">&quot;@163.com&quot;</span></span><br><span class="line">    information[<span class="string">&quot;pwd&quot;</span>] = getRandomStr(<span class="number">12</span>)</span><br><span class="line">    record_per_page.append(information)</span><br><span class="line">records.append(record_per_page)</span><br><span class="line">yema = <span class="built_in">input</span>(<span class="string">&quot;请输入查询页码&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> yema.isdigit() == <span class="literal">True</span>:</span><br><span class="line">    yema = <span class="built_in">int</span>(yema)</span><br><span class="line">    <span class="keyword">for</span> people <span class="keyword">in</span> records[yema]:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> people.items():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>--<span class="subst">&#123;value&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入有误&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码在第一次写在 record_per_page = [] 写成了
record_per_page.clear()</p>
<p>虽然都是清空列表，但第一种写法是将record_per_page指向一个新对象，而第二种写法没有</p>
<p>所以第二种写法导致的问题就会出现改一个跟着改了几个</p>
<p>问题简化就是下面这种情况</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/408b5898-aff7-4fd9-bbcb-2c3186083ed6.gif" /></p>
<p>修改inner的同时out也被改变</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-模块文件操作</title>
    <url>/posts/ea79def.html</url>
    <content><![CDATA[<h1 id="文件操作">文件操作</h1>
<span id="more"></span>
<h2 id="从文件中读取">从文件中读取</h2>
<p>text.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="read">read</h3>
<h4 id="不加限制就是全部读取文件">不加限制就是全部读取文件</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="读取指定长度">读取指定长度</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(f.read(2))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">he</span><br></pre></td></tr></table></figure>
<p>注：read移动的是文件指针，一开始写成这样结果发现后面什么都没有读到，因为文件指针已经读到末尾了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;全部读取\n<span class="subst">&#123;f.read()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#f.seek(0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;读取前两个字符\n<span class="subst">&#123;f.read(<span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#f.seek(0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;读取前10个字符\n<span class="subst">&#123;f.read(<span class="number">10</span>)&#125;</span>&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全部读取</span><br><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br><span class="line">读取前两个字符</span><br><span class="line"></span><br><span class="line">读取前10个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要将文件指针复位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;text.txt&quot;, &quot;r&quot;)</span><br><span class="line">print(f&quot;全部读取\n&#123;f.read()&#125;&quot;)</span><br><span class="line">f.seek(0)</span><br><span class="line">print(f&quot;读取前两个字符\n&#123;f.read(2)&#125;&quot;)</span><br><span class="line">f.seek(0)</span><br><span class="line">print(f&quot;读取前10个字符\n&#123;f.read(10)&#125;&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全部读取</span><br><span class="line">hello world</span><br><span class="line">python  java c c++</span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br><span class="line">读取前两个字符</span><br><span class="line">he</span><br><span class="line">读取前10个字符</span><br><span class="line">hello worl</span><br></pre></td></tr></table></figure>
<h4 id="用for循环就会一行一行读">用for循环就会一行一行读</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for循环</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">python  java c c++</span><br><span class="line"></span><br><span class="line">for f serj eoifjwefj;asf</span><br><span class="line"></span><br><span class="line">aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结:如果读取多次,下次读取是从上次读取结束的位置开始读取</p>
<h3 id="readline">readline</h3>
<h4 id="一行一行读">一行一行读</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readline()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h4
id="如果限制字符数就读取一行中限制字符数">如果限制字符数就读取一行中限制字符数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readline(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hel</span><br></pre></td></tr></table></figure>
<h4
id="for循环逐个打印文件中一行中字符">for循环逐个打印文件中一行中字符</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> f.readline():</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line"> </span><br><span class="line">w</span><br><span class="line">o</span><br><span class="line">r</span><br><span class="line">l</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<h3 id="readlines">readlines()</h3>
<h4
id="不加限制就是读取文件中全部行将每一行作为列表中一个元素最终保存到一个列表里">不加限制就是读取文件中全部行，将每一行作为列表中一个元素，最终保存到一个列表里</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">content = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;hello world\n&#x27;, &#x27;python  java c c++\n&#x27;, &#x27;for f serj eoifjwefj;asf\n&#x27;, &#x27;aefdeoifjeoifzsfkskfdjasofwqkqjz;ovjzpjvnnbaeawkoijq\n&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="读取xlsx文件">读取xlsx文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readExcel</span>(<span class="params">file_path</span>):</span><br><span class="line">    wb = openpyxl.load_workbook(file_path)</span><br><span class="line">    sheet = wb.active</span><br><span class="line">    <span class="comment"># sheet = wb.active 这行代码的作用是获取 Excel 工作簿（Workbook）中的活动工作表（Sheet）。在一个 Excel 文件中，可以包含多个工作表，而 active 方法用于获取当前活动的工作表，即当前被选中的工作表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> sheet.iter_rows():</span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">            <span class="built_in">print</span>(cell.value, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(readExcel(<span class="string">r&quot;D:\HuaweiMoveData\Users\piolet\Desktop\寒假每天任务记录.xlsx&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日期 正式工作时间 蓝桥杯（5：30-11：30）目标4） 科研（13：00-18：00， 19：00-20：00，目标6h） 数模（21：00-23：00，目标2） 开小差次数 手机使用时间 总工作时间 None </span><br><span class="line">1.13 05:28:00 4 None None 1 2h28min None None </span><br><span class="line">1.14 05:30:00 4,明天从</span><br><span class="line">https://blog.csdn.net/weixin_43914593/article/details/133969568开始做 3，明天继续看https://zh.d2l.ai/chapter_linear-networks/softmax-regression.html#equation-eq-softmax-y-and-o留下来的一点小尾巴，然后要从https://zh.d2l.ai/chapter_linear-networks/softmax-regression-concise.html#sec-softmax-concise和https://zh.d2l.ai/chapter_multilayer-perceptrons/mlp-concise.html开始看，争取一天看完动手深度学习 None 1 2h23min 7 None </span><br><span class="line">1.15 05:36:00 3 4 2 1 2h41min 9 None </span><br><span class="line">1.16 05:35:00 5 3 1 2 2和4min 9 None </span><br><span class="line">1.17 05:45:00 0 8 0 0 2h40min 8 None </span><br><span class="line">1.18 05:32:00 5 4.5 1.5 1 1h55min 11 None </span><br><span class="line">1.19 05:25:00 1 5 0 6 5h 6 None </span><br><span class="line">1.2 06:40:00 维护博客3h 0 3 0 5h 6 None </span><br><span class="line">1.21 05:39:00 6 0 0 5 6h8min 6 None </span><br><span class="line">1.22 05:22:00 5 4 2 4 2h30min 11 None </span><br><span class="line">日期 正式工作时间 科研（5：30-11：30，目标4） 蓝桥杯（13：30-6：30，目标4） 数模（19：00-20：00，21：00-23：00，目标3） 开小差次数 手机使用时间 总工作时间 运动次数 </span><br><span class="line">1.23 05:30:00 4 4 2 5 None None 2 </span><br><span class="line">None</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="写入xlsx文件">写入xlsx文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writeExcel</span>(<span class="params">path, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param path: 写入数据的文件路径</span></span><br><span class="line"><span class="string">    :param data: 要写入到文件里数据</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    wb = openpyxl.Workbook()</span><br><span class="line">    sheet = wb.active</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">        sheet.append(row)</span><br><span class="line"></span><br><span class="line">    wb.save(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">path = <span class="string">&#x27;D:\\yaoming.xlsx&#x27;</span></span><br><span class="line">writeExcel(path, [[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>], [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>], [<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="应用---制作文件的备份">应用---制作文件的备份</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任务描述：</span><br><span class="line">输入文件名字，然后程序自动完成对该文件的备份操作：</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">input---&gt;string</span></span><br><span class="line"><span class="string">打开需要备份的文件</span></span><br><span class="line"><span class="string">            存在</span></span><br><span class="line"><span class="string">                读取打开需要备份文件数据</span></span><br><span class="line"><span class="string">                关闭需要备份文件</span></span><br><span class="line"><span class="string">            不存在</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实现备份</span></span><br><span class="line"><span class="string">1.定义备份文件的规则</span></span><br><span class="line"><span class="string">2.将备份文件数据写入到新文件里面</span></span><br><span class="line"><span class="string">3.关闭新文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">path</span>): <span class="comment">#path需要备份文件路径</span></span><br><span class="line">    <span class="comment">#打开需要备份的文件</span></span><br><span class="line">    oldFileName = <span class="built_in">input</span>(<span class="string">&#x27;请输入你要备份文件的名称:&#x27;</span>)</span><br><span class="line">    <span class="comment">#打开文件</span></span><br><span class="line">    fileName = <span class="built_in">open</span>(oldFileName,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="comment">#判断文件是否打开</span></span><br><span class="line">    <span class="keyword">if</span> fileName:</span><br><span class="line">        <span class="comment">#获取备份的文件名</span></span><br><span class="line">        copyFile = oldFileName.rfind(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        name = oldFileName[<span class="number">0</span>:copyFile]</span><br><span class="line">        <span class="comment">#splitText获取文件名和扩展名</span></span><br><span class="line">        fileFlag = os.path.splitext(path)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义新文件备份规则</span></span><br><span class="line">        newFileName = name+<span class="string">&#x27;-副本&#x27;</span>+fileFlag</span><br><span class="line">        <span class="comment">#打开新文件</span></span><br><span class="line">        newFile = <span class="built_in">open</span>(newFileName,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#读取旧文件数据,一行行往新文件里面写入</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fileName.readlines():</span><br><span class="line">            newFile.write(line)</span><br><span class="line">        <span class="comment">#关闭文件</span></span><br><span class="line">        fileName.close()</span><br><span class="line">        newFile.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没有文件打开&#x27;</span>)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">copy(<span class="string">&#x27;text.txt&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="文件的定位读写">文件的定位读写</h3>
<h4 id="获取当前读写文件的位置">获取当前读写文件的位置</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;text.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.read(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取的数据是:&#x27;</span>,<span class="built_in">str</span>)</span><br><span class="line">position = f.tell()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取的位置是:&#x27;</span>,position)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取的数据是: b&#x27;hel&#x27;</span><br><span class="line">读取的位置是: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="定位到某一个位置">定位到某一个位置</h4>
<h4 id="定位到某一个位置-1">定位到某一个位置</h4>
<h2 id="文件的重命名">文件的重命名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;毕业论文.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="文件的删除">文件的删除</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.remove(<span class="string">&quot;待删除文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="文件夹操作">文件夹操作</h1>
<h2 id="创建">创建</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">&quot;新文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取当前的目录">获取当前的目录</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&quot;./&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="删除文件夹">删除文件夹</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rmdir(<span class="string">&quot;待删除文件夹名&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2
id="应用----批量修改文件名重命名">应用----批量修改文件名（重命名）</h2>
<h1 id="stringio和bytesio">StringIO和BytesIO</h1>
<h2 id="stringio">StringIO</h2>
<h2 id="bytesio">BytesIO</h2>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-函数</title>
    <url>/posts/984d2642.html</url>
    <content><![CDATA[<h1 id="函数的参数传递">函数的参数传递</h1>
<h2 id="不可变对象">不可变对象</h2>
<p>number, string, turple</p>
<p>函数传参如果传递的是这种类型，无法在函数内改变传入的参数的值</p>
<h2 id="可变对象">可变对象</h2>
<p>list, dict, set</p>
<p>函数传参如果传递的是这种类型，可以在函数内改变传入的参数的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a</span>):  <span class="comment"># a形参</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;inside <span class="subst">&#123;<span class="built_in">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;outside <span class="subst">&#123;<span class="built_in">id</span>(<span class="built_in">list</span>)&#125;</span>&quot;</span>)</span><br><span class="line">fun(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;inside <span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;outside <span class="subst">&#123;<span class="built_in">id</span>(num)&#125;</span>&quot;</span>)</span><br><span class="line">add(num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;now num: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122205506418.png" /></p>
<p>在 Python 中，整数是不可变的（immutable），所以在 <code>add</code>
函数中，执行 <code>num += 10</code>
时，实际上是创建了一个新的整数对象，并将 <code>num</code>
重新指向这个新对象。这并不会影响到函数外部的 <code>num</code> 变量</p>
<h1 id="关键字参数args">关键字参数:**args</h1>
<p>允许函数调用时参数顺序和定义时不一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_stu_info</span>(<span class="params">name,age,**args</span>):</span><br><span class="line">    <span class="comment">#print(&#x27;姓名是:%s,年龄是:%d&#x27;%(name,age))</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">get_stu_info(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">29</span>,sex=<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">get_stu_info(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">29</span>,sex=<span class="string">&#x27;男&#x27;</span>,height=<span class="number">178</span>,weight=<span class="number">80</span>,hobby=<span class="string">&#x27;唱歌&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122210136207.png" /></p>
<h1 id="默认参数">默认参数</h1>
<p>调用函数时，缺省参数的值如果没有传入，<strong>则会被认为是默认值</strong></p>
<h1 id="不定长参数">不定长参数</h1>
<p>加了一个*号的变量args会存放所有未命名的变量参数，----》元祖
加了**号，存放所有命名的变量参数----》字典</p>
<p>加了一个*号的变量args会存放所有未命名的变量参数，----》元祖
加了**号，存放所有命名的变量参数----》字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c,*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;args=&#x27;</span>,args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kwargs=&#x27;</span>,kwargs)</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;key=&#x27;</span>,key,<span class="string">&#x27;value=&#x27;</span>,value)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">fun(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,name=<span class="string">&#x27;鹿晗&#x27;</span>,age=<span class="number">20</span>,height=<span class="number">180</span>)</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a= 1</span><br><span class="line">b= 3</span><br><span class="line">c= 5</span><br><span class="line">args= (6,)</span><br><span class="line">kwargs= &#123;&#x27;name&#x27;: &#x27;鹿晗&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 180&#125;</span><br></pre></td></tr></table></figure>
<p>先后顺序方面一般先*再**</p>
<h1 id="匿名函数">匿名函数</h1>
<h2 id="定义">定义：</h2>
<p>不使用def这样语句来定义函数 使用lambda来创建一个匿名函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lambda</code>: 关键字，表示定义一个匿名函数。</li>
<li><code>arguments</code>:
参数列表，类似于函数的参数，但不能包含默认值、可变参数等。</li>
<li><code>expression</code>: 单一的表达式，函数的返回值。</li>
</ul>
<h2 id="应用">应用</h2>
<h3 id="作为参数进行传递">作为参数进行传递</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b,opt</span>): <span class="comment">#opt当做参数传递</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(opt(<span class="number">1</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">test(<span class="number">10</span>,<span class="number">100</span>,<span class="keyword">lambda</span> x,y:x+y)</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">100</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="作为内置函数的参数">作为内置函数的参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stus = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;wangwu&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;laowang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">35</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据名称进行排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;排序之前的数据:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照名称进行排序&quot;</span>)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> y: y[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据年龄进行排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按照年龄排序&quot;</span>)</span><br><span class="line">stus.sort(key=<span class="keyword">lambda</span> c: c[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(stus)</span><br></pre></td></tr></table></figure>
<p>sort 函数接受一个关键字参数 key，这个参数是一个函数或 lambda
表达式，用于指定排序的依据。</p>
<p>lambda y: y['name'] 是一个匿名函数，接受一个字典 y，返回该字典中键为
'name' 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序之前的数据:</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;]</span><br><span class="line">按照名称进行排序</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;]</span><br><span class="line">按照年龄排序</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: 18&#125;, &#123;&#x27;name&#x27;: &#x27;wangwu&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;laowang&#x27;, &#x27;age&#x27;: 35&#125;]</span><br></pre></td></tr></table></figure>
<h1 id="偏函数">偏函数</h1>
<p>函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。</p>
<p>可以有效冻结一些预先定义好的参数,对函数参数做缓存,后面想使用再解冻
类似斐波那契数列,知道了前面的几个数,就能推导出后面的数字
比如定义了一个函数,传了2个参数,现在调用可能只会用到部分参数,可以将它冻结起来
后面想使用时候随时解冻</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">plus = partial(add,<span class="number">100</span>) <span class="comment">#提前获知第一个参数的值</span></span><br><span class="line">res = plus(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>使用了 Python 中的 <code>functools.partial</code>
函数来创建一个偏函数</p>
<p>定义了一个原始函数 <code>add(a, b)</code>，用于计算两个数之和。</p>
<p>使用 <code>functools.partial</code> 创建了一个新的函数
<code>plus</code>，通过 <code>partial(add, 100)</code>，将原始函数
<code>add</code> 的第一个参数 <code>a</code> 固定为
<code>100</code>，这样，<code>plus</code> 函数实际上就是
<code>add</code> 函数的一个变体，其中第一个参数已经被固定为
<code>100</code>。</p>
<p>调用 <code>plus(9)</code>，相当于调用
<code>add(100, 9)</code>，得到结果 <code>109</code>。</p>
<h1 id="局部变量和全局变量">局部变量和全局变量</h1>
<h2
id="如何在函数里修改全局变量global-全局变量名">如何在函数里修改全局变量：global
全局变量名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="comment"># x = 100</span></span><br><span class="line">    <span class="comment"># print(x)</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;before function:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;after function:<span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before function:10</span><br><span class="line">after function:1010</span><br></pre></td></tr></table></figure>
<p>当不可变的数据类型作为全局变量，需要用global声明，进行修改
可变的数据类型 不一定</p>
<h2
id="如何在函数里使用外层变量nonlocal-外层变量名">如何在函数里使用外层变量:nonlocal
外层变量名</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nonlocal:使用函数的外层变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;before test2, num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> num</span><br><span class="line">        num *= <span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;in test2,num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;after test2,num:<span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> test2()</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h1 id="装饰器">装饰器</h1>
<h2 id="定义-1">定义:</h2>
<p><strong>本质上就是一个python函数</strong>，他可以让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。</p>
<p>这么做目的是：首先把函数传递到装饰器里面,先验证权限,验证通过,再调用传递进来函数</p>
<h2 id="基本格式">基本格式</h2>
<p><span class="citation" data-cites="函数名">@函数名</span></p>
<p>举例说明</p>
<p>定义一种装饰器函数如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">w1</span>(<span class="params">fun</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="comment"># 验证1</span></span><br><span class="line">        <span class="comment"># 验证2</span></span><br><span class="line">        <span class="comment"># 验证3</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        fun()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<p>定义带装饰器的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@w1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>直接调用装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接调用装饰器&quot;</span>)</span><br><span class="line">f = w1(f1)</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1</span><br></pre></td></tr></table></figure>
<p>使用被语法糖修饰的带装饰器的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1</span><br></pre></td></tr></table></figure>
<p>举例运用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义了一个装饰器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeBold</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;b&gt;&#x27;</span>+fn()+<span class="string">&#x27;&lt;/b&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"><span class="comment">#定义一个带装饰器的函数</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello-world-1&#x27;</span></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">print</span>(test1())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;hello-world-1&lt;/b&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>调试</title>
    <url>/posts/aaf56f78.html</url>
    <content><![CDATA[<h1 id="调试">调试</h1>
<h2 id="断言assert">断言assert</h2>
<p>格式：assert expression 等价于： if not expression: raise
AssertError</p>
<h2 id="logging">logging</h2>
<p>导入模块</p>
<p>添加配置</p>
<p>写入的信息的类别</p>
<p>debug,info,warnning,error
如果指定info,debug不再起作用,如果指定wranning,debug,info不起作用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">导入logging模块</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加一个配置</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="comment">#控制台打印的日志级别</span></span><br><span class="line">                    filename=<span class="string">&#x27;./log/new.log&#x27;</span>,</span><br><span class="line">                    filemode=<span class="string">&#x27;a&#x27;</span>,<span class="comment">##模式，有w和a，w就是写模式，每次都会重新写日志，覆盖之前的日志</span></span><br><span class="line">                    <span class="comment">#a是追加模式，默认如果不写的话，就是追加模式</span></span><br><span class="line">                    <span class="built_in">format</span>=</span><br><span class="line">                    <span class="string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span></span><br><span class="line">                    <span class="comment">#日志格式</span></span><br><span class="line">                    )</span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">logging.info(<span class="string">&#x27;n=%d&#x27;</span>%n)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span>/n)</span><br></pre></td></tr></table></figure>
<h2 id="pdb">pdb</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">命令           用途</span><br><span class="line"><span class="keyword">break</span> 或则 b  设置断点</span><br><span class="line"><span class="keyword">continue</span>/c    继续执行程序，或者跳到下一个断点</span><br><span class="line"><span class="built_in">next</span>/n       执行下一行</span><br><span class="line">step/s       进入函数</span><br><span class="line"><span class="built_in">list</span>/l      查看当前的代码段</span><br><span class="line"><span class="keyword">return</span>/r    执行代码直到从当前函数的返回</span><br><span class="line">exit/q       终止，退出</span><br><span class="line">p/!          打印变量的值    p c</span><br><span class="line"><span class="built_in">help</span>/h       帮助</span><br></pre></td></tr></table></figure>
<h1 id="单元测试">单元测试</h1>
<p>导入unittest模块</p>
<h2 id="测试函数">测试函数</h2>
<h2 id="测试类">测试类</h2>
<h1 id="文档测试">文档测试</h1>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第三周-作业</title>
    <url>/posts/581bdacc.html</url>
    <content><![CDATA[<h1
id="exercise1写一个函数求三个数的平均值要求分别使用默认参数和不定长参数">exercise1:写一个函数求三个数的平均值(要求分别使用默认参数和不定长参数)</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用不定长参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args) / <span class="built_in">len</span>(args)</span><br></pre></td></tr></table></figure>
<h1 id="exercise2偏函数">exercise2：偏函数</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">键盘录入一个数字,使用偏函数计算这个数字表示n周（一周7天）的总天数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 从functools中导包</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="comment"># 定义原始函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">days_per_week, n</span>):</span><br><span class="line">    <span class="keyword">return</span> n * days_per_week</span><br><span class="line"><span class="comment"># 利用partial装饰原始函数，就是新建了一个函数</span></span><br><span class="line">count_days = partial(count, <span class="number">7</span>)</span><br><span class="line">days = count_days(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(days)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第五周作业</title>
    <url>/posts/74265ed1.html</url>
    <content><![CDATA[<h1
id="exercise1修改类属性值的两种方式并写出具体的代码">exercise1：修改类属性值的两种方式？并写出具体的代码</h1>
<h2 id="类属性">类属性：</h2>
<p>和java相似的是，就是这一类公共的属性，修改这一个其他是这个类（不是同一个对象的）都会变</p>
<p>不同点在于java中类属性是用static修饰的，就是类属性和普通属性之间由严格的界定，而python没有</p>
<h2 id="方法">方法</h2>
<ol type="1">
<li>直接通过类名修改类属性的值。</li>
<li>通过实例对象修改类属性的值（这种方式会在实例中创建同名的实例属性，并覆盖类属性）。</li>
</ol>
<p>比如下面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_attr = <span class="string">&quot;I am a class attribute&quot;</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类名修改类属性的值</span></span><br><span class="line">MyClass.class_attr = <span class="string">&quot;Modified class attribute&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出修改后的类属性值</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attr)  <span class="comment"># 输出：&quot;Modified class attribute&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例对象</span></span><br><span class="line">obj = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过实例对象修改类属性的值</span></span><br><span class="line">obj.class_attr = <span class="string">&quot;New class attribute value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出实例对象的属性值</span></span><br><span class="line"><span class="built_in">print</span>(obj.class_attr)  <span class="comment"># 输出：&quot;New class attribute value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出类属性的值</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_attr)  <span class="comment"># 输出：&quot;Modified class attribute&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="exercise2">exercise2</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.定义学生类student,在该类中使用构造函数实现对学生信息(姓名、年龄、性别)</span><br><span class="line">的初始化，然后针对类的各个属性建立相应的方法来获取属性的值</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2.定义学生类student,在该类中使用构造函数实现对学生信息(姓名、年龄、性别)</span></span><br><span class="line"><span class="string">的初始化，然后针对类的各个属性建立相应的方法来获取属性的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>():</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    sex = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sex</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sex</span><br><span class="line"></span><br><span class="line">studentA = student(<span class="string">&quot;xiaoming&quot;</span>, <span class="number">19</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(studentA.get_name())</span><br><span class="line"><span class="built_in">print</span>(studentA.get_age())</span><br><span class="line"><span class="built_in">print</span>(studentA.get_sex())</span><br></pre></td></tr></table></figure>
<h1 id="exercise3">exercise3</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.定义一个学生类。有下面的类属性:</span><br><span class="line">1 姓名</span><br><span class="line">2 年龄</span><br><span class="line">3 成绩（语文,数学,英语)[每课成绩的类型为整数]</span><br><span class="line">类方法：</span><br><span class="line">1 获取学生的姓名：get_name() 返回类型:str</span><br><span class="line">2 获取学生的年龄：get_age() 返回类型:int</span><br><span class="line">3 返回3门科目中最高的分数。get_course() 返回类型:int</span><br><span class="line">写好类以后,可以创建对象测试下：</span><br><span class="line">stu = Student(&#x27;zhangming&#x27;,20,[69,88,100])</span><br><span class="line">返回结果：</span><br><span class="line">zhangming</span><br><span class="line">20</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="代码-1">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">3.定义一个学生类。有下面的类属性:</span></span><br><span class="line"><span class="string">1 姓名</span></span><br><span class="line"><span class="string">2 年龄</span></span><br><span class="line"><span class="string">3 成绩（语文,数学,英语)[每课成绩的类型为整数]</span></span><br><span class="line"><span class="string">类方法：</span></span><br><span class="line"><span class="string">1 获取学生的姓名：get_name() 返回类型:str</span></span><br><span class="line"><span class="string">2 获取学生的年龄：get_age() 返回类型:int</span></span><br><span class="line"><span class="string">3 返回3门科目中最高的分数。get_course() 返回类型:int</span></span><br><span class="line"><span class="string">写好类以后,可以创建对象测试下：</span></span><br><span class="line"><span class="string">stu = Student(&#x27;zhangming&#x27;,20,[69,88,100])</span></span><br><span class="line"><span class="string">返回结果：</span></span><br><span class="line"><span class="string">zhangming</span></span><br><span class="line"><span class="string">20</span></span><br><span class="line"><span class="string">100</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, scores</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.scores = scores</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_course</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建学生对象并测试</span></span><br><span class="line">stu = Student(<span class="string">&#x27;zhangming&#x27;</span>, <span class="number">20</span>, [<span class="number">69</span>, <span class="number">88</span>, <span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span>(stu.get_name())</span><br><span class="line"><span class="built_in">print</span>(stu.get_age())</span><br><span class="line"><span class="built_in">print</span>(stu.get_course())</span><br></pre></td></tr></table></figure>
<h1 id="exercise4">exercise4</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.练习：</span><br><span class="line">    有一个学校,人数为0,入职的老师和学生,人数增加1,老师要显示姓名和工号,</span><br><span class="line">   学生要显示姓名和成绩,老师和学生入职后都需要做自我介绍</span><br></pre></td></tr></table></figure>
<h2 id="知识点">知识点</h2>
<p>继承：teacher和student继承自people</p>
<p>通过修改__str__方法来打印信息</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">4.练习：</span></span><br><span class="line"><span class="string">    有一个学校,人数为0,入职的老师和学生,人数增加1,老师要显示姓名和工号,</span></span><br><span class="line"><span class="string">	学生要显示姓名和成绩,老师和学生入职后都需要做自我介绍</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduction</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;大家好，我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(teacher, self).__init__(name, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        msg = <span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>  工号：<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, <span class="built_in">id</span>, scores</span>):</span><br><span class="line">        self.scores = scores</span><br><span class="line">        <span class="built_in">super</span>(student, self).__init__(name, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        msg = <span class="string">f&quot;姓名：<span class="subst">&#123;self.name&#125;</span>  学号：<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>  成绩：<span class="subst">&#123;self.scores&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">school</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.total_num = <span class="number">0</span></span><br><span class="line">        self.teachers = []</span><br><span class="line">        self.students = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_teachers</span>(<span class="params">self, teacher</span>):</span><br><span class="line">        self.teachers.append(teacher)</span><br><span class="line">        self.total_num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(teacher)</span><br><span class="line">        teacher.introduction()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_student</span>(<span class="params">self, student</span>):</span><br><span class="line">        self.students.append(student)</span><br><span class="line">        self.total_num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(student)</span><br><span class="line">        student.introduction()</span><br><span class="line"></span><br><span class="line">jinan_university = school()</span><br><span class="line">teacherA = teacher(<span class="string">&quot;xiazhihua&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">studentA = student(<span class="string">&quot;ztb&quot;</span>, <span class="string">&quot;123&quot;</span>, [<span class="number">89</span>, <span class="number">89</span>, <span class="number">89</span>])</span><br><span class="line">jinan_university.add_teachers(teacherA)</span><br><span class="line">jinan_university.add_student(studentA)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第六周-面向对象、函数高阶用法</title>
    <url>/posts/40aa2ee.html</url>
    <content><![CDATA[<h1 id="多态">多态</h1>
<p>python的多态与java的多态类似。比如一种常见的使用形式就是在函数传参的时候传递的可以是父类和继承该父类的多种子类。然而python比java更灵活</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">   多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）</span><br><span class="line">   </span><br><span class="line">例如:</span><br><span class="line">	序列有多种形态:字符串，列表，元祖</span><br><span class="line">	动物有多种形态:人，猪，狗</span><br><span class="line">	</span><br><span class="line">多态和多态性的区别:</span><br><span class="line">    多态：同一种事物的多种形态，动物分为人类，猪类（在定义角度） </span><br><span class="line">    多态性：一种调用方式，不同的执行效果（多态性）</span><br><span class="line">   </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">面向对象的三大特征:封装,继承,多态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">封装:又称为信息的隐藏,类的实现和使用时分开的,类提供了外部访问的方法,调用者不需要关注</span></span><br><span class="line"><span class="string">类里面的具体实现,会调用即可</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生活中封装:买手机会用就可以</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">继承:一个类继承另外一个类,被继承的类称为父类或者基类,继承的类称为子类或者派生类,</span></span><br><span class="line"><span class="string">子类可以共享父类里面受保护,公有属性和方法,子类不能共享父类私有属性和方法</span></span><br><span class="line"><span class="string">继承可以减少代码的书写,提高代码的可维护性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多态:同一种事物有多种形态</span></span><br><span class="line"><span class="string">多态性:同一种调用方式,返回不同的结果</span></span><br><span class="line"><span class="string">多态的前提:继承和重写</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#多态:一种事物有多种表现形式</span></span><br><span class="line"><span class="comment">#定义一个父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Person,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello,i am Person&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Pig,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;aoao,i am Pig&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类Dog,继承父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="comment">#重写父类同名的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wangwang,i am Dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化不同子类创建对象</span></span><br><span class="line">Per = Person()</span><br><span class="line">Pi = Pig()</span><br><span class="line">Do = Dog()</span><br><span class="line"><span class="comment"># Per.sayHello()</span></span><br><span class="line"><span class="comment"># Pi.sayHello()</span></span><br><span class="line"><span class="comment"># Do.sayHello()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多态性:同一种调用方式,返回不同的结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">o</span>):  <span class="comment">#python是动态语言,o是多态性的体现,这里不需要指定类型,参数的类型由调用者传的值决定</span></span><br><span class="line">    o.sayHello()</span><br><span class="line"></span><br><span class="line">func(Per)</span><br><span class="line">func(Pi)</span><br><span class="line">func(Do)</span><br><span class="line"></span><br><span class="line"><span class="comment">#多态的好处</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>): <span class="comment">#继承父类Animal重新定义子类Cat</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;mimi,i am Cat&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个Cat的对象ca</span></span><br><span class="line">ca = Cat()</span><br><span class="line">func(ca)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多态的好处:</span></span><br><span class="line"><span class="string">1.提高代码在外部调用灵活性</span></span><br><span class="line"><span class="string">2.提高代码的扩展性</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="类属性和实例属性">类属性和实例属性</h1>
<h2 id="类属性">类属性</h2>
<h3 id="定义在类中定义的属性">定义：在类中定义的属性</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">    在类中定义的属性（公有和私有）</span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义一个人类，设置姓名和年龄属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;xiaoming&#x27;</span>  <span class="comment">#公有类属性</span></span><br><span class="line">    __age = <span class="number">12</span>          <span class="comment">#私有类属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象p</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.name)  <span class="comment">#实例对象访问类的公有属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.name)  <span class="comment">#类对象访问类的公有属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__age)   <span class="comment">#实例对象访问类的私有属性   not ok</span></span><br><span class="line"><span class="built_in">print</span>(Person.__age) <span class="comment">##类对象访问类的私有属性 not ok </span></span><br></pre></td></tr></table></figure>
<h2 id="实例属性">实例属性</h2>
<h3
id="定义定义在init初始化方法中的属性">定义：定义在init初始化方法中的属性</h3>
<p>举个例子，什么是实例属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个人类，设置姓名，年龄和地址等属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    address = <span class="string">&#x27;上海市&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name  <span class="comment">#实例属性</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象pe</span></span><br><span class="line">pe = Person(<span class="string">&#x27;张三&#x27;</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment"># print(pe.address)  #通过实例对象访问类属性</span></span><br><span class="line"><span class="comment"># print(pe.name)  #通过实例对象访问实例属性</span></span><br><span class="line"><span class="comment"># print(pe.age)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Person.address)    <span class="comment">#类在定义的时候已经产生了,类属性直接属于类</span></span><br><span class="line"><span class="built_in">print</span>(Person.name)  <span class="comment">#当实例化类创建对象,对属性赋值 实例属性才会产生内存里面 类访问不到实例属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.age)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="实例属性和类属性的关系同名的情况下实例属性会覆盖类属性">实例属性和类属性的关系：同名的情况下，实例属性会覆盖类属性</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.country = <span class="string">&#x27;上海市&#x27;</span> <span class="comment">#实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象p</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.country)  <span class="comment">#通过实例对象访问属性 输出“上海市”</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment">#类对象访问属性 输出“china”</span></span><br><span class="line"><span class="comment">#通过实例属性修改类属性的值</span></span><br><span class="line">p.country = <span class="string">&#x27;chinese&#x27;</span>  <span class="comment">#实例属性会屏蔽类属性</span></span><br><span class="line"><span class="built_in">print</span>(p.country) <span class="comment"># 输出“chinese”</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment"># 输出“china”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> p.country  <span class="comment">#删除实例对象</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(p.country) <span class="comment"># 输出“china”，是类对象，不是实例对象</span></span><br><span class="line"><span class="built_in">print</span>(Person.country) <span class="comment"># 输出“china”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类里面定义同名的实例属性和类属性,实例对象修改类属性,实例属性会屏蔽同名类属性</span></span><br><span class="line"><span class="comment">#实例属性优先级高于类属性</span></span><br></pre></td></tr></table></figure>
<h1 id="静态方法和类方法">静态方法和类方法</h1>
<h2 id="类方法">类方法</h2>
<h3 id="定义">定义</h3>
<p>概述: 类对象所拥有的方法，需要使用到修饰器 <span class="citation"
data-cites="classmethod">@classmethod</span>----&gt;类方法
对于类方法，第一个参数必须是类对象，一般以cls表示作为第一个参数（当然可以用其他的名字，但是不建议修改）</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 定义一个人类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCountry</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.country</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setCountry</span>(<span class="params">cls, country</span>):</span><br><span class="line">        cls.country = country</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Person对象</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.getCountry())  <span class="comment"># 通过实例对象访问类方法 输出“china”</span></span><br><span class="line"><span class="built_in">print</span>(Person.getCountry())  <span class="comment"># 通过类对象访问类方法 输出“china”</span></span><br><span class="line"></span><br><span class="line">p.setCountry(<span class="string">&#x27;chinese&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.getCountry()) <span class="comment"># 输出&quot;chinese&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Person.getCountry()) <span class="comment"># 输出“chinese”    </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:类方法可以修改类属性</span></span><br></pre></td></tr></table></figure>
<h2 id="静态方法">静态方法</h2>
<h3
id="定义通过修饰器staticmethod来进行修饰不需要传参数">定义：通过修饰器@staticmethod来进行修饰，不需要传参数</h3>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">   需要通过修饰器@<span class="built_in">staticmethod</span>来进行修饰，不需要传参数  </span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    country = <span class="string">&#x27;china&#x27;</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getCountry</span>():</span><br><span class="line">        <span class="keyword">return</span> Person.country</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Person类的对象</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.getCountry())  <span class="comment">#通过实例对象访问静态方法</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>类方法:声明方法之前,需要使用到修饰器 <span class="citation"
data-cites="classmethod">@classmethod</span>,里面第一个参数类对象cls,类对象访问的是类属性或者类方法
实例方法:隐含传递的参数是self,对象本身,self访问的可能是实例属性,也有可能是类属性,类方法,静态方法
静态方法:声明方法之前,需要使用到修饰器@staticmethod，不需要加任何参数,访问的是类属性的引用,只能通过类对象调用</p>
<h1 id="slots__">__slots__</h1>
<h2 id="定义限制实例属性">定义：限制实例属性</h2>
<p>语法格式:<strong>slots</strong> = ('属性1','属性2')</p>
<p>__slots__属性限制添加属性只对当前类的实例对象起作用,对类属性,继承的子类实例对象不起作用的</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">动态语言：可以在运行的过程中，修改代码</span><br><span class="line">静态语言：编译时已经确定的代码，运行的时候不能修改</span><br><span class="line"></span><br><span class="line">如果我们想要限制实例属性？</span><br><span class="line">    允许对Person实例中添加name和age属性，</span><br><span class="line">    python允许定义<span class="keyword">class</span>的时候，定义一个特殊的变量----&gt;__slots__，限制<span class="keyword">class</span>能够添加的属性</span><br><span class="line">    </span><br><span class="line">语法格式:__slots__ = (<span class="string">&#x27;属性1&#x27;</span>,<span class="string">&#x27;属性2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#定义一个人类，只允许添加姓名和年龄属性    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>)  <span class="comment">#限制当前类添加的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Student类创建对象stu</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="comment">#往对象里面添加属性</span></span><br><span class="line">stu.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">stu.sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(stu.name)</span><br><span class="line"><span class="built_in">print</span>(stu.sex)</span><br><span class="line"><span class="comment">#增加一个新的属性</span></span><br><span class="line"><span class="comment"># stu.weight = &#x27;80kg&#x27;  #报错,类中限制添加属性没有weight</span></span><br><span class="line"><span class="comment"># print(stu.weight)</span></span><br><span class="line">Student.weight = <span class="string">&#x27;50kg&#x27;</span> <span class="comment"># 添加类属性</span></span><br><span class="line"><span class="built_in">print</span>(stu.weight)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个子类demo,继承Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">d = Demo()</span><br><span class="line">d.height = <span class="string">&#x27;180&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d.height)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意:__slots__属性限制添加属性只对当前类的实例对象起作用,对类属性,继承的子类实例对象不起作用的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="property"><span class="citation"
data-cites="property">@property</span></h1>
<h2
id="私有属性添加getter和setter方法">私有属性添加getter和setter方法</h2>
<p>python中和java类似的是私有属性不能直接修改，需要调用专门的方法才能修改；但python相对于java做出了优化，通过property函数创建一个特性（property），将
<code>getMoney</code> 方法作为获取属性值的方法，<code>setMoney</code>
方法作为设置属性值的方法。这样就可以像访问普通属性一样来访问
<code>Money</code> 类中的 <code>money</code> 属性</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个money类，设置一个私有的__money属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义对属性设置的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setMoney</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value,<span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(value,<span class="built_in">float</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error:金额只能是整形或者浮点型&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义方法获取属性值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMoney</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加实例属性</span></span><br><span class="line">    money = <span class="built_in">property</span>(getMoney,setMoney)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Money类创建对象mo</span></span><br><span class="line">mo = Money()</span><br><span class="line"><span class="comment"># print(mo.__money)  #实例对象不能访问类的私有属性</span></span><br><span class="line">mo.setMoney(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(mo.getMoney()) <span class="comment"># 输出100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这两行代码看似是直接修改了对象的私有属性，实际上是先调用了getMoney和setMoney方法</span></span><br><span class="line">mo.money = <span class="number">500</span></span><br><span class="line"><span class="built_in">print</span>(mo.money) <span class="comment"># 输出500</span></span><br></pre></td></tr></table></figure>
<h2
id="使用property取代getter和setter方法">使用property取代getter和setter方法</h2>
<p>取代set/get------》修饰器-----》<span class="citation"
data-cites="property">@property</span> <span class="citation"
data-cites="property">@property</span>---&gt;属性函数，可以对属性赋值时候做必要的检查，并保证代码的清晰简短
作用： 1.将方法转化为只读
2.重新实现一个属性的设置和读取方法，可做边界判定</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):  <span class="comment">#相当于获取元素值方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line"></span><br><span class="line"><span class="meta">    @money.setter   </span><span class="comment">#money是上面取值的方法名  赋值的方法</span></span><br><span class="line">    <span class="comment"># @money.setter是一个装饰器，用于指定一个方法作为属性的设置方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value,<span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(value,<span class="built_in">float</span>):</span><br><span class="line">            self.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error:不是整形也不是浮点型&#x27;</span>)</span><br><span class="line">    <span class="comment"># 上面两个方法同名，第一个用来获取元素，第二个用来设置元素的值，然后在外界看起来虽然是私有属性的money和实例属性并无区别</span></span><br><span class="line"><span class="comment">#通过Money创建对象m</span></span><br><span class="line">m = Money()</span><br><span class="line"><span class="built_in">print</span>(m.money)</span><br><span class="line">m.money = <span class="number">16888</span></span><br><span class="line"><span class="built_in">print</span>(m.money)</span><br></pre></td></tr></table></figure>
<h1 id="发送邮件">发送邮件</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入邮件库</span></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="comment">#导入邮箱文本</span></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置邮箱服务器 qq/126/163/gmail/yahoo/阿里云</span></span><br><span class="line">SMTPServer = <span class="string">&#x27;smtp.163.com&#x27;</span></span><br><span class="line"><span class="comment">#设置发送邮箱的地址</span></span><br><span class="line">sender = <span class="string">&#x27;ztb0016@163.com&#x27;</span></span><br><span class="line"><span class="comment">#设置发送邮箱的通行码，不是密码</span></span><br><span class="line">password = <span class="string">&#x27;GTTULMLHIKOZSXIZ&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置发送的内容</span></span><br><span class="line">message = <span class="string">&#x27;你是一个好人123333...&#x27;</span></span><br><span class="line"><span class="comment">#转换成人能够看懂的格式</span></span><br><span class="line">msg = MIMEText(message)</span><br><span class="line"><span class="comment">#设置发送邮件的主题</span></span><br><span class="line">msg[<span class="string">&#x27;subject&#x27;</span>] = <span class="string">&#x27;来自一位帅哥的表白33333&#x27;</span></span><br><span class="line"><span class="comment">#发送者</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置邮箱服务器， 25表示的是端口</span></span><br><span class="line">emailServer = smtplib.SMTP(SMTPServer,<span class="number">25</span>)</span><br><span class="line"><span class="comment">#登录邮箱</span></span><br><span class="line">emailServer.login(sender,password)</span><br><span class="line"><span class="comment">#发送邮件的内容</span></span><br><span class="line">emailServer.sendmail(sender,[<span class="string">&#x27;piolet0016@gmail.com&#x27;</span>],msg.as_string())</span><br><span class="line"><span class="comment">#关闭邮箱</span></span><br><span class="line">emailServer.quit()</span><br></pre></td></tr></table></figure>
<h1 id="用列表模拟栈">用列表模拟栈</h1>
<p>append模拟入栈</p>
<p>pop模拟出栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">栈---&gt;有名堆栈</span></span><br><span class="line"><span class="string">原理:先进后出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">装子弹</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#使用列表模拟堆栈</span></span><br><span class="line"><span class="comment">#入栈</span></span><br><span class="line"><span class="comment"># stack = []</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;A&#x27;)</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;B&#x27;)</span></span><br><span class="line"><span class="comment"># stack.append(&#x27;C&#x27;)</span></span><br><span class="line"><span class="comment"># print(stack)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># #出栈</span></span><br><span class="line"><span class="comment"># stack.pop()</span></span><br><span class="line"><span class="comment"># print(stack)</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAllFileDir</span>(<span class="params">path</span>):</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="comment">#入栈</span></span><br><span class="line">    stack.append(path)</span><br><span class="line">    <span class="comment">#处理栈,当栈为空的时候结束操作</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#出栈</span></span><br><span class="line">        outDir = stack.pop()</span><br><span class="line">        <span class="comment">#获取当前目录所有文件</span></span><br><span class="line">        filelist = os.listdir(outDir)</span><br><span class="line">        <span class="comment">#判断哪些是目录,继续入栈,如果是文件直接打印</span></span><br><span class="line">        <span class="keyword">for</span> fileName <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment">#判断文件是否是路径(用绝对路径)</span></span><br><span class="line">            fileAbsPath = os.path.join(outDir,fileName)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(fileAbsPath):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;目录:&#x27;</span>,fileName)</span><br><span class="line">                <span class="comment">#入栈</span></span><br><span class="line">                stack.append(fileAbsPath)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;文本文件:&#x27;</span>,fileName)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getAllFileDir(<span class="string">&#x27;C:\python课程大纲\python课程大纲&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="专门模拟队列的">专门模拟队列的</h1>
<p>定义一个队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">queue = collections.deque()</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queue.append(path)</span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outDir = queus.popLeft()</span><br></pre></td></tr></table></figure>
<p>具体事例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">队列原理:先进先出</span></span><br><span class="line"><span class="string">#银行办理业务排队</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">collections</span></span><br><span class="line"><span class="string">deque()  创建一个队列</span></span><br><span class="line"><span class="string">append() 队列添加元素</span></span><br><span class="line"><span class="string">popLeft() 从队列里面删除元素</span></span><br><span class="line"><span class="string">len() 获取长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">listdir()获取当前目录下所有的文件</span></span><br><span class="line"><span class="string">isdir()判断是否是目录</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getAllFileDir</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="comment">#创建一个队列</span></span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    <span class="comment">#入队</span></span><br><span class="line">    queue.append(path)</span><br><span class="line">    <span class="comment">#处理队列,如果队列为空结束操作</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#出队</span></span><br><span class="line">        outDir = queue.popleft()</span><br><span class="line">        <span class="comment">#获取当前目录下所有的文件</span></span><br><span class="line">        filelist = os.listdir(outDir)</span><br><span class="line">        <span class="comment">#判断哪些是目录,入队,如果是文件直接打印</span></span><br><span class="line">        <span class="keyword">for</span> fileName <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment">#判断是否是路径(用绝对路径)</span></span><br><span class="line">            fileAbsPath = os.path.join(outDir,fileName)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(fileAbsPath):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;目录:&#x27;</span>,fileName)</span><br><span class="line">                <span class="comment">#入队</span></span><br><span class="line">                queue.append(fileAbsPath)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;文本文件:&#x27;</span>,fileName)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">getAllFileDir(<span class="string">&#x27;C:\python课程大纲\python课程大纲&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="高阶函数">高阶函数</h1>
<h2 id="map">map</h2>
<h3
id="定义根据提供的函数对指定的序列做映射">定义：根据提供的函数对指定的序列做映射</h3>
<h3 id="格式">格式</h3>
<p>map(function,iterable)
function---》函数，两个参数---》返回值是一个新的列表
iterable---》一个或者多个序列</p>
<p>python2:返回列表 python3:返回的是迭代器</p>
<h3 id="举例">举例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">#案例1:计算列表各个元素的平方</span></span><br><span class="line"><span class="comment">#定义一个求平方的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> n ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">map</span>(square,li)  <span class="comment">#将li列表里面每个元素先作为square函数参数,获取每个元素平方,再执行map函数</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment">#输出&lt;map object at 0x000002C8C4875CC0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(res))   <span class="comment">#输出(1, 4, 9, 16)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))  <span class="comment">#输出[]</span></span><br><span class="line"><span class="comment">#案例2：将单个字符转换为对应的字面量整数</span></span><br><span class="line">li2 = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>]</span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chrToInt</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>&#125;[<span class="built_in">str</span>]</span><br><span class="line">res2 = <span class="built_in">map</span>(chrToInt,li2)</span><br><span class="line"><span class="comment"># print(list(res2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例3：将整数元素的序列，转换为字符串类型</span></span><br><span class="line"><span class="comment">#[1,2,3,4]---&gt;[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;]</span></span><br><span class="line">res3 = <span class="built_in">map</span>(<span class="built_in">str</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(res3))</span><br></pre></td></tr></table></figure>
<h2 id="reduce">reduce</h2>
<h3
id="定义reduce函数会对参数中的元素进行累积">定义：reduce()函数会对参数中的元素进行累积</h3>
<p>函数将一个数据集合(列表，元组)中的所有数据进行下列操作：用传给 reduce
中的函数 function（有两个参数）先对集合中的第 1、2
个元素进行操作，得到的结果再与第三个数据用 function
函数运算，最后得到一个结果。</p>
<h3 id="格式-1">格式：</h3>
<p>reduce(function,iterable,[initializer]) function:函数，有两个参数
iterable：可迭代的对象 initializer：可选，初始化参数</p>
<h3 id="举例-1">举例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment">#案例1:两个数的求和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">res = reduce(add,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2:获取每一个词出现的次数（空格）</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hello python hello php python aa ss aa&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">if</span> y <span class="keyword">in</span> x:</span><br><span class="line">        x[y] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[y] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">res3 = reduce(func,<span class="built_in">list</span>,&#123;&#125;)</span><br><span class="line"><span class="comment"># reduce 函数的工作流程是：</span></span><br><span class="line"><span class="comment"># 将初始值 &#123;&#125; 和列表中的第一个元素传递给函数 func 进行处理，得到一个新的结果。</span></span><br><span class="line"><span class="comment"># 将上一步的结果和列表中的下一个元素传递给函数 func 进行处理，得到另一个新的结果。</span></span><br><span class="line"><span class="comment"># 不断重复上述过程，直到列表中的所有元素都被处理完毕。</span></span><br><span class="line"><span class="comment"># 返回最终的结果，即字典，其中存储了每个单词的出现次数。</span></span><br><span class="line"><span class="built_in">print</span>(res3)</span><br></pre></td></tr></table></figure>
<h2 id="filter">filter</h2>
<h3 id="定义-1">定义</h3>
<p>filter()函数：用于过滤序列，过滤掉不符合条件的元素，返回由符合条件的元素组成的新列表</p>
<h3 id="格式-2">格式</h3>
<p>filter(function,iterable) function:函数 判断函数
iterable：序列，序列的每一个元素作为参数传递到函数进行判断，返回True,False,最后将返回True的元素存放到一个新的列表中</p>
<h3 id="返回值">返回值</h3>
<p>Pyhton2返回列表 Python3返回迭代器对象</p>
<h3 id="举个例子">举个例子</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例1:筛选指定的元素</span></span><br><span class="line">list01 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">#案例1:将偶数筛选出来,奇数删除</span></span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">even</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">res = <span class="built_in">filter</span>(even,list01)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2:将没有爱好的信息过滤掉</span></span><br><span class="line">list02 = [[<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;爱好&#x27;</span>],[<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;无&#x27;</span>],[<span class="string">&#x27;laowang&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;写代码&#x27;</span>],[<span class="string">&#x27;xiaogang&#x27;</span>,<span class="number">29</span>,<span class="string">&#x27;无&#x27;</span>]]</span><br><span class="line"><span class="comment">#定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> v == <span class="string">&#x27;无&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> list02:</span><br><span class="line">    res2 = <span class="built_in">filter</span>(test,line)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res2))</span><br><span class="line"><span class="comment">#使用匿名函数</span></span><br><span class="line">res4 = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x.isdigit(),L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res4))</span><br></pre></td></tr></table></figure>
<h2 id="sorted">sorted</h2>
<h3 id="定义-2">定义</h3>
<p>sorted()函数对所有的可迭代的对象进行排序的操作 sort:
方法返回的是对已经存在的列表进行操作
sorted:返回值为一个新的list，而不是在原来的基础上进行的操作。</p>
<h3 id="格式-3">格式</h3>
<p>sorted(iterable[, cmp[, key[, reverse]]]) iterable:可迭代的对象 cmp
---》比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
key
---》主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
reverse ---》 排序规则，reverse = True 降序 ， reverse = False
升序（默认）。</p>
<h3 id="举个例子-1">举个例子</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">99</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">111</span>]</span><br><span class="line">lst.sort()</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line">res = <span class="built_in">sorted</span>(lst)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#key接受一个内置函数进行排序</span></span><br><span class="line">lst2 = [-<span class="number">3</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">111</span>,-<span class="number">200</span>]</span><br><span class="line">lst2.sort()</span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br><span class="line">res2 = <span class="built_in">sorted</span>(lst2,key=<span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第四周-作业</title>
    <url>/posts/1cb8774b.html</url>
    <content><![CDATA[<h1 id="exercise6装饰器的使用">exercise6:装饰器的使用</h1>
<p>user-credentials.txt内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;xiaoming&quot;, &quot;password&quot;:&quot;123&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaowang&quot;, &quot;password&quot;:&quot;321&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaofang&quot;, &quot;password&quot;:&quot;432&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;xiaobai&quot;, &quot;password&quot;:&quot;111&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_user_credentials</span>(<span class="params">file_path</span>):</span><br><span class="line">    credentials = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            user_info = json.loads(line.strip())</span><br><span class="line">            credentials.append(user_info)</span><br><span class="line">    <span class="keyword">return</span> credentials</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authentication_required</span>(<span class="params">func</span>):</span><br><span class="line">    authenticated = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> authenticated</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> authenticated:</span><br><span class="line">            username = <span class="built_in">input</span>(<span class="string">&quot;Enter your username: &quot;</span>)</span><br><span class="line">            password = <span class="built_in">input</span>(<span class="string">&quot;Enter your password: &quot;</span>)</span><br><span class="line">            user_credentials = read_user_credentials(<span class="string">&quot;user_credentials.txt&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> user_info <span class="keyword">in</span> user_credentials:</span><br><span class="line">                <span class="keyword">if</span> user_info.get(<span class="string">&#x27;name&#x27;</span>) == username <span class="keyword">and</span> user_info.get(<span class="string">&#x27;password&#x27;</span>) == password:</span><br><span class="line">                    authenticated = <span class="literal">True</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Authentication successful!&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Authentication failed. Please try again.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is function 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is function 2.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    function1()</span><br><span class="line">    function1()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter your username: xiaoming</span><br><span class="line">Enter your password: 123</span><br><span class="line">Authentication successful!</span><br><span class="line">This is function 1.</span><br><span class="line">This is function 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第四周-面向对象</title>
    <url>/posts/2cc950a3.html</url>
    <content><![CDATA[<h1 id="定义一个类">定义一个类</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):	<span class="comment">#objectobject 是所有类的基类，也称为顶级类或根类。在定义类时，如果没有明确指定继承的父类，则默认继承自 object 类，可以省略</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):	<span class="comment"># self 是一个惯用的命名约定，用来表示对象自身。在类的方法定义中，self 参数指向类的实例，也就是调用该方法的对象本身。通过 self，可以在方法内部访问和操作对象的属性和方法。是 Python 中定义类方法的标准做法，不可省略</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self</span>):</span><br></pre></td></tr></table></figure>
<h1 id="类中几种常见方法">类中几种常见方法</h1>
<h2
id="init__方法类似与java类的构造函数">__init__方法（类似与java类的构造函数）</h2>
<h2
id="del方法删除对象时自动调用在对一个对象引用次数为0才算彻底删除">del()方法：删除对象时自动调用，在对一个对象引用次数为0才算彻底删除</h2>
<p>举个例子</p>
<p>定义一个动物的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法  创建对象时候自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;__init__方法被调用&#x27;)</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物会跑&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个析构方法  删除对象的时候自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;__del__方法被调用&#x27;)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s对象被干掉&#x27;</span>%(self.name))</span><br></pre></td></tr></table></figure>
<p>然后实例化一个猫的对象，并且多次引用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cat = Animal(<span class="string">&#x27;波斯猫&#x27;</span>)</span><br><span class="line">cat2 = cat</span><br><span class="line">cat3 = cat</span><br></pre></td></tr></table></figure>
<p>发现创建了多个cat对象</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220170553004.png" /></p>
<p>如果只删除一个，另外两个还存在</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220170715549.png" /></p>
<h2
id="魔法方法python中的一种特殊方法它们以双下划线开头和结尾例如-__init____str____add__-等这些方法在特定的情况下会被python解释器自动调用而不需要我们显式地调用它们">魔法方法：Python中的一种特殊方法，它们以双下划线开头和结尾，例如
<code>__init__</code>、<code>__str__</code>、<code>__add__</code>
等。这些方法在特定的情况下会被Python解释器自动调用，而不需要我们显式地调用它们。</h2>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法  创建对象的时候被自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,newColor,newWheelNum</span>):</span><br><span class="line">        self.color = newColor</span><br><span class="line">        self.wheelNum = newWheelNum</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个析构方法  删除对象的时候被自动调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s对象被删除&#x27;</span>%(self.color))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义一个魔方方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># msg = &#x27;%s-%d&#x27;%(self.color,self.wheelNum)</span></span><br><span class="line">        <span class="comment"># return msg</span></span><br><span class="line">        <span class="keyword">return</span> self.color</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个对象laosi</span></span><br><span class="line">laosi = Car(<span class="string">&#x27;红色&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 通过print打印对象的时候,如果类中定义__str__方法,自动调用,一般方便查看类中属性值</span></span><br><span class="line"><span class="built_in">print</span>(laosi)</span><br><span class="line"><span class="comment"># 后面做开发的时候,想直接返回对象中属性值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#总结:如果类的属性比较多,可以重写__str__()方法打印属性,方便阅读,无需手动调用,当使用print打印对象的时候,自动调用</span></span><br></pre></td></tr></table></figure>
<p>定义一个魔法方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.color</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220172039437.png" /></p>
<p>如果类的属性比较多,可以重写__str__()方法打印属性,方便阅读,无需手动调用,当使用print打印对象的时候,自动调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    msg = <span class="string">&#x27;%s-%d&#x27;</span>%(self.color,self.wheelNum)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240220172155163.png" /></p>
<h2 id="str和repr">str()和repr()</h2>
<h3
id="str_用于将数值转化为人阅读的形式调用print的时候自动调用">_<strong>str</strong>_()用于将数值转化为人阅读的形式，调用print的时候自动调用</h3>
<h3
id="repr__用于转化为解释器读取的形式">__repr__()用于转化为解释器读取的形式</h3>
<p>注：在没有__str__的时候，认为str == repr</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前的时间</span></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(now)</span><br><span class="line"><span class="comment"># output 2024-02-05 22:12:48.663497</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(now))</span><br><span class="line"><span class="comment"># output &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(now))  <span class="comment">#转换成字符串</span></span><br><span class="line"><span class="comment"># output: 2024-02-05 22:12:48.663497</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>(now)))</span><br><span class="line"><span class="comment"># output: &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(now))</span><br><span class="line"><span class="comment"># output: datetime.datetime(2024, 2, 5, 22, 12, 48, 663497)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="built_in">repr</span>(now)))  <span class="comment">#eval参数是字符串表达式 repr(now)当成整体作为参数执行 再返回repr之后的结果</span></span><br><span class="line"><span class="comment"># output: 2024-02-05 22:12:48.663497</span></span><br></pre></td></tr></table></figure>
<p>总结: repr返回的是字符串,一般用来获取对象</p>
<p>obj == eval(repr(obj)) 这个公式是成立的</p>
<h1 id="继承">继承</h1>
<h2 id="定义">定义</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    attribute1, attribute2</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):	<span class="comment"># 表示B继承A</span></span><br></pre></td></tr></table></figure>
<p>如果有两个类,一个父类,一个子类,定义了同名的方法,如果实例化子类对象调用方法的时候先从子类查找
，再一级一级往上查找</p>
<h2 id="初始化">初始化</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,sex</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人都需要吃饭&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我会汉语&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义子类Student继承父类Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment">#定义初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,name,age,sex</span>):</span><br><span class="line">        self.no = no</span><br><span class="line">        <span class="comment"># 调用父类同名方法</span></span><br><span class="line">        <span class="comment"># 1.父类类名.父类方法</span></span><br><span class="line">        <span class="comment"># Person.__init__(self,name,age,sex)  直接调用父类的初始化方法，并将 self（当前实例）以及需要传递的参数传递给它。</span></span><br><span class="line">        <span class="comment"># 2.super()</span></span><br><span class="line">        <span class="comment"># super().__init__(name,age,sex) 使用 super() 函数获取父类的引用，并调用其初始化方法，无需手动传递 self，它会自动传递。</span></span><br><span class="line">        <span class="built_in">super</span>(Student, self).__init__(name,age,sex)</span><br><span class="line">        <span class="comment"># 调用父类 Person 的 __init__ 方法，以便在创建 Student 对象时对父类属性进行初始化。</span></span><br></pre></td></tr></table></figure>
<h1 id="访问限制">访问限制</h1>
<h2
id="私有就是按java中私有属性的来理解">私有，就是按java中私有属性的来理解</h2>
<p>__双下划线后面跟属性名</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#定义一个初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,money</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义普通方法对属性设置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="comment">#数据过滤</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(value) &lt;= <span class="number">4</span>:</span><br><span class="line">            self.__name = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;名称的长度不能大于4个字符&#x27;</span>)</span><br><span class="line">    <span class="comment">#定义普通方法获取属性值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义私有方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我的名字是:%s,我有%s存款&#x27;</span>%(self.__name,self._money))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义公有方法获取私有属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        self.__sayHello()</span><br></pre></td></tr></table></figure>
<h2 id="半公开_单下划线后面跟属性名">半公开：_单下划线后面跟属性名</h2>
<h2 id="公开直接属性名">公开：直接属性名</h2>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>调试</title>
    <url>/posts/aaf56f78.html</url>
    <content><![CDATA[<h1 id="调试">调试</h1>
<h2 id="断言assert">断言assert</h2>
<p>等价于： if not expression: raise AssertError</p>
<h2 id="logging">logging</h2>
<h3 id="导入">导入</h3>
<h3 id="配置">配置</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(</span><br><span class="line">    filename</span><br><span class="line">    filenode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="种类">种类</h3>
<p>debug，error， info，warning</p>
<h2 id="pdb">pdb</h2>
<p>可以在终端调试代码</p>
<h1 id="单元测试">单元测试</h1>
<p>概述： 单元测试：
用来对一个函数，一个类或者一个模块来进行一个正确性的校验工作</p>
<p>结果： 1.单元测试通过：说明测试的函数功能正常
2.单元测试不通过：函数有BUG，测试条件输入有误</p>
]]></content>
      <categories>
        <category>python</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟环境</title>
    <url>/posts/48543190.html</url>
    <content><![CDATA[<p>conda管理环境下pip的安装路径</p>
<p>默认conda下用pip安装的路径都会在一个地方</p>
<p><a
href="https://blog.csdn.net/mukvintt/article/details/80908951">参考文章</a></p>
<p>另外关于vir管理问题就比较迷惑了</p>
<p>我将C:3个G的文件移动到其他盘就报错，必须把它移会来</p>
<p>报错如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OSError: [WinError 649] 创建操作失败，因为名称含有至少一个装入点</span><br></pre></td></tr></table></figure>
<p>正常pip的虚拟环境就配置在venv里面</p>
<p>比如安装numpy后</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126232333231.png" /></p>
<p>哦原来如此，上面提到的放的是缓存，可以删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip cache purge</span><br></pre></td></tr></table></figure>
<p>修改pip安装包的位置</p>
<p>/home/ztb/.conda/envs/FaceXray_env2/lib/python3.6/site.py</p>
]]></content>
  </entry>
  <entry>
    <title>接口与继承</title>
    <url>/posts/d3f99f79.html</url>
    <content><![CDATA[<h1 id="接口">接口</h1>
<span id="more"></span>
<p><strong>接口就像是一种约定</strong>，我们约定某些英雄是物理系英雄，那么他们就一定能够进行物理攻击。</p>
<h2 id="创建接口">创建接口</h2>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface AD &#123;</span><br><span class="line">        //物理伤害</span><br><span class="line">    public void physicAttack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口">实现接口</h2>
<p><strong>实现某个接口，就相当于承诺了某种约定</strong></p>
<p>所以，<strong>实现</strong>了<strong>AD</strong>这个接口，就<strong>必须</strong>提供AD接口中声明的方法<strong>physicAttack()</strong>
<strong>实现</strong>在语法上使用关键字 <strong>implements</strong></p>
<h2 id="默认方法">默认方法</h2>
<h3 id="定义">定义</h3>
<p>接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public interface Mortal &#123;</span><br><span class="line">    public void die();</span><br><span class="line"> </span><br><span class="line">    default public void revive() &#123;</span><br><span class="line">        System.out.println(&quot;本英雄复活了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么会有默认方法">为什么会有默认方法</h3>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
<h1 id="对象转型">对象转型</h1>
<h2 id="引用类型与对象类型">引用类型与对象类型</h2>
<p>在这个例子里，有一个对象 new ADHero(), 同时也有一个引用ad
对象是有类型的， 是ADHero 引用也是有类型的，是ADHero
通常情况下，引用类型和对象类型是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向上转型">向上转型</h2>
<h3 id="子类转父类">子类转父类</h3>
<p>一个很简单的判别办法
<font color = "red"><strong>把右边的当做左边来用</strong>，看说得通不</font></p>
<p>所有的<strong>子类转换为父类</strong>，都是说得通的</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;   </span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        Hero h = new Hero();//h引用的类型是Hero</span><br><span class="line">        ADHero ad = new ADHero();//ad引用的类型是ADHero</span><br><span class="line">        h = ad; //把ADHero当做Hero使用，一定可以         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类转换接口">类转换接口</h3>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">       </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">          </span><br><span class="line">        AD adi = ad;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从语义上来讲，把一个ADHero当做AD来使用，而AD接口只有一个physicAttack方法，这就意味着转换后就有可能要调用physicAttack方法，而ADHero一定是有physicAttack方法的，所以转换是能成功的。</p>
<h2 id="向下转型">向下转型</h2>
<h3 id="父类转子类">父类转子类</h3>
<p>父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。
强制转换的意思就是 转换有风险，风险自担。</p>
<h3 id="接口转实现类">接口转实现类</h3>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">     </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">         </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">            </span><br><span class="line">        AD adi = ad;	//ad引用指向ADHero， 而adi引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功</span><br><span class="line">   </span><br><span class="line">        ADHero adHero = (ADHero) adi;	//adi实际上是指向一个ADHero的，所以能够转换成功</span><br><span class="line">            </span><br><span class="line">        ADAPHero adapHero = (ADAPHero) adi;	// adi引用所指向的对象是一个ADHero，要转换为ADAPHero就会失败。</span><br><span class="line">        adapHero.magicAttack();</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口要先向下转型成为一个类，这个接口实际上已经只想一个类(应该不全，有空看看文章)</p>
<p>所以继承并实现这个接口的类才有可能让接口向下转型，与这个接口没有继承关系的类一定不能</p>
<h2 id="instanceof">instanceof</h2>
<p>判断一个引用所指向的对象</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ADHero ad = new ADHero();</span><br><span class="line">        APHero ap = new APHero();</span><br><span class="line">         </span><br><span class="line">        Hero h1= ad;</span><br><span class="line">        Hero h2= ap;</span><br><span class="line">         </span><br><span class="line">        //判断引用h1指向的对象，是否是ADHero类型</span><br><span class="line">        System.out.println(h1 instanceof ADHero);</span><br><span class="line">         </span><br><span class="line">        //判断引用h2指向的对象，是否是APHero类型</span><br><span class="line">        System.out.println(h2 instanceof APHero);</span><br><span class="line">         </span><br><span class="line">        //判断引用h1指向的对象，是否是Hero的子类型</span><br><span class="line">        System.out.println(h1 instanceof Hero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态">多态</h1>
<h2 id="操作符的多态">操作符的多态</h2>
<p>如果+号两侧都是整型，那么<strong>+代表 数字相加</strong>
如果+号两侧，任意一个是字符串，那么<strong>+代表字符串连接</strong></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        int i = 5;</span><br><span class="line">        int j = 6;</span><br><span class="line">        int k = i+j; //如果+号两侧都是整型，那么+代表 数字相加</span><br><span class="line">         </span><br><span class="line">        System.out.println(k);</span><br><span class="line">         </span><br><span class="line">        int a = 5;</span><br><span class="line">        String b = &quot;5&quot;;</span><br><span class="line">         </span><br><span class="line">        String c = a+b; //如果+号两侧，任意一个是字符串，那么+代表字符串连接</span><br><span class="line">        System.out.println(c);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的多态">类的多态</h2>
<p>同一个类型，调用同一个方法，却能呈现不同的状态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Item i1= new LifePotion();	// i1实际上指向LifePotion这种对象</span><br><span class="line">Item i2 = new MagicPotion();	//i2实际上指向MagicPotion这种对象</span><br><span class="line">System.out.print(&quot;i1  是Item类型，执行effect打印:&quot;);	//i1调用LifePotion对象中方法</span><br><span class="line">i1.effect();</span><br><span class="line">System.out.print(&quot;i2也是Item类型，执行effect打印:&quot;);		//i2调用MagicPotion对象中effect方法</span><br><span class="line">i2.effect();</span><br></pre></td></tr></table></figure>
<h3 id="类的多态条件">类的多态条件</h3>
<ol type="1">
<li>父类（接口）引用指向子类对象</li>
<li>调用的方法有重写</li>
</ol>
<h2 id="使用多态与不使用多态区别">使用多态与不使用多态区别</h2>
<p>不使用多态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void useLifePotion(LifePotion lp)&#123;</span><br><span class="line">    lp.effect();</span><br><span class="line">&#125;</span><br><span class="line">public void useMagicPotion(MagicPotion mp)&#123;</span><br><span class="line">    mp.effect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useLifePotion(LifePotion lp)&#123;</span><br><span class="line">        lp.effect();</span><br><span class="line">    &#125;</span><br><span class="line">    public void useMagicPotion(MagicPotion mp)&#123;</span><br><span class="line">        mp.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp =new LifePotion();</span><br><span class="line">        MagicPotion mp =new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useLifePotion(lp);</span><br><span class="line">        garen.useMagicPotion(mp);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用多态</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void useItem(Item i)&#123;</span><br><span class="line">    i.effect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line">   </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">     </span><br><span class="line">        LifePotion lp =new LifePotion();</span><br><span class="line">        MagicPotion mp =new MagicPotion();</span><br><span class="line">         </span><br><span class="line">        garen.useItem(lp);</span><br><span class="line">        garen.useItem(mp);     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exercise</p>
<ol type="1">
<li>设计一个接口</li>
</ol>
<p>接口叫做Mortal,其中有一个方法叫做die</p>
<ol start="2" type="1">
<li>实现接口</li>
</ol>
<p>分别让ADHero,APHero,ADAPHero这三个类，实现Mortal接口，不同的类实现die方法的时候，都打印出不一样的字符串</p>
<ol start="3" type="1">
<li><p>为Hero类，添加一个方法,在这个方法中调用 m的die方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void kill(Mortal m)</span><br></pre></td></tr></table></figure></li>
<li><p>在主方法中 首先实例化出一个Hero对象:盖伦
然后实例化出3个对象，分别是ADHero,APHero,ADAPHero的实例 然后让盖伦 kill
这3个对象</p></li>
</ol>
<p>answer</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void kill(Mortal m) &#123;</span><br><span class="line">    m.die();</span><br><span class="line">&#125;</span><br><span class="line">    ADHero shibing1 = new ADHero();</span><br><span class="line">    APHero shibing2 = new APHero();</span><br><span class="line">    ADAPHero shibing3 = new ADAPHero();</span><br><span class="line">    garen.kill(shibing1);</span><br><span class="line">    garen.kill(shibing2);</span><br><span class="line">    garen.kill(shibing3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面在尝试的时候发现只能在声明shibing的时候必须用对应的类或者声明成接口类型Mortal，如果声明成Hero类型会报错。个人理解原因是Hero与Mortal之间没有继承关系</p>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">import property.Item;</span><br><span class="line">import property.LifePotion;</span><br><span class="line">import property.MagicPotion;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void kill(Mortal m) &#123;</span><br><span class="line">        m.die();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero garen =  new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line"></span><br><span class="line">        Mortal shibing1 = new ADHero();</span><br><span class="line">        Mortal shibing2 = new APHero();</span><br><span class="line">        Mortal shibing3 = new ADAPHero();</span><br><span class="line">        garen.kill(shibing1);</span><br><span class="line">        garen.kill(shibing2);</span><br><span class="line">        garen.kill(shibing3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="隐藏">隐藏</h1>
<p>与重写类似，方法的<strong>重写是</strong>子类覆盖父类的<strong>对象方法</strong></p>
<p><strong>隐藏</strong>，就是子类覆盖父类的<strong>类方法</strong></p>
<p><font color = "red">子类中的静态方法覆盖率父类中的静态方法</font></p>
<p>举例：</p>
<p>父类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    //类方法，静态方法</span><br><span class="line">    //通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;hero battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //隐藏父类的battleWin方法</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;ad hero battle win&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exercise:</p>
<p>Hero h =new ADHero();</p>
<p>h.battleWin(); //battleWin是一个类方法 h是父类类型的引用
但是指向一个子类对象 h.battleWin();
会调用父类的方法？还是子类的方法？</p>
<p>answer:</p>
<p><font color = "red">静态方法与类直接关联，而不是与实例对象关联</font>。所以声明为Hero的类，就调用Hero的类方法</p>
<h1 id="super关键字">super关键字</h1>
<h2 id="父类显式提供无参构造方法">父类显式提供无参构造方法</h2>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Hero()&#123;</span><br><span class="line">    System.out.println(&quot;Hero的构造方法 &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; //姓名</span><br><span class="line">        </span><br><span class="line">    float hp; //血量</span><br><span class="line">        </span><br><span class="line">    float armor; //护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化子类，父类的构造方法一定会被调用</p>
<p>实例化一个ADHero(), 其构造方法会被调用
其<strong>父类的构造方法也会被调用</strong>
并且是父类构造方法<strong>先调用</strong> 子类构造方法会默认调用父类的
无参的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ADHero()&#123;</span><br><span class="line">     </span><br><span class="line">    System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">new ADHero();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完整代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero()&#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        new ADHero();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hero的构造方法 </span><br><span class="line">AD Hero的构造方法</span><br></pre></td></tr></table></figure>
<h2 id="父类显式提供两个构造方法">父类显式提供两个构造方法</h2>
<p>分别是无参的构造方法和带一个参数的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Hero()&#123;</span><br><span class="line">    System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public Hero(String name)&#123;</span><br><span class="line">    System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">import property.Item;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">        </span><br><span class="line">    String name; //姓名</span><br><span class="line">        </span><br><span class="line">    float hp; //血量</span><br><span class="line">        </span><br><span class="line">    float armor; //护甲</span><br><span class="line">        </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">     </span><br><span class="line">    public void useItem(Item i)&#123;</span><br><span class="line">        System.out.println(&quot;hero use item&quot;);</span><br><span class="line">        i.effect();</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.println(&quot;Hero的无参的构造方法 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;Hero的有一个参数的构造方法 &quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Hero();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类显式调用父类带参构造方法</p>
<p>使用关键字<strong>super</strong> 显式调用父类带参的构造方法</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ADHero(String name)&#123;</span><br><span class="line">    super(name);</span><br><span class="line">    System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class ADHero extends Hero implements AD&#123;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void physicAttack() &#123;</span><br><span class="line">        System.out.println(&quot;进行物理攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public ADHero(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        System.out.println(&quot;AD Hero的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ADHero(&quot;德莱文&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用父类属性</p>
<h1 id="objext类">Objext类</h1>
<p>Object类是所有类的父类</p>
<h2 id="tostring">toString()</h2>
<p>toString()的意思是返回当前对象的<strong>字符串表达</strong></p>
<p>举例说明</p>
<p>直接调用原式版本的toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">//    public String toString()&#123;</span><br><span class="line">//        return name;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero h = new Hero();</span><br><span class="line">        h.name = &quot;盖伦&quot;;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        //直接打印对象就是打印该对象的toString()返回值</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Hero h = new Hero();</span><br><span class="line">        h.name = &quot;盖伦&quot;;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        //直接打印对象就是打印该对象的toString()返回值</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finalize">finalize()</h2>
<p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。</p>
<p>举例</p>
<h2 id="equals">equals()</h2>
<p>equals() 用于判断两个对象的内容是否相同</p>
<p>原始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">//    public boolean equals(Object o)&#123;</span><br><span class="line">//        if(o instanceof Hero)&#123;</span><br><span class="line">//            Hero h = (Hero) o;</span><br><span class="line">//            return this.hp == h.hp;</span><br><span class="line">//        &#125;</span><br><span class="line">//        return false;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1.equals(h2));</span><br><span class="line">        System.out.println(h1.equals(h3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>改写：</p>
<p>假设，当两个英雄的hp相同的时候，我们就认为这两个英雄相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h = (Hero) o;</span><br><span class="line">            return this.hp == h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1.equals(h2));</span><br><span class="line">        System.out.println(h1.equals(h3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section">==</h2>
<p>这不是Object的方法，但是用于判断两个对象是否相同
<strong>更准确的讲</strong>，用于判断两个引用，是否指向了同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o)&#123;</span><br><span class="line">        if(o instanceof Hero)&#123;</span><br><span class="line">            Hero h = (Hero) o;</span><br><span class="line">            return this.hp == h.hp;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h1= new Hero();</span><br><span class="line">        h1.hp = 300;</span><br><span class="line">        Hero h2= new Hero();</span><br><span class="line">        h2.hp = 400;</span><br><span class="line">        Hero h3= new Hero();</span><br><span class="line">        h3.hp = 300;</span><br><span class="line"></span><br><span class="line">        System.out.println(h1==h2);</span><br><span class="line">        System.out.println(h1==h3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<h1 id="final">final</h1>
<h2 id="final修饰类">final修饰类</h2>
<p>当Hero被修饰成final的时候，表示Hero不能够被继承
其子类会出现编译错误</p>
<h2 id="final修饰方法">final修饰方法</h2>
<p>父类中被final修饰的方法不能在子类中重写</p>
<h2 id="final修饰基本类型变量">final修饰基本类型变量</h2>
<p>final修饰基本类型变量，表示该变量只有一次赋值机会</p>
<h2 id="final修饰引用">final修饰引用</h2>
<p>final修饰引用
h引用被修饰成final，表示该引用只有<strong>1</strong>次指向对象的机会</p>
<h1 id="抽象类">抽象类</h1>
<h2 id="定义-1">定义</h2>
<p>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</p>
<p>这样的方法就叫抽象方法，使用修饰符“abstract"</p>
<p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p>
<p><font color = "red">抽象类可以没有抽象方法，一旦一个类被声明为抽象类，就不能够被直接实例化</font></p>
<h2 id="与子类的关系">与子类的关系</h2>
<p>为Hero增加一个<strong>抽象方法
attack</strong>，并且把Hero声明为abstract的。继承Hero类后，这些<strong>子类就必须提供</strong>不一样的attack方法实现。</p>
<h2 id="抽象类和接口的区别">抽象类和接口的区别</h2>
<p>区别1：</p>
<ul>
<li><p>子类只能继承一个抽象类，不能继承多个</p></li>
<li><p>子类可以实现<strong>多个</strong>接口</p></li>
</ul>
<p>区别2：</p>
<ul>
<li>抽象类可以定义
public,protected,package,private、静态和非静态属性、final和非final属性</li>
<li>接口中声明的属性，即便没有显式的声明，也只能是public、静态和final</li>
</ul>
<h1 id="内部类">内部类</h1>
<h2 id="非静态内部类">非静态内部类</h2>
<h3 id="定义-2">定义：</h3>
<p>非静态内部类可以直接在一个类里面定义</p>
<h3 id="语法">语法</h3>
<p><strong>new 外部类().new 内部类()</strong></p>
<h3 id="使用">使用</h3>
<p>作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name<strong>的</strong></p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">class BattleScore &#123;</span><br><span class="line">    int kill;</span><br><span class="line">    int die;</span><br><span class="line">    int assit;</span><br><span class="line"> </span><br><span class="line">    public void legendary() &#123;</span><br><span class="line">        if (kill &gt;= 8)</span><br><span class="line">            System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        // 实例化内部类</span><br><span class="line">    // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    // 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">    BattleScore score = garen.new BattleScore();</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    private String name; // 姓名</span><br><span class="line"> </span><br><span class="line">    float hp; // 血量</span><br><span class="line"> </span><br><span class="line">    float armor; // 护甲</span><br><span class="line"> </span><br><span class="line">    int moveSpeed; // 移动速度</span><br><span class="line"> </span><br><span class="line">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    // 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    class BattleScore &#123;</span><br><span class="line">        int kill;</span><br><span class="line">        int die;</span><br><span class="line">        int assit;</span><br><span class="line"> </span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;= 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen = new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">        // 实例化内部类</span><br><span class="line">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        // 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">        BattleScore score = garen.new BattleScore();</span><br><span class="line">        score.kill = 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类">静态内部类</h2>
<h3 id="定义-3">定义</h3>
<p>与非静态内部类不同，<strong>静态内部类</strong>水晶类的实例化
<strong>不需要一个外部类的实例为基础</strong>，可以直接实例化</p>
<h3 id="语法-1">语法</h3>
<p><strong>new 外部类.静态内部类();</strong></p>
<h3 id="使用-1">使用</h3>
<p>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong>
除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class EnemyCrystal&#123;</span><br><span class="line">    int hp=5000;</span><br><span class="line">     </span><br><span class="line">    //如果水晶的血量为0，则宣布胜利</span><br><span class="line">    public void checkIfVictory()&#123;</span><br><span class="line">        if(hp==0)&#123;</span><br><span class="line">            Hero.battleWin();</span><br><span class="line">             </span><br><span class="line">            //静态内部类不能直接访问外部类的对象属性</span><br><span class="line">            System.out.println(name + &quot; win this game&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        //实例化静态内部类</span><br><span class="line">    Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">  </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line">  </span><br><span class="line">    private static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //敌方的水晶</span><br><span class="line">    static class EnemyCrystal&#123;</span><br><span class="line">        int hp=5000;</span><br><span class="line">         </span><br><span class="line">        //如果水晶的血量为0，则宣布胜利</span><br><span class="line">        public void checkIfVictory()&#123;</span><br><span class="line">            if(hp==0)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                //静态内部类不能直接访问外部类的对象属性</span><br><span class="line">                System.out.println(name + &quot; win this game&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //实例化静态内部类</span><br><span class="line">        Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名类">匿名类</h2>
<h3 id="定义-4">定义</h3>
<ol type="1">
<li>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练
通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</li>
<li>有的时候，为了快速使用，<font color = "red">直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。</font>
既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。
<font color = "red">这样的类，叫做匿名类</font></li>
<li>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</li>
</ol>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; //姓名</span><br><span class="line">          </span><br><span class="line">    float hp; //血量</span><br><span class="line">          </span><br><span class="line">    float armor; //护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh=new ADHero();</span><br><span class="line">        //通过打印adh，可以看到adh这个对象属于ADHero类</span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        Hero h = new Hero()&#123;</span><br><span class="line">            //当场实现attack方法</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本地类">本地类</h2>
<h3 id="定义-5">定义</h3>
<p>本地类可以理解为<font color = "red">有名字的匿名类</font>,可以直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//与匿名类的区别在于，本地类有了自定义的类名</span><br><span class="line">class SomeHero extends Hero&#123;</span><br><span class="line">    public void attack() &#123;</span><br><span class="line">        System.out.println( name+ &quot; 新的进攻手段&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line">   </span><br><span class="line">public abstract class Hero &#123;</span><br><span class="line">    String name; //姓名</span><br><span class="line">          </span><br><span class="line">    float hp; //血量</span><br><span class="line">          </span><br><span class="line">    float armor; //护甲</span><br><span class="line">          </span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line">      </span><br><span class="line">    public abstract void attack();</span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          </span><br><span class="line">        //与匿名类的区别在于，本地类有了自定义的类名</span><br><span class="line">        class SomeHero extends Hero&#123;</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println( name+ &quot; 新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        SomeHero h  =new SomeHero();</span><br><span class="line">        h.name =&quot;地卜师&quot;;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="uml图">UML图</h1>
<h2 id="类图">类图</h2>
<p><img src="https://stepimagewm.how2j.cn/2318.png" /></p>
<h2 id="接口图">接口图</h2>
<p><img src="https://stepimagewm.how2j.cn/2319.png" /></p>
<h2 id="继承关系">继承关系</h2>
<p><img src="https://stepimagewm.how2j.cn/2320.png" /></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>数字与字符串</title>
    <url>/posts/37035380.html</url>
    <content><![CDATA[<h1 id="装箱和拆箱">装箱和拆箱</h1>
<span id="more"></span>
<h2 id="封装类">封装类</h2>
<p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong>
比如int对应的类是Integer 这种类就叫做封装类</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">         </span><br><span class="line">        //把一个基本类型的变量,转换为Integer对象</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">        //把一个Integer对象，转换为一个基本类型的int</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="number类">Number类</h2>
<p>数字封装类有 Byte,Short,Integer,Long,Float,Double
这些类都是抽象类Number的子类</p>
<h2 id="基本类型转封装类">基本类型转封装类</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装类转基本类型">封装类转基本类型</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">        //封装类型转换成基本类型</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动装箱">自动装箱</h2>
<p>不需要调用构造方法，<strong>通过=符号自动</strong>把 基本类型 转换为
类类型 就叫装箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line"> </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line"> </span><br><span class="line">        //基本类型转换成封装类型</span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">         </span><br><span class="line">        //自动转换就叫装箱</span><br><span class="line">        Integer it2 = i;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动拆箱">自动拆箱</h2>
<p>不需要调用Integer的intValue方法，通过=就自动转换成int类型，就叫拆箱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">  </span><br><span class="line">        Integer it = new Integer(i);</span><br><span class="line">          </span><br><span class="line">        //封装类型转换成基本类型</span><br><span class="line">        int i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">        //自动转换就叫拆箱</span><br><span class="line">        int i3 = it;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串转换">字符串转换</h1>
<h2 id="数字转字符串">数字转字符串</h2>
<p>先把基本类型装箱为类对象，然后调用类对象的静态方法toString</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">         </span><br><span class="line">        //方法1</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">         </span><br><span class="line">        //方法2</span><br><span class="line">        Integer it = i;</span><br><span class="line">        String str2 = it.toString();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转数字">字符串转数字</h2>
<p>调用类对象的静态方法parseInt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String str = &quot;999&quot;;</span><br><span class="line">         </span><br><span class="line">        int i= Integer.parseInt(str);</span><br><span class="line">         </span><br><span class="line">        System.out.println(i);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学方法">数学方法</h1>
<h2 id="四舍五入-随机数开方次方π自然常数">四舍五入,
随机数，开方，次方，π，自然常数</h2>
<h3 id="四舍五入round">四舍五入round</h3>
<h3 id="随机数random">随机数random</h3>
<h3 id="开方sqrt">开方sqrt</h3>
<h3 id="次方pow">次方pow</h3>
<h3 id="π">π</h3>
<h3 id="自然常数e">自然常数e</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">5.4f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">5.5f</span>;</span><br><span class="line">        <span class="comment">//5.4四舍五入即5</span></span><br><span class="line">        System.out.println(Math.round(f1));</span><br><span class="line">        <span class="comment">//5.5四舍五入即6</span></span><br><span class="line">        System.out.println(Math.round(f2));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-1之间的随机浮点数（取不到1）</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//得到一个0-10之间的随机整数 （取不到10）</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)( Math.random()*<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//开方</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">9</span>));</span><br><span class="line">        <span class="comment">//次方（2的4次方）</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//π</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//自然常数</span></span><br><span class="line">        System.out.println(Math.E);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="格式化输出">格式化输出</h1>
<h2 id="printf和format">printf和format</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package digit;</span><br><span class="line">  </span><br><span class="line">public class TestNumber &#123;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        String name =&quot;盖伦&quot;;</span><br><span class="line">        int kill = 8;</span><br><span class="line">        String title=&quot;超神&quot;;</span><br><span class="line">         </span><br><span class="line">        String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">        //使用printf格式化输出</span><br><span class="line">        System.out.printf(sentenceFormat,name,kill,title);</span><br><span class="line">        //使用format格式化输出</span><br><span class="line">        System.out.format(sentenceFormat,name,kill,title);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="总长度左对齐补0千位分隔符小数点位数本地化表达">总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2020</span>;</span><br><span class="line">        <span class="comment">//总长度，左对齐，补0，千位分隔符，小数点位数，本地化表达</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//直接打印数字</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,默认右对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,左对齐</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%-8d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//总长度是8,不够补0</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%08d%n&quot;</span>,year);</span><br><span class="line">        <span class="comment">//千位分隔符</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%,8d%n&quot;</span>,year*<span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//小数点位数</span></span><br><span class="line">        System.out.format(<span class="string">&quot;%.2f%n&quot;</span>,Math.PI);</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//不同国家的千位分隔符</span></span><br><span class="line">        System.out.format(Locale.FRANCE,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.US,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">        System.out.format(Locale.UK,<span class="string">&quot;%,.2f%n&quot;</span>,Math.PI*<span class="number">10000</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符">字符</h1>
<h2 id="常用方法">常用方法</h2>
<h3 id="是否是字母isletter">是否是字母isLetter</h3>
<h3 id="是否为数字isdigit">是否为数字isDigit</h3>
<h3 id="是否是空白iswhitespace">是否是空白isWhiteSpace</h3>
<h3 id="是否是大写isuppercase">是否是大写isUpperCase</h3>
<h3 id="是否是小写islowercase">是否是小写isLowerCase</h3>
<h3 id="转换为大写touppercase">转换为大写toUpperCase</h3>
<h3 id="转换为小写tolowercase">转换为小写toLowerCase</h3>
<h3 id="转换为字符串tostring">转换为字符串toString</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChar</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.isLetter(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//判断是否为字母</span></span><br><span class="line">        System.out.println(Character.isDigit(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//判断是否为数字</span></span><br><span class="line">        System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>)); <span class="comment">//是否是空白</span></span><br><span class="line">        System.out.println(Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是大写</span></span><br><span class="line">        System.out.println(Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//是否是小写</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//转换为大写</span></span><br><span class="line">        System.out.println(Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//转换为小写</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; <span class="comment">//不能够直接把一个字符转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> Character.toString(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//转换为字符串</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2 id="创建字符串">创建字符串</h2>
<h3
id="字面值就是用双引号括起来的值">字面值，就是用双引号括起来的值</h3>
<h3 id="通过字符数组创建">通过字符数组创建</h3>
<h3 id="通过拼接">通过+拼接</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">garen</span> <span class="operator">=</span><span class="string">&quot;盖伦&quot;</span>; <span class="comment">//字面值,虚拟机碰到字面值就会创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;提莫&quot;</span>); <span class="comment">//创建了两个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;崔&#x27;</span>,<span class="string">&#x27;斯&#x27;</span>,<span class="string">&#x27;特&#x27;</span>&#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);<span class="comment">//  通过字符数组创建一个字符串对象</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">String</span> <span class="variable">hero3</span> <span class="operator">=</span> garen + teemo;<span class="comment">//  通过+加号进行字符串拼接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串不能被继承，不能被改变</p>
<h2 id="exercise">Exercise</h2>
<h3 id="ex.1随机字符串">ex.1:随机字符串</h3>
<p>碰到问题：</p>
<ol type="1">
<li><p>random如何获得指定范围内随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span>)(Math.random() * <span class="number">10</span>)</span><br><span class="line"><span class="comment">//(int)用来将double强转成int类型</span></span><br><span class="line"><span class="comment">//(Math.random() * 10)外括号一定要有，否则会先运算将Math.random()结果强转成int类型再乘10，就始终是0</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何获得随机的26个字母</p>
<p>先用random获得随机距离，从0到25，然后用(char)('a' +
distance)获得随机的字母</p></li>
<li><p>如何将int类型数字转换成char类型数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">char</span>)(<span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> study_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">random_5_length_string</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> flag_for_capacity;</span><br><span class="line">        <span class="type">char</span>[] charStrings = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag_for_digit_or_char</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            flag_for_digit_or_char = (<span class="type">int</span>)(Math.random() * <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// flag_for_digit_or_char如果是0就填数字</span></span><br><span class="line">            <span class="keyword">if</span>(flag_for_digit_or_char == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">                charStrings[i] = (<span class="type">char</span>)(number + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag_for_capacity = (<span class="type">int</span>)(Math.random() * <span class="number">2</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">26</span>);</span><br><span class="line">                charStrings[i] = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + distance);</span><br><span class="line">                <span class="comment">// flag_for_capacity 如果是0就大写</span></span><br><span class="line">                <span class="keyword">if</span>(flag_for_capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                    charStrings[i] = Character.toUpperCase(charStrings[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charStrings);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/340249a9.html</url>
    <content><![CDATA[<h1
id="system.arraycopysrc-srcpos-dest-destpos-length">System.arraycopy(src,
srcPos, dest, destPos, length)</h1>
<span id="more"></span>
<p>src:源数组</p>
<p>srcPos：复制源数组的起始位置</p>
<p>dest：目标数组</p>
<p>destPos：复制目标数组的起始位置</p>
<p>length：复制长度</p>
<p>举个例子：复制一个数组前3个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item: b) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span> <span class="number">62</span> <span class="number">68</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exercise</span><br><span class="line">首先准备两个数组，他俩的长度是5-10之间的随机数，并使用随机数初始化这两个数组</span><br><span class="line">([向数组填充随机数](https://how2j.cn/k/array/array-create/280.html#step2182)的办法，[参考这里](https://how2j.cn/k/array/array-create/280.html#step2182))</span><br><span class="line"></span><br><span class="line">然后准备第三个数组，第三个数组的长度是前两个的和</span><br><span class="line">通过System.arraycopy 把前两个数组合并到第三个数组中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>java中产生随机数：</p>
<p>Math.random():产生0-1的浮点数</p>
<p>Math.random()*100：产生0-100的浮点数</p>
<p>(Math.random() + 6) * 10:产生5-10的浮点数</p>
<p>anser</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">exercise</span></span><br><span class="line"><span class="comment">首先准备两个数组，他俩的长度是5-10之间的随机数，并使用随机数初始化这两个数组</span></span><br><span class="line"><span class="comment">([向数组填充随机数](https://how2j.cn/k/array/array-create/280.html#step2182)的办法，[参考这里](https://how2j.cn/k/array/array-create/280.html#step2182))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后准备第三个数组，第三个数组的长度是前两个的和</span></span><br><span class="line"><span class="comment">通过System.arraycopy 把前两个数组合并到第三个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mergeArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">6</span>) + <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">6</span>) + <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lengthC</span> <span class="operator">=</span> lengthA + lengthB;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[lengthA];</span><br><span class="line">        System.out.println(<span class="string">&quot;数组A：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthA; i++) &#123;</span><br><span class="line">            a[i] = (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[lengthB];</span><br><span class="line">        System.out.println(<span class="string">&quot;数组B：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthB; i++) &#123;</span><br><span class="line">            b[i] = (<span class="type">int</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[lengthC];</span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, c, <span class="number">0</span>, lengthA);</span><br><span class="line">        System.arraycopy(b, <span class="number">0</span>, c, lengthA, lengthB);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item : c) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二维数组">二维数组</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	   <span class="comment">//初始化二维数组，</span></span><br><span class="line">	   <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//有两个一维数组，每个一维数组的长度是3</span></span><br><span class="line">	   a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">5</span>;  <span class="comment">//可以直接访问一维数组，因为已经分配了空间</span></span><br><span class="line">	     </span><br><span class="line">	   <span class="comment">//只分配了二维数组</span></span><br><span class="line">	   <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][]; <span class="comment">//有两个一维数组，每个一维数组的长度暂未分配</span></span><br><span class="line">	   b[<span class="number">0</span>]  =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//必须事先分配长度，才可以访问</span></span><br><span class="line">	   b[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	   </span><br><span class="line">	   <span class="comment">//指定内容的同时，分配空间</span></span><br><span class="line">	   <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">			   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">			   &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">	   &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二维数组要求每个空间都必须先new才能使用（就是往里面放东西）</p>
<p>二维数组不一定要等长</p>
<p>exercise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个5X5的二维数组。 然后使用随机数填充该二维数组。</span><br><span class="line">找出这个二维数组里，最大的那个值，并打印出其二维坐标</span><br></pre></td></tr></table></figure>
<p>answer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个5X5的二维数组。 然后使用随机数填充该二维数组。</span></span><br><span class="line"><span class="comment">找出这个二维数组里，最大的那个值，并打印出其二维坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maxNum</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">maxNum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">twoDimensionArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                a[i][j] = (<span class="type">int</span>)(Math.random() * <span class="number">6</span> +<span class="number">5</span>);</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">maxNum</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">maxNum</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j] &gt; max.val) &#123;</span><br><span class="line">                    max.val = a[i][j];</span><br><span class="line">                    max.x = i;</span><br><span class="line">                    max.y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最大：%d 横坐标：%d 纵坐标：%d&quot;</span>, max.val, max.x, max.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java.util.arrays类常用方法">java.util.Arrays类常用方法</h1>
<h2 id="数组复制">数组复制</h2>
<p>与<a
href="https://how2j.cn/k/array/array-copyarray/284.html#step575">使用System.arraycopy进行数组复制</a>类似的，
Arrays提供了一个copyOfRange方法进行数组复制。
不同的是System.arraycopy，需要事先准备好目标数组，并分配长度。
copyOfRange 只需要源数组就就可以了，就是目标数组不需要new</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyOfArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item : b) &#123;</span><br><span class="line">            System.out.print(item + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组转换为字符串">数组转换为字符串</h2>
<p>通过Arrays.toString(a)</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arrayToString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a的类别是：&quot;</span> + a.getClass().getName());</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringA</span> <span class="operator">=</span> Arrays.toString(a);</span><br><span class="line">        System.out.println(stringA);</span><br><span class="line">        System.out.println(<span class="string">&quot;stringA的类型是：&quot;</span> + stringA.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的类别是：[I</span><br><span class="line">[<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>]</span><br><span class="line">stringA的类型是：java.lang.String</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<p>Arrays.sort(a)</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arraySort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line">[<span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span>]</span><br><span class="line">排序后：</span><br><span class="line">[<span class="number">9</span>, <span class="number">18</span>, <span class="number">62</span>, <span class="number">65</span>, <span class="number">68</span>, <span class="number">82</span>]</span><br></pre></td></tr></table></figure>
<h2 id="搜索">搜索</h2>
<p>查询元素出现的位置
需要注意的是，使用binarySearch进行查找之前，必须使用sort进行排序
如果数组中有多个相同的元素，查找结果是不确定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字62出现的位置&quot;</span> + Arrays.binarySearch(a, <span class="number">62</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字<span class="number">62</span>出现的位置<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="比较两个数组是否相同">比较两个数组是否相同</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="填充">填充</h2>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fill</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(a, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>exercise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先定义一个5X8的二维数组，然后使用随机数填充满。</span><br><span class="line">借助Arrays的方法对二维数组进行排序。</span><br><span class="line">参考思路：</span><br><span class="line">先把二维数组使用System.arraycopy进行数组复制到一个一维数组</span><br><span class="line">然后使用sort进行排序</span><br><span class="line">最后再复制回到二维数组。</span><br></pre></td></tr></table></figure>
<p>answer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Array.Arrays_method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用随机数构造二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                a[i][j] = (<span class="type">int</span>)(Math.random() * <span class="number">40</span>);</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本来是想利用Arrays.copyOfRange,但是Arrays.copyOfRange会对数组重新引用</span></span><br><span class="line">        <span class="comment">// 将二维数组中内容复制到一维数组里面</span></span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.arraycopy(a[i], <span class="number">0</span>, tmp, i * <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            System.out.print(tmp[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 对数组排序</span></span><br><span class="line">        Arrays.sort(tmp);</span><br><span class="line">        <span class="comment">// 将一维数组中内容复制到二维数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            a[i] = Arrays.copyOfRange(tmp, i * <span class="number">8</span>, (i + <span class="number">1</span>) * <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝问题</title>
    <url>/posts/b273c765.html</url>
    <content><![CDATA[<p><a href="">刷蓝桥杯碰到的</a>，觉得有必要另写一篇文章</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] backUp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMatrix</span><span class="params">(Scanner scan)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			matrix[i] = scan.nextLine().toCharArray();</span><br><span class="line">			backUp[i] = Arrays.copyOf(matrix[i], matrix[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 上</span></span><br><span class="line">		<span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x - <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 左</span></span><br><span class="line">		<span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x, y - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 右</span></span><br><span class="line">		<span class="keyword">if</span>(y + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x, y + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(x + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x + <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 自个</span></span><br><span class="line">		flip(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 一共要有n次读取</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">// 读取每次的初始灯矩阵并保存备份</span></span><br><span class="line">			readMatrix(scan);</span><br><span class="line">			System.out.println(<span class="string">&quot;初始化矩阵为：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				System.out.println(matrix[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minChange</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">			<span class="comment">// 遍历 32 种可能性</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将第一行的按法调整成对应的5位二进制</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%5s&quot;</span>, Integer.toBinaryString(j)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">				System.out.format(<span class="string">&quot;第一行的开关状态为：%s\n&quot;</span>, tmpString);</span><br><span class="line">				<span class="comment">// 第一行的按完后的状态</span></span><br><span class="line">				System.out.print(<span class="string">&quot;第一行现在状态：&quot;</span>);</span><br><span class="line">				System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(tmpString.charAt(k) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						changeMatrix(<span class="number">0</span>, k);</span><br><span class="line">						System.out.format(<span class="string">&quot;按下开关%d, 第一行现在状态 &quot;</span>, k + <span class="number">1</span>);</span><br><span class="line">						System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;开关按完后第一行现在的状态：&quot;</span>);</span><br><span class="line">				System.out.println(matrix[<span class="number">0</span>]);</span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; <span class="number">5</span>; b++) &#123;</span><br><span class="line">						<span class="comment">// 通过这一行确定下一行的开关，再根据这个开关看灯的亮暗</span></span><br><span class="line">						<span class="keyword">if</span>(matrix[a][b] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">							changeMatrix(a + <span class="number">1</span>, b);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.format(<span class="string">&quot;经过第%d行后的状态\n&quot;</span>, a+<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">5</span>; c++) &#123;</span><br><span class="line">						System.out.println(matrix[c]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 遍历第5行，看是不是都是1</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(matrix[<span class="number">4</span>][k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">					minChange = Math.min(count, minChange);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 将备份矩阵拷贝回原矩阵</span></span><br><span class="line">				matrix = Arrays.copyOf(backUp, backUp.length);	</span><br><span class="line">				System.out.println(<span class="string">&quot;backUp数组是：&quot;</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">					System.out.println(backUp[a]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(count &lt;= <span class="number">6</span>) System.out.println(count);</span><br><span class="line">			<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很逆天的一个问题</p>
<p>比如原数组是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br></pre></td></tr></table></figure>
<p>第一次将backUp数组拷贝回原数组时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backUp数组是：</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br></pre></td></tr></table></figure>
<p>第二次就做妖了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">00100</span><br></pre></td></tr></table></figure>
<p>出问题的代码是这里,将backUp拷贝回matrix时</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = Arrays.copyOf(backUp, backUp.length);	</span><br></pre></td></tr></table></figure>
<p>受影响的表现是修改matrix的时候，backUp也会被改变</p>
<p>改为下面后就正常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">	matrix[a] = Arrays.copyOf(backUp[a], backUp[a].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先明确的是System.arraycopy和Arrays.copyOf，如果拷贝的对象是基本数据类型，则是深拷贝，而对于引用数据类型则是浅拷贝</p>
<p>拷贝对象是基本数据类型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126192504250.png" /></p>
<p>拷贝对象是引用数据类型,比如int[](虽然是二维数组之间的拷贝，但是拷贝对象是int[])</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240126193150985.png" /></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/28239a8d.html</url>
    <content><![CDATA[<h1 id="面向对象">面向对象</h1>
<span id="more"></span>
<h2 id="继承">继承</h2>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Object_oriented.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Weapon</span> <span class="keyword">extends</span> <span class="title class_">Item</span>&#123;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">infinityEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Weapon</span>();</span><br><span class="line">        infinityEdge.damage = <span class="number">65</span>;</span><br><span class="line">        infinityEdge.name = <span class="string">&quot;无尽之刃&quot;</span>;</span><br><span class="line">        infinityEdge.price = <span class="number">3600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="方法重载方法名一样但是参数类型不一样">方法重载:方法名一样，但是参数类型不一样</h2>
<p>采用可变数量的参数 <strong>只需要设计一个方法</strong> public void
attack(Hero <strong>...</strong>heros) 即可代表上述所有的方法了
在方法里，使用操作数组的方式处理参数heros即可</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADHero</span> <span class="keyword">extends</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot; 进行了一次攻击 ，但是不确定打中谁了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可变数量的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero... heros)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">			System.out.println(name + <span class="string">&quot; 攻击了 &quot;</span> + heros[i].name);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ADHero</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ADHero</span>();</span><br><span class="line">		bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">Hero</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		h1.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		h2.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line"></span><br><span class="line">		bh.attack(h1);</span><br><span class="line">		bh.attack(h1, h2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<p>通过一个类创建一个对象，这个过程叫做<strong>实例化</strong></p>
<p>实例化是通过调用<strong>构造方法</strong>(又叫做<strong>构造器</strong>)实现的</p>
<h3 id="定义">定义：</h3>
<p>方法名和类名一样（包括大小写） <strong>没有返回类型</strong>
实例化一个对象的时候，必然调用构造方法</p>
<h3 id="隐式的构造方法">隐式的构造方法</h3>
<p>无参的构造方法，如果不写，就会默认提供一个</p>
<p>如果提供了一个有参的构造方法，同时又<strong>没有显式</strong>的提供一个无参的构造方法那么默认的无参的构造方法，就“木有了“</p>
<h3 id="构造方法的重载">构造方法的重载</h3>
<h2 id="this的使用">this的使用</h2>
<p>this这个关键字，相当于普通话里的“我” this即代表当前对象</p>
<h3 id="this代表当前对象">this代表当前对象</h3>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">	</span><br><span class="line">	String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印内存中的虚拟地址</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAddressInMemory</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印this看到的虚拟地址：&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">		<span class="comment">//直接打印对象，会显示该对象在内存中的虚拟地址</span></span><br><span class="line">		<span class="comment">//格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;打印对象看到的虚拟地址：&quot;</span>+garen);</span><br><span class="line">		<span class="comment">//调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址</span></span><br><span class="line">		garen.showAddressInMemory();</span><br><span class="line">		</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印对象看到的虚拟地址：&quot;</span>+teemo);</span><br><span class="line">		teemo.showAddressInMemory();</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">打印对象看到的虚拟地址：Object_oriented.reload.Hero@1b6d3586(和下面<span class="built_in">this</span>引用的一样)</span><br><span class="line">打印<span class="built_in">this</span>看到的虚拟地址：Object_oriented.reload.Hero@1b6d3586</span><br><span class="line">打印对象看到的虚拟地址：Object_oriented.reload.Hero@4554617c</span><br><span class="line">打印<span class="built_in">this</span>看到的虚拟地址：Object_oriented.reload.Hero@4554617c</span><br></pre></td></tr></table></figure>
<h3 id="通过this访问属性">通过this访问属性</h3>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName3</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//name代表的是参数name</span></span><br><span class="line">    <span class="comment">//this.name代表的是属性name</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">	</span><br><span class="line">	String name; <span class="comment">//姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//参数名和属性名一样</span></span><br><span class="line">	<span class="comment">//在方法体中，只能访问到参数name</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName1</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了避免setName1中的问题，参数名不得不使用其他变量名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName2</span><span class="params">(String heroName)</span>&#123;</span><br><span class="line">		name = heroName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过this访问属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName3</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="comment">//name代表的是参数name</span></span><br><span class="line">		<span class="comment">//this.name代表的是属性name</span></span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span>  <span class="variable">h</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">		</span><br><span class="line">		h.setName1(<span class="string">&quot;teemo&quot;</span>);</span><br><span class="line">		System.out.println(h.name);</span><br><span class="line">		</span><br><span class="line">		h.setName2(<span class="string">&quot;garen&quot;</span>);</span><br><span class="line">		System.out.println(h.name);		</span><br><span class="line">		</span><br><span class="line">		h.setName3(<span class="string">&quot;死歌&quot;</span>);</span><br><span class="line">		System.out.println(h.name);		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">garen</span><br><span class="line">死歌</span><br></pre></td></tr></table></figure>
<h3 id="通过this调用其他的构造方法">通过this调用其他的构造方法</h3>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(name);</span><br><span class="line">    System.out.println(<span class="string">&quot;两个参数的构造方法&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.hp = hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Object_oriented.reload;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line"></span><br><span class="line">    String name; //姓名</span><br><span class="line"></span><br><span class="line">    float hp; //血量</span><br><span class="line"></span><br><span class="line">    float armor; //护甲</span><br><span class="line"></span><br><span class="line">    int moveSpeed; //移动速度</span><br><span class="line"></span><br><span class="line">    //带一个参数的构造方法</span><br><span class="line">    public Hero(String name)&#123;</span><br><span class="line">        System.out.println(&quot;一个参数的构造方法&quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //带两个参数的构造方法</span><br><span class="line">    public Hero(String name,float hp)&#123;</span><br><span class="line">        this(name);</span><br><span class="line">        System.out.println(&quot;两个参数的构造方法&quot;);</span><br><span class="line">        this.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero teemo =  new Hero(&quot;提莫&quot;,383);</span><br><span class="line">        System.out.println(teemo.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传参">传参</h2>
<h3 id="基本类型传参">基本类型传参</h3>
<p>基本类型传参 在方法内，无法修改方法外的基本类型参数</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">xueping</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提莫通过这个血瓶回血</span></span><br><span class="line"></span><br><span class="line">teemo.huixue(xueping);</span><br><span class="line"></span><br><span class="line">System.out.println(xueping);</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">       </span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">       </span><br><span class="line">    <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回血</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">huixue</span><span class="params">(<span class="type">int</span> xp)</span>&#123;</span><br><span class="line">    	hp = hp + xp;</span><br><span class="line">    	<span class="comment">//回血完毕后，血瓶=0</span></span><br><span class="line">    	xp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name,<span class="type">float</span> hp)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.hp = hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;提莫&quot;</span>,<span class="number">383</span>);</span><br><span class="line">        <span class="comment">//血瓶，其值是100</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xueping</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提莫通过这个血瓶回血</span></span><br><span class="line">        </span><br><span class="line">        teemo.huixue(xueping);</span><br><span class="line">        </span><br><span class="line">        System.out.println(xueping);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">(按理说不应该是100，因为已经回血后按理说血瓶废了，说明方法没有修改方法外参数)</span><br></pre></td></tr></table></figure>
<h3 id="引用与">引用与=</h3>
<p>如果一个变量是基本类型 比如 int hp = 50; 我们就直接管hp叫变量
<strong>=表示赋值的意思</strong>。 如果一个变量是类类型 比如 Hero h =
new Hero(); 我们就管h叫做<strong>引用</strong>。
<strong>=不再是赋值的意思</strong> <strong>=表示指向的意思</strong> 比如
Hero h = new Hero(); 这句话的意思是 引用h，指向一个Hero对象</p>
<h3 id="类类型传参">类类型传参</h3>
<p>关键代码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322150201788.png" /></p>
<p>传递给方法里的如果是类类型那么就可以在方法内修改方法外的变量</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(String name, <span class="type">float</span> hp)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.hp = hp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 攻击一个英雄，并让他掉damage点血</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Hero hero, <span class="type">int</span> damage)</span> &#123;</span><br><span class="line">		hero.hp = hero.hp - damage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">teemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;提莫&quot;</span>, <span class="number">383</span>);</span><br><span class="line">		<span class="type">Hero</span> <span class="variable">garen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;盖伦&quot;</span>, <span class="number">616</span>);</span><br><span class="line">		garen.attack(teemo, <span class="number">100</span>);</span><br><span class="line">		System.out.println(teemo.hp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">283.0</span><br></pre></td></tr></table></figure>
<h2 id="四种访问修饰符">四种访问修饰符</h2>
<p>成员变量有四种修饰符 <strong>private</strong> 私有的
<strong>package</strong>/friendly/default 不写
<strong>protected</strong> 受保护的 <strong>public</strong> 公共的</p>
<h3 id="类之间的关系">类之间的关系</h3>
<p>类和类之间的关系有如下几种: 以Hero为例
<strong>自身：</strong>指的是Hero自己
<strong>同包子类：</strong>ADHero这个类是Hero的子类，并且和Hero处于<strong>同一个包下</strong>
<strong>不同包子类：</strong>Support这个类是Hero的子类，但是在<strong>另一个包下</strong>
<strong>同包类：</strong> GiantDragon
这个类和Hero是<strong>同一个包</strong>，但是彼此<strong>没有继承关系</strong>
<strong>其他类：</strong>Item这个类，<strong>在不同包</strong>，也没有继承关系的类</p>
<p><img src="https://stepimagewm.how2j.cn/605.png" /></p>
<h3 id="private-私有的">private 私有的</h3>
<p><font color = "red">只能自己用</font></p>
<p>自身：是可以访问的 同包子类：不能继承 不同包子类：不能继承
同包类：不能访问 其他包类：不能访问</p>
<h3 id="packagefriendlydefault-不写">package/friendly/default 不写</h3>
<p><font color = "red">只能在同一个包里用</font></p>
<p><img src="https://stepimagewm.how2j.cn/609.png" /></p>
<p>### protected 受保护的</p>
<p><font color = "red">同一个包里和是它的子类都能用</font></p>
<p><img src="https://stepimagewm.how2j.cn/610.png" /></p>
<h3 id="public-公共的">public 公共的</h3>
<p><font color = "red">谁都可以用</font></p>
<p><img src="https://stepimagewm.how2j.cn/611.png" /></p>
<h3 id="选择依据">选择依据</h3>
<ol type="1">
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ol>
<p>再就是<strong>作用范围最小原则</strong>
简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。
这样就能把数据尽量的封装起来，没有必要<strong>露出来的</strong>，就不用<strong>露出来</strong>了</p>
<h2 id="类属性静态属性">类属性、静态属性</h2>
<p>当一个属性被<strong>static</strong>修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong>
当一个属性被声明成类属性，那么<strong>所有的对象，都共享一个值</strong>
与对象属性对比： 不同对象的 对象属性 的值都可能不一样。 比如盖伦的hp 和
提莫的hp 是不一样的。
<font color = "red">但是所有对象的类属性的值，都是一样的</font></p>
<h3 id="类属性">类属性</h3>
<p><strong>类属性：</strong> 又叫做静态属性 <strong>对象属性：</strong>
又叫实例属性，非静态属性
<font color = "red">如果一个属性声明成类属性，那么所有的对象，都共享这么一个值</font></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String name; //实例属性，对象属性，非静态属性</span><br><span class="line">protected float hp;</span><br><span class="line">static String copyright;//类属性,静态属性</span><br></pre></td></tr></table></figure>
<h3 id="访问类属性">访问类属性</h3>
<ol type="1">
<li><p>对象.类属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">teemo.copyright</span><br></pre></td></tr></table></figure></li>
<li><p>类.类属性</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hero.copyright</span><br></pre></td></tr></table></figure>
<h2 id="类方法">类方法</h2>
<p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上
访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<h3 id="类方法-1">类方法</h3>
<p>举例</p>
<p>关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//实例方法,对象方法，非静态方法</span><br><span class="line">//必须有对象才能够调用</span><br><span class="line">public void die()&#123;</span><br><span class="line">    hp = 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//类方法，静态方法</span><br><span class="line">//通过类就可以直接调用</span><br><span class="line">public static void battleWin()&#123;</span><br><span class="line">    System.out.println(&quot;battle win&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class Hero &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    protected float hp;</span><br><span class="line"> </span><br><span class="line">    //实例方法,对象方法，非静态方法</span><br><span class="line">    //必须有对象才能够调用</span><br><span class="line">    public void die()&#123;</span><br><span class="line">        hp = 0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //类方法，静态方法</span><br><span class="line">    //通过类就可以直接调用</span><br><span class="line">    public static void battleWin()&#123;</span><br><span class="line">        System.out.println(&quot;battle win&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           Hero garen =  new Hero();</span><br><span class="line">           garen.name = &quot;盖伦&quot;;</span><br><span class="line">           //必须有一个对象才能调用</span><br><span class="line">           garen.die();</span><br><span class="line">            </span><br><span class="line">           Hero teemo =  new Hero();</span><br><span class="line">           teemo.name = &quot;提莫&quot;;</span><br><span class="line">            </span><br><span class="line">           //无需对象，直接通过类调用</span><br><span class="line">           Hero.battleWin();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用类方法">调用类方法</h3>
<ol type="1">
<li><p>对象.类方法</p></li>
<li><p>类.类方法</p></li>
</ol>
<h2 id="属性初始化">属性初始化</h2>
<h3 id="对象属性初始化">对象属性初始化</h3>
<ol type="1">
<li>声明该属性的时候初始化</li>
<li>构造方法中初始化</li>
<li>初始化块</li>
</ol>
<p><font color = "red">初始化块中的代码会先执行，接着是构造方法中的代码，最后是在属性声明时直接赋值的代码。</font></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">	public String name = &quot;some hero&quot;; //声明该属性的时候初始化 </span><br><span class="line">	protected float hp;</span><br><span class="line">	float maxHP;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		maxHP = 200; //初始化块</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	public Hero()&#123;</span><br><span class="line">		hp = 100; //构造方法中初始化</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类属性初始化">类属性初始化</h3>
<ol type="1">
<li>声明该属性的时候初始化</li>
<li>静态初始化块</li>
</ol>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"></span><br><span class="line">public class Hero &#123;</span><br><span class="line">	public String name; </span><br><span class="line">	protected float hp;</span><br><span class="line">	float maxHP;</span><br><span class="line">	</span><br><span class="line">	//物品栏的容量</span><br><span class="line">	public static int itemCapacity=8; //声明的时候 初始化</span><br><span class="line">	</span><br><span class="line">	static&#123;</span><br><span class="line">		itemCapacity = 6;//静态初始化块 初始化</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Hero()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(Hero.itemCapacity);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="单例模式">单例模式</h2>
<p>单例模式又叫做
Singleton模式，<font color = "red">指的是一个类，在一个JVM里，只有一个实例存在。</font></p>
<h3 id="饿汉式单例模式">饿汉式单例模式</h3>
<ol type="1">
<li>通过<font color = "red">私有化其构造方法</font>，使得外部无法通过new
得到新的实例。</li>
<li><font color = "red">私有实例化一个对象</font></li>
<li><font color = "red">定义一个公共的类方法用于返回之前创建的对象</font></li>
</ol>
<p>关键：<font color = "red">无论如何都会创建一个实例</font></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line"> </span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span><br><span class="line"> </span><br><span class="line">    private static GiantDragon instance = new GiantDragon();</span><br><span class="line">     </span><br><span class="line">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式单例模式">懒汉式单例模式</h3>
<p>使用：</p>
<ol type="1">
<li><font color = "red">私有化构造方法</font></li>
<li>准备一个私有的类属性，<font color = "red">但是暂时只想NULL</font></li>
<li>定义一个<font color = "red">公共的类方法</font>，如果之前私有的类属性指向空，就实例化一个对象，否则就不用</li>
</ol>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package charactor;</span><br><span class="line"> </span><br><span class="line">public class GiantDragon &#123;</span><br><span class="line">  </span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class="line">    private static GiantDragon instance;</span><br><span class="line">      </span><br><span class="line">    //public static 方法，返回实例对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class="line">        if(null==instance)&#123;</span><br><span class="line">            instance = new GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        //返回 instance指向的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式三元素</p>
<ol type="1">
<li>构造方法私有化</li>
<li>静态属性指向实例</li>
<li>public static的 getInstance方法，返回第二步的静态属性</li>
</ol>
<h2 id="枚举类型">枚举类型</h2>
<h3 id="预先定义的常量">预先定义的常量</h3>
<p><strong>注：</strong>因为是常量，所以一般都是全大写</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        switch (season) &#123;</span><br><span class="line">        case SPRING:</span><br><span class="line">            System.out.println(&quot;春天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case SUMMER:</span><br><span class="line">            System.out.println(&quot;夏天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AUTUMN:</span><br><span class="line">            System.out.println(&quot;秋天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case WINTER:</span><br><span class="line">            System.out.println(&quot;冬天&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历枚举">遍历枚举</h3>
<p>增强型for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Season s : Season.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/posts/a444b428.html</url>
    <content><![CDATA[<h1 id="排序">排序</h1>
<span id="more"></span>
<h2 id="插入排序">插入排序</h2>
<h3
id="直接插入排序不断从无序序列中挑选出元素插入有序序列">直接插入排序：不断从无序序列中挑选出元素插入有序序列</h3>
<h3
id="折半插入排序先折半查找出待插入位置再统一移动">折半插入排序：先折半查找出待插入位置，再统一移动</h3>
<h3
id="希尔排序每次取不同的步长按步长从原序列里挑出子序列直到最后步长为0">希尔排序：每次取不同的步长，按步长从原序列里挑出子序列，直到最后步长为0</h3>
<p>举例1：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231230195246.jpg" /></p>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序：</h3>
<h4
id="每轮排序结果确定1个位置可以从最后一个开始也可以从第一个开始">每轮排序结果确定1个位置，可以从最后一个开始，也可以从第一个开始</h4>
<h4
id="每轮排序过程中比较交换两个相邻的元素">每轮排序过程中比较交换两个相邻的元素</h4>
<h3
id="快排主要思想是分治pivot前都比它小pivot后都比它大再对左右子序列继续选pivot分解">快排：主要思想是分治，pivot前都比它小，pivot后都比它大，再对左右子序列继续选pivot，分解</h3>
<h4
id="一轮分治过程中high和low依次运行">一轮分治过程中，high和low依次运行</h4>
<h4
id="首先high运行当high所指元素小于pivot时high所指元素放到low指的地方认为每次停下来i的那个highlow指向的位置为空">首先high运行，当high所指元素小于pivot时，high所指元素放到low指的地方（认为每次停下来i的那个（high/low）指向的位置为空)</h4>
<h4
id="然后low开始运行当low所指元素大于pivot时low所指元素放到high所指位置">然后low开始运行，当low所指元素大于pivot时，low所指元素放到high所指位置</h4>
<h4
id="不断循环直到low-high将pivot放到i与j此时指向的位置">不断循环直到low
== high,将pivot放到i与j此时指向的位置</h4>
<h4
id="快排每次分治都有1个元素被放到最终位置">快排每次分治都有1个元素被放到最终位置</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Partition函数参数是待划分序列，开头位置（low指针指向的位置）结尾位置（high指针指向的位置），返回最终pivot的位置*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> high, <span class="type">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = data[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[high] &gt;= pivot) high--;</span><br><span class="line">        data[low] = data[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; data[low] &lt;= pivot) low++;</span><br><span class="line">        data[high] = data[low];    </span><br><span class="line">    &#125;   </span><br><span class="line">    data[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*QuickSort函数参数是待划分序列，开头位置（low指向位置），结尾位置（high指向位置）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotPosition = <span class="built_in">Partition</span>(data, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(data, low, pivotPosition - <span class="number">1</span>);    <span class="comment">//对左子表再快排</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(data, pivotPosition + <span class="number">1</span>, high);   <span class="comment">//对右子表再快排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例1：判断排序结果</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231122081638.jpg" />
1 写出最终排序结果 2
逐个选项选出已经放到应该排的位置的元素，因为针对每一个子列排序，都会有一个元素排到它应该排的位置，所以排第n趟的时候至少有n个元素已经放到正确位置
3
再看每个放到正确位置元素将原序列分成几段，因为如果每趟的pivot恰好放在端的地方，那么就是排第n趟的时候有n个元素归位，但如果分割了原序列，就是n+1</p>
<h2 id="选择排序">选择排序</h2>
<h3
id="简单选择排序每次确定一个元素位置比如确定最后一个就是最大元素比较范围从1n-1确定倒数第二个比较范围从1到n-1以此类推">简单选择排序：每次确定一个元素位置，比如确定最后一个，就是最大元素，比较范围从1~n-1，确定倒数第二个，比较范围从1到n-1……以此类推</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231230213447.jpg" /></p>
<h3 id="堆排序">堆排序</h3>
<h4 id="存储与结构">1 存储与结构</h4>
<h5 id="树形结构">1.1 树形结构</h5>
<p>堆的最常用结构是二叉树，且一般是完全二叉树</p>
<h5 id="存储结构">1.2 存储结构</h5>
<p>堆实际存储一般不用指针，而是使用数组，如下图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231124085512.jpg" /></p>
<h5 id="数组下标关系">1.3 数组下标关系</h5>
<h6 id="起始存储单元为1而不是0-0作为哨兵且也易于从子节点找到父节点">1.
起始存储单元为1，而不是0, 0作为哨兵，且也易于从子节点找到父节点</h6>
<h6
id="对于下标为i的节点父节点下标是i2向下取整反过来对于下标为i的节点左孩子下标是2-i右孩子是-2-i-1">2.
对于下标为i的节点，父节点下标是i/2向下取整，反过来，对于下标为i的节点，左孩子下标是2
* i，右孩子是 2 * i + 1</h6>
<h4 id="操作">2 操作</h4>
<h5 id="插入">2.1 插入</h5>
<p>以大顶堆为例</p>
<h6
id="先将待插入节点放到数组最后一位">先将<strong>待插入节点</strong>放到<strong>数组最后一位</strong></h6>
<h6
id="然后向上上滤寻找插入位置即与父节点比较如果比父节点大那么就把父节点下放-直到找到待插入节点应该插入的位置">然后<strong>向上上滤</strong>寻找插入位置，即与父节点比较，如果比父节点大，那么就把父节点<strong>下放</strong>
，直到找到待插入节点应该插入的位置</h6>
<p>但是注意到，如果插入的新节点比原堆中任意元素都大，那么到堆顶（下标为1）的时候又/=2得0，0不断/=2得0陷入死循环，所以如果已知堆中元素范围，可以将下标0设置为大于堆中可能元素，这样循环到0就一定会退出</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 1000000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> x, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = ++size;	<span class="comment">//因为要插入元素，所以大顶堆size + 1</span></span><br><span class="line">    <span class="keyword">for</span>(; data[i / <span class="number">2</span>] &lt; x; i /= <span class="number">2</span>) &#123;	<span class="comment">//向上寻找插入位置</span></span><br><span class="line">        data[i] = data[i / <span class="number">2</span>];			<span class="comment">//将父节点下放</span></span><br><span class="line">    &#125;	</span><br><span class="line">    data[i] = x;	<span class="comment">//将新节点插入到应该插入的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除">2.2 删除</h5>
<p>以大顶堆为例</p>
<h6 id="先弹出根节点">先弹出根节点</h6>
<h6
id="然后取数组中最后一个元素因为它在大顶堆中必然是叶子节点向下下滤寻找插入位置">然后取数组中最后一个元素（因为它在大顶堆中必然是叶子节点）<strong>向下下滤</strong>寻找插入位置</h6>
<h6
id="通过与当前层为根节点此时为空的左右子树中最大值比较如果左右子树中最大值比最后一个元素大就将左右子树中最大值上移接着从上移节点的位置此时为空继续向下比较否则将最后一个元素插入当前层为根节点">通过<strong>与当前层为根节点（此时为空）</strong>的<strong>左右子树中最大值</strong>比较，如果左右子树中最大值比最后一个元素大，就将左右子树中最大值上移，接着从上移节点的位置（此时为空）继续向下比较，否则将最后一个元素插入当前层为根节点</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231124095808.jpg" /></p>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">PopMax</span><span class="params">(MaxHeap maxHeap)</span> &#123;</span><br><span class="line">	<span class="type">int</span> maxData = maxHeap-&gt;Data[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x = maxHeap-&gt;Data[maxHeap-&gt;Size--];	<span class="comment">//选择原来大顶堆中最后一个存储的元素来下滤</span></span><br><span class="line">    <span class="type">int</span> parent = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= maxHeap-&gt;Size; parent = child) &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(child != maxHeap-&gt;Size &amp;&amp; maxHeap-&gt;Data[child] &lt; maxHeap-&gt;Data[child + <span class="number">1</span>]) &#123;</span><br><span class="line">			child = child + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; maxHeap-&gt;Data[child]) &#123;	<span class="comment">//将x与child比较，注意这时parent指向的位置为空, 如果小就将child提上来</span></span><br><span class="line">            maxHeap-&gt;Data[parent] = maxHeap-&gt;Data[child];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果x比child大就break出循环，注意不能在循环里赋值，具体还不清楚，但在循环里就把x赋给parent会报错</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxHeap-&gt;Data[parent] = x;</span><br><span class="line">    <span class="keyword">return</span> maxData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<h3 id="一-算法思想分治">一 算法思想：分治</h3>
<p>不过归并分治过程和快排有区别</p>
<p>快排是先对一个大序列(在一个大序列中找到pivot，利用pivot将大序列分割成左右两个小序列)操作，再分割成小序列</p>
<p>归并是先分割成小序列(先将大序列分割成小序列)
，再操作(对将小序列两个两个归并成一个大序列)</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231128090112.jpg" /></p>
<h4 id="分分割成小序列">1 “分”：分割成小序列</h4>
<h4 id="治小序列两个两个合并成大序列">2
治：小序列两个两个合并成大序列</h4>
<h5 id="开一个辅助数组b">2.1 开一个辅助数组B</h5>
<h5 id="将待排数组名义上两个但实际上存在一个里面存放到辅助数组里面">2.2
将待排数组(名义上两个，但实际上存在一个里面)存放到辅助数组里面</h5>
<h5
id="这时待排数组为空利用两个指针分别指示待归并的两个数组的起点在辅助数组上移动将其中大的重新拷贝回待排数组">2.3
这时待排数组为空，利用两个指针(分别指示待归并的两个数组的起点)在辅助数组上移动，将其中大的重新拷贝回待排数组</h5>
<h5
id="如果其中一个指针移动的位置超过了原来对应待归并的数组的范围将剩下一个数组里元素全部拷贝回待排数组">2.4
如果其中一个指针移动的位置超过了原来对应待归并的数组的范围，将剩下一个数组里元素全部拷贝回待排数组</h5>
<h3 id="二-代码">二 代码</h3>
<h4 id="merge用来合并两个序列">Merge()(用来合并两个序列)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Assistance[MAXNUM];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line">    <span class="comment">/*拷贝到辅助数组*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; high; i++) &#123;</span><br><span class="line">        Assistance[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p, q, r;</span><br><span class="line">    <span class="keyword">for</span>(p = low, q = mid + <span class="number">1</span>, r = low; p &lt;= mid &amp;&amp; q &lt;= high; ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Assistance[p] &gt; Assistance[q]) &#123;</span><br><span class="line">            data[r++] = Assistance[q];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[r++] = Assistance[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= mid) data[r++] = Assistance[p];</span><br><span class="line">    <span class="keyword">while</span>(q &lt;= high) data[r++] = Assistance[q]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="mergesort用来分割">MergeSort()(用来分割)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(data, low, mid);</span><br><span class="line">        MergeSort(data, mid + <span class="number">1</span>, low);</span><br><span class="line">        Merge(data, low, high, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序">基数排序</h2>
<h3 id="主要思想">主要思想</h3>
<h4
id="不基于比较和移动而基于关键字各位的大小">不基于比较和移动，而基于关键字各位的大小</h4>
<h4 id="分配">分配：</h4>
<h4 id="收集">收集：</h4>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231231071221.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231231071233.jpg" /></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构绪论</title>
    <url>/posts/b06cc6ec.html</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<h2 id="数据结构基本概念">数据结构基本概念</h2>
<h3
id="数据元素数据项数据元素包含数据项举例学生这个数据元素里会有姓名学号等数据项">数据元素、数据项：数据元素包含数据项，举例：学生这个数据元素里会有姓名、学号等数据项</h3>
<h3
id="数据对象数据对象是相同数据元素的集合">数据对象：数据对象是相同数据元素的集合</h3>
<h3 id="数据类型">数据类型</h3>
<h4
id="原子类型不可再分的最小数据类型">原子类型：不可再分的最小数据类型</h4>
<h4 id="结构类型可以再分">结构类型：可以再分</h4>
<h4
id="抽象数据类型可以从java中接口理解既要有属性也要有方法">抽象数据类型：可以从java中接口理解，既要有属性，也要有方法</h4>
<h3 id="数据">数据</h3>
<h4 id="记录各个数据元素的值">记录各个数据元素的值</h4>
<h4 id="记录数据元素之间关系">记录数据元素之间关系</h4>
<h3 id="数据结构三要素">数据结构三要素</h3>
<h4
id="逻辑结构描述的是数据之间的逻辑关系与怎么存储无关">逻辑结构：描述的是数据之间的逻辑关系，与怎么存储无关。</h4>
<h5 id="线性结构">线性结构</h5>
<h6 id="一般线性表">一般线性表</h6>
<h6 id="栈和队列">栈和队列</h6>
<h6 id="串">串</h6>
<h6 id="数组">数组</h6>
<h5 id="非线性结构">非线性结构</h5>
<h6 id="集合">集合</h6>
<h6 id="树">树</h6>
<h6 id="图">图</h6>
<h4
id="存储结构用计算机语言实现的逻辑结构">存储结构：用计算机语言实现的逻辑结构</h4>
<h5 id="顺序存储逻辑相邻物理相邻">顺序存储：逻辑相邻，物理相邻</h5>
<h5
id="链式存储逻辑相邻物理不一定相邻存储空间不一定相连但存储的地址一定相邻">链式存储：逻辑相邻，物理不一定相邻(存储空间不一定相连，但存储的地址一定相邻)</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217100037.jpg"
alt="微信图片_20231217100037" />
<figcaption aria-hidden="true">微信图片_20231217100037</figcaption>
</figure>
<h5
id="索引存储通过索引表去查经典的就是数组下标就是索引表">索引存储：通过索引表去查，经典的就是数组下标，就是索引表</h5>
<h5 id="散列存储经典的就是哈希">散列存储：经典的就是哈希</h5>
<h3 id="数据运算">数据运算</h3>
<h4
id="运算定义针对逻辑结构可以理解为java的抽象类里面定义的抽象方法">运算定义针对逻辑结构，可以理解为java的抽象类里面定义的抽象方法</h4>
<h4
id="运算实现针对存储结构可以理解为java继承抽象类的子类中对抽象类里面定义的抽象方法的具体实现">运算实现针对存储结构，可以理解为java继承抽象类的子类中对抽象类里面定义的抽象方法的具体实现=</h4>
<h3 id="题型">题型</h3>
<h4
id="判断一个结构是逻辑结构还是存储结构">判断一个结构是逻辑结构还是存储结构：</h4>
<h5 id="首先要熟悉基本数据结构的实现">首先要熟悉基本数据结构的实现</h5>
<h5
id="判断逻辑结构就是看给出的结构抽不抽象如果可以用多种存储方式实现就是抽象">判断逻辑结构就是看给出的结构抽不抽象，如果可以用多种存储方式实现就是抽象</h5>
<h5
id="判断存储结构就是看具不具体如果指定了存储方式就是具体">判断存储结构就是看具不具体，如果指定了存储方式就是具体</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217094819.jpg"
alt="微信图片_20231217094819" />
<figcaption aria-hidden="true">微信图片_20231217094819</figcaption>
</figure>
<h5
id="逻辑结构与存储结构之间关系逻辑结构是独立的但存储结构依赖于逻辑结构是逻辑结构在计算机上的实现">逻辑结构与存储结构之间关系：逻辑结构是独立的，但存储结构依赖于逻辑结构，是逻辑结构在计算机上的实现</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217095851.jpg"
alt="微信图片_20231217095851" /> ## 算法评价 ### 时间复杂度 ####
计算规则 ##### 加法：一个算法的时间复杂度由其中最耗时的决定 #####
乘法：嵌套的循环里时间复杂度相乘 #### 题型 ##### 嵌套循环的计算： ######
1 外层循环计算了多少次，在多少次终止 ###### 2 内存循环每次计算了多少次
###### 3 外层执行一次乘这次内层执行的次数后求和 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217101508.jpg"
alt="微信图片_20231217101508" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217102736.jpg"
alt="微信图片_20231217102736" />
<figcaption aria-hidden="true">微信图片_20231217102736</figcaption>
</figure>
<h5 id="递归的计算">递归的计算</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217103806.jpg"
alt="微信图片_20231217103806" />
<figcaption aria-hidden="true">微信图片_20231217103806</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217104339.jpg"
alt="微信图片_20231217104339" />
<figcaption aria-hidden="true">微信图片_20231217104339</figcaption>
</figure>
<h3 id="空间复杂度">空间复杂度</h3>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>绪论</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/posts/40f24371.html</url>
    <content><![CDATA[<h1 id="线性表">线性表</h1>
<h2 id="定义">定义：</h2>
<h3 id="类型相同的数据元素">类型相同的数据元素</h3>
<h3 id="长度有限">长度有限</h3>
<h3 id="逻辑结构">逻辑结构</h3>
<h3 id="题型一什么是线性表">题型一：什么是线性表</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217105307.jpg"
alt="微信图片_20231217105307" />
<figcaption aria-hidden="true">微信图片_20231217105307</figcaption>
</figure>
<h2 id="线性表的顺序表示又叫顺序表">线性表的顺序表示，又叫顺序表</h2>
<h3 id="定义-1">定义：</h3>
<h4 id="逻辑相邻物理也相邻">逻辑相邻，物理也相邻</h4>
<h4
id="与数组区别在于线性表是从下标1开始存储数组是从0开始">与数组区别在于线性表是从下标1开始存储，数组是从0开始</h4>
<p>举例：顺序存储线性表的特点：随机存取，含义是线性表可以直接访问指定地址元素，且时间复杂度为O(1)</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140802.jpg"
alt="微信图片_20231217140802" />
<figcaption aria-hidden="true">微信图片_20231217140802</figcaption>
</figure>
<h3 id="基本操作">基本操作</h3>
<h4
id="在第i个位置插入新元素e插入位置可以从1到l.length-1">在第i个位置插入新元素e(插入位置可以从1到L.length
+ 1)</h4>
<h5
id="主要思路从最后一个起到第i个将所有元素往后移动一位这样位置i就空出来可以放元素了">主要思路：从最后一个起到第i个将所有元素往后移动一位，这样位置i就空出来可以放元素了</h5>
<h5 id="平均次数fracn2"><span
class="math inline">\(平均次数：\frac{n}{2}\)</span></h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140039.jpg"
alt="微信图片_20231217140039" />
<figcaption aria-hidden="true">微信图片_20231217140039</figcaption>
</figure>
<h5 id="时间复杂度on"><span
class="math inline">\(时间复杂度O(n)\)</span></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) &#123;	<span class="comment">//判断插入位置是否合理，注意，插入的最后一个可以是在现在队尾的下一位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length; L &gt;= i; i++) &#123;	<span class="comment">//后移，注意，后移的范围是从当前队尾到插入位置</span></span><br><span class="line">        L.data[j + <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="删除第i个位置元素删除位置1到l.length">删除第i个位置元素，删除位置1到L.length</h4>
<h5
id="主要思路通过将从i-1个位置起元素一起向前移动一位覆盖前一位元素实现">主要思路：通过将从i
+ 1个位置起元素一起向前移动一位,覆盖前一位元素实现</h5>
<h5 id="移动节点平均次数fracn-12"><span
class="math inline">\(移动节点平均次数\frac{n-1}{2}\)</span></h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217140458.jpg"
alt="微信图片_20231217140458" />
<figcaption aria-hidden="true">微信图片_20231217140458</figcaption>
</figure>
<h5 id="时间复杂度on-1"><span
class="math inline">\(时间复杂度O(n)\)</span></h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype &amp;e)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.length; j++) &#123;</span><br><span class="line">        L.data[j] = L.data[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="查找值是i的元素就是遍历整个数组查找">查找值是i的元素：就是遍历整个数组查找</h4>
<h2 id="线性表的链式表示">线性表的链式表示：</h2>
<h3 id="头节点和头指针">头节点和头指针</h3>
<h4
id="头节点叫头结点的就是虚拟头节点">头节点：叫头结点的就是虚拟头节点</h4>
<h4
id="头指针头指针始终指向第一个节点如果有头节点就指向头节点如果没有就指向链表的第一个节点">头指针：头指针始终指向第一个节点，如果有头节点就指向头节点，如果没有就指向链表的第一个节点</h4>
<h3 id="单链表">单链表</h3>
<h4 id="头插法">头插法</h4>
<h5 id="新节点的尾指针指向虚拟头节点的next">1
新节点的尾指针指向虚拟头节点的next</h5>
<h5 id="虚拟头节点的next再指向新节点">2
虚拟头节点的next再指向新节点</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">newNode-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="尾插法">尾插法</h4>
<h5 id="定义一个额外的尾指针">1定义一个额外的尾指针</h5>
<h5 id="先把尾指针的next指向新节点">2 先把尾指针的next指向新节点</h5>
<h5 id="再移动尾指针指向新节点">3 再移动尾指针指向新节点</h5>
<h5 id="最后把尾指针的next放空">4最后把尾指针的next放空</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rear-&gt;next = newNode;</span><br><span class="line">rear = newNode;</span><br></pre></td></tr></table></figure>
<h4
id="按序号查找注意节点序号从1开始因为链表也是线性表线性表就是从1开始-指针p一次往后移动1次移动i-1次最终指向的位置就是序号i的节点">按序号查找：注意节点序号从1开始(因为链表也是线性表，线性表就是从1开始)
，指针p一次往后移动1次，移动i-1次，最终指向的位置就是序号i的节点</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<h4 id="按值查找">按值查找</h4>
<h4 id="在位置i插入节点">在位置i插入节点</h4>
<h5
id="先查找插入位置前驱节点利用前面写好的按序号查找方法">先查找插入位置前驱节点，利用前面写好的按序号查找方法</h5>
<h5
id="在将新节点的next指向原来序号i的节点序号i-1的next指向新节点">在将新节点的next指向原来序号i的节点，序号i-1的next指向新节点</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *before = GetElem(LinkList L, i<span class="number">-1</span>);</span><br><span class="line">newNode-&gt;next = before-&gt;next;</span><br><span class="line">before-&gt;next = newNode;</span><br></pre></td></tr></table></figure>
<h4 id="删除序号是i的节点">删除序号是i的节点</h4>
<h5
id="利用前面查找节点查找到节点i-1">利用前面查找节点查找到节点i-1</h5>
<h5 id="用临时指针指向节点i">用临时指针指向节点i</h5>
<h5 id="节点i-1的next直接指向i的next">节点i-1的next直接指向i的next</h5>
<h5 id="free掉节点i">free掉节点i</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *before = GetElem(LinkList L, i);</span><br><span class="line">LNode *tmp = before-&gt;next;</span><br><span class="line">before-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br></pre></td></tr></table></figure>
<h4 id="求表长">求表长</h4>
<h3 id="双链表">双链表</h3>
<h4
id="在指定节点p之后插入节点s顺序不唯一但一定要注意操作过程不能把原来的后继节点位置中途搞丢">在指定节点p之后插入节点s(顺序不唯一，但一定要注意操作过程不能把原来的后继节点位置中途搞丢)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先处理后半部分</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line"><span class="comment">//再处理前半部分</span></span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<h4 id="删除节点p的后继节点q">删除节点p的后继节点q</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;priror = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<h4
id="循环单链表尾节点的next不是null而指向头节点">循环单链表：尾节点的next不是NULL，而指向头节点</h4>
<p>举个例子</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231217160038.jpg"
alt="微信图片_20231217160038" />
<figcaption aria-hidden="true">微信图片_20231217160038</figcaption>
</figure>
<p>删除后还要判断链表是否为空，如果为空(临时指针和尾指针指向同一个节点，就要修改尾指针)</p>
<p>####循环双链表</p>
<h3
id="静态链表结构体数组的数据域data里存数据指针域里存下一个节点的地址不过这个地址是结构体数组里unsigned-int类型的下标">静态链表：结构体数组的数据域data里存数据，指针域里存下一个节点的地址，不过这个地址是结构体数组里unsigned
int类型的下标</h3>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
  </entry>
  <entry>
    <title>网页开发基础知识</title>
    <url>/posts/d417c152.html</url>
    <content><![CDATA[<h1 id="html常用的标签">html常用的标签</h1>
<h1 id="注释标签文字标签和段落标签">注释标签、文字标签和段落标签</h1>
<h2 id="注释标签">注释标签</h2>
<p>原文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Welcome to my website!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>加上注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Welcome to my website!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt; --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="文字标签">文字标签</h2>
<h3 id="格式-fontfont">格式 &lt;font&gt;……&lt;/font&gt;</h3>
<h3 id="常用属性">常用属性</h3>
<h4 id="color">color</h4>
<p>1.使用英文单词表示 red black blue green</p>
<p>2.rgb(十六进制,0~9 a~f) 每两位代表一种颜色 red green blue
常用的十六进制颜色: 语法格式:#后面跟上随机6个位数</p>
<p>#ffffff 白色 #000000 黑色 #abcdef 天蓝色 #ff0000 红色</p>
<h4 id="size">size</h4>
<p>size:取值范围1~7之间
如果超出了最大值使用默认最大值7size:取值范围1~7之间
如果超出了最大值使用默认最大值7</p>
<p>举个例子</p>
<p>&lt;font color="red"
size="4"&gt;宣示—习近平发出新时代改革开放强音&lt;/font&gt;</p>
<p>效果如下</p>
<p><font color="red"  size="4">宣示—习近平发出新时代改革开放强音</font></p>
<h2 id="段落标签">段落标签</h2>
<h3 id="格式-pp">格式 &lt;p&gt;……&lt;/p&gt;</h3>
<p>作用:设置文本的样式(外观)
语法格式:style='属性名:属性值;属性名2:属性值2..'</p>
<p>font-size:修改文字的大小 fonts-size:20px 单位像素
background-color:设置文本的背景颜色</p>
<p>width:设置宽度的属性<br />
1.使用像素 800px 2.使用百分比: 80% height:设置高度的属性</p>
<p>举个例子</p>
<p>&lt;p style="color:white;background:
red;width:80%;height:200px;"&gt;新浪科技讯
北京时间12月21日早间消息，本周四，苹果宣布约翰·詹南德雷亚（John
Giannandrea）进入公司执行团队。不久之前，苹果刚刚任命詹南德雷亚担任AI、机器学习战略高级副总裁。晋升之后，詹南德雷亚直接向苹果CEO库克汇报工作。&lt;/p&gt;</p>
<p>效果如下</p>
<p style="color:white;background: red;width:80%;height:200px;">
新浪科技讯
北京时间12月21日早间消息，本周四，苹果宣布约翰·詹南德雷亚（John
Giannandrea）进入公司执行团队。不久之前，苹果刚刚任命詹南德雷亚担任AI、机器学习战略高级副总裁。晋升之后，詹南德雷亚直接向苹果CEO库克汇报工作。
</p>
<h2 id="和字体相关的其他标签">和字体相关的其他标签</h2>
<h3 id="加粗">加粗</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加粗--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗2<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--加粗-->
<p>
段落
</p>
<p><b>加粗</b> <strong>加粗2</strong></p>
<h3 id="下划线">下划线</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下划线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--下划线-->
<p><u>下划线</u></p>
<h3 id="删除线">删除线</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">s</span>&gt;</span></span><br><span class="line">市场价:<span class="tag">&lt;<span class="name">s</span>&gt;</span>999<span class="tag">&lt;/<span class="name">s</span>&gt;</span>现价:99</span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--删除线-->
<p><s>删除线</s> 市场价:<s>999</s>现价:99</p>
<h3 id="换行">换行</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">这一举动表明苹果高度重要AI。库克在声明中说：“在苹果，约翰做得很好，<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">很高兴能看到他加入我们的执行团队。机器学习与AI对于苹果的未来至关重</span><br></pre></td></tr></table></figure>
<!--换行-->
<p>一举动表明苹果高度重要AI。库克在声明中说：“在苹果，约翰做得很好，<br/>很高兴能看到他加入我们的执行团队。机器学习与AI对于苹果的未来至关重</p>
<h3 id="上标和下标">上标和下标</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>上标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">正常显示的文字</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>下标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<p>
<sup>上标</sup> 正常显示的文字 <sub>下标</sub>
</p>
<h3 id="斜体">斜体</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--斜体--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体2<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--斜体-->
<p><i>斜体</i> <em>斜体2</em></p>
<h3 id="缩进">缩进</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--缩进--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>詹南德雷亚在谷歌工作8年，4月份加入苹果。在谷歌工作时，他曾经是搜索、机器智能与研发主管。跳到苹果之后，詹南德雷亚对Siri、Core Ml负责。</span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果 <!--缩进--></p>
<blockquote>
詹南德雷亚在谷歌工作8年，4月份加入苹果。在谷歌工作时，他曾经是搜索、机器智能与研发主管。跳到苹果之后，詹南德雷亚对Siri、Core
Ml负责。
</blockquote>
<h1 id="标题标签和字符实体">标题标签和字符实体</h1>
<h2
id="标题标签hnhn-注意n的取值范围为16的整数">标题标签：&lt;hn&gt;&lt;/hn&gt;
注意：n的取值范围为1~6的整数</h2>
<p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<h1>
标题1
</h1>
<h2>
标题2
</h2>
<h3>
标题3
</h3>
<h4>
标题4
</h4>
<h5>
标题5
</h5>
<h6>
标题6
</h6>
<h2 id="字符实体">字符实体</h2>
<h3 id="特殊字符">特殊字符</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&amp;lt ---&gt; &lt;</span><br><span class="line">&amp;gt ---&gt; &gt;</span><br></pre></td></tr></table></figure>
<h3 id="版权">版权</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--版权--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;copy;</span>北京清华出版社<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<!--版权-->
<p>
©北京清华出版社
</p>
<h3 id="空格">空格</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--空格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>一名在美中国公民被控窃取商业机密,美方称涉案达18亿<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--空格-->
<p>
    一名在美中国公民被控窃取商业机密,美方称涉案达18亿
</p>
<h3 id="双引号">双引号</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--双引号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="symbol">&amp;quot;</span>华为回应部分国际银行断交:公司经营稳健,业务运转正常<span class="symbol">&amp;quot;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--双引号-->
<p>
"华为回应部分国际银行断交:公司经营稳健,业务运转正常"
</p>
<h3 id="和号">和号</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--和号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>11人跨省全链条制贩毒网络团伙<span class="symbol">&amp;amp;</span>被摧毁,头目是前知名歌手<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<!--和号-->
<p>
11人跨省全链条制贩毒网络团伙&amp;被摧毁,头目是前知名歌手
</p>
<h1 id="图像标签和路径">图像标签和路径</h1>
<h2 id="图像标签">图像标签</h2>
<h3 id="格式img">格式&lt;img……/&gt;</h3>
<h3 id="作用显示网页上面的图片">作用：显示网页上面的图片</h3>
<h3 id="常用属性-1">常用属性</h3>
<p>1.src:图片的路径 2.width:设置图片的宽度 3.height:设置图片的高度
4.alt:图片的替换文本,如果图片资源加载不出来,显示文本
5.title:鼠标悬浮标题</p>
<p>举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接设置网页上显示图片,使用图片默认宽高--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic.jpg&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用width和height--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic4.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--图片替换文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic33.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;圣诞节快乐&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--鼠标悬浮标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/pic2.jpg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;美女与野兽&quot;</span> <span class="attr">width</span>=<span class="string">&#x27;200px&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;200px&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>第一章-命题逻辑的基本概念</title>
    <url>/posts/10c6a857.html</url>
    <content><![CDATA[<h1 id="命题与联结词">命题与联结词</h1>
<span id="more"></span>
<h2 id="命题"><strong>命题</strong></h2>
<p>判断结果惟一（非真即假）的陈述句</p>
<h3 id="命题的真值-判断的结果"><strong>命题的真值</strong>
<strong>判断的结果</strong></h3>
<h3 id="真值的取值-真与假"><strong>真值的取值</strong>
<strong>真与假</strong></h3>
<p>注意</p>
<p><strong>感叹句、祈使句、疑问句都不是命题</strong></p>
<p><strong>陈述句中的悖论，判断结果不惟一确定的不是命题</strong></p>
<p>举个例子</p>
<p><span class="math inline">\(\sqrt{2}是有理数\)</span>
是命题，但是是假命题</p>
<p>x + 5 &gt; 3 不是命题</p>
<p>2050年元旦下大雪 是命题，但是真假未知</p>
<h3
id="命题分类简单命题也称原子命题与复合命题">命题分类：简单命题（也称原子命题）与复合命题</h3>
<h4 id="简单命题符号化"><strong>简单命题符号化</strong></h4>
<p>用小写英文字母 <span class="math inline">\(p,q,r, …,p_i, q_i, r_i(i
&gt; 1)\)</span>表示简单命题</p>
<p>用1表示真，用0表示假</p>
<p>举个例子</p>
<p><span class="math inline">\(p:\sqrt{2}是有理数，
则p的真值为0\)</span></p>
<h2 id="联结词">联结词</h2>
<h3 id="否定lnot">否定：<span class="math inline">\(\lnot\)</span></h3>
<p>规定<span class="math inline">\(\lnot p\)</span>
为真当且仅当p为假</p>
<h3 id="合取-land"><strong>合取</strong>: <span
class="math inline">\(\land\)</span></h3>
<p>p与q要同时为真才为真</p>
<h3 id="析取lor">析取：<span class="math inline">\(\lor\)</span></h3>
<p>p与q之一为真即为真</p>
<h4 id="相同或">相同或</h4>
<p>举个例子</p>
<p>令p:2是素数,q:4是素数,<span class="math inline">\(p\lor
q\)</span></p>
<h4 id="排斥或">排斥或</h4>
<p>举个例子</p>
<p>p:王小红生于1975年,q:王小红生于1976年,</p>
<p><span class="math inline">\((p\land \lnot q)\lor (\lnot p \lor q)或p
\or q\)</span></p>
<h3 id="蕴含to">蕴含：<span class="math inline">\(\to\)</span></h3>
<p>如果p，则q，记作<span class="math inline">\(p \to q\)</span>，
p是前件，q是后件，规定<span class="math inline">\(p \to
q\)</span>为假当且仅当p为真q为假</p>
<p>注：</p>
<ol type="1">
<li><p><span class="math inline">\(p \to
q\)</span>的逻辑关系：<font color = "red">q为p的必要条件</font>,这个很重要，直接区分了只要……就和只有……才的区别</p></li>
<li><p>当p为假时，<span class="math inline">\(p\to
q\)</span>恒为真，称为空证明</p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9431cbcfcb225833f2a8472c4f728c9.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="等价联结词leftrightarrow">等价联结词:<span
class="math inline">\(\leftrightarrow\)</span></h3>
<h1 id="命题公式及其赋值"><strong>命题公式及其赋值</strong></h1>
<h2 id="命题变项与合式公式"><strong>命题变项与合式公式</strong></h2>
<h3 id="命题变项">命题变项</h3>
<p>命题常项：简单命题</p>
<p>命题变项（命题变元）：真值可以变化的陈述句</p>
<h3 id="合式公式的递归定义">合式公式的递归定义</h3>
<p>就是如果一个已经时合式公式，那么在基础上的运算产生的公式也是合式公式</p>
<h3 id="合式公式的层次">合式公式的层次</h3>
<p>(1)若公式A是单个命题变项，则称A为0层公式</p>
<ol start="2" type="1">
<li>A时n+1层的前提，在于得到A的公式中最大层数时n</li>
</ol>
<p>举个例子</p>
<p><span class="math inline">\(A = B \land
C\)</span>,其中B,C分别为层和j层公式，且n =max(i,j)</p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/82d3859feb3ba201b0d65a55243be82.jpg" /></p>
<h2
id="公式的赋值使这个公式为真的赋值称作成真赋值成假的就是成假赋值"><strong>公式的赋值</strong>：使这个公式为真的赋值称作成真赋值，成假的就是成假赋值</h2>
<p>注: 含n个命题变项的公式有<span
class="math inline">\(2^n\)</span>个赋值</p>
<h2 id="真值表从0列到2n---1">真值表：从0列到<span
class="math inline">\(2^n - 1\)</span></h2>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240226162335090.png" /></p>
<h3 id="公式的类型">公式的类型</h3>
<h3 id="重言式永真式">重言式(永真式)</h3>
<h3 id="矛盾式永假式">矛盾式(永假式)</h3>
<h3 id="可满足式">可满足式</h3>
<h2 id="公式和真值表用途">公式和真值表用途</h2>
<p>n个命题变项，可以构成无穷多个合式公式，这些公式的真值表有<span
class="math inline">\(2^{2^n}\)</span>个不同的情况，因为有n个命题变项，每个有2种选择，有<span
class="math inline">\(2^n\)</span>种，结果有2种选择</p>
<h1 id="section"></h1>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第七章_二元关系</title>
    <url>/posts/fc115c62.html</url>
    <content><![CDATA[<h1 id="有序对与笛卡儿积">有序对与笛卡儿积</h1>
<span id="more"></span>
<h2 id="有序对">有序对</h2>
<h3 id="定义">定义</h3>
<p>由两个元素 x 和
y，按照一定的顺序组成的二元组称为有序对或序偶，记作&lt;x,y&gt;</p>
<h3 id="性质">性质</h3>
<ol type="1">
<li>有序性 <span class="math inline">\(&lt;x,y&gt; \neq
&lt;y,x&gt;\)</span> （当<span class="math inline">\(x \neq
y\)</span>时）<br />
(2)<span class="math inline">\(&lt;x,y&gt;\)</span>与<span
class="math inline">\(&lt;u,v&gt;\)</span>相等的充分必要条件是<br />
<span class="math inline">\(&lt;x,y&gt; = &lt;u,v&gt; \iff x=u \land
y=v\)</span>.</li>
</ol>
<h2 id="笛卡尔积">笛卡尔积</h2>
<h3 id="定义-1">定义</h3>
<p>设 <span class="math inline">\(A,B\)</span> 为集合，<span
class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span> 的笛卡尔积记作 <span
class="math inline">\(A \times B\)</span>，且<span
class="math inline">\(A \times B = \{ &lt;x,y&gt; | x \in A \land y \in
B \}\)</span></p>
<p><font color = "yellow">上面要求集合A中元素在前，集合B中元素在后</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506085529315.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506085539471.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="性质-1">性质</h3>
<ol type="1">
<li><p>不适合交换律: $ A B B A ( A B, A , B ) $</p></li>
<li><p>不适合结合律: $ (A B) C A (B C) ( A , B , C ) $</p></li>
<li><p>对于并或交运算满足分配律: $ <span
class="math display">\[\begin{align*}
A \times (B \cup C) &amp;= (A \times B) \cup (A \times C) \\
(B \cup C) \times A &amp;= (B \times A) \cup (C \times A) \\
\\
A \times (B \cap C) &amp;= (A \times B) \cap (A \times C) \\
(B \cap C) \times A &amp;= (B \times A) \cap (C \times A)
\end{align*}\]</span> $</p></li>
<li><p>若 <span class="math inline">\(A\)</span> 或 <span
class="math inline">\(B\)</span> 中有一个为空集，则 <span
class="math inline">\(A \times B\)</span> 就是空集: $ A = B = $</p></li>
<li><p>若 <span class="math inline">\(A \subseteq C\)</span> 且 <span
class="math inline">\(B \subseteq D\)</span>，则 <span
class="math inline">\(A \times B \subseteq C \times D\)</span>.</p></li>
<li><p>若 <span class="math inline">\(|A| = m\)</span>, <span
class="math inline">\(|B| = n\)</span>，则 <span
class="math inline">\(|A \times B| = mn\)</span></p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例1</p>
<p><a href="">视频讲解</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/86e37ee02d0eabdef3d7cf722efa748.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506092806904.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="二元关系">二元关系</h1>
<h2 id="二元关系定义">二元关系定义</h2>
<p>如果一个集合满足以下条件之一： (1) 集合非空, 且它的元素都是有序对 (2)
集合是空集 则称该集合为一个二元关系, 简称为关系，记作R</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506093525471.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506093556257.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="a到b的关系与a上的关系">A到B的关系与A上的关系</h2>
<h3 id="定义-2">定义</h3>
<p>设A,B为集合, A×B的任何子集所定义的二元关系叫做从A 到B的二元关系,
当A=B时则叫做A上的二元关系.</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513135719978.png" /></p>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：关系数量的计算</p>
<p><font color = "red">A上的二元关系数量等价于A <span
class="math inline">\(\times\)</span> A的子集数量</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513135854140.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0b09339d5af7d6a6189189f4db77df9.jpg" /></p>
<hr style = "border:2px solid yellow">
</blockquote>
<h2 id="a上重要关系">A上重要关系</h2>
<h3 id="空关系">空关系</h3>
<p><span class="math inline">\(\emptyset\)</span> 是 $ A $
上的关系，称为空关系。</p>
<h3 id="全域关系">全域关系</h3>
<p>全域关系 $ E_A = { (x,y) x A y A } = A A $</p>
<h3 id="恒等关系">恒等关系</h3>
<p>恒等关系 $ I_A = { (x,x) x A } $</p>
<h3 id="小于等于关系">小于等于关系</h3>
<p>小于等于关系 $ L_A = { (x,y) x,y A x y } $, $ A $ 为实数子集</p>
<h3 id="整除关系">整除关系</h3>
<p>整除关系 $ D_A = { (x,y) x,y A x y } $, $ A $ 为非零整数子集</p>
<h3 id="包含关系">包含关系</h3>
<p>包含关系 $ R = { (x,y) x,y A x y } $, $ A $ 是集合族。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513141310194.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="关系的表示">关系的表示</h2>
<p>关系矩阵与关系图</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513141412610.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="关系的运算">关系的运算</h1>
<h2 id="定义域值域与域">定义域、值域与域</h2>
<p><font color = "yellow">定义域：第一个元素组成的集合</font></p>
<p><font color = "yellow">值域：第二个元素组成的集合</font></p>
<p><font color = "yellow">域就是定义域和值域合并</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513141717678.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="逆运算">逆运算</h2>
<p>就是前后交换位置</p>
<h2 id="右复合运算circ">右复合运算<span
class="math inline">\(\circ\)</span></h2>
<p><font color = "yellow">两个不同关系集合之间某两个关系之间传递</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ca5ef66d1cbe16696ec2f6e4365b928.jpg" /></p>
<p>右复合（合成）画图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513142250426.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="限制">限制</h2>
<p><font color = "yellow">依次从A中选择元素，这些元素作为关系集合R中第一位</font></p>
<p>R在A上的限制记作 R↾A, 其中 R↾A = { &lt;x,y&gt; | xRy∧x∈A }</p>
<h2 id="像">像</h2>
<p><font color = "yellow">依次从A中选择元素，这些元素在关系集合R中对应的第二位</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513142837727.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="关系运算的性质">关系运算的性质</h2>
<h3 id="逆关系">逆关系</h3>
<p><font color = "yellow">"奇变偶不变"，两重含义，一个是这个关系本身与自己的逆，一个是定义域与值域之间的转换</font></p>
<p>设 $ F $ 是任意的关系，则</p>
<ol type="1">
<li><p><span class="math inline">\((F^{-1})^{-1} = F\)</span></p></li>
<li><p><span class="math inline">\(\text{dom}(F^{-1}) =
\text{ran}(F)\)</span>, <span class="math inline">\(\text{ran}(F^{-1}) =
\text{dom}(F)\)</span></p></li>
</ol>
<h3 id="结合律">结合律</h3>
<p><span class="math inline">\((F \circ G) \circ H = F \circ (G \circ
H)\)</span></p>
<h3 id="逆关系的分配律">逆关系的分配律</h3>
<p>分配以后还要调换顺序</p>
<p><span class="math inline">\((F \circ G)^{-1} = G^{-1} \circ
F^{-1}\)</span></p>
<h3 id="单位元">单位元</h3>
<p><span class="math inline">\(R \circ I_A = I_A \circ R =
R\)</span></p>
<h3 id="与并运算的分配律">与并运算的分配律</h3>
<p>以下是重新使用 LaTeX 语法打印上述内容：</p>
<p><span class="math inline">\(F \circ (G \cup H) = F \circ G \cup F
\circ H\)</span></p>
<p><span class="math inline">\((G \cup H) \circ F = G \circ F \cup H
\circ F\)</span></p>
<h3 id="与交运算的分配包含">与交运算的分配包含</h3>
<p><span class="math inline">\(F \circ (G \cap H) \subseteq F \circ G
\cap F \circ H\)</span></p>
<p><span class="math inline">\((G \cap H) \circ F \subseteq G \circ F
\cap H \circ F\)</span></p>
<h3 id="限制与交并的分配律">限制↾与交、并的分配律</h3>
<p>F ↾(A∪B) = F ↾A∪F ↾B</p>
<p>F ↾(A∩B) = F ↾A∩F ↾B</p>
<h3 id="像与并分配与交包含">像[]与并分配，与交包含</h3>
<p>F [A∪B] = F [A]∪F [B]</p>
<p>以下是重新使用 LaTeX 语法打印上述内容：</p>
<p><span class="math inline">\(F[A \cap B] \subseteq F[A] \cap
F[B]\)</span></p>
<h2 id="关系的幂运算">关系的幂运算</h2>
<p><a
href="https://youtu.be/E6BcFNKHTFo">视频讲解：如何直接用关系和关系图替代关系矩阵计算</a></p>
<h3 id="定义-3">定义</h3>
<p><span class="math inline">\(R^0 = \{ (x,x) \mid x \in A \} =
I_A\)</span></p>
<p><span class="math inline">\(R^{n+1} = R^n \circ R\)</span></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a783152b62ca68985def02cad7ec38c.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513152803354.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="幂运算的性质">幂运算的性质</h3>
<h4 id="循环">循环</h4>
<p>设 A 为 n 元集, R 是A上的关系, 则存在自然数 s 和 t, 使得 <span
class="math inline">\(R^s = R^t\)</span>.</p>
<h4 id="幂的相加和想乘">幂的相加和想乘</h4>
<p><span class="math inline">\(R^m \circ R^n = R^{m+n}\)</span></p>
<p><span class="math inline">\((R^m)^n = R^{mn}\)</span></p>
<h1 id="关系的性质">关系的性质</h1>
<h2 id="自反与反自反">自反与反自反</h2>
<h3 id="定义-4">定义</h3>
<p><a
href="https://www.youtube.com/watch?v=ZFEm1pAEz2I">视频讲解：自反与反自反</a></p>
<p><font color = "red">自反就是这种关系能让元素x得到自己本身，反自反就是得不到</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513160034656.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="关系矩阵与关系图">关系矩阵与关系图</h3>
<p><a
href="https://www.youtube.com/watch?v=iBiLOkCKu70">视频讲解：自反的关系矩阵与关系图</a></p>
<p><font color = "red"> 1. 自反的关系矩阵主对角线元素都是1</font>
<font color = "red"> 2. 自反的关系图每个节点都有自回路</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513161459159.png"
alt="自反关系的关系矩阵与关系图" />
<figcaption aria-hidden="true">自反关系的关系矩阵与关系图</figcaption>
</figure>
<p><a href="">视频讲解：反自反的关系矩阵与关系图</a></p>
<p><font color = "red">反自反关系关系矩阵主对角线都是0，关系图每个节点没有自回路</font></p>
<h2 id="对称与反对称">对称与反对称</h2>
<h3 id="定义-5">定义</h3>
<p><a
href="https://www.youtube.com/watch?v=FyEyeMAH5tg">视频讲解：对称与反对称</a></p>
<p><font color = "red">对称关系就是两个不同的元素x和y在交换位置后关系依然满足，反对称就是两个元素x和y只有在相等是才能实现调换位置</font></p>
<p><font color = "red">对称是2个不同元素，自反是1个元素</font></p>
<h3 id="关系矩阵与关系图-1">关系矩阵与关系图</h3>
<p>对称关系</p>
<p><a href="">视频讲解：对称关系的关系矩阵与关系图</a></p>
<p><font color = "red">1. 对称关系关系矩阵关于主对角线对称</font></p>
<p><font color = "red"> 2. 对称关系关系图有成对的有向边</font></p>
<p>反对称关系</p>
<p><a
href="https://www.youtube.com/watch?v=Y5swiaJEAJk">视频讲解：反对称关系的关系矩阵与关系图</a></p>
<p><font color = "red"> 1. 反对称关系的关系矩阵中除了对角线，<span
class="math inline">\(a_{ij}与a_{ji}\)</span>不能同时为1</font></p>
<p><font color = "red">2.
反对称关系的关系图两个节点之间最多只有1条有向边</font></p>
<h2 id="传递">传递</h2>
<p><a
href="https://www.youtube.com/watch?v=lvc6Nb0XxZw">视频讲解：传递</a></p>
<h1 id="关系的闭包">关系的闭包</h1>
<h2 id="定义-6">定义</h2>
<p><a
href="https://www.youtube.com/watch?v=w4itKhPjP8E">视频讲解：关系闭包定义</a></p>
<p><font color = "yellow">关系闭包个人理解就是在原来关系集合R基础上加上尽可能少的关系，组成新集合R'，新集合R’满足自反或者对称或者传递</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513183754873.png" /></p>
<h2 id="构造闭包">构造闭包</h2>
<h3 id="自反闭包r">自反闭包r</h3>
<p><font color = "yellow">就是并上一个恒等关系</font></p>
<p><a
href="https://www.youtube.com/watch?v=7YTXzxuD4Cs">视频讲解：如何构造自反闭包</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/46c5f305326a4098e2c844acf701a1e.jpg" style="zoom:50%;" /></p>
<h3 id="对称闭包s">对称闭包s</h3>
<p><font color = "yellow">就是并上一个逆关系</font></p>
<p><a
href="https://www.youtube.com/watch?v=WjGcEOMm_xw">视频讲解：如何构造对称闭包</a></p>
<h3 id="传递闭包t">传递闭包t</h3>
<p><a
href="https://www.youtube.com/watch?v=fVa6EkN1hM0">视频讲解：如何构造传递闭包</a></p>
<p><font color = "yellow">传递闭包就是将所有独立的幂（就是有的幂最后循环是一样的）并起来,一般就是算到R的某个幂变成恒等关系就行</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e224953a4d2029027264e9c483010a5.jpg" /></p>
<h2 id="warshall算法">warshall算法</h2>
<p><a
href="https://www.youtube.com/watch?v=hKZXvD0sqg4">视频讲解：warshall算法</a></p>
<p><font color = "yellow">"看列加行"</font></p>
<ol type="1">
<li>这里的加是逻辑加（就是或）</li>
<li>看一列，这一列如果有1，将对应的行加到另一行</li>
</ol>
<h2 id="闭包的性质">闭包的性质</h2>
<h1 id="等价类">等价类</h1>
<p><a
href="https://www.youtube.com/watch?v=3zFZnW_fOuI">等价关系的定义</a></p>
<p><a
href="https://www.youtube.com/watch?v=PdcSh6W6ujY">等价关系中模n的经典例子</a></p>
<p><a
href="https://www.youtube.com/watch?v=69qMSiXcSB4">等价类的定义和例子</a></p>
<h1 id="偏序关系">偏序关系</h1>
<p><a
href="https://www.bilibili.com/video/BV1FK4y1i7FP/?spm_id_from=333.788&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：偏序关系与偏序集、Hasse图、极大元、极小元、全序关系、最大元、良序集</a></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-命题逻辑的推理理论</title>
    <url>/posts/b34dc25f.html</url>
    <content><![CDATA[<h1 id="推理的形式结构">推理的形式结构</h1>
<span id="more"></span>
<h2 id="推理的正确与错误">推理的正确与错误</h2>
<p>设 A1, A2, ..., Ak, B 为命题公式。若对于每一组赋值，当 A1 ∧ A2 ∧ ...
∧ Ak 为假时，或者当 A1 ∧ A2 ∧ ... ∧ Ak 为真时，B 也为真，则称由前提 A1,
A2, ..., Ak 推出结论 B 的推理是有效的或正确的，并称 B 是有效结论。</p>
<h2 id="推理的形式结构-1">推理的形式结构</h2>
<ol type="1">
<li>{A1, A2, …, Ak} ⊢ B 若推理正确，记为 {A1, A2, ..., An} ⊢ B 记Γ =
{A1, A2, …, Ak}，则 Γ ⊢ B. 若推理正确，则 Γ ⊢ B.</li>
<li><span class="math inline">\((A1 ∧ A2 ∧ … ∧ Ak \rightarrow B)
若推理正确，记为 (A1 ∧ A2 ∧ … ∧ Ak \Rightarrow B)\)</span></li>
<li>前提：(A1, A2, ..., Ak) 结论：(B)</li>
</ol>
<h2 id="判断推理正确的方法">判断推理正确的方法</h2>
<ol type="1">
<li>真值表法</li>
<li>等值演算法</li>
<li>主析取范式法</li>
</ol>
<p>举例：</p>
<p>判断下面推理是否正确 (1) 若今天是1号, 则明天是5号. 今天是1号. 所以,
明天是5号.<br />
(2) 若今天是1号, 则明天是5号. 明天是5号. 所以, 今天是1号.</p>
<p>首先表示（1）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6a754e0ce024506e9bd01c6a5fb74f2.jpg" /></p>
<p>用等值演算法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5e7b6268e783c344436a60e51802d24.jpg" /></p>
<p>用主析取范式，以（2）为例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/77a01b599885f2e3178da79f3b105ae.jpg" /></p>
<h2 id="推理定律重点"><font color = "red">推理定律(重点)</font></h2>
<ol type="1">
<li><span class="math inline">\(A \Rightarrow (A \lor B)\)</span> 附加律
(如果命题A为真，那么命题A或B为真)</li>
<li><span class="math inline">\((A \land B) \Rightarrow A\)</span>
化简律</li>
<li><span class="math inline">\((A \Rightarrow B) \land A \Rightarrow
B\)</span> 假言推理</li>
<li><span class="math inline">\((A \Rightarrow B) \land \lnot B
\Rightarrow \lnot A\)</span> 拒取式<br />
</li>
<li><span class="math inline">\((A \lor B) \land \lnot B \Rightarrow
A\)</span> 析取三段论</li>
<li><span class="math inline">\((A \Rightarrow B) \land (B \Rightarrow
C) \Rightarrow (A \Rightarrow C)\)</span> 假言三段论</li>
<li><span class="math inline">\((A \Leftrightarrow B) \land (B
\Leftrightarrow C) \Rightarrow (A \Leftrightarrow C)\)</span>
等价三段论</li>
<li><span class="math inline">\((A \Rightarrow B) \land (C \Rightarrow
D) \land (A \lor C) \Rightarrow (B \lor D)\)</span> 构造性二难 <span
class="math inline">\((A \Rightarrow B) \land (\lnot A \Rightarrow B)
\Rightarrow B\)</span> 构造性二难(特殊形式)</li>
<li><span class="math inline">\((A \Rightarrow B) \land (C \Rightarrow
D) \land (\lnot B \lor \lnot D) \Rightarrow (\lnot A \lor \lnot
C)\)</span> 破坏性二难</li>
</ol>
<p>每个等值式可产生两个推理定律 如，由 <span class="math inline">\(A
\Leftrightarrow \lnot \lnot A\)</span> 可产生 <span
class="math inline">\(A \Rightarrow \lnot \lnot A\)</span> 和 <span
class="math inline">\(\lnot \lnot A \Rightarrow A\)</span></p>
<h1 id="自然推理系统p">自然推理系统P</h1>
<h2 id="形式系统的定义与分类">形式系统的定义与分类</h2>
<h2 id="自然推理系统p-1">自然推理系统P</h2>
<h3 id="字母表">字母表</h3>
<ol type="1">
<li>命题变项符号：p, q, r, …, pi, qi, ri, …</li>
<li>联结词符号：¬, ∧, ∨, →, ↔︎</li>
<li>括号与逗号：(, ), ，</li>
</ol>
<h3 id="合式公式同定义1.6">合式公式（同定义1.6）</h3>
<p>有限次地应用联结词和括号形成的命题符号串是合式公式</p>
<h3
id="推理规则重点中的重点"><font color = "red">推理规则(重点中的重点)</font></h3>
<ol type="1">
<li>前提引入规则</li>
<li>结论引入规则</li>
<li>置换规则（就是德摩根律）</li>
</ol>
<p>注：</p>
<p><font color = "red">假言推理在于蕴含式前提为真</font></p>
<p><font color = "red">拒取式规则在于蕴含式结论为假</font></p>
<p><font color = "red">假言三段论在于递推</font></p>
<p><font color = "red">析取三段论或的一方为假</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325150416218.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325150426381.png" /></p>
<h2
id="在p中构造证明直接证明法附加前提证明法归谬法">在P中构造证明:直接证明法、附加前提证明法、归谬法</h2>
<h3 id="直接证明法">直接证明法</h3>
<p>举例：</p>
<p>构造下面推理的证明： 若明天是星期一或星期三, 我明天就有课.
若我明天有课, 今天必备课. 我今天没备课. 所以, 明天不是星期一, 也不
是星期三.</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/1d9392a9b4536441ba48c4005c0ce49.jpg" /></p>
<h3 id="附加前提证明法">附加前提证明法</h3>
<p>欲证 前提：(A1, A2, …, Ak) 结论：<span class="math inline">\(C
\Rightarrow B\)</span></p>
<p>等价地证明 前提：(A1, A2, …, Ak, C) 结论：B</p>
<p>理由： <span class="math inline">\((A1 \land A2 \land … \land Ak)
\Rightarrow (C \Rightarrow B)\)</span> <span
class="math inline">\(\equiv \lnot (A1 \land A2 \land … \land Ak) \lor
(\lnot C \lor B)\)</span> <span class="math inline">\(\equiv \lnot (A1
\land A2 \land … \land Ak \land C) \lor B\)</span> <span
class="math inline">\(\equiv (A1 \land A2 \land … \land Ak \land C)
\Rightarrow B\)</span></p>
<p><font color = "red">适用于结论为蕴涵式，本质就是将本来结论中的前提也作为条件</font></p>
<p>举例:构造下面推理的证明:</p>
<p>"2是素数或合数. 若2是素数, 则 () 是无理数. 若 () 是无理数,
则4不是素数. 所以, 如果4是素数, 则2是合数."</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5586ba2610cf6608c526036e805adb5.jpg" /></p>
<h3 id="归谬法反证法">归谬法（反证法）</h3>
<p>欲证 前提：(A1, A2, … , Ak)<br />
结论：(B)</p>
<p>做法 <font color = "red">在前提中加入<span class="math inline">\(lnot
B\)</span>，推出矛盾.</font></p>
<p>理由： <span class="math inline">\(A1\land A2\land …\land
Ak\Rightarrow B\)</span> <span class="math inline">\(\equiv
\lnot(A1\land A2\land …\land Ak)\lor B\)</span> <span
class="math inline">\(\equiv \lnot(A1\land A2\land …\land Ak\land\lnot
B)\)</span> <span class="math inline">\(\equiv \lnot(A1\land A2\land
…\land Ak\land\lnot B)\lor 0\)</span> <span class="math inline">\(\equiv
A1\land A2\land …\land Ak\land\lnot B\Rightarrow 0\)</span></p>
<p>举例：</p>
<p>前提：<span class="math inline">\(\lnot(p\land q))\lor r\)</span>,
<span class="math inline">\(r\Rightarrow s\)</span>, <span
class="math inline">\(\lnot s\)</span>, <span
class="math inline">\(p\)</span><br />
结论：<span class="math inline">\(\lnot q\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c8cc52970162529ec6abfc6e1d19155.jpg" /></p>
<h1 id="消解证明法">消解证明法</h1>
<p>基本做法：
1.<font color = "red">把前提中的公式,结论的否定都化成等值的合取范式</font>
2.<font color = "red">列出所有合取范式的所有简单析取式作为前提</font>
3.用消解规则构造证明.
4.<font color = "red">如果得到空式(就是矛盾），则证明推理是正确的.</font></p>
<p>举例</p>
<p>前提：<span class="math inline">\(q\Rightarrow p\)</span>, <span
class="math inline">\(q\Leftrightarrow s\)</span>, <span
class="math inline">\(s\Leftrightarrow t\)</span>, <span
class="math inline">\(t\land r\)</span><br />
结论：<span class="math inline">\(p\land q\land s\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9451f03b4db5480042cc1f2b2ba5d82.jpg" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-命题逻辑等值演算</title>
    <url>/posts/d8837e86.html</url>
    <content><![CDATA[<h1 id="等值式与基本的等值式">等值式与基本的等值式</h1>
<span id="more"></span>
<h2 id="等值式定义">等值式定义</h2>
<p>如果A<span
class="math inline">\(\leftrightarrow\)</span>B是永真式(重言式)，则称A与B等值</p>
<p>注：</p>
<ol type="1">
<li>哑元</li>
</ol>
<p>举例</p>
<ol type="1">
<li>判断两个公式是否等值</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/729b4593eee6390e616eb31c6f4911c.jpg" /></p>
<h2 id="基本等值式">基本等值式</h2>
<h3 id="双重否定律-a-a">双重否定律: ¬(¬A) ↔︎ A</h3>
<h3 id="幂等律-a-a-a-a-a-a">幂等律: A ∨ A ↔︎ A, A ∧ A ↔︎ A</h3>
<h3 id="交换律-a-b-b-a-a-b-b-a">交换律: A ∨ B ↔︎ B ∨ A, A ∧ B ↔︎ B ∧
A</h3>
<h3 id="结合律-a-b-c-a-b-c-a-b-c-a-b-c">结合律: (A ∨ B) ∨ C ↔︎ A ∨ (B ∨
C), (A ∧ B) ∧ C ↔︎ A ∧ (B ∧ C)</h3>
<h3 id="分配律-a-b-c-a-b-a-c-a-b-c-a-b-a-c">分配律: A ∨ (B ∧ C) ↔︎ (A ∨
B) ∧ (A ∨ C), A ∧ (B ∨ C) ↔︎ (A ∧ B) ∨ (A ∧ C)</h3>
<h3 id="德摩根律-a-b-a-b-a-b-a-b"><font color = "red">德摩根律</font>:
¬(A ∨ B) ↔︎ (¬A) ∧ (¬B), ¬(A ∧ B) ↔︎ (¬A) ∨ (¬B)</h3>
<h3 id="吸收律-a-a-b-a-a-a-b-a"><font color = "red">吸收律:</font> A ∨
(A ∧ B) ↔︎ A, A ∧ (A ∨ B) ↔︎ A</h3>
<h3 id="零律-a-1-1-a-0-0">零律: A ∨ 1 ↔︎ 1, A ∧ 0 ↔︎ 0</h3>
<h3 id="同一律-a-0-a-a-1-a">同一律: A ∨ 0 ↔︎ A, A ∧ 1 ↔︎ A</h3>
<h3 id="排中律-a-a-1">排中律: A ∨ ¬A ↔︎ 1</h3>
<h3 id="矛盾律-a-a-0">矛盾律: A ∧ ¬A ↔︎ 0</h3>
<h3 id="蕴涵等值式-a-b-a-b"><font color = "red">蕴涵等值式</font>: A → B
↔︎ ¬A ∨ B</h3>
<h3 id="等价等值式-a-b-a-b-b-a">等价等值式: A ↔︎ B ↔︎ (A → B) ∧ (B →
A)</h3>
<h3 id="假言易位-a-b-b-a"><font color = "red">假言易位</font>: A → B ↔︎
¬B → ¬A</h3>
<h3 id="等价否定等值式-a-b-a-b">等价否定等值式: A ↔︎ B ↔︎ ¬A ↔︎ ¬B</h3>
<h3 id="归谬论-a-b-a-b-a"><font color = "red">归谬论</font>: (A → B) ∧
(A → ¬B) ↔︎ ¬A</h3>
<h1 id="等值演算与置换规则">等值演算与置换规则</h1>
<h2 id="置换规则">置换规则</h2>
<p><span class="math inline">\(如果 \Phi(A) 是包含公式 A 的命题公式，
\Phi(B) 是将公式 B 替换为 \Phi(A) 中所有的 A 后得到的命题公式，则若 B
\leftrightarrow A ，则 \Phi(B) \leftrightarrow \Phi(A)。\)</span></p>
<p>等值演算应用举例</p>
<ol type="1">
<li><p>证明两个公式等值</p>
<p>比如证明$p (q r) (p q) r $</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/e2a76a38f993148b2fbf3817eaecb5d.jpg" /></p></li>
</ol>
<p>​ 注：用等值演算不能直接证明两个公式不等值</p>
<p>​ 证明两个公式不等值的方法：</p>
<p>​ 举个例子：$p (q r) 与 (p q) r $</p>
<p>​ ①真值表</p>
<p>​ ②观察:000左真右假</p>
<p>​ ③先用等值化简再观察</p>
<ol start="2" type="1">
<li><p>判断公式类型</p>
<p><span class="math inline">\(q \land \neg (p \rightarrow
q)\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/949c2cc74f5622a9fac0fc88879c8ca.jpg" /></p></li>
</ol>
<h1
id="析取范式与合取范式主析取范式与主合取范式">析取范式与合取范式，主析取范式与主合取范式</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="文字">文字</h3>
<p>命题变项及其否定的总称</p>
<h3 id="简单析取式">简单析取式</h3>
<h3
id="由有限个文字构成的析取式一些例子包括">由有限个文字构成的析取式。一些例子包括：</h3>
<ul>
<li>p</li>
<li><span class="math inline">\(\neg q\)</span></li>
<li><span class="math inline">\(p \lor \neg q\)</span></li>
<li><span class="math inline">\(p \lor q \lor r\)</span></li>
<li>...</li>
</ul>
<h3 id="简单合取式">简单合取式</h3>
<p>由有限个文字构成的合取式。一些例子包括：</p>
<ul>
<li>p</li>
<li>$ q $</li>
<li>$ p q $</li>
<li>$ p q r $</li>
<li>...</li>
</ul>
<h3 id="析取范式">析取范式</h3>
<p>是由有限个简单合取式组成的析取式。以下是一些例子：</p>
<p><span class="math inline">\(p, \quad \neg p \land q, \quad p \lor
\neg q, \quad (p \land \neg q) \lor (\neg p \land q \land \neg r) \lor
(q \land r)\)</span></p>
<h3 id="合取范式">合取范式</h3>
<p>由有限个简单析取式组成的合取式。以下是一个例子：</p>
<p><span class="math inline">\(p, \quad p \lor \neg q, \quad \neg p
\land q, \quad (p \lor q) \land \neg p \land (p \lor \neg q \lor \neg
r)\)</span></p>
<h3 id="范式">范式</h3>
<p>析取范式与合取范式的总称</p>
<h2 id="范式的性质">范式的性质</h2>
<h3 id="简单范式">简单范式</h3>
<ol type="1">
<li><p>一个简单析取式是重言式当且仅当它同时含有某个命题变项和它的否定式</p></li>
<li><p>一个简单合取式是矛盾式当且仅当它同时含有某个命题变项和它的否定式</p></li>
</ol>
<h3 id="复合范式">复合范式</h3>
<ol type="1">
<li><p>一个析取范式是矛盾式当且仅当它每个简单合取式都是矛盾式</p></li>
<li><p>一个合取范式是重言式当且仅当它的每个简单析取式都是重言式</p></li>
</ol>
<p>注：单个文字既是简单析取式，又是简单合取式</p>
<h3 id="范式存在定理">范式存在定理</h3>
<p>任何命题公式都存在与之等值的析取范式与合取范式</p>
<h2 id="求公式的范式">求公式的范式</h2>
<h3 id="消去a中的to-leftrightarrow">消去A中的<span
class="math inline">\(\to\)</span> , <span
class="math inline">\(\leftrightarrow\)</span></h3>
<h3 id="否定连接词lnot內移或消去">否定连接词<span
class="math inline">\(\lnot\)</span>內移或消去</h3>
<h3 id="分配律">分配律</h3>
<p>举个例子</p>
<p>(p→¬q)→r</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d8bde4ae81b9643ff4d2ca7207fc200.jpg" /></p>
<h2 id="极小项与极大项">极小项与极大项</h2>
<h3 id="定义">定义：</h3>
<p>在含有n个命题变项的简单合取式（简单析取式）中，若每个命题变项均以文字的形式在其中出现且仅出现一次，而且第k个文字出现在左起第k位上（1≤k≤n），称这样的简单合取式（简单析取式）为极小项（极大项）。</p>
<p>①每个命题变项均以文字的形式在其中出现且仅出现一次</p>
<p>②第k个文字出现在左起第k位上（1≤k≤n）</p>
<p>③简单合取<span class="math inline">\(\land\)</span>,成真赋值<span
class="math inline">\(\to\)</span>极小项，简单析取<span
class="math inline">\(\lor\)</span>，成假赋值<span
class="math inline">\(\to\)</span>极大项</p>
<p>注：</p>
<ol type="1">
<li><p>n个命题变项有<span
class="math inline">\(2^n\)</span>个极小项和<span
class="math inline">\(2^n\)</span>个极大项</p></li>
<li><p>这些极小项（极大项）均互不等值。</p></li>
<li><p>用<span
class="math inline">\(m_i\)</span>表示第i个极小项，其中i是该极小项成真赋值的十进制表示。用<span
class="math inline">\(M_i\)</span>表示第i个极大项，其中i是该极大项成假赋值的十进制表示。<span
class="math inline">\(m_i\)</span>（<span
class="math inline">\(M_i\)</span>）称为极小项（极大项）的名称。</p></li>
</ol>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304163125914.png" /></p>
<h2 id="主析取范式与主合取范式">主析取范式与主合取范式</h2>
<h3 id="主析取范式">主析取范式</h3>
<p>由极小项构成的析取范式</p>
<h3 id="主合取范式">主合取范式</h3>
<p>由极大项构成的合取范式</p>
<p>例如，n=3，命题变项为 p, q, r 时，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(¬p ∧ ¬q ∧ r) ∨ (¬p ∧ q ∧ r) </span><br><span class="line">   ⇔ m1 ∨ m3 ——主析取范式</span><br><span class="line"></span><br><span class="line">(p ∨ q ∨ ¬r) ∧ (¬p ∨ ¬q ∨ ¬r) </span><br><span class="line">   ⇔ M1 ∧ M7——主合取范式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3
id="求公式主析取范式的步骤"><font color = "red">求公式主析取范式的步骤:</font></h3>
<p>设公式A含命题变项p1,p2,…,pn。</p>
<ol type="1">
<li>求A的<font color = "red">析取范式A' = B1 ∨ B2 ∨ … ∨
Bs</font>，其中Bj是简单合取式 j=1,2, … ,s。</li>
</ol>
<p>(2)确保<font color = "red">每项简单合取式含有n个不同命题变项</font>。<font color = "red">若某个Bj既不含pi，又不含¬pi，则将Bj展开成：
Bj ⇔ Bj ∧ (pi ∨ ¬pi) ⇔ (Bj ∧ pi) ∨ (Bj ∧ ¬pi)</font>
。重复这个过程，直到所有简单合取式都是长度为n的极小项为止。</p>
<ol start="3" type="1">
<li><p><font color = "red">消去重复出现的极小项</font>，即用mi代替mi ∨
mi。</p></li>
<li><p>将极小项<font color = "red">按下标从小到大排列</font>。</p></li>
</ol>
<h3
id="求公式主范式的步骤"><font color = "red">求公式主范式的步骤</font></h3>
<p>设公式A含命题变项p1,p2,…,pn。</p>
<ol type="1">
<li>求A的合取范式A' = B1 ∧ B2 ∧ … ∧ Bs，其中Bj是简单析取式 j=1,2, …
,s。</li>
</ol>
<p>(2)确保每项简单合取式含有n个不同命题变项。若某个Bj既不含pi，又不含¬pi，则将Bj展开成：
Bj ⇔ Bj ∨ (pi ∧ ¬pi) ⇔ (Bj ∨ pi) ∧ (Bj ∨
¬pi)。重复这个过程，直到所有简单析取式都是长度为n的极大项为止。</p>
<ol start="3" type="1">
<li><p>消去重复出现的极大项，即用Mi代替Mi ∧ Mi。</p></li>
<li><p>将极大项按下标从小到大排列。</p></li>
</ol>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8db38cd2f3eb0bee006a209b4b93cd5.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1f10bde7bacb2bad2f2f56d6344f41b.jpg" /></p>
<h2 id="主范式的应用">主范式的应用</h2>
<h3 id="求公式的成真成假赋值">求公式的成真成假赋值</h3>
<p>举例：(p→¬q)→r</p>
<p>由上面可知</p>
<p>(p→¬q)→r ⇔ m1∨m3∨m5∨m6∨m7</p>
<p>成真赋值为 001, 011, 101, 110, 111， 成假赋值为 000, 010, 100.</p>
<h3 id="判断公式的类型">判断公式的类型</h3>
<p>A为重言式 ⇔ A的主析取范式含全部<span
class="math inline">\(2^n\)</span>个极小项 ⇔
A的主合取范式不含任何极大项，记为1.</p>
<p>A为矛盾式 ⇔ A的主合析取范式含全部<span
class="math inline">\(2^n\)</span>个极大项 ⇔
A的主析取范式不含任何极小项，记为0.</p>
<p>A为非重言式的可满足式<br />
⇔ A的主析取范式中至少含一个，但不是全部极小项 ⇔
A的主合取范式中至少含一个，但不是全部极大项.</p>
<p>举例</p>
<ol type="1">
<li>A ⇔ ¬(p→q)∧q<br />
</li>
<li>B ⇔ p→(p∨q)<br />
</li>
<li>C ⇔ (p∨q)→r</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/fa93bc4f19f4d865fe21f49f9ce9552.jpg" /></p>
<h3 id="解实际问题">解实际问题</h3>
<p>例9 某单位要从A,B,C三人中选派若干人出国考察, 需满足下 述条件: (1)
若A去, 则C必须去; (2) 若B去, 则C不能去; (3) A和B必须去一人且只能去一人.
问有几种可能的选派方案?</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/99ba1fd29a01ec68306533acc168ab7.jpg" /></p>
<h2
id="用成真赋值和成假赋值确定主范式">用成真赋值和成假赋值确定主范式</h2>
<p>例10 设A有3个命题变项, 且已知A= m1∨m3∨m7, 求A的主合取范式.</p>
<p>解 A的成真赋值是1,3,7的二进制表示, 成假赋值是在主析取
范式中没有出现的极小项的下角标0,2,4,5,6的二进制表示, 它
们恰好是A的主合取范式的极大项的下角标, 故 A ⇔ M0∧M2∧M4∧M5∧M6</p>
<p><font color = "red">主析取范式和主合取范式下标"互补"</font></p>
<h1 id="联结词完备集">联结词完备集</h1>
<h2 id="联结词完备集-1"><strong>联结词完备集</strong></h2>
<p>定义2.7 设S是一个联结词集合，如果任何n(n≥1)
元真值函数都可以由仅含S中的联结词构成的公式表示，则称S是联结词完备集</p>
<p>若S是联结词完备集, 则任何命题公式都可由S中的联结词表示</p>
<p>定理2.6 <font color = "red">S = {¬, ∧, ∨}是联结词完备集</font></p>
<h2 id="复合联结词">复合联结词</h2>
<p>定义2.8 设 p, q 为两个命题, 非(p且q)称作p与q的与非式, 记作 p↑q,
<font color = "red">即 p↑q ⇔ 非(p且q)</font>,
↑称为与非联结词。非(p或q)称作p与q的或非式, 记作 p↓q, 即 p↓q ⇔ 非(p或q),
↓称为或非联结词。</p>
<p>定理2.7 {↑}与{↓}为联结词完备集。</p>
<p>证明：{非, 且, 或}为完备集 非p ⇔ 非p且非p ⇔ 非(p或p) ⇔ p↓p p且q ⇔
非(非p或非q) ⇔ 非p↓非q ⇔ (p↓p)↓(q↓q) p或q ⇔ 非非(p或q) ⇔ 非(p↓q) ⇔
(p↓q)↓(p↓q)</p>
<p>得证{↓}为联结词完备集。对{↑}类似可证。</p>
<p>举例：用联接集中联接词改写</p>
<ol type="1">
<li><p>{¬, ∧, ∨}： A = (¬p ∨ ¬q) ∧ r</p></li>
<li><p>{¬, ∧}： A = (¬p ∧ ¬q) ∧ r</p></li>
<li><p>{¬, ∨}： A = (¬p ∨ ¬q) ∨ r （这种情况下无法使用∧）</p></li>
<li><p>{¬, →}： A = ¬(p → ¬q) ∧ r</p></li>
<li><p>{↑}： A = (p↑¬q) ∧ r</p></li>
<li><p>{↓}： A = (p↓¬q) ∧ r</p></li>
</ol>
<h1 id="可满足性问题与消解法">可满足性问题与消解法</h1>
<p>空简单析取定义：不含任何文字的简单析取式称作空简单析取式，记作λ。规定λ是不可满足的。</p>
<p>常见字母和含义：</p>
<p>S: 合取范式,</p>
<p>C: 简单析取式,</p>
<p>l: 文字,</p>
<p>α: 赋值,</p>
<p>公式可带下角标或 ′</p>
<p>文字 l 的补 lc: 若 l = p，则 lc = ¬p；若 l = ¬p，则 lc = p。</p>
<p>S <span class="math inline">\(\approx\)</span> S': S
是可满足的当且仅当 S' 是可满足的</p>
<p>消解式定义： 设 C1 = λ ∨ C1'，C2 = λc ∨ C2'，其中 C1' 和 C2' 不含 λ
和 λc，称 C1' ∨ C2' 为 C1 和 C2（以 λ 和 λc
为消解文字）的消解式或消解结果，记作 Res(C1, C2)。</p>
<p>消解式举例：Res(¬p ∨ q ∨ r, p ∨ q ∨ ¬s) = q ∨ r ∨
¬s，<font color = "red">观察可知没有p</font></p>
<p><font color = "yellow">消解步骤：</font></p>
<ol type="1">
<li><font color = "yellow">将公共字母且互为“相反数”的两个字母消去，比如上面的p</font></li>
<li><font color = "yellow">将剩下字母用∨连接</font></li>
</ol>
<h2 id="消解序列与合取范式的否证">消解序列与合取范式的否证</h2>
<p>消解序列的定义：设 S 是一个合取范式，C1, C2, ..., Cn
是一个简单析取式序列。如果对每一个 i (1 ≤ i ≤ n)，Ci 是 S
的一个简单析取式或者是 Res(Cj, Ck) (1 ≤ j &lt; k &lt; i)，则称此序列是由
S 导出 Cn 的消解序列。当 Cn = λ 时，称此序列是 S 的一个否证。</p>
<p><font color = "red">上面说白了就是消解到最后字母没了那么就是否证，否证又说明是不可满足</font></p>
<p>举个例子：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8647c26f8f4942650220ed6b886dc6e.jpg" /></p>
<h2 id="消解算法"><font color = "red">消解算法</font></h2>
<p>算法概括：</p>
<p>首先将<span
class="math inline">\(S_0和S_2设置为空集，S_1设置为原式S中的析取式的集合\)</span></p>
<p>然后每轮循环将<span class="math inline">\(S_0\)</span>与<span
class="math inline">\(S_1\)</span>中元素进行消解运算，运算得到的结果如果没有字母就退出循环，说明不可消解，如果消解结果既不在<span
class="math inline">\(S_0\)</span>中也不在<span
class="math inline">\(S_1\)</span>中就与<span
class="math inline">\(S_2\)</span>取并集</p>
<p>然后一轮消解后将S1赋给<span class="math inline">\(S_0\)</span>,<span
class="math inline">\(S_2\)</span>赋给<span
class="math inline">\(S_1\)</span>,<span
class="math inline">\(S_2\)</span>重置为空集。直到一轮循环后<span
class="math inline">\(S_2\)</span>还是空集循环结束输出yes</p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c81a1fdaf9df2d5784d6fe57958382d.jpg" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第八章_函数</title>
    <url>/posts/655befd.html</url>
    <content><![CDATA[<h1 id="函数的定义与性质">函数的定义与性质</h1>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p><font color = "red">一句话，不能一对多</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例 F1={&lt;x1,y1&gt;,&lt;x2,y2&gt;,&lt;x3,y2&gt;}
F2={&lt;x1,y1&gt;,&lt;x1,y2&gt;} F1是函数, F2不是函数</p>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：如果2个函数相等，定义域和值域都要相等</p>
</blockquote>
<h2 id="从a到b的函数">从A到B的函数</h2>
<p><font color = "red">说白了，就是一个定义域A，在这个定义域上构建一个函数，由此产生的值域在集合B内，就叫从A到B的函数</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>设A={1,2,3}, B={a,b}, 求<span class="math inline">\(B^A\)</span></p>
<p>f0 = {&lt;1,a&gt;,&lt;2,a&gt;,&lt;3,a&gt;} f1 =
{&lt;1,a&gt;,&lt;2,a&gt;,&lt;3,b&gt;} f2 =
{&lt;1,a&gt;,&lt;2,b&gt;,&lt;3,a&gt;} f3 =
{&lt;1,a&gt;,&lt;2,b&gt;,&lt;3,b&gt;} f4 =
{&lt;1,b&gt;,&lt;2,a&gt;,&lt;3,a&gt;} f5 =
{&lt;1,b&gt;,&lt;2,a&gt;,&lt;3,b&gt;} f6 =
{&lt;1,b&gt;,&lt;2,b&gt;,&lt;3,a&gt;} f7 =
{&lt;1,b&gt;,&lt;2,b&gt;,&lt;3,b&gt;}</p>
<hr style = "border:2px solid yellow">
<h2 id="函数的性质">函数的性质</h2>
<p>设 f：A→B</p>
<h3 id="满射">满射</h3>
<p><font color = "red">值域中每一个元素都有定义域对应</font>，不过不一定是一个</p>
<h3 id="单射">单射</h3>
<p><font color = "red">值域中每一个元素在定义域中如果有元素对应，有且只有一个</font></p>
<h3 id="双射">双射</h3>
<p><font color = "red">一一对应</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240527220107112.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="函数的像与完全原像">函数的像与完全原像</h2>
<h3 id="像">像</h3>
<p><font color = "red">给一个定义域集合，函数的像就是这个定义域集合对应的值域集合</font></p>
<h3 id="完全原像">完全原像</h3>
<p><font color = "red">给一个值域中的数，得到定义域中一个集合，这个集合中所有数经过函数都可以得到这个值域中的值</font></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240528084532247.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="某些重要函数">某些重要函数</h2>
<h3 id="特征函数">特征函数</h3>
<p><font color = "red">在定义域里再划分一个小子集，在这个小子集里的都是1，不在里面的就是0</font></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7e1bbf8fa17786d5eabaf016d9e83a8.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="自然映射">自然映射</h3>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/87b10ca46a9cb76d28cc125262fd2de.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="函数的复合与反函数">函数的复合与反函数</h1>
<h2 id="函数的复合">函数的复合</h2>
<h2 id="反函数">反函数</h2>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章-一阶逻辑等值演算与推理</title>
    <url>/posts/9973ebf8.html</url>
    <content><![CDATA[<h1 id="一阶逻辑等值式与置换规则">一阶逻辑等值式与置换规则</h1>
<span id="more"></span>
<h2 id="基本等值式">基本等值式</h2>
<h3
id="第一组命题逻辑中16组基本等值式">第一组:命题逻辑中16组基本等值式</h3>
<p>就是下面这些东西</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408140333849.png" /></p>
<h3 id="第二组">第二组</h3>
<h4 id="消去量词等值式">消去量词等值式</h4>
<p><font color = "yellow">说白了就是任意就是将所有情况并起来，存在就是将所有情况和起来</font></p>
<p>设D = {a1, a2, … , an}</p>
<p>① ∀xA(x) ≡ A(a1)∧A(a2)∧…∧A(an)</p>
<p>② ∃xA(x) ≡ A(a1)∨A(a2)∨…∨A(an)</p>
<h4 id="量词否定等值式">量词否定等值式</h4>
<p>① ¬∀xA(x) ≡
∃x¬A(x)(<font color = "yellow">任意的非就意味着存在非的情况</font>)</p>
<p>② ¬∃xA(x) ≡
∀x¬A(x)(<font color = "yellow">存在的非就意味着任意都是非</font>)</p>
<h4 id="量词辖域收缩与扩张等值式">量词辖域收缩与扩张等值式。</h4>
<p><font color = "yellow">1.
收缩是指收到约束变量，把自由变量扔出去，扩张就是将自由变量也考虑进来</font></p>
<p><font color = "yellow">2.
无论是∨还是∧收缩辖域时，∀或者∃都只能对含约束变量的作用</font></p>
<p><font color = "yellow">3.
→收缩辖域时，∀或者∃如果约束变量<font color = "red">在前面需要取反</font>,如果约束变量<font color = "red">在后面就不用取反</font></font></p>
<p>关于全称量词的：</p>
<p>①∀x(A(x)∨B) ≡ ∀xA(x)∨B</p>
<p>②∀x(A(x)∧B) ≡ ∀xA(x)∧B</p>
<p>③∀x(A(x)→B) ≡ ∃xA(x)→B</p>
<p>④∀x(B→A(x)) ≡ B→∀xA(x)</p>
<p>关于存在量词的：</p>
<p>①∃x(A(x)∨B) ≡ ∃xA(x)∨B</p>
<p>②∃x(A(x)∧B) ≡ ∃xA(x)∧B</p>
<p>③∃x(A(x)→B) ≡ ∀xA(x)→B</p>
<p>④∃x(B→A(x)) ≡ B→∃xA(x)</p>
<h4 id="量词分配等值式">量词分配等值式</h4>
<p><font color = "yellow">1.
与前面收缩扩张的区别在于，将∀（或者∃）分配给所有约束变量</font></p>
<p><font color = "yellow">2. ∀对∨，∃对∧无分配律</font></p>
<p>① ∀x(A(x)∧B(x)) ≡ ∀xA(x)∧∀xB(x)</p>
<p>② ∃x(A(x)∨B(x)) ≡ ∃xA(x)∨∃xB(x)</p>
<h2 id="置换规则换名规则代替规则">置换规则、换名规则、代替规则</h2>
<h3 id="置换规则">置换规则</h3>
<p><font color = "yellow">等价交换</font></p>
<p>设ϕ(A)是含A的公式，那么，若A⇔B，则ϕ(A)⇔ϕ(B).</p>
<h3 id="换名规则">换名规则</h3>
<p><font color = "yellow">指导变元和约束变量要换一起换</font></p>
<p>设A为一公式，将A中某量词辖域中一个个体变项的所有约束出现及相应的指导变元换成该量词辖域中未曾出现过的某个个体变项符号，其余部分不变，设所得公式为A'，则A'⇔A.</p>
<h3 id="代替规则">代替规则</h3>
<p><font color = "yellow">自由出现自个玩</font></p>
<p>设A为一公式，将A中某个个体变项的所有自由出现用A中未曾出现过的个体变项符号代替，其余部分不变，设所得公式为A'，则A'⇔A.</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例1 将下面命题用两种形式符号化, 并证明两者等值: (1)
没有不犯错误的人</p>
<p><a
href="https://www.bilibili.com/video/BV1Kz42117hH/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<ol start="2" type="1">
<li>不是所有的人都爱看电影</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/40456114877658721cdba1b5a1cf4b3.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>例2：将公式化成等值的不含既有约束出现、又有自由出现的个体变项：</p>
<p>∀x(F(x,y,z)→∃yG(x,y,z))</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/935b94e84a67e326ab9f309c28035cb.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>例3：设个体域D={a,b,c}，消去下述公式中的量词:</p>
<p>∀x∃y(F(x)→G(y))</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/376e0e692502bd7a6eabdca22aed69b.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="一阶逻辑前束范式">一阶逻辑前束范式</h1>
<p><font color = "yellow">1. 指导变元必须在一起</font></p>
<p><font color = "yellow">2. 指导变元前不能有非</font></p>
<p><font color = "yellow">3.
这一条不是必须，当往往遵守，就是不同辖域的指导变元尽量不要重名</font></p>
<p>例如， ∀x¬(F(x)∧G(x)) ∀x∃y(F(x)→(G(y)∧H(x,y))) 是前束范式 而
¬∃x(F(x)∧G(x)) ∀x(F(x)→∃y(G(y)∧H(x,y))) 不是前束范式,</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>求下列公式的前束范式:</p>
<ol type="1">
<li>∀xF(x)∧¬∃xG(x)</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a6fb111098f93eeb048d540d62f55bf.jpg" /></p>
<p>上面这个例子就是呼应了第三点不同指导变元尽量不要重名</p>
<ol start="2" type="1">
<li>∀x(F(x)→∃y(G(x,y)∧¬H(y)))</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9c72c5dce9e6f3093ffcd56f7ff5477.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="一阶逻辑的推论理论">一阶逻辑的推论理论</h1>
<h2 id="推理定律">推理定律</h2>
<h3 id="重言蕴涵式">重言蕴涵式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. A ⇒ (A∨B)                                                   附加律 </span><br><span class="line">2. (A∧B) ⇒ A                                                   化简律</span><br><span class="line">3. (A→B)∧A ⇒ B                                                 假言推理</span><br><span class="line">4. (A→B)∧¬B ⇒ ¬A                                               拒取式    </span><br><span class="line">5. (A∨B)∧¬B ⇒ A                                                析取三段论</span><br><span class="line">6. (A→B)∧(B→C) ⇒ (A→C)                                         假言三段论</span><br><span class="line">7. (A↔B)∧(B↔C) ⇒ (A↔C)                                         等价三段论</span><br><span class="line">8. (A→B)∧(C→D)∧(A∨C) ⇒ (B∨D)                                   构造性二难</span><br><span class="line">    (A→B)∧(¬A→B) ⇒ B                                           构造性二难(特殊形式)</span><br><span class="line">9. (A→B)∧(C→D)∧(¬B∨¬D) ⇒ (¬A∨¬C)                               破坏性二难</span><br></pre></td></tr></table></figure>
<h3 id="基于基本等值式">基于基本等值式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 零律: A∨1 ⇔ 1, A∧0 ⇔ 0</span><br><span class="line">2. 同一律: A∨0 ⇔ A, A∧1 ⇔ A</span><br><span class="line">3. 排中律: A∨¬A ⇔ 1</span><br><span class="line">4. 矛盾律: A∧¬A ⇔ 0</span><br><span class="line">5. 蕴涵等值式: A→B ⇔ ¬A∨B</span><br><span class="line">6. 等价等值式: A↔B ⇔ (A→B)∧(B→A)</span><br><span class="line">7. 假言易位: A→B ⇔ ¬B→¬A</span><br><span class="line">8. 等价否定等值式: A↔B ⇔ ¬A↔¬B</span><br><span class="line">9. 归谬论: (A→B)∧(A→¬B) ⇔ ¬A</span><br></pre></td></tr></table></figure>
<h3 id="量词分配蕴涵律">量词分配蕴涵律</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) ∀x(A(x)∨∀xB(x)) ⇒ ∀x(A(x)∨B(x)) </span><br><span class="line"></span><br><span class="line">(2) ∃x(A(x)∧B(x)) ⇒ ∃xA(x)∧∃xB(x)</span><br><span class="line"></span><br><span class="line">(3) ∀x(A(x)→B(x)) ⇒ ∀xA(x)→∀xB(x)</span><br><span class="line"></span><br><span class="line">(4) ∃x(A(x)→B(x)) ⇒ ∃xA(x)→∃xB(x)</span><br></pre></td></tr></table></figure>
<h2 id="量词消去引入规则">量词消去引入规则</h2>
<h3 id="全称量词消去规则-">全称量词消去规则(∀-)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415142936856.png" /></p>
<p>全称量词消去规则(∀-)</p>
<p>其中 x, y 是个体变项符号，c
是个体常项符号，<font color = "red">并且在 A 中 x 不在 ∀y 和 ∃y
的辖域内自由出现</font></p>
<p>来解释下这句绕口令一样的话</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>要特别注意使用∀-, ∀+, ∃-, ∃+规则的条件。就是上面那句像绕口令的话</p>
<p>反例1. 对 A = ∀x∃yF(x,y) 使用 ∀-规则，推得 B = ∃yF(y,y)。 取解释
I：个体域为 R，F(x, y): x &gt; y 在 I 下 A 被解释为 ∀x∃y(x&gt;y)，真；而
B 被解释为 ∃y(y&gt;y)，假。 原因：在 A 中 x 自由出现在 ∃y 的辖域 F(x,y)
内。</p>
<p>将上述段落重新打印。</p>
<hr style = "border:2px solid yellow">
<h3 id="全称量词引入规则">全称量词引入规则（∀+）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415143917922.png" /></p>
<p>其中 x
是个体变项符号，并且<font color = "red">不在前提的任何公式中自由出现</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>反例2. 前提: P(x)→Q(x), P(x) 结论: ∀xQ(x) 取解释I: 个体域为Z,
P(x):x是偶数， Q(x):x被2整除</p>
<p>在 I 下前提为真，结论为假，从而推理不正确</p>
<p>错误的证明如下</p>
<p>“证明”: ① P(x)→Q(x) 前提引入 ② P(x) 前提引入 ③ Q(x) ①②假言推理 ④
∀xQ(x) ③∀+</p>
<p>错误原因: 在④使用∀+规则，而 x 在前提的公式中自由出现。</p>
<hr style = "border:2px solid yellow">
<h3 id="存在量词消去规则-">存在量词消去规则（∃-）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415144537991.png" /></p>
<p>其中x是个体变项符号, 且不在前提的任何公式和B中自由出现</p>
<h3 id="存在量词引入消去规则">存在量词引入消去规则（∃+）</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415150227362.png" /></p>
<p>其中 x, y 是个体变项符号，c 是个体常项符号，且在 A 中 y 和 c 不在 ∀x
和 ∃x 的辖域内自由出现。</p>
<h1 id="自然推理系统的证明">自然推理系统的证明</h1>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b435e0641c7c0e17e51f0c18f399c7b.jpg" /></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e8a5df5c71f58076fc8829a802fb10c.jpg" /></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章-集合代数</title>
    <url>/posts/36cbec99.html</url>
    <content><![CDATA[<h1 id="集合的基本概念">集合的基本概念</h1>
<span id="more"></span>
<p>集合表示法中微词表示法举例：<span class="math inline">\(S =
\{x|x是实数且x^2 - 1 = 0\}\)</span></p>
<h2 id="元素与集合">元素与集合</h2>
<h3 id="性质">性质</h3>
<p>无序性：元素列出的顺序无关 相异性：集合的每个元素只计数一次
确定性：对任何元素和集合都能确定这个元素是否为该集合的元素
任意性：集合的元素也可以是集合</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415082840554.png"
alt="集合1树状表示" />
<figcaption aria-hidden="true">集合1树状表示</figcaption>
</figure>
<p><font color = "yellow">从上图来看，集合中元素属于这个集合必须是直接属于</font></p>
<h2 id="集合与集合">集合与集合</h2>
<p>定义6.1子集: <span class="math inline">\(A \subseteq B
\Leftrightarrow \forall x (x \in A \rightarrow x \in B\)</span></p>
<p>定义6.1非子集: <span class="math inline">\(A \nsubseteq B
\Leftrightarrow \exists x (x \in A \land x \notin B)\)</span></p>
<p>定义6.2相等: <span class="math inline">\(A = B \Leftrightarrow A
\subseteq B \land B \subseteq A\)</span></p>
<p>定义6.3真子集: <span class="math inline">\(A \subsetneq B
\Leftrightarrow A \subseteq B \land A \neq B\)</span></p>
<p>注意： <font color = "yellow"><span
class="math inline">\(\in\)</span>和 <span
class="math inline">\(\subseteq\)</span>是不同层次的问题</font>，其中：</p>
<ul>
<li><span
class="math inline">\(\in\)</span>可以看作是不同层次上的集合元素与集合之间的关系。<font color = "red">通俗点说就是{
}数量不等</font></li>
<li><span
class="math inline">\(\subseteq\)</span>是同一层次上的两个集合之间的关系。<font color = "red">通俗点说就是{
}数量相等</font></li>
</ul>
<h2 id="空集全集和幂集">空集、全集和幂集</h2>
<p>幂集：集合A的全体子集构成的集合，记作 $P(A) = { x , | , x A } $</p>
<p>实例：</p>
<p><span class="math inline">\(P(\emptyset) = \{\emptyset\},
P(\{\emptyset\}) = \{\emptyset, \{\emptyset\}\}\)</span></p>
<p><font color = "yellow">第二个例子就是把空集当成1个普通元素就行，同时注意集合包含关系要求{
}层数相等</font></p>
<p>计数：如果 $ |A| = n ，则 |P(A)| = 2^n $</p>
<h1 id="集合的基本运算">集合的基本运算</h1>
<h2 id="初级运算">初级运算</h2>
<p>并: $ A B = {x , | , x A x B} $</p>
<p>交: $ A B = {x , | , x A x B} $</p>
<p>相对补: $ A - B = {x , | , x A x B} $</p>
<p>对称差: <span class="math inline">\(A \oplus B = (A - B) \cup (B -
A)\)</span></p>
<p>绝对补: $ A = E - A $</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415084558934.png"
alt="初级运算的文氏图表示" />
<figcaption aria-hidden="true">初级运算的文氏图表示</figcaption>
</figure>
<h2 id="广义运算">广义运算</h2>
<h3 id="集合的广义并与广义交">集合的广义并与广义交</h3>
<p>广义并：集合A的元素的元素构成的集合，记作 $A = { x , | , z (z A x z)
} $</p>
<p>广义交：非空集合A的所有元素的公共元素构成的集合，记作 $ A = { x , | ,
z (z A x z) } $</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240417084719497.png" /></p>
<h3 id="性质-1">性质</h3>
<ol type="1">
<li>$ = ， $无意义</li>
<li><font color = "red">单元集 <span
class="math inline">\(\{x\}\)</span> 的广义并和广义交都等于 <span
class="math inline">\(x\)</span></font></li>
<li><font color ="red">广义运算减少集合的层次（括弧减少一层）</font></li>
<li>广义运算的计算：一般情况下可以转变成初级运算</li>
</ol>
<h2 id="运算的优先权规定">运算的优先权规定</h2>
<ol type="1">
<li><p>类运算：初级运算 $ , , - , $， 优先顺序由括号确定。</p></li>
<li><p>类运算：广义运算和 $ $运算， 运算由右向左进行。</p></li>
</ol>
<p>混合运算：2 类运算优先于 1 类运算。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9b405f93ea904fd3d76b2685b20a14f.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="有穷集的计数">有穷集的计数</h1>
<h2 id="容斥原理">容斥原理</h2>
<p>(多个字母的并事件)：奇数个字母前面是正号，偶数个字母前面是负号，然后组合排列出所有情况</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150120.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150328.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/16d2c959ab4666a7647f250f6251e61.jpg" /></p>
<hr style = "border:2px solid yellow">
<h1 id="集合恒等式">集合恒等式</h1>
<h2 id="只涉及一个运算的算律">只涉及一个运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093700840.png" /></p>
<h2 id="涉及两个不同运算的算律">涉及两个不同运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093725135.png" /></p>
<h2 id="涉及补运算的算律">涉及补运算的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093821897.png" /></p>
<h2 id="涉及全集和空集的算律">涉及全集和空集的算律</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415093841769.png" /></p>
<h2 id="集合证明题">集合证明题</h2>
<ol type="1">
<li><p>证 $ X Y $ 任取 $ x $， $ x X x Y $</p></li>
<li><p>证 $ X = Y $ 方法一：分别证明 $ X Y $ 和 $ Y X $ 方法二：任取
<span class="math inline">\(x\)</span>， $ x X x Y $</p></li>
</ol>
<h3 id="集合等式的证明">集合等式的证明</h3>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f42b9be412e552825a360c5161bd797.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="包含等价条件的证明">包含等价条件的证明</h3>
<p><font color = "red">确定命题，确定顺序</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-一阶（谓词）逻辑基本概念</title>
    <url>/posts/bf8cfd61.html</url>
    <content><![CDATA[<h1 id="一阶逻辑命题符号化">一阶逻辑命题符号化</h1>
<span id="more"></span>
<h2 id="个体词谓词量词">个体词、谓词、量词</h2>
<h3 id="谓词">谓词</h3>
<p>定义：刻画个体词性质或个体词之间相互关系的词，<strong>常用F, G,
H等表示</strong></p>
<p><strong>谓词常项 如, F(a)</strong>：a是人</p>
<p><strong>谓词变项 如, F(x)</strong>：x具有性质F</p>
<p><strong>n（n≥1）元谓词</strong>：P(x1, x2, …, xn)
，可以看成是以个体域为定义域，以{0,1}为值域的n元函数
<strong>一元谓词(n=1)</strong>——表示性质
<strong>多元谓词(n≥2)</strong>——表示事物之间的关系 如, L(x,y)：x与 y
有关系 L；G(x,y)：x≥y；…</p>
<p><strong>0元谓词</strong>——不含个体变项的谓词,
即命题常项或命题变项，<font color = "red">0元谓词是命题。任何命题均可以表示为0元谓词</font></p>
<h3 id="量词">量词</h3>
<p>定义：表示个体常项或变项之间数量关系的词</p>
<p><strong>全称量词∀</strong></p>
<p><strong>存在量词∃</strong></p>
<h2 id="一阶逻辑命题符号化-1">一阶逻辑命题符号化</h2>
<h3 id="元谓词">0元谓词</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401141229538.png" /></p>
<p>解析：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401143755193.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1h1421U7Yt/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e6175f817d342a0f111b3a39332ef34.jpg" /></p>
<hr style = "border:2px solid yellow;">
<h3 id="涉及到量词">涉及到量词</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 人都爱美 (2) 有人用左手写字
个体域分别为 (a) D为人类集合 (b) D为全总个体域</p>
<p>分析：</p>
<ol type="a">
<li></li>
</ol>
<ol type="1">
<li><p>∀xG(x), G(x)：x爱美</p></li>
<li><p>∃xG(x), G(x)：x用左手写字</p></li>
</ol>
<ol start="2" type="a">
<li></li>
</ol>
<p>F(x)：x为人，G(x)：x爱美</p>
<ol type="1">
<li><p>∀x(F(x) → G(x))</p></li>
<li><p>∃x(F(x) ∧ G(x))</p></li>
</ol>
<p><a
href="https://www.bilibili.com/video/BV1wp421y7QA/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/df718134d2f6c900f4199ab6ff090de.jpg" /></p>
<h3 id="多元变量的符号化">多元变量的符号化</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 正数都大于负数 (2)
有的无理数大于有的有理数</p>
<p><a href="">视频讲解</a></p>
<h3 id="带否定的命题符号化">带否定的命题符号化</h3>
<p>在一阶逻辑中将下面命题符号化 (1) 没有不呼吸的人 (2)
不是所有的人都喜欢吃糖</p>
<p><a
href="https://www.bilibili.com/video/BV1fx4y1a7Z1/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="顺序不能调换">顺序不能调换</h3>
<p>设个体域为实数域, 将下面命题符号化 (1)
对每一个数x都存在一个数y使得x&lt;y (2)
存在一个数x使得对每一个数y都有x&lt;y</p>
<p>分析：</p>
<p>解 L(x,y):x&lt;y</p>
<ol type="1">
<li><p>∀x∃yL(x,y)</p></li>
<li><p>∃x∀yL(x,y)</p></li>
</ol>
<h1 id="一阶逻辑公式及其解释">一阶逻辑公式及其解释</h1>
<h2 id="合式公式">合式公式</h2>
<p>合式公式定义如下： (1) 原子公式是合式公式. (2) 若A是合式公式，则
(¬A)也是合式公式 (3) 若A, B是合式公式，则(A∧B), (A∨B), (A→B),
(A↔︎B)也是合式公式 (4) 若A是合式公式，则∀xA, ∃xA也是合式公式 (5)
只有有限次地应用(1)—(4)形成的符号串才是合式公式.
合式公式也称为谓词公式，简称公式 如, F(x), F(x)∨¬G(x,y), ∀x(F(x)→G(x))
∃x∀y(F(x)→G(y)∧L(x,y))等都是合式公式</p>
<h2 id="封闭的公式">封闭的公式</h2>
<h3 id="指导变元和辖域">指导变元和辖域</h3>
<p>定义:在公式 ∀xA 和 ∃xA 中，称 x 为指导变元，A 为相应量词的辖域。在 ∀x
和 ∃x 的辖域中，x 的所有出现都称为约束出现，A
中不是约束出现的其他变项均称为是自由出现的。</p>
<p>举例：</p>
<p>例1：</p>
<p>∀x(F(x,y)→G(x,z))，x 为指导变元，(F(x,y)→G(x,z)) 为 ∀x 的辖域，x
的两次出现均为约束出现，y 与 z 均为自由出现。</p>
<p>例2：</p>
<p>∃x(F(x,y,z)→∀y(G(x,y)∧H(x,y,z)))，∃x 中的 x 是指导变元，辖域为
(F(x,y,z)→∀y(G(x,y)∧H(x,y,z)))。∀y 中的 y 是指导变元，辖域为
(G(x,y)∧H(x,y,z))。x 的 3 次出现都是约束出现，y
的第一次出现是自由出现，后 2 次是约束出现，z 的 2
次出现都是自由出现。</p>
<p><a
href="https://www.bilibili.com/video/BV1NZ421i7Ti/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="闭式">闭式</h3>
<p>定义4.6 若公式 A 中不含自由出现的个体变项，则称 A
为封闭的公式，简称闭式。</p>
<p>例如，∀x∀y(F(x)∧G(y)→H(x,y)) 为闭式，而 ∃x(F(x)∧G(x,y)) 不是闭式</p>
<h2 id="合式公式的解释">合式公式的解释</h2>
<p>说白了就是广义赋值</p>
<hr style = "border:2px solid yellow;">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401231018822.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Qp421C72h/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow;">
<h2 id="永真式矛盾式可满足式">永真式、矛盾式、可满足式</h2>
<ol type="1">
<li>闭式在任何解释下都是命题</li>
<li>若公式A在任何解释下均为真, 则称A为永真式(逻辑有效式).
若A在任何解释下均为假, 则称A为矛盾式(永假式). 若至少有一个解释使A为真,
则称A为可满足式.</li>
</ol>
<blockquote>
<p>注：</p>
<p>永真式为可满足式，但反之不真 判断公式是否是可满足的(永真式,
矛盾式)是不可判定的</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：判断公式类型</p>
<p><font color = "yellow">闭式只用假设前件真假来判断整个公式真假</font></p>
<p><font color = "yellow">非闭式需要找出具体假设</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0864a4cc957e2b8ccb38555953686ce.jpg" /></p>
<hr style = "border:2px solid yellow">
<h2 id="代换实例">代换实例</h2>
<p>说白了就是替换，将复杂的替换成简单的</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401231924387.png" /></p>
]]></content>
      <categories>
        <category>离散数学</category>
        <category>数理逻辑与集合论</category>
      </categories>
  </entry>
  <entry>
    <title>随机事件与概率</title>
    <url>/posts/becb01a7.html</url>
    <content><![CDATA[<h1 id="随机事件与概率">随机事件与概率</h1>
<h2 id="事件的关系与运算">事件的关系与运算</h2>
<h3 id="一关系">一：关系</h3>
<h4 id="包含">1 包含</h4>
<h4 id="相等">2 相等</h4>
<h4 id="相容ab-not-emptyset">3 相容：AB <span
class="math inline">\(\not=\)</span> <span
class="math inline">\(\emptyset\)</span></h4>
<h4 id="互斥ab-emptyset">4 互斥：AB = <span
class="math inline">\(\emptyset\)</span></h4>
<h4 id="对立overlinea">5 对立：<span
class="math inline">\(\overline{A}\)</span></h4>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210110051.jpg" /></p>
<h3 id="二运算">二：运算</h3>
<h4 id="运算类型">运算类型</h4>
<h5 id="并">1 并</h5>
<h5 id="交">2 交</h5>
<h5 id="差">3 差</h5>
<h5 id="section"><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210110517.jpg" /></h5>
<h4 id="运算律均只针对交并运算">运算律(均只针对交并运算)</h4>
<h5 id="吸收若asubsetb则abigcupb-b-abigcapb-a">1 吸收：若A<span
class="math inline">\(\subset\)</span>B,则A<span
class="math inline">\(\bigcup\)</span>B = B, A<span
class="math inline">\(\bigcap\)</span>B = A</h5>
<h5 id="交换">2 交换</h5>
<h5 id="结合">3 结合</h5>
<h5 id="分配">4 分配</h5>
<h5 id="德摩根长杠变短杠开口换方向">5
德摩根:长杠变短杠，开口换方向、</h5>
<h3 id="题型">题型</h3>
<h4 id="题型一判断命题是否成立">题型一：判断命题是否成立</h4>
<h5 id="法一画文氏图">法一：画文氏图</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231113154301.jpg" /></p>
<h5 id="法二公式推理">法二：公式推理</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231113154944.jpg" /></p>
<h4 id="题型二关于至少这个事件">题型二：关于“至少”这个事件</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231119152722.jpg" /></p>
<h5 id="ab中至少有一个发生leftrightarrowab">A，B中至少有一个发生<span
class="math inline">\(\Leftrightarrow\)</span>A∪B</h5>
<h5 id="a---b-aoverlineb-a---ab">A - B ↔︎ A<span
class="math inline">\(\overline{B}\)</span> ↔︎ A - AB</h5>
<h2 id="古典概型和几何概型">古典概型和几何概型</h2>
<h3 id="一-古典概型">一 古典概型</h3>
<h4
id="排列从n个元素中取出m个排成一列所有排列的个数-p第一个有n种取法第二个有n---1种取法第m个前面已经选了m---1个还剩n---m---1个所以有n---m-1种取法">1
排列：从n个元素中取出m个排成一列，所有排列的个数
P，第一个有n种取法，第二个有n - 1种取法……第m个,前面已经选了(m -
1)个，还剩n - (m - 1)个，所以有n - m + 1种取法</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210113017.jpg" /></p>
<h4
id="组合从n个元素里挑m个成一种组合因为m个元素有m中排列方式而组合只选择其中一种">2
组合：从n个元素里挑m个成一种组合，因为m个元素有m!中排列方式，而组合只选择其中一种</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210113408.jpg" /></p>
<h4 id="题型-1">3 题型</h4>
<h5 id="随机分配将n个质点放到n个盒子里">3.1
随机分配：将n个质点放到N个盒子里</h5>
<h6 id="盒子容量不限制每个质点有n个选择分法总数-nn">(1)
盒子容量不限制：每个质点有N个选择，分法总数 = n<sup>N</sup></h6>
<h6
id="盒子最多放一个第一个质点有n种选择第二个质点有n-1种选择最后一个前面已经选了n---1个盒子剩下n---n---1个盒子的选择即是pnm">(2)
盒子最多放一个：第一个质点有N种选择，第二个质点有N-1种选择，……最后一个前面已经选了n
- 1个盒子，剩下N - (n -
1)个盒子的选择，即是P<sub>n</sub><sup>m</sup></h6>
<h5 id="简单随机抽样从盒子n个里抽n个">3.2
简单随机抽样：从盒子N个里抽n个</h5>
<h6 id="有放回每次都有n个选择一共nn">(1)
有放回：每次都有N个选择，一共n<sup>N</sup></h6>
<h6
id="无放回第一次有n种选择第二次有n-1种选择最后一个前面已经选了n---1个剩下n---n---1个的选择即是pnm">(2)
无放回：第一次有N种选择，第二次有N-1种选择，……最后一个前面已经选了n -
1个，剩下N - (n - 1)个的选择，即是P<sub>n</sub><sup>m</sup></h6>
<h6 id="一口气取无放回的是排列一口气取的是组合">(3)
一口气取：无放回的是排列，一口气取的是组合</h6>
<h3 id="二-几何概型常见面积问题">二 几何概型：常见面积问题</h3>
<h2 id="概率的基本性质与公式">概率的基本性质与公式</h2>
<h3 id="一-性质">一 性质</h3>
<h4 id="有界性任何一个时间的概率在010与1都能取得到">1
有界性：任何一个时间的概率在0~1(0与1都能取得到)</h4>
<h4 id="单调性若asubsetb则pb--a-pb---pa">2 单调性：若A<span
class="math inline">\(\subset\)</span>B,则P(B- A) = P(B) - P(A)</h4>
<h4 id="逆概率公式poverlinea-1---pa">3 逆概率公式：P(<span
class="math inline">\(\overline{A}\)</span>) = 1 - P(A)</h4>
<h3 id="二-公式">二 公式</h3>
<h4
id="加法公式多个字母的并事件奇数个字母前面是正号偶数个字母前面是负号然后组合排列出所有情况">1
加法公式(多个字母的并事件)：奇数个字母前面是正号，偶数个字母前面是负号，然后组合排列出所有情况</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150120.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210150328.jpg" /></p>
<h4 id="减法公式pa---b-pa---pab">2 减法公式：P(A - B) = P(A) -
P(AB)</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210141229.jpg" /></p>
<p>题型： (1) 常在AB 和 A<span
class="math inline">\(\bigcup\)</span>B上做文章</p>
<ol start="2" type="1">
<li>前面公式要熟记</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210144150.jpg" /></p>
<figure>
<img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\微信图片_20231210144201.jpg"
alt="微信图片_20231210144201" />
<figcaption aria-hidden="true">微信图片_20231210144201</figcaption>
</figure>
<h4 id="条件概率公式">3 条件概率公式</h4>
<h4 id="全概率公式由因推果多重因素ai导致事件b发生求事件b发生的概率">4
全概率公式(由因推果，多重因素A<sub>i</sub>导致事件B发生，求事件B发生的概率)</h4>
<h5 id="完备事件组的全集分解">4.1 完备事件组的全集分解</h5>
<h5 id="加法公式的互斥">4.2 加法公式的互斥</h5>
<h5 id="条件概率公式-1">4.3 条件概率公式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210141537.jpg" /></p>
<p>举例：</p>
<p>嵌套：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210153433.jpg" /></p>
<h4 id="贝叶斯公式由果索因已知事件b发生求是因素ai导致其发生的概率">5
贝叶斯公式(由果索因，已知事件B发生，求是因素A<sub>i</sub>导致其发生的概率)</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210142447.jpg" /></p>
<p>举例：</p>
<p>结合全概率公式使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210154248.jpg" /></p>
<h2 id="事件的独立性">事件的独立性</h2>
<h3 id="两两独立与相互独立">两两独立与相互独立</h3>
<h4 id="定义">定义</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210155554.jpg" />
题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210155705.jpg" /></p>
<h4
id="性质如果若干个事件相互独立则其中一部分事件与另一部分事件的运算生成的新事件与另一部分事件运算生成的新事件仍然相互独立">性质：如果若干个事件相互独立，则其中一部分事件与另一部分事件的运算生成的新事件与另一部分事件运算生成的新事件仍然相互独立</h4>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210163747.jpg" /></p>
<p>​</p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章：大数定律与中心极限定理</title>
    <url>/posts/c0910902.html</url>
    <content><![CDATA[<h1 id="大数定律与中心极限定理">大数定律与中心极限定理</h1>
<span id="more"></span>
<h2 id="一依概率收敛">(一）依概率收敛</h2>
<h3 id="一定义">一：定义</h3>
<h4
id="鬼话forall-epsilon-0-exist-n-0-当n-n时-有lim_n-to-inftypleftx_n-a-epsilonright-1则称x_n依概率收敛于a">鬼话：<span
class="math inline">\(\forall \epsilon &gt; 0, \exist N &gt; 0, 当n &gt;
N时, 有\lim_{n \to \infty}P\left\{|X_n-a| &lt; \epsilon\right\} =
1,则称X_n依概率收敛于a\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126134818.jpg" /></p>
<h4 id="人话形容一列数x_n到点a的距离很近极限状态下概率是1">人话：<span
class="math inline">\(形容一列数X_n到点a的距离很近，极限状态下概率是1\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126134851.jpg" /></p>
<h3
id="题型证明一个随机变量序列收敛">题型：证明一个随机变量序列收敛</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140719.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140649.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126140824.jpg" /></p>
<h4 id="方法">方法</h4>
<h5 id="构造xn到一个数的距离小于ε">1 构造Xn到一个数的距离小于ε</h5>
<h5 id="对上面构造的求极限一般会向切比雪夫不等式靠近">2
对上面构造的求极限，一般会向切比雪夫不等式靠近</h5>
<h2 id="二大数定律">(二)大数定律</h2>
<h3 id="切比雪夫">1 切比雪夫</h3>
<h4 id="条件">条件</h4>
<h5 id="变量序列相互独立">(1) 变量序列相互独立</h5>
<h5 id="变量序列的方差存在且有上界">(2) 变量序列的方差存在且有上界</h5>
<h4
id="结论-frac1n-sum_i1n-x_i-oversetprightarrow-frac1nsum_i1nex_i-这堆变量序列的均值最终依概率收敛到这堆变量序列的期望们的均值">结论
<span class="math inline">\(\frac{1}{n} \sum_{i=1}^n X_i
\overset{P}{\rightarrow} \frac{1}{n}\sum_{i=1}^{n}E(X_i)\)</span> ,
这堆变量序列的均值最终依概率收敛到这堆变量序列的期望们的均值</h4>
<h3 id="辛钦">2 辛钦</h3>
<h4 id="条件-1">条件</h4>
<h5 id="独立">(1) 独立</h5>
<h5 id="同分布">(2) 同分布</h5>
<h5 id="期望存在">(3) 期望存在</h5>
<h4
id="结论-frac1nsum_i1nx_i-frac1nsum_i1nex_i-frac1nnu-u-与切比雪夫结论类似不过因为同分布所以ex_i一样">结论
<span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}X_i =
\frac{1}{n}\sum_{i=1}^{n}E(X_i) = \frac{1}{n}nu = u\)</span>,
与切比雪夫结论类似，不过因为同分布所以<span
class="math inline">\(E(X_i)一样\)</span></h4>
<h2 id="三-中心极限定理">(三) 中心极限定理</h2>
<h3 id="条件-2">条件</h3>
<h4 id="xi独立同分布于某种类型的分布">(1)
Xi独立同分布于某种类型的分布</h4>
<h4 id="xi的期望和方差都存在分别设期望是u方差是σ2">(2)
Xi的期望和方差都存在，分别设期望是u，方差是σ^2</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144358.jpg" /></p>
<h3
id="结论对xi求和再取极限n-就趋向于正态分布nnsigma-nsigma2">结论：对Xi求和再取极限(n-&gt;∞)就趋向于正态分布<span
class="math inline">\(N(n\sigma, n\sigma^2)\)</span></h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144404.jpg" /></p>
<h3 id="标准化的结论">标准化的结论</h3>
<h4 id="fracsum_i1nx_i-nsigmasqrtnsigma-sim-n0-1">1 <span
class="math inline">\(\frac{(\sum_{i=1}^{n}X_i)-n\sigma}{\sqrt{n}\sigma}
\sim N(0, 1)\)</span></h4>
<h4
id="lim_nrightarrowinftypleftfracsum_i1nx_i-nsigmasqrtnsigma-leq-xright-phix">2
<span
class="math inline">\(\lim_{n\rightarrow\infty}P\left\{\frac{(\sum_{i=1}^{n}X_i)-n\sigma}{\sqrt{n}\sigma}
\leq x\right\} = \Phi{(x)}\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231126144407.jpg" /></p>
<p>对于二项分布来说，其实每一次是一个0-1分布，所以均值是0-1分布的均值而不是二项分布的均值</p>
<h3 id="题型求一个范围ab的概率">题型：求一个范围A~B的概率</h3>
<h4 id="看一次取样满足于什么分布">1 看一次取样满足于什么分布</h4>
<h4 id="求这种分布的均值u和方差σ">2 求这种分布的均值u和方差σ</h4>
<h4 id="看取了几次样作为n得到近似正态分布nnu-nσ2">3
看取了几次样，作为n，得到近似正态分布<span class="math inline">\(N(nu,
nσ^2)\)</span></h4>
<h4 id="ab的概率就是φfracb-nuσ---φfraca-nuσ">4 A~B的概率就是<span
class="math inline">\(Φ(\frac{B-nu}{σ}) -
Φ(\frac{A-nu}{σ})\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214163043.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章：多维随机变量及其分布</title>
    <url>/posts/d1c25b21.html</url>
    <content><![CDATA[<h1 id="多维随机变量及其分布">多维随机变量及其分布</h1>
<span id="more"></span>
<h2 id="一-二维随机变量">(一) 二维随机变量</h2>
<h3 id="概念">1 概念</h3>
<h3 id="联合分布函数如果说之前一维积分是面积那这里二维积分就是体积">2
联合分布函数(如果说之前一维积分是面积，那这里二维积分就是体积)</h3>
<h4 id="概念fx-y-px-leq-x-y-leq-y">2.1 概念:F(x, y) = P{X <span
class="math inline">\(\leq\)</span> x, Y <span
class="math inline">\(\leq\)</span> y}</h4>
<h4 id="性质">2.2 性质</h4>
<h5 id="单调性固定一个看另一个">(1) 单调性(固定一个，看另一个)</h5>
<h5 id="右连续性固定一个看另一个">(2) 右连续性(固定一个，看另一个)</h5>
<h5 id="有界性全体积为1">(3) 有界性(全体积为1)</h5>
<h5 id="非负性下面这个公式重点根据旁边的图理解是如何计算的">(4)
非负性(下面这个公式重点根据旁边的图理解是如何计算的)</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211153025.jpg" /></p>
<h3 id="边缘分布函数求哪一个保留哪一个另一个极限取到无穷">3
边缘分布函数(求哪一个，保留哪一个，另一个极限取到无穷)</h3>
<h4 id="f_xx-fx-infty"><span class="math inline">\(F_X(x) = F(x,
+\infty)\)</span></h4>
<h4 id="f_yy-finfty-y"><span class="math inline">\(F_Y(y) = F(+\infty,
y)\)</span></h4>
<h2 id="二-二维离散型随机变量">(二) 二维离散型随机变量</h2>
<h3 id="联合分布律">1 联合分布律</h3>
<h3 id="边缘分布律">2 边缘分布律</h3>
<h3 id="条件分布律">3 条件分布律</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211153837.jpg" /></p>
<h3 id="独立性forall-i-j-p_ij-p_i.p_j.-longleftrightarrow-x-y相互对立">4
独立性：<span class="math inline">\(\forall\ i, j, P_{ij} = P_i.P_j.
\Longleftrightarrow X, Y相互对立\)</span></h3>
<h2 id="三-二维连续型随机变量">(三) 二维连续型随机变量</h2>
<h3 id="概率密度">1 概率密度</h3>
<h4 id="联合概率密度fx-y">1.1 联合概率密度：f(x, y)</h4>
<h4
id="边缘概率密度求谁不积谁不积先定限限内画条线先交取下限后交取上限">1.2
边缘概率密度：求谁不积谁，不积先定限，限内画条线，先交取下限，后交取上限</h4>
<h5
id="f_xx-int_-inftyinftyfx-ydy表示的几何意义是求沿x-x对几何体切一刀得到的切片面积关键是要求y的积分范围方法是求谁不积谁限内画条线先交取下限后交取上限"><span
class="math inline">\(f_X(x) = \int_{-\infty}^{+\infty}f(x,
y)\,dy\)</span>(表示的几何意义是求沿X =
x对几何体切一刀得到的切片面积，关键是要求y的积分范围，方法是求谁不积谁，限内画条线，先交取下限，后交取上限)</h5>
<h5 id="f_yy-int_-inftyinftyfx-ydx"><span class="math inline">\(f_Y(y) =
\int_{-\infty}^{+\infty}f(x, y)\,dx\)</span></h5>
<h3 id="分布函数">2 分布函数</h3>
<h4
id="联合分布函数fx-y-px-leq-x-y-leq-y-int_-inftyy-int_inftyxfu-v-dudv">2.1
联合分布函数：F(x, y) = P{X <span class="math inline">\(\leq\)</span> x,
Y <span class="math inline">\(\leq\)</span> y} = <span
class="math inline">\(\int_{-\infty}^{y} \int_{\infty}^{x}f(u, v)\,
dudv\)</span></h4>
<h4 id="边缘分布函数">2.2 边缘分布函数</h4>
<h5 id="已知联合概率密度fx-y">已知联合概率密度<span
class="math inline">\(f(x, y)\)</span></h5>
<h6
id="f_xx-int_-inftyxf_xt-dt-int_-inftyxint_-inftyinftyfu-vdudv"><span
class="math inline">\(F_X(x) = \int_{-\infty}^xf_X(t)\, dt =
\int_{-\infty}^{x}[\int_{-\infty}^{+\infty}f(u, v)du]dv\)</span></h6>
<h6
id="f_yy-int_-inftyyf_yt-dt-int_-inftyyint_-inftyinftyfu-vdvdu"><span
class="math inline">\(F_Y(y) = \int_{-\infty}^yf_Y(t)\, dt =
\int_{-\infty}^{y}[\int_{-\infty}^{+\infty}f(u, v)dv]du\)</span></h6>
<h5
id="已知联合分布函数fx-y不用积分了取极限到无穷就行">已知联合分布函数<span
class="math inline">\(F(x,
y)\)</span>(不用积分了！取极限到无穷就行)</h5>
<h6 id="f_xx-fx-infty-1"><span class="math inline">\(F_X(x) = F(x,
+\infty)\)</span></h6>
<h6 id="f_yy-finfty-y-1"><span class="math inline">\(F_Y(y) = F(+\infty,
y)\)</span></h6>
<h4 id="与概率密度关系">2.3 与概率密度关系</h4>
<h5
id="联合-联合分布函数fx-y求两次偏导就可以得到联合概率密度fx-y-fx-y求二重积分就可以得到fx-y">2.3.1
联合 ：联合分布函数F(x, y)求两次偏导就可以得到联合概率密度f(x, y), f(x,
y)求二重积分就可以得到F(x, y)</h5>
<h5 id="边缘边沿分布函数f_xx和边缘概率密度f_xx不存在这种关系y同理">2.3.2
边缘：<span
class="math inline">\(边沿分布函数F_X(x)和边缘概率密度f_X(x)不存在这种关系,Y同理\)</span></h5>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212113847.jpg" /></p>
<h3 id="条件条件-frac联合边缘">3 条件：<span class="math inline">\(条件
= \frac{联合}{边缘}\)</span></h3>
<h4 id="条件概率密度">3.1 条件概率密度</h4>
<h5 id="f_yxyx-fracfx-yf_xx"><span class="math inline">\(f_{Y|X}(y|x) =
\frac{f(x, y)}{f_{X}(x)}\)</span></h5>
<h5 id="f_xyxy-fracfx-yf_yy"><span class="math inline">\(f_{X|Y}(x|y) =
\frac{f(x, y)}{f_{Y}(y)}\)</span></h5>
<h4
id="条件分布函数哪个是条件哪个保留积另外一个以f_yxyx为例因为叫在x-x条件下的条件分布函数所以是对y积分">3.2
条件分布函数：哪个是条件，哪个保留，积另外一个，以<span
class="math inline">\(F_{Y|X}(y|x)\)</span>为例，因为叫在X =
x条件下的条件分布函数，所以是对y积分</h4>
<h5 id="f_yxyx-int_-inftyyf_yxyxdy"><span
class="math inline">\(F_{Y|X}(y|x) =
\int_{-\infty}^{y}f_{Y|X}(y|x)dy\)</span></h5>
<h5 id="f_xyxy-int_-inftyxf_xyxydx"><span
class="math inline">\(F_{X|Y}(x|y) =
\int_{-\infty}^{x}f_{X|Y}(x|y)dx\)</span></h5>
<p>举个例子</p>
<h3 id="独立性">4 独立性：</h3>
<h4 id="从概率密度角度fx-y-f_xxf_yy">4.1 从概率密度角度：<span
class="math inline">\(f(x, y) = f_{X}(x)f_{Y}(y)\)</span></h4>
<h4 id="从分布函数角度fx-y-f_xxf_yy">4.2 从分布函数角度：<span
class="math inline">\(F(X, Y) = F_X(x)F_Y(y)\)</span></h4>
<p>举个例子，也涉及概率密度与分布函数关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212113501.jpg" /></p>
<h4
id="相互独立随机变量函数的分布及卷积公式积谁不换谁换完求偏导加绝对值如果独立进一步拆分">4.3
相互独立随机变量函数的分布及卷积公式：积谁不换谁，换完求偏导加绝对值,如果独立，进一步拆分</h4>
<p>设(X, Y)~f(x, y)</p>
<h5
id="和的分布z-x-y的概率密度f_zz-int_-inftyinftyfx-z-xdx换成y同理进一步如果x与y相互独立f_zz-int_-inftyinftyfx-z-xdx-int_-inftyinftyf_xxf_yz-xdx">(1)
和的分布:Z = X + Y的概率密度<span class="math inline">\(f_Z(z) =
\int_{-\infty}^{+\infty}f(x,
z-x)dx\)</span>(换成y同理)，进一步如果X与Y相互独立,<span
class="math inline">\(f_Z(z) = \int_{-\infty}^{+\infty}f(x, z-x)dx =
\int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx\)</span></h5>
<h5 id="差的分布">(2) 差的分布</h5>
<h5 id="积的分布">(3) 积的分布</h5>
<h5 id="商的分布">(4) 商的分布</h5>
<h5 id="maxx-y的分布">(5) max{X, Y}的分布</h5>
<h5 id="minx-y的分布">(6) min{X, Y}的分布</h5>
<h3 id="两个常见的二维连续分布">5 两个常见的二维连续分布</h3>
<h4 id="二维均匀分布">5.1 二维均匀分布</h4>
<h4 id="二维正态分布这个有大问题">5.2 二维正态分布(这个有大问题)</h4>
<p>概念</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114137.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114147.jpg" /></p>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211204826.jpg" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212114251.jpg"
alt="微信图片_20231212114251" />
<figcaption aria-hidden="true">微信图片_20231212114251</figcaption>
</figure>
<h2 id="四-经典题型">(四) 经典题型：</h2>
<h3 id="求二维随机变量在限制条件下概率">1
求二维随机变量在限制条件下概率</h3>
<h4
id="二维随机变量相互独立常见于两个相互独立的正态分布直接将限制条件转换成一个新函数">1.1
二维随机变量相互独立,常见于两个相互独立的正态分布，直接将限制条件转换成一个新函数</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214140814.jpg" /></p>
<h4 id="二维随机变量独立性未知只知fx-y">1.2
二维随机变量独立性未知，只知f(x, y)</h4>
<h5 id="找出正概率区间">1.2.1 找出正概率区间</h5>
<h5 id="画出正概率区间与限定区间的交集">1.2.2
画出正概率区间与限定区间的交集</h5>
<h5 id="计算二重积分或求和">1.2.3 计算二重积分或求和</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212160900.jpg" /></p>
<h3 id="二维复合成一维z-fx-y求复合后的概率密度">2 二维复合成一维(Z =
F(X, Y))，求复合后的概率密度</h3>
<h4 id="连续-连续">2.1连续-连续</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212171443.jpg" /></p>
<h5 id="法一">法一：</h5>
<h6 id="求联合概率密度">1 求联合概率密度</h6>
<h6
id="通过代入定义f_zz-pleftz-leq-zright-pleftfx-y-leq-zright转换成前面求限制条件下概率问题">2
通过代入定义<span class="math inline">\(F_Z(z) = P\left\{Z \leq
z\right\} = P\left\{F(X, Y) \leq
z\right\}\)</span>转换成前面求限制条件下概率问题</h6>
<h6 id="通过分布函数求概率密度">3 通过分布函数求概率密度</h6>
<h5 id="法二如果已知xy相互独立">法二：如果已知x，y相互独立</h5>
<h6
id="求联合概率密度fx-y没讲独立直接将x-z---x代入fx-y即可讲独立就可以不用求fx-y">1
求联合概率密度f(x, y)(没讲独立，直接将x， z - x代入f(x,
y)即可，讲独立，就可以不用求f(x, y))</h6>
<h6 id="积谁不换谁换完求偏导加绝对值">2
积谁不换谁，换完求偏导加绝对值</h6>
<h6
id="确定被积函数fx-z---x确定x的范围再通过y的范围经过还原确定z的范围">3
确定被积函数f(x, z -
x)，确定x的范围，再通过y的范围经过还原确定z的范围</h6>
<h6 id="以x为横轴z为纵轴作图以z为横线讨论z的范围求fz">4
以x为横轴，z为纵轴作图，以z为横线讨论z的范围求f(z)</h6>
<h4 id="连续-离散">2.2 连续-离散</h4>
<h5 id="全概率公式分解">1 全概率公式分解</h5>
<h5 id="条件公式分解">2 条件公式分解</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231212144542.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>一维随机变量及其分布</title>
    <url>/posts/4583997a.html</url>
    <content><![CDATA[<h1 id="一维随机变量及其分布">一维随机变量及其分布</h1>
<h2 id="一-一维随机变量分布函数">(一) 一维随机变量分布函数</h2>
<h3 id="概念fx-px-leqx">1 概念：F(x) = P{X <span
class="math inline">\(\leq\)</span>x}</h3>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211140411.jpg" /></p>
<p>注意求X的分布函数，F(x) = P{X <span
class="math inline">\(\leq\)</span> x} = <span
class="math inline">\(\int_{\infty}^{x} f(x)\,
dx\)</span>(因为这里是连续型)</p>
<h3 id="性质">2 性质</h3>
<h4 id="单调不减">2.1 单调不减</h4>
<h4 id="右连续">2.2 右连续</h4>
<h4 id="向负无穷取极限是0想正无穷取极限是1">2.3
向负无穷取极限是0，想正无穷取极限是1</h4>
<span id="more"></span>
<h3 id="应用求概率">3 应用：求概率</h3>
<h4 id="px-leq-a-fa">3.1 P{X <span class="math inline">\(\leq\)</span>
a} = F(a)</h4>
<h4 id="px-a-fa---0左极限">3.2 P{X &lt; a} = F(a - 0)(左极限)</h4>
<h4 id="px-a-fa---fa---0">3.3 P{X = a} = F(a) - F(a - 0)</h4>
<h2 id="二-一维离散型">(二) 一维离散型</h2>
<h3
id="分布律将每一个正概率点不一定值是正而是对应概率值是正的点-与其对应的概率做成表格">1
分布律：将每一个正概率点(不一定值是正，而是对应概率值是正的点)
与其对应的概率做成表格</h3>
<h4 id="第一行每个正概率点的值">第一行：每个正概率点的值</h4>
<h4
id="第二行每个正概率点对应的概率">第二行：每个正概率点对应的概率</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210173027.jpg" /></p>
<h3 id="分布函数fx对所有小于x的正概率点求和常成阶梯状">2
分布函数F(x)：对所有小于x的正概率点求和，常成阶梯状</h3>
<h3 id="应用求概率说白了就是将区域内所有正概率点求和比如求pa-x-b">3
应用：求概率，说白了就是将区域内所有正概率点求和，比如求P{a &lt; X &lt;
b}</h3>
<h4
id="从分布律角度就是将ab范围内所有正概率点求和">从分布律角度，就是将a~b范围内所有正概率点求和</h4>
<h4 id="从分布函数角度就是fb---0---fa">从分布函数角度，就是F(b - 0) -
F(a)</h4>
<h3 id="常见分布">4 常见分布</h3>
<h4 id="n重伯努利分布n-p">4.1 n重伯努利分布(n, p)</h4>
<h5 id="n重复实验次数">n：重复实验次数</h5>
<h5
id="p一次实验中成功的概率每次实验只有两种结果">p：一次实验中成功的概率(每次实验只有两种结果)</h5>
<h5 id="分布律">分布律</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210174402.jpg" /></p>
<h5
id="n重伯努利分布里几种特殊的分布">n重伯努利分布里几种特殊的分布</h5>
<h6 id="分布就取1次">(1) 0 - 1分布：就取1次</h6>
<h6 id="几何分布前n---1次都没中第n次中">(2) 几何分布：前(n -
1)次都没中，第n次中</h6>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210190359.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191058.jpg" /></p>
<h4
id="超几何分布好的坏的混在一起一共有n个其中好的有m个取n个n个里面有k个好的n---k个坏的">4.2
超几何分布：好的坏的混在一起，一共有N个，其中好的有M个，取n个，n个里面有k个好的，(n
- k)个坏的</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191123.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191326.jpg" /></p>
<h4 id="泊松分布">4.3 泊松分布</h4>
<h5 id="公式">公式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210191417.jpg" /></p>
<h5 id="性质-lambda-np">性质 <span
class="math inline">\(\lambda\)</span> = np</h5>
<h5 id="section"></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211072246.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211072409.jpg" /></p>
<p>上面这道题计算要用到<span class="math inline">\(\lambda\)</span> =
np</p>
<h2 id="三-一维连续型">(三) 一维连续型</h2>
<h3 id="概率密度fx">1 概率密度f(x)</h3>
<h3 id="分布函数fx-pleftxleq-x-right-int_-inftyx-fx-dx">2 分布函数：F(x)
= <span class="math inline">\(P\left\{X\leq\ x \right\} =
\int_{-\infty}^{x} f(x)\, dx\)</span></h3>
<h3 id="应用求概率说白了就是对在指定区域的fx求积分">3
应用：求概率,说白了就是对在指定区域的f(x)求积分</h3>
<h3 id="主要分布">4 主要分布</h3>
<h4 id="均匀分布ua-b">4.1 均匀分布U(a, b)</h4>
<h5 id="概率密度">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210192914.jpg" /></p>
<h5 id="分布函数">分布函数</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210192947.jpg" /></p>
<h4 id="指数分布elambda指数分布具有无记忆性">4.2 指数分布E(<span
class="math inline">\(\lambda\)</span>)(指数分布具有无记忆性)</h4>
<h5 id="概率密度-1">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193254.jpg" /></p>
<h5 id="分布函数-1">分布函数</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193311.jpg" /></p>
<p>题型：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210210012.jpg" /></p>
<h4 id="正态分布nu-σ2">4.3 正态分布N(u, σ<sup>2</sup>)</h4>
<h5 id="概率密度-2">概率密度</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193522.jpg" /></p>
<h5
id="上alpha分位数ualpha使点alpha右侧φ的面积是alpha计算出alpha右侧面积就是下标alpha">上<span
class="math inline">\(\alpha\)</span>分位数u<sub><span
class="math inline">\(\alpha\)</span></sub>：使点<span
class="math inline">\(\alpha\)</span>右侧φ的面积是<span
class="math inline">\(\alpha\)</span>,计算出<span
class="math inline">\(\alpha\)</span>右侧面积就是下标<span
class="math inline">\(\alpha\)</span></h5>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210211242.jpg" /></p>
<h5 id="标准正态分布n0-1">标准正态分布N(0, 1)</h5>
<h6 id="概率密度phix">概率密度<span
class="math inline">\(\phi\)</span>(x)</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210193854.jpg" /></p>
<h6
id="分布函数只用记住是phix就行性质围绕其奇偶性展开">分布函数：只用记住是<span
class="math inline">\(\Phi\)</span>(x)就行，性质围绕其奇偶性展开</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210194320.jpg" /></p>
<h5
id="标准化所有有关正态分布不等式的判别都要标准化">标准化(所有有关正态分布不等式的判别都要标准化)</h5>
<p>题型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210210747.jpg" /></p>
<h6 id="换元标准化">换元标准化</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231210195631.jpg" /></p>
<h6 id="性质-1">性质</h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%A4%B1%E8%B4%A51.jpg" /></p>
<h2
id="四-典型题型一维随机变量函数的分布已知一种随机变量的概率分布fx通过某种函数变换得到另一种函数y-求fy的概率分布">(四)
典型题型：一维随机变量函数的分布，已知一种随机变量的概率分布f(x)，通过某种函数变换得到另一种函数Y,
求f(y)的概率分布</h2>
<h3 id="根据函数变换y-gx得y-gx代入x的范围得到y的范围作为y的定义域">1
根据函数变换Y = g(X)得y = g(x)，代入x的范围得到y的范围作为Y的定义域</h3>
<h3 id="求出fx的分布函数">2 求出F(x)的分布函数</h3>
<h3
id="利用定义fy-pyleqy将y用x代入转化为px-leqhy后将hy代入fx得到fhy和定义域因为fx一般是分段函数所以也要将hy代入到分段的定义域里得到新的分段定义域">3
利用定义F(y) = P{Y<span
class="math inline">\(\leq\)</span>y}，将Y用X代入，转化为P{X <span
class="math inline">\(\leq\)</span>h(y)}后将h(y)代入F(X)得到F(h(y))和定义域(因为F(x)一般是分段函数，所以也要将h(y)代入到分段的定义域里得到新的分段定义域)</h3>
<h3 id="对fy求导得到概率分布fy">4 对F(y)求导得到概率分布f(y)</h3>
<p>开胃小菜</p>
<figure>
<img src="E:\Daershang\概率论\笔记\图片\微信图片_20231119171115.jpg"
alt="微信图片_20231119171115" />
<figcaption aria-hidden="true">微信图片_20231119171115</figcaption>
</figure>
<p>难度加强</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231211144008.jpg"
alt="微信图片_20231211144008" />
<figcaption aria-hidden="true">微信图片_20231211144008</figcaption>
</figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%A4%B1%E8%B4%A52.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章：数理统计</title>
    <url>/posts/29760bc5.html</url>
    <content><![CDATA[<h1 id="数理统计">数理统计</h1>
<span id="more"></span>
<h2 id="总体与样本">总体与样本</h2>
<h3 id="总体研究对象全体">总体：研究对象全体</h3>
<h3 id="样本">样本：</h3>
<h4 id="n个没有抽样的x_ii1-2-n">1 n个(没有抽样)的<span
class="math inline">\(X_i(i=1, 2, ……, n)\)</span></h4>
<h4 id="相互独立且同分布于某个随机变量x">2
相互独立且同分布于某个随机变量X</h4>
<h4
id="组成的整体x_1-x_2-x_n-叫做一个样本一次抽样结果的n个具体数值x_1-x_2-x_n叫做这个样本的观测值">3
组成的整体<span class="math inline">\((X_1, X_2, ……，X_n)\)</span>
叫做一个样本，一次抽样结果的n个具体数值<span class="math inline">\((x_1,
x_2, ……， x_n)\)</span>叫做这个样本的观测值</h4>
<h3
id="样本的分布如果样本x_1-x_2-x_n服从的x的分布函数是fx则fx_1-x_2-x_n-prod_i1nfx_i理解上就是相互独立所以可以拆分另外什么概率密度分布律类似">样本的分布：如果样本<span
class="math inline">\((X_1, X_2, ……，
X_n)\)</span>服从的X的分布函数是F(x)，则<span
class="math inline">\(F(x_1, x_2, x_n) =
\prod_{i=1}^nF(x_i)\)</span>(理解上就是相互独立所以可以拆分，另外什么概率密度，分布律类似)</h3>
<p>举个例子</p>
<p>离散型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216120104.jpg" /></p>
<p>连续型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216120917.jpg" /></p>
<h2 id="统计量及其分布">统计量及其分布</h2>
<h3 id="统计量">统计量</h3>
<h4 id="样本数字特征">1 样本数字特征</h4>
<h5 id="样本均值-overlinex-frac1nsum_i1nx_i">样本均值： <span
class="math inline">\(\overline{X} =
\frac{1}{n}\sum_{i=1}^{n}X_i\)</span></h5>
<h5
id="样本方差标准差s2-frac1n-1sum_i1nx_i-overline-x2-s-sqrtfrac1n-1sum_i1nx_i-overline-x2">样本方差，标准差：<span
class="math inline">\(S^2 = \frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline
X)^2\)</span>， <span class="math inline">\(S =
\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline X)^2}\)</span></h5>
<h5 id="样本k阶原点矩-a_k-frac1nsum_i1nx_ikk-1-2">样本k阶原点矩： <span
class="math inline">\(A_k = \frac{1}{n}\sum_{i=1}^{n}X_i^k(k = 1, 2,
……)\)</span></h5>
<h5 id="样本k阶中心矩-b_k-frac1nsum_i1nx_i-overlinexk">样本k阶中心矩：
<span class="math inline">\(B_k =
\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k\)</span></h5>
<h4 id="顺序统计量">2 顺序统计量</h4>
<h5 id="最大顺序统计量x_n-maxleftx_1-x_2-x_nright">最大顺序统计量：<span
class="math inline">\(X_(n) = max\left\{X_1, X_2,……，
X_n\right\}\)</span></h5>
<h6 id="分布函数f_nx-fxn">分布函数：<span
class="math inline">\(F_{(n)}(x) = [F(x)]^n\)</span></h6>
<h6
id="概率密度f_nx-nfxn-1fx对上面f求导注意是复合函数求导">概率密度：<span
class="math inline">\(f_(n)(x) =
n[F(x)]^{n-1}f(x)\)</span>(对上面F求导，注意是复合函数求导)</h6>
<h5 id="最小顺序统计量x_1minleftx_1-x_2-x_nright">最小顺序统计量：<span
class="math inline">\(X_{(1)}=min\left\{X_1, X_2,
……X_n\right\}\)</span></h5>
<h6 id="分布函数f_1x-1-1-fxn">分布函数：<span
class="math inline">\(F_{(1)}(x) = 1-[1-F(x)]^n\)</span></h6>
<h6 id="概率密度f_1x-n1-fxn-1fx">概率密度：<span
class="math inline">\(f_{(1)}(x) = n[1-F(x)]^{n-1}f(x)\)</span></h6>
<h4 id="性质设总体exmudx-sigma2">3 性质(<span
class="math inline">\(设总体E(X)=\mu,D(X) = \sigma^2\)</span>)</h4>
<h5 id="x_i的期望与方差"><span
class="math inline">\(X_i的期望与方差\)</span></h5>
<h6 id="ex_i-mu"><span class="math inline">\(E(X_i) = \mu\)</span></h6>
<h6 id="dx_i-sigma2"><span class="math inline">\(D(X_i) =
\sigma^2\)</span></h6>
<h5 id="overlinex的期望与方差"><span
class="math inline">\(\overline{X}的期望与方差\)</span></h5>
<h6 id="eoverlinex-ex-mu"><span class="math inline">\(E(\overline{X}) =
E(X) = \mu\)</span></h6>
<h6 id="doverlinex-fracsigma2n"><span
class="math inline">\(D(\overline{X}) = \frac{\sigma^2}{n}\)</span></h6>
<h5 id="s2"><span class="math inline">\(S^2\)</span></h5>
<h6 id="es2-dx-sigma2"><span class="math inline">\(E(S^2) = D(X) =
\sigma^2\)</span></h6>
<h3 id="三大分布">三大分布</h3>
<h4 id="chi2分布">1 <span class="math inline">\(\chi^2分布\)</span></h4>
<h5 id="定义-x_i独立同分布于n0-1x-_i-1nx_i2-2n">1.1 定义：$
X_i独立同分布于N(0, 1)，X = _{i = 1}<sup>{n}X_{i}</sup>2 ^2(n)$</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214194907.jpg" /></p>
<h5 id="性质">1.2 性质：</h5>
<h6
id="若x_1-sim-chi2n_1-x_2-sim-chi2n_2-x_1与x_2相互独立则x_1-x_2-sim-chi2n_1n_2">(1)
<span class="math inline">\(若X_1 \sim \chi^2(n_1), X_2 \sim
\chi^2(n_2), X_1与X_2相互独立，则X_1 + X_2 \sim
\chi^{2}(n_1+n_2)\)</span></h6>
<h6 id="若xsim-chi2nexn-dx2n">(2) <span class="math inline">\(若X\sim
\chi^2(n),E(X)=n, D(X)=2n\)</span></h6>
<h4 id="t分布">2 t分布</h4>
<h5
id="定义xsim-n0-1-ysim-chi2n-x与y相互独立t-fracxsqrtfracyn-sim-tn">2.1
定义：<span class="math inline">\(X\sim N(0, 1), Y\sim \chi^2(n),
X与Y相互独立，t = \frac{X}{\sqrt{\frac{Y}{N}}} \sim t(n)\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214195812.jpg" /></p>
<h5
id="性质-图形关于y轴对称所以t_alphan这个点右侧面积是alpha--t_1-alphan这个点右侧面积是1-alpha">2.2
性质: <span
class="math inline">\(图形关于y轴对称，所以t_{\alpha}(n)(这个点右侧面积是\alpha)
= -t_{1-\alpha}(n)(这个点右侧面积是1-\alpha)\)</span></h5>
<h4 id="f分布">3 F分布</h4>
<h5
id="定义xsim-chi2n_1-ysim-chi2n_2x与y相互独立f-fracxn_1yn_2sim-fn_1-n_2">3.1
定义：<span class="math inline">\(X\sim \chi^2(n_1), Y\sim
\chi^2(n_2),X与Y相互独立，F = \frac{X/{n_1}}{Y/{n_2}}\sim F(n_1,
n_2)\)</span></h5>
<h5 id="性质-1">3.2 性质</h5>
<h6 id="若fsim-fn_1-n_2则frac1fsim-fn_2-n_1">(1) <span
class="math inline">\(若F\sim F(n_1, n_2)，则\frac{1}{F}\sim F(n_2,
n_1)\)</span></h6>
<h6 id="若f_1-alphan_1-n_2-frac1f_alphan_2-n_1">(2)<span
class="math inline">\(若F_{1-\alpha}(n_1, n_2) =
\frac{1}{F_{\alpha}(n_2, n_1)}\)</span></h6>
<p>题型：给一个不标准的分布，去表示出一个标准的分布</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094116.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094141.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231224094152.jpg" /></p>
<h3
id="x_1-x_2x_n独立同分布正态nmu-sigma2时常用结论这些结论常用于后面区间估计和假设检验"><span
class="math inline">\(X_1, X_2,……X_n独立同分布正态(N(\mu,
\sigma^2))时常用结论\)</span>(这些结论常用于后面区间估计和假设检验)</h3>
<h4
id="overlinexsim-nmu-fracsigma2n从前面overlinex的均值与方差可知所以fracoverlinex-musigmasqrtnsim-n0-1">(1)
<span class="math inline">\(\overline{X}\sim N(\mu,
\frac{\sigma^2}{n})(从前面\overline{X}的均值与方差可知),所以\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}\sim
N(0, 1)\)</span></h4>
<h4
id="sum_i1nfracx_i-musigma2-sim-chi2nx_i标准化后的平方和服从与chi2">(2)
<span class="math inline">\(\sum_{i=1}^{n}(\frac{X_i-\mu}{\sigma})^2
\sim \chi^2(n)(X_i标准化后的平方和服从与\chi^2)\)</span></h4>
<h4
id="sum_i1nfracx_i-overlinexsigma2-fracn-1s2sigma2-sim-chi2n-1上面如果总体期望未知可以用样本均值代替后做相应改动">(3)
<span
class="math inline">\(\sum_{i=1}^{n}(\frac{X_i-\overline{X}}{\sigma})^2
= \frac{(n-1)S^2}{\sigma^2} \sim
\chi^2(n-1)(上面如果总体期望未知，可以用样本均值代替后做相应改动)\)</span></h4>
<h4
id="fracoverlinex-mussqrtn-sim-tn-1将1中的总体标准差sigma用样本标准差s替换-fracnoverlinex-mu2s2-sim-f1-n-1">(4)
<span class="math inline">\(\frac{(\overline{X}-\mu)}{S/\sqrt{n}} \sim
t(n-1)(将(1)中的总体标准差\sigma用样本标准差S替换),
\frac{n(\overline{X}-\mu)^2}{S^2} \sim F(1, n-1)\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216121331.jpg" /></p>
<p>(1)先确定要表示的分布</p>
<p>(2)将要表示的分布里的标准分布通过题干中分布标准化后换元表示</p>
<h2 id="参数的区间估计">参数的区间估计</h2>
<p>首先需要了解一些基本概念：</p>
<p><span
class="math inline">\(\mu\)</span>：表示期望，不随抽样改变而改变</p>
<p><span
class="math inline">\(\overline{X}\)</span>：均值，由每次抽样决定</p>
<p>均值虽然不是期望，但一般来说均值与期望之间距离<span
class="math inline">\(|\overline{X}-u|\)</span>比较小的概率还是很大的，公式表示就是</p>
<p><span class="math inline">\(P\left\{|\overline{X}-\mu| \leq
\varepsilon \right\} = 1 - \alpha\)</span></p>
<p>其中<span class="math inline">\(\alpha\)</span>叫显著性水平，<span
class="math inline">\(1-\alpha\)</span>叫置信区间</p>
<h3
id="sigma2已知时的置信区间overlinex-z_fracalpha2fracsigmasqrtn-overlinexz_fracalpha2fracsigmasqrtn"><span
class="math inline">\(\sigma^2已知时的置信区间：(\overline{X}-z_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}},
\overline{X}+z_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}})\)</span></h3>
<p>证明：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216090745.jpg" /></p>
<h3
id="sigma2未知时的置信区间overlinex-t_fracalpha2n-1fracssqrtn-overlinext_fracalpha2n-1fracssqrtn"><span
class="math inline">\(\sigma^2未知时的置信区间：(\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}},
\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}})\)</span></h3>
<p>证明</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216091229.jpg" /></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216091404.jpg" /></p>
<h2
id="假设检验u只是一个假设的值在求出拒绝域后看实际得到的结果落在哪里如果落在拒绝域说明假设不成立">假设检验(u只是一个假设的值，在求出拒绝域后，看实际得到的结果落在哪里，如果落在拒绝域说明假设不成立)</h2>
<p>基本思想是<span class="math inline">\(P(\overline{A}) = 1 -
P(A)\)</span></p>
<p>拒绝域：拒绝原假设<span
class="math inline">\(H_0\)</span>的全体样本点组成集合</p>
<p>接受域：接受原假设<span
class="math inline">\(H_0\)</span>的全体样本点组成集合</p>
<h3 id="双边检验分布的下标是fracalpha2">1 双边检验(<span
class="math inline">\(分布的下标是\frac{\alpha}{2}\)</span>)</h3>
<h4 id="sigma2已知">(1) <span
class="math inline">\(\sigma^2已知\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216093736.jpg" /></p>
<h4 id="sigma2未知">(2) <span
class="math inline">\(\sigma^2未知\)</span></h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216093840.jpg" /></p>
<h3 id="单边检验分布的下标是">2 单边检验($分布的下标是$)</h3>
<h4 id="sigma2已知-1">(1) <span
class="math inline">\(\sigma^2已知\)</span></h4>
<h5 id="mu-leq-u_0"><span class="math inline">\(\mu \leq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094230.jpg" /></p>
<h5 id="mu-geq-u_0"><span class="math inline">\(\mu \geq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094312.jpg" /></p>
<h4 id="sigma2未知-1">(2)<span
class="math inline">\(\sigma^2未知\)</span></h4>
<h5 id="mu-leq-u_0-1"><span class="math inline">\(\mu \leq
u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094446.jpg" /></p>
<h5 id="u-geq-u_0"><span class="math inline">\(u \geq u_0\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094521.jpg" /></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216095445.jpg" /></p>
<h2 id="参数的点估计">参数的点估计</h2>
<h3 id="方法">方法</h3>
<h4
id="矩估计法样本中有未知值theta用样本均值等于总体期望ex-overlinex来计算theta的估计值hattheta">矩估计法：<span
class="math inline">\(样本中有未知值\theta，用样本均值等于总体期望E(X) =
\overline{X}来计算\theta的估计值\hat{\theta}\)</span></h4>
<h4 id="求ex">1 <span class="math inline">\(求E(X)\)</span></h4>
<h4 id="另ex-overlinex">2 <span class="math inline">\(另E(X) =
\overline{X}\)</span></h4>
<h4
id="最大似然估计法-如果是离散型概率分布中含theta如果是连续型概率函数含theta即后面所求将是包含theta的函数">最大似然估计法
<span
class="math inline">\(如果是离散型，概率分布中含\theta，如果是连续型，概率函数含\theta,即后面所求将是包含\theta的函数\)</span></h4>
<h5 id="将样本中所有结果相乘得到ltheta-prod_i1npleftx_i-xright">(1)
<span class="math inline">\(将样本中所有结果相乘得到L(\theta) =
\prod_{i=1}^nP\left\{X_i = x\right\}\)</span></h5>
<h5 id="第一步得到的等式两边取对数">(2) 第一步得到的等式两边取对数</h5>
<h5 id="等式两边关于theta求导并另之为0">(3) <span
class="math inline">\(等式两边关于\theta求导，并另之为0\)</span></h5>
<p>举个例子</p>
<p>离散型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215085510.jpg" /></p>
<p>矩估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215091131.jpg" /></p>
<p>最大似然估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215094536.jpg" /></p>
<p>连续型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215090002.jpg" /></p>
<p>矩估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215091143.jpg" /></p>
<p>最大似然估计法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215095428.jpg" /></p>
<h3 id="估计量的评价标准">估计量的评价标准</h3>
<h4 id="无偏性得到hattheta后证明ehattheta-theta">无偏性：<span
class="math inline">\(得到\hat{\theta}后证明E(\hat{\theta}) =
\theta\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215142836.jpg" /></p>
<h4 id="有效性比较哪个dhattheta更小">有效性：<span
class="math inline">\(比较哪个D(\hat{\theta})更小\)</span></h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231215143607.jpg" /></p>
<h4
id="一致性相合性证明hattheta依概率收敛于theta即lim_nrightarrowinftyplefthattheta-theta-epsilonright-1使用时往往结合切比雪夫不等式">一致性(相合性)：<span
class="math inline">\(证明\hat{\theta}依概率收敛于\theta，即\lim_{n\rightarrow\infty}P\left\{|\hat{\theta}-\theta|
&lt; \epsilon\right\} = 1\)</span>，使用时往往结合切比雪夫不等式</h4>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216094731.jpg" /></p>
<h2 id="两类错误">两类错误</h2>
<p>以有没有病举例</p>
<h3 id="p拒绝h_0h_0为真-有病但被判成无病的概率">$P{拒绝H_0|H_0为真} = $
有病但被判成无病的概率</h3>
<h3 id="pleft接受h_0h_0为假right-无病但被判成有病的概率"><span
class="math inline">\(P\left\{接受H_0|H_0为假\right\}\)</span>
无病但被判成有病的概率</h3>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231216100549.jpg" /></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章：随机变量的数字特征</title>
    <url>/posts/a17c09d9.html</url>
    <content><![CDATA[<h1 id="随机变量的数字特征">随机变量的数字特征</h1>
<span id="more"></span>
<h2 id="一-一维随机变量的数字特征">(一) 一维随机变量的数字特征</h2>
<h3 id="数学期望可以理解为加权平均求和">1
数学期望(可以理解为加权平均求和)</h3>
<h4 id="概念">1.1 概念</h4>
<h5 id="离散型x-p_i">(1) 离散型：X ~ <span
class="math inline">\(P_i\)</span></h5>
<h6
id="ex-sum_in-x_ip_i每一个正概率点是x_i对应的概率是p_i对应相乘后求和"><span
class="math inline">\(E(X) = \sum_{i}^n
x_ip_i\)</span>(每一个正概率点是<span
class="math inline">\(x_i\)</span>，对应的概率是<span
class="math inline">\(p_i\)</span>，对应相乘后求和)</h6>
<h6 id="如果y-gx-ey-sum_ingx_ip_i">如果Y = g(x), <span
class="math inline">\(E(Y) = \sum_{i}^{n}g(x_i)p_i\)</span></h6>
<h5 id="连续型x-fx">(2) 连续型：X ~ <span
class="math inline">\(f(x)\)</span></h5>
<h6
id="ex-int_-inftyinftyxfxdx对于任意在正概率区间内的x可以形成一个以底是dx高是fx的小矩形面积是fxdx可以近似认为是x对应的概率所以在整个区间上对所有的x积分就是int_-inftyinftyxfxdx"><span
class="math inline">\(E(X) =
\int_{-\infty}^{+\infty}xf(x)dx\)</span>(对于任意在正概率区间内的x，可以形成一个以底是dx，高是f(x)的小矩形，面积是f(x)dx,可以近似认为是x对应的概率，所以在整个区间上对所有的x积分就是<span
class="math inline">\(\int_{-\infty}^{+\infty}xf(x)dx\)</span>)</h6>
<h6
id="如果y-gx-ey-int_-inftyinftygxfxdxy-gx只是修改了定义域的范围将定义域从x的范围变成了gx的范围而对概率密度并没有影响">如果Y
= g(x), <span class="math inline">\(E(Y) =
\int_{-\infty}^{+\infty}g(x)f(x)dx\)</span>(Y=
g(x)，只是修改了定义域的范围，将定义域从x的范围变成了g(x)的范围，而对概率密度并没有影响)</h6>
<h4 id="性质">1.2 性质</h4>
<h5 id="线性eax-b-aex-b">1.2.1 线性：E(aX + b) = aE(X) + b</h5>
<h5
id="独立如果x与y相互独立才可以拆分exy-exey也常用这个证明是否相互独立">1.2.2
独立：如果X与Y相互独立，才可以拆分E(XY) =
E(X)E(Y)(也常用这个证明是否相互独立)</h5>
<h3 id="方差标准差">2 方差、标准差</h3>
<h3
id="概念方差反应的是每个数据点对于均值的偏离情况标准差就是方差开根号">2.1
概念：方差反应的是每个数据点对于均值的偏离情况，标准差就是方差开根号</h3>
<h4 id="dx-ex---ex2-ex2---ex2-sigma-sqrtdx"><span
class="math inline">\(D(X) = E((X - E(X)^2) = E(X^2) - (E(X))^2, \sigma
= \sqrt{D(X)}\)</span></h4>
<p>如果是求D(g(X))，或者说所有求D(X),都要利用定义转换成计算均值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231214084118.jpg" /></p>
<h3 id="性质-1">2.2 性质</h3>
<h4 id="dax-b-a2dx">2.2.1 <span class="math inline">\(D(aX + b) =
a^2D(X)\)</span></h4>
<h4 id="dxpm-y-dx-dy-pm-2covx-y">2.2.2 <span
class="math inline">\(D(X\pm Y) = D(X) + D(Y) \pm 2Cov(X,
Y)\)</span></h4>
<h4 id="如果x与y相互独立dax-by-a2dx-b2dy">2.2.3 如果X与Y相互独立，<span
class="math inline">\(D(aX + bY) = a^2D(X) + b^2D(Y)\)</span></h4>
<h3 id="切比雪夫不等式偏离期望值的概率小靠近期望值的概率大">3
切比雪夫不等式(偏离期望值的概率小，靠近期望值的概率大)</h3>
<h4 id="pleftx---ex-epsilon-right-geq-1---fracdxepsilon2">3.1 <span
class="math inline">\(P\left\{|X - E(X)| &lt; \epsilon \right\} \geq 1 -
\frac{D(X)}{\epsilon^2}\)</span></h4>
<h4 id="pleftx---ex-geq-epsilonright-leq-fracdxepsilon2">3.2 <span
class="math inline">\(P\left\{|X - E(X)| \geq \epsilon\right\} \leq
\frac{D(X)}{\epsilon^2}\)</span></h4>
<p>常用期望和分布</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231213160527.jpg" /></p>
<h2 id="二-二维随机变量的数字特征">(二) 二维随机变量的数字特征</h2>
<h3 id="期望">1 期望</h3>
<h3
id="离散型-egx-y-sum_isum_jgx-yp_i-jgx-y实际上代表的是平面定义域">1.1
离散型 <span class="math inline">\(E[g(X, Y)] = \sum_{i}\sum_{j}g(x,
y)p_{i, j})\)</span>(g(x, y)实际上代表的是平面定义域)</h3>
<h3 id="连续型-设x-yfx-y-egx-y-iint_-inftyinftygx-yfx-ydxdy">1.2 连续型
，设(x, y)~f(x, y) <span class="math inline">\(E[g(X, Y)] =
\iint_{-\infty}^{+\infty}g(x, y)f(x, y)dxdy\)</span></h3>
<h3 id="协方差与相关系数">2 协方差与相关系数</h3>
<h4 id="概念-1">1 概念：</h4>
<h5 id="协方差概念-covx-y-ex---exy---ey-exy---exey">协方差概念 Cov(X, Y)
= E[(X - E(X))(Y - E(Y))] = E(XY) - E(X)E(Y)</h5>
<h5 id="相关系数概念-rho_xy-fraccovx-ysqrtdx-sqrtdy">相关系数概念 <span
class="math inline">\(\rho_{XY} = \frac{Cov(X, Y)}{\sqrt{D(X)}
\sqrt{D(Y)}}\)</span></h5>
<p>如果<span class="math inline">\(\rho _{XY} =
0\)</span>,说明X与Y之间没有线性相关性，但可能有其他形式的相关，如果不为0，就是有线性相关性</p>
<h4 id="性质都可以从定义推出来">2 性质(都可以从定义推出来)</h4>
<h5 id="对称性">2.1 对称性</h5>
<h5 id="线性性">2.2 线性性</h5>
<h2 id="典型题型">典型题型</h2>
<h3 id="求二维连续型随机变量相关系数">1
求二维连续型随机变量相关系数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231120140922.jpg" /></p>
<h4 id="求ex">求EX</h4>
<h4 id="求ex2">求E(X^2)</h4>
<h4 id="求dx-ex2---ex2">求DX = E(X^2) - (EX)^2</h4>
<h4 id="y同理">Y同理</h4>
<h4 id="求exy">求E(XY)</h4>
<h4 id="利用相关系数公式">利用相关系数公式</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231120143419.jpg" /></p>
<p>### 2 独立性与相关性的判定</p>
<p>#### 计算Cov(X, Y)</p>
<p>#### <span class="math inline">\(Cov(X, Y) \neq 0 \Rightarrow
X与Y相关 \Rightarrow X与Y不相互独立\)</span></p>
<p>####<span class="math inline">\(Cov(X, Y) = 0 \Rightarrow X与Y不相关
\Rightarrow 通过构造事件组P\left\{X \leq a\right\}, P\left\{Y \leq
a\right\}\)</span></p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
  </entry>
  <entry>
    <title>softmax的定义与实现</title>
    <url>/posts/ebe4d421.html</url>
    <content><![CDATA[<h1 id="基本术语的介绍">基本术语的介绍</h1>
<h2 id="特征feature">特征：（feature）：</h2>
<h3
id="描述一件事物的特性如一个人的身高体重年龄和五官">描述一件事物的特性，如一个人的身高、体重、年龄和五官。</h3>
<h3
id="代码里就是用来表示某样事物的矩阵">代码里就是用来表示某样事物的矩阵</h3>
<h2 id="样本sample">样本（sample）：</h2>
<h3
id="由一个人的特征组成的数据如1807019精致1807019精致">由一个人的特征组成的数据，如{180,70,19,精致}{180,70,19,精致}。</h3>
<h3
id="代码里就是从整个数据集里抽取的一部分">代码里就是从整个数据集里抽取的一部分</h3>
<h2 id="标签label">标签（label）：</h2>
<h3
id="描述一件事物的特性如一个人帅或丑一个人的财富数量注特征和标记没有明确的划分由于问题的不同可能导致">描述一件事物的特性，如一个人帅或丑、一个人的财富数量。<strong>注：特征和标记没有明确的划分，由于问题的不同可能导致</strong></h3>
<h3
id="a问题的特征是b问题的标记b问题的标记是a问题的特征"><strong>A问题的特征是B问题的标记，B问题的标记是A问题的特征。</strong></h3>
<h3
id="在代码里面往往表示的是真正的结果">在代码里面往往表示的是真正的结果</h3>
<h2 id="样例example">样例（example）：</h2>
<h3
id="由一个人的特征和标记组成的数据如1807019精致帅1807019精致帅">由一个人的特征和标记组成的数据，如{180,70,19,精致,帅}{180,70,19,精致,帅}。</h3>
<h2 id="特征空间feature-space">特征空间（feature space）：</h2>
<h2
id="特征向量feature-vector特征空间内的某一个具体的向量">特征向量（feature
vector）：特征空间内的某一个具体的向量</h2>
<h1 id="softmax回归">softmax回归</h1>
<h2 id="要解决的问题-分类问题">要解决的问题: 分类问题</h2>
<p>从一个图像分类问题开始。 假设每次输入是一个2×2的灰度图像。
我们可以用一个标量表示每个像素值，每个图像对应四个特征<span
class="math inline">\(x1,x2,x3,x4\)</span>。
此外，假设每个图像属于类别“猫”“鸡”和“狗”中的一个。</p>
<p>独热编码： （1）一个向量，它的分量和类别一样多
（2）类别对应的分量设置为1，其他所有分量设置为0。
（3）举例：标签y将是一个三维向量，
其中(1,0,0)对应于“猫”、(0,1,0)对应于“鸡”、(0,0,1)对应于“狗”：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114211802509.png" /></p>
<h2
id="优点softmax函数能够将未规范化的预测变换为非负数并且总和为1同时让模型保持可导的性质">优点：softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质</h2>
<h2 id="形成的网络架构">形成的网络架构</h2>
<p>（1）估计所有可能类别的条件概率，我们需要一个有多个输出的模型，每个类别对应一个输出</p>
<p>（2）所以需要和输出一样多的<em>仿射函数</em>（affine
function）(没那么高大上，就是实现映射关系的函数)，
每个输出对应于它自己的仿射函数</p>
<p>（3）有4个特征(因为前面说的灰度图有4个像素点）和3个可能的输出类别（猫，鸡，狗）</p>
<p>（4）所以需要12个标量来表示权重（带下标的<span
class="math inline">\(w\)</span>）， 3个标量来表示偏置（带下标的<span
class="math inline">\(b\)</span>），每个输入计算三个**（logit）：<span
class="math inline">\(o1、o2和o3\)</span>。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114213059124.png" /></p>
<p>（5）所以softmax回归是一个单层神经网络。softmax回归的输出层也是全连接层</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240114213251337.png" /></p>
<h2 id="运算">运算</h2>
<h3 id="对每个项求幂使用exp">1.
对每个项求幂（使用<code>exp</code>）；</h3>
<h3 id="对每一行求和小批量中每个样本是一行得到每个样本的规范化常数">2.
对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</h3>
<h3 id="将每一行除以其规范化常数确保结果的和为1">3.
将每一行除以其规范化常数，确保结果的和为1。</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115162440275.png" /></p>
<h1 id="实现">实现</h1>
<h2 id="读取数据集">读取数据集</h2>
<p>练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型</p>
<p>打乱数据集中的样本并以小批量方式获取数据</p>
<p>接收批量大小、特征矩阵和标签向量作为输入</p>
<p>生成大小为<code>batch_size</code>的小批量。
每个小批量包含一组特征和标签。</p>
<p>读取第一个小批量数据样本并打印。
每个批量的特征维度显示批量大小和输入特征数。
同样的，批量的标签形状与<code>batch_size</code>相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[-0.594405    0.7975923 ]</span><br><span class="line"> [ 0.5477517   0.15074243]</span><br><span class="line"> [-0.34835348  0.929739  ]</span><br><span class="line"> [-1.5249145   0.701587  ]</span><br><span class="line"> [-2.298264    0.10911477]</span><br><span class="line"> [ 1.6356094   0.14286116]</span><br><span class="line"> [-0.19882555 -0.85171705]</span><br><span class="line"> [ 1.2024101  -1.7029836 ]</span><br><span class="line"> [-0.60534513 -0.39319903]</span><br><span class="line"> [-1.771029   -0.5459446 ]]</span><br><span class="line"> [[ 0.30207413]</span><br><span class="line"> [ 4.786745  ]</span><br><span class="line"> [ 0.33858034]</span><br><span class="line"> [-1.2297847 ]</span><br><span class="line"> [-0.75900215]</span><br><span class="line"> [ 6.979927  ]</span><br><span class="line"> [ 6.7001796 ]</span><br><span class="line"> [12.39533   ]</span><br><span class="line"> [ 4.3220677 ]</span><br><span class="line"> [ 2.517848  ]]</span><br></pre></td></tr></table></figure>
<h2 id="定义模型">定义模型</h2>
<h3 id="手搓版本">手搓版本</h3>
<h4 id="初始化模型参数">初始化模型参数</h4>
<h5 id="展平">展平</h5>
<p>每个样本都将用固定长度的向量表示。 原始数据集中的每个样本都是28×28 =
784的图像。 展平每个图像，把它们看作长度为784的向量</p>
<h5 id="输出维度">输出维度</h5>
<p>输出与类别一样多。
因为我们的数据集有10个类别，所以网络输出维度为10</p>
<h5 id="权重矩阵和偏置矩阵">权重矩阵和偏置矩阵</h5>
<h6 id="大小">大小</h6>
<p>因此，权重将构成一个784×10（每个数据由一维列向量构成，这个一维向量由784个数字构成，一共有10个输出，每个输出对应的每一行就是一个公式)的权重矩阵，
偏置将构成一个1×10的<strong>行向量</strong>（每个输出对应一个偏置，一共10个输出），注意这里是<strong>“立”</strong>着来，从上往下计算，不像前面提到和一般从左到右</p>
<h6 id="初始化">初始化</h6>
<p>使用正态分布初始化我们的权重<code>W</code>，偏置初始化为0。</p>
<h5 id="代码">代码</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 使用 PyTorch 的 torch.normal 函数生成行数为 num_inputs，列数为 num_outputs的二维矩阵，并且服从正态分布（均值为0，标准差为0.01），并设置 requires_grad=True</span></span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="定义softmax操作">定义softmax操作</h4>
<h5 id="对每个项求幂使用exp-1">1.
对每个项求幂（使用<code>exp</code>）；</h5>
<h5 id="对每一行求和小批量中每个样本是一行得到每个样本的规范化常数-1">2.
对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</h5>
<h5 id="将每一行除以其规范化常数确保结果的和为1-1">3.
将每一行除以其规范化常数，确保结果的和为1。</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115162440275.png" />
##### 代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure></p>
<p>其中sum操作，如果指定在一个轴（同一列（轴0）或同一行（轴1））上求和，</p>
<p>如果<code>X</code>是一个形状为<code>(2, 3)</code>的张量，我们对列进行求和</p>
<p>默认情况会降维，得到一个形状<code>(3,)</code>的向量</p>
<p>但keepdim=True指定保持在原始张量的轴数，将产生一个具有形状<code>(1, 3)</code>的二维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">X.<span class="built_in">sum</span>(<span class="number">0</span>, keepdim=<span class="literal">True</span>), X.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(tensor([[5., 7., 9.]]),</span><br><span class="line"> tensor([[ 6.],</span><br><span class="line">         [15.]]))</span><br></pre></td></tr></table></figure>
<h4 id="合并">合并</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br></pre></td></tr></table></figure>
<p><code>X.reshape((-1, W.shape[0]))</code>：这一步将输入 <code>X</code>
重塑为一个二维张量，其形状的第二个维度与权重 <code>W</code>
的第一个维度相同。<code>-1</code> 表示该维度的大小会自动计算，以保持
<code>X</code> 中元素的总数不变</p>
<p><code>torch.matmul(X.reshape((-1, W.shape[0])), W)</code>：这一步执行矩阵乘法，将重塑后的
<code>X</code> 与权重 <code>W</code> 相乘</p>
<p>。<code>torch.matmul(X.reshape((-1, W.shape[0])), W) + b</code>：这一步将偏置
<code>b</code>
加到矩阵乘法的结果上。注意，由于广播（broadcasting）机制，即使
<code>b</code> 的形状与矩阵乘法的结果不同，这一步也能正确执行。</p>
<p><code>softmax(torch.matmul(X.reshape((-1, W.shape[0])), W) + b)</code>：最后，这一步将
softmax 函数应用到加上偏置的结果上。softmax 函数能将其输入（通常被称为
logits 或分数）转换为正值且和为 1 的概率分布。</p>
<h3 id="导包版本">导包版本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PyTorch不会隐式地调整输入的形状,我们在线性层前定义了展平层（flatten），来调整网络输入的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接将模型定义和损失函数合并到一起去了</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="定义损失函数">定义损失函数</h2>
<h3 id="损失函数是什么">损失函数是什么</h3>
<p>量化目标的<em>实际</em>值与<em>预测</em>值之间的差距</p>
<p>选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0</p>
<p>回归问题中最常用的损失函数是平方误差函数 ###
对数似然(就是大二上学的概率论里的第六章的最大似然估计，与矩估计并列)</p>
<h3 id="交叉熵损失">交叉熵损失</h3>
<p>观察到的不仅仅是一个结果，现在用一个概率向量表示，如(0.1,0.2,0.7)，
而不是仅包含二元项的向量(0,0,1)。使用下面这个公式定义损失，它是所有标签分布的预期损失值。称为<em>交叉熵损失</em>（cross-entropy
loss）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/11.png" />
实现交叉熵损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y])</span><br><span class="line"></span><br><span class="line">cross_entropy(y_hat, y)</span><br></pre></td></tr></table></figure>
<h2 id="定义优化算法">定义优化算法</h2>
<p>每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。
接下来，朝着减少损失的方向更新我们的参数</p>
<p>接受模型参数集合、学习速率和批量大小作为输入。</p>
<p>每 一步更新的大小由学习速率<code>lr</code>决定</p>
<p>计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>）
来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br></pre></td></tr></table></figure>
<h2
id="分类精度确预测数量与总预测数量之比">分类精度：确预测数量与总预测数量之比</h2>
<p>须输出硬预测（hard prediction）时，
我们通常选择<strong>预测概率最高</strong>的类</p>
<p>当预测与标签分类<code>y</code>一致时，即是正确的。</p>
<p>计算方法：</p>
<p>如果<code>y_hat</code>是矩阵，那么假定第二个维度存储每个类的预测分数。
我们使用<code>argmax</code>获得每行中最大元素的索引来获得预测类别。
然后我们将预测类别与真实<code>y</code>元素进行比较。
由于等式运算符“<code>==</code>”对数据类型很敏感，
因此我们将<code>y_hat</code>的数据类型转换为与<code>y</code>的数据类型一致。
结果是一个包含0（错）和1（对）的张量。
最后，我们求和会得到正确预测的数量。</p>
<p>举例说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.tensor([<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 标签y, 在第一个样本中，第一类是正确的预测； 而在第二个样本中，第三类是正确的预测</span></span><br><span class="line">y_hat = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>], [<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.5</span>]])</span><br><span class="line"><span class="comment"># y_hat包含2个样本在3个类别的预测概率， 以及它们对应的标签y</span></span><br><span class="line">y_hat[[<span class="number">0</span>, <span class="number">1</span>], y]</span><br><span class="line"><span class="comment"># 对一个二维张量 y_hat 进行索引。具体来说，它选择了 y_hat 的第 0 行和第 1 行中，由 y 指定的列</span></span><br></pre></td></tr></table></figure>
<p>输出 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([0.1000, 0.5000])</span><br></pre></td></tr></table></figure> 定义计算精度的函数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>)</span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure></p>
<p>使用之前定义的变量<code>y_hat</code>和<code>y</code>分别作为预测的概率分布和标签，第一个样本的预测类别是2（该行的最大元素为0.6，索引为2），这与实际标签0不一致。
第二个样本的预测类别是2（该行的最大元素为0.5，索引为2），这与实际标签2一致。
因此，这两个样本的分类精度率为0.5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accuracy(y_hat, y) / <span class="built_in">len</span>(y)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.5</span><br></pre></td></tr></table></figure>
<h2 id="训练">训练</h2>
<h3
id="在每次迭代中我们读取一小批量训练样本">在每次迭代中，我们读取一小批量训练样本</h3>
<h3
id="通过调用模型来获得一组预测并计算损失l前向传播">通过调用模型来获得一组预测并计算损失l（前向传播）</h3>
<h3
id="计算完损失后开始反向传播来计算每个参数的梯度">计算完损失后，开始反向传播来计算每个参数的梯度。</h3>
<h3
id="最后我们调用优化器比如sgd来更新模型参数">最后，我们调用优化器(比如sgd)来更新模型参数。</h3>
<h2 id="预测">预测</h2>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>transformer在cv中应用</title>
    <url>/posts/f8648800.html</url>
    <content><![CDATA[<h1 id="基础transformer讲解">基础transformer讲解</h1>
<h2 id="position-encoding">Position Encoding</h2>
<p>前面是没有考虑位置信息的，举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = nn.MultiheadAttention(embed_dim=<span class="number">2</span>, num_heads=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># embed_dim=2：指定了输入的嵌入维度（embedding dimension），即每个输入样本的特征维度为2，说白了就是图像的列数</span></span><br><span class="line"><span class="comment"># num_heads=1：指定了注意力头的数量，即将输入特征分成几份进行注意力计算。在这个例子中，只使用了1个注意力头。</span></span><br><span class="line">t1 = [[[<span class="number">1.</span>, <span class="number">2.</span>],   <span class="comment"># q1, k1, v1</span></span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>],   <span class="comment"># q2, k2, v2</span></span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>]]]  <span class="comment"># q3, k3, v3</span></span><br><span class="line"></span><br><span class="line">t2 = [[[<span class="number">1.</span>, <span class="number">2.</span>],   <span class="comment"># q1, k1, v1</span></span><br><span class="line">       [<span class="number">3.</span>, <span class="number">4.</span>],   <span class="comment"># q3, k3, v3</span></span><br><span class="line">       [<span class="number">2.</span>, <span class="number">3.</span>]]]  <span class="comment"># q2, k2, v2</span></span><br><span class="line"></span><br><span class="line">q, k, v = torch.as_tensor(t1), torch.as_tensor(t1), torch.as_tensor(t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result1: \n&quot;</span>, m(q, k, v))</span><br><span class="line"></span><br><span class="line">q, k, v = torch.as_tensor(t2), torch.as_tensor(t2), torch.as_tensor(t2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result2: \n&quot;</span>, m(q, k, v))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/20210611164732523.png" /></p>
<p>发现对b1没有影响</p>
<p>所以</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/20210611154758830.png" /></p>
<h1 id="vision-transformer模型详解">Vision Transformer模型详解</h1>
<p><strong><a
href="https://blog.csdn.net/qq_37541097/article/details/118242600#078b00d2-5d7d-f09f-c2b7-5f65765519fb">参考文章一</a></strong></p>
<p><a
href="https://blog.csdn.net/qq_37541097/article/details/117691873">参考文章二</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>卷积神经网络理论基础</title>
    <url>/posts/6b55376.html</url>
    <content><![CDATA[<h1 id="卷积">卷积</h1>
<h2 id="互相关运算">互相关运算：</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/correlation.svg" /></p>
<p>卷积核的每一位与待卷积矩阵对应位相乘后求和</p>
<p>0 x 0+1 x 1+3 x 2+4 x 3=19，其他类似</p>
<p>卷积核向右移动一位后，0 * 1 + 2 * 1 + 4 * 2 + 5 * 3 = 25</p>
<p>卷积核到下一行：0 * 3 + 1 * 4 + 6 * 2 + 7 * 3 = 37</p>
<p>再向右移动一位：0 * 4 + 1 * 5 + 7 * 2 + 8 * 3 = 43</p>
<h2 id="卷积层">卷积层</h2>
<p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。所以卷积层中的两个被训练的参数是卷积核权重和标量偏置</p>
<p>机初始化卷积核权重。</p>
<h3 id="手搓实现">手搓实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure>
<h3 id="导包实现">导包实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line">conv1 = nn.Conv2d(in_channel = , out_channel = , kernel_size = )</span><br></pre></td></tr></table></figure>
<p>一般首先关心的就是输入的通道数，输出的通道数，卷积核大小，初始化权重什么的不用操心</p>
<h2 id="特征映射和感受野">特征映射和感受野</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/correlation.svg" /></p>
<p>上图输出的卷积层有时被称为<em>特征映射</em>（feature
map），因为它可以被视为一个输入映射到下一层的空间维度的转换器，</p>
<p>卷积神经网络中，对于某一层的任意元素x，其<em>感受野</em>（receptive
field）是指在前向传播期间可能影响x计算的所有元素（来自所有先前层）。如上图,给定2×2卷积核，阴影输出元素值19的感受野是输入阴影部分的四个元素</p>
<p>感受野可能大于输入的实际大小。(这个很好理解，因为来自前面所有层，二输入仅仅指的是输出的前一层)</p>
<h2 id="卷积中的填充">卷积中的填充：</h2>
<p>减少边缘像素的丢失</p>
<h2 id="卷积中的步幅">卷积中的步幅</h2>
<h2 id="多输入多输出">多输入多输出</h2>
<h3 id="多输入">多输入</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/conv-multi-in.svg" /></p>
<p>输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数的卷积核，以便与输入数据进行互相关运算</p>
<p>先是各自通道上卷积核与各自通道进行互相关运算，然后将得到的两个输入求和成一个数作为对应位置的输出</p>
<h3 id="多输出">多输出</h3>
<p>随着神经网络层数的加深，我们常会增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度。</p>
<h1 id="汇聚">汇聚</h1>
<p>处理图像时，我们希望逐渐降低隐藏表示的空间分辨率、聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p>
<p>通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p>
<h2 id="目的">目的</h2>
<p>降低卷积层对位置的敏感性</p>
<p>同时降低对空间降采样表示的敏感性。</p>
<h2 id="种类">种类</h2>
<h3 id="最大汇聚层">最大汇聚层</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/pool.svg" /></p>
<p>每次取核里面最大的作为对应位置的输出</p>
<h3 id="平均汇聚层">平均汇聚层</h3>
<p>每次对核里面的求和取平均作为对应位置的输出</p>
<h2 id="多个通道">多个通道</h2>
<p>汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。
这意味着汇聚层的输出通道数与输入通道数相同。</p>
<h1 id="调整大小计算宽和高">调整大小计算宽和高</h1>
<p>参数计算主要是在从最后的卷积层或者池化层后，进行映射的全连接层的第一层前，需要展平成一维张量，这时就要通过参数计算来确定目前输出通道数，全部相乘的结果作为全连接层的第一层的输入通道数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">卷积后宽和高常用计算公式：</span><br><span class="line">(图像尺寸-卷积核尺寸 + 2*填充值)/步长+1</span><br><span class="line">池化后宽和高常用计算公式：</span><br><span class="line">(图像尺寸-池化窗尺寸 + 2*填充值)/步长+1</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/205453986">参考文章</a></p>
<h1 id="不成文规定">不成文规定</h1>
<p>池化参数一般就是（2， 2）</p>
<p>中间的channel数量都是自己设定的，二的次方就行</p>
<p>kernelsize一般3或者5之类的</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>图像增广</title>
    <url>/posts/c2a0da7c.html</url>
    <content><![CDATA[<h1 id="翻转和裁剪">翻转和裁剪</h1>
<h2 id="水平翻转-transforms.randomhorizontalflip">水平翻转
transforms.RandomHorizontalFlip()</h2>
<p>有50%的几率水平翻转图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像</span></span><br><span class="line">img_path = <span class="string">&quot;/home/ztb/CV_method/image_augmentation/img.png&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义水平翻转变换</span></span><br><span class="line">horizontal_flip = transforms.RandomHorizontalFlip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用水平翻转</span></span><br><span class="line">flipped_image = horizontal_flip(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存水平翻转后的图像</span></span><br><span class="line">flipped_image.save(<span class="string">&quot;/home/ztb/CV_method/image_augmentation/flip.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于图像读取的补充：</p>
<p>PIL：推荐使用，读出来就是RGB</p>
<p>cv2：也可以用，不过读出来</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>多层感知机</title>
    <url>/posts/c3f7cdb7.html</url>
    <content><![CDATA[<h1
id="多层感知机定义与前面提到的softmax回归构成的全连接层相比就是增加了隐藏层">多层感知机定义：与前面提到的softmax回归构成的全连接层相比就是增加了隐藏层</h1>
<p>通过在网络中加入一个或多个隐藏层</p>
<p>最简单的方法是将许多全连接层堆叠在一起。
每一层都输出到上面的层，直到生成最后的输出</p>
<p>这种架构通常称为<em>多层感知机</em>（multilayer
perceptron），通常缩写为<em>MLP</em>。</p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116133945207.png" /></p>
<span id="more"></span>
<p>4个输入，3个输出</p>
<p>隐藏层包含5个隐藏单元。</p>
<p>输入层不涉及任何计算</p>
<p>产生输出只需要实现隐藏层和输出层的计算。</p>
<p>因此，这个多层感知机中的层数为2。</p>
<p>两个层都是全连接的。 每个输入都会影响隐藏层中的每个神经元，
而隐藏层中的每个神经元又会影响输出层中的每个神经元。</p>
<h1 id="激活函数">激活函数</h1>
<h2 id="定义">定义：</h2>
<p>在仿射变换之后对每个隐藏单元应用非线性的<em>激活函数</em>（activation
function）<span
class="math inline">\(\sigma\)</span>，防止多层感知机退化成线性模型</p>
<p>大多数激活函数都是非线性的</p>
<h2 id="作用">作用：</h2>
<p>过计算加权和并加上偏置来确定神经元是否应该被激活</p>
<h2 id="种类">种类</h2>
<h3 id="relu函数">ReLU函数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/output_mlp_76f463_21_0.svg" /></p>
<p>当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。</p>
<p>输入值精确等于0时，ReLU函数不可导。
在此时，我们默认使用左侧的导数，即当输入为0时导数为0</p>
<h3 id="sigmoid函数">sigmoid函数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-7c4e9e545f0cc76bb5202fec4202f873_r.jpg" /></p>
<h1 id="实现">实现</h1>
<h2 id="初始化模型参数">初始化模型参数</h2>
<p>每个图像由 28×28=784个灰度像素值组成。 所有图像共分为10个类别。
忽略像素之间的空间结构， 我们可以将每个图像视为具有784个输入特征
和10个类的简单分类数据集</p>
<p>实现一个具有单隐藏层的多层感知机， 它包含256个隐藏单元</p>
<p>可以将这两个变量都视为超参数。
通常，我们选择2的若干次幂作为层的宽度</p>
<p>对于每一层我们都要记录一个权重矩阵和一个偏置向量</p>
<h2 id="激活函数relu">激活函数RELU</h2>
<h2 id="模型">模型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">                    nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">                    nn.ReLU(),</span><br><span class="line">                    nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<h2 id="损失函数交叉熵损失">损失函数：交叉熵损失</h2>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>配置带参数的远程调试</title>
    <url>/posts/5b87369e.html</url>
    <content><![CDATA[<h1 id="如何配置带参数的远程调试">如何配置带参数的远程调试</h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240131130659524.png" /></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>手写数字识别LeNet的实现</title>
    <url>/posts/9ffa7954.html</url>
    <content><![CDATA[<h1 id="前期准备工作">前期准备工作</h1>
<h2 id="配置环境和解释器">配置环境和解释器</h2>
<h3 id="配置远程环境">配置远程环境</h3>
<p>命令行查看所有环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<p>命令行创建环境</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python=X.X</span><br></pre></td></tr></table></figure>
<p>激活指定环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117084339703.png" /></p>
<p>再用查看所有环境，打*的环境表示是当前激活的环境</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117084441366.png" /></p>
<h3 id="配置本地解释器">配置本地解释器</h3>
<p>添加SSH解释器</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082843831.png" /></p>
<p>选择现有</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082955955.png" /></p>
<p>等待内省完毕</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117083008284.png" /></p>
<p>选择现有，找到之前创建的环境位置，后面加上/bin/pythonX.X(最初创建python的版本号)</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085311087.png" /></p>
<p>修改同步文件夹的远程文件夹为之前创建project的位置</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085448125.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085511661.png" /></p>
<p>如下所示则配置完成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117085811089.png" /></p>
<h2 id="安装pytorch框架">安装pytorch框架</h2>
<p>查看当前cuda版本和python版本，这两个都会决定要下载的pytorch版本</p>
<p>cuda版本查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117092054384.png" /></p>
<p><a
href="https://github.com/pytorch/vision#installation">python版本对应</a></p>
<p>到<a
href="https://pytorch.org/get-started/previous-versions/">官网</a>下载(下载的版本可以略低与当前CUDA版本),基本上是宁高勿低</p>
<p>查看当前虚拟环境中cuda版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda activate cp36</span><br><span class="line">python</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line">torch.cuda.is_available()   <span class="comment"># cuda是否可用</span></span><br><span class="line">torch.version.cuda          <span class="comment"># cuda版本</span></span><br><span class="line"> </span><br><span class="line">torch.backends.cudnn.is_available()  <span class="comment"># cudnn是否可用</span></span><br><span class="line">torch.backends.cudnn.version()       <span class="comment"># cudnn版本</span></span><br></pre></td></tr></table></figure>
<h2 id="项目同步部署到远程服务器">项目同步部署到远程服务器</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081508016.png" /></p>
<p>新建选择SFTP</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081637151.png" /></p>
<p>便于区分输入项目名称作为新的服务器部署</p>
<p>配置SSH并测试连接</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117081834114.png" /></p>
<p>设置项目主文件夹为根路径</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082019469.png" /></p>
<p>因为之前根路径就是项目主目录，所以部署路径是相对于根目录的相对路径</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082555518.png" /></p>
<p>将这个服务器的部署作为默认值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117082738866.png" /></p>
<h1 id="读取数据集">读取数据集</h1>
<p><code>datasets.MNIST(...)</code> 返回一个
<code>torchvision.datasets.MNIST</code> 的实例，而
<code>torch.utils.data.DataLoader</code>
则接收这个数据集实例，并使用指定的参数创建一个 <code>DataLoader</code>
实例</p>
<h2
id="利用torch.util.data.dataloader创建dataloader的实例">利用torch.util.data.DataLoader创建DataLoader的实例</h2>
<h3
id="创建一个dataset的实例pytorch框架中已经实现了mnist的set">创建一个dataset的实例(pytorch框架中已经实现了MNIST的set)</h3>
<h4 id="数据集要被存储的根目录">数据集要被存储的根目录</h4>
<h4 id="下载的是训练集还是测试集">下载的是训练集还是测试集</h4>
<h4 id="如果数据集尚未下载是否下载">如果数据集尚未下载，是否下载</h4>
<h4
id="创建对数据集的操作的transform实列一般是必备的两条">创建对数据集的操作的transform实列（一般是必备的两条）</h4>
<h5 id="将数据集里的图片转化为张量">将数据集里的图片转化为张量</h5>
<h5 id="将数据集里的图片归一化">将数据集里的图片归一化</h5>
<h3
id="从数据集里面一次读取的batch_size大小">从数据集里面一次读取的batch_size大小</h3>
<h3
id="每次读取后是否打乱原来的数据集">每次读取后是否打乱原来的数据集</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立训练集</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">	datasets.MNIST(</span><br><span class="line">    	<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">        train = <span class="literal">True</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ]),</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 建立测试集</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">   		train = <span class="literal">False</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="搭建网络">搭建网络</h1>
<h2 id="模板">模板</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConvNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br></pre></td></tr></table></figure>
<p>根据下图搭建</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/lenet-vert.svg" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 第一个卷积层，输入是1个通道（因为输入的是灰度图只有1个通道），输出根据图是6个通道</span></span><br><span class="line">        <span class="comment"># 卷积核大小是5 * 5</span></span><br><span class="line">        self.avgPool = nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)   <span class="comment"># 第一个汇聚层，汇聚层不改变通道数量</span></span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x : 1 * 28 * 28</span></span><br><span class="line">        out = self.conv1(x)     <span class="comment"># 28 - 5 + 2 * 2 + 1 = 28, 6 * 28 * 28</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (28 - 2) / 2 + 1 = 14, 6 * 14 * 14</span></span><br><span class="line">        out = self.conv2(out)   <span class="comment"># 14 - 5 + 1 = 10, 16 * 10 * 10</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (10 - 2) / 2 + 1 = 5, 16 * 5 * 5</span></span><br><span class="line">        out = self.flatten(out)</span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc3(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h1 id="定义训练函数">定义训练函数</h1>
<h2 id="将模型设置为训练模式">将模型设置为训练模式</h2>
<h2
id="利用enumerate遍历dataloader从中获取训练的批次核数据标签数据-标签对">利用enumerate遍历dataloader，从中获取训练的批次核（数据，标签）数据-标签对</h2>
<h2 id="将数据和标签移动到gpu上">将数据和标签移动到GPU上</h2>
<h2 id="梯度清零">梯度清零</h2>
<h2 id="将数据传入模型进行前向传播">将数据传入模型进行前向传播</h2>
<h2 id="计算损失">计算损失</h2>
<h2 id="反向传播">反向传播</h2>
<h2 id="调用优化器更新参数">调用优化器更新参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, label = data.to(device), label.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(batch_idx + <span class="number">1</span>) % <span class="number">30</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="定义测试函数">定义测试函数</h1>
<h2 id="设置模型为评估模式">设置模型为评估模式</h2>
<h2
id="初始化测试损失和正确预测的样本数为零">初始化测试损失和正确预测的样本数为零</h2>
<h2 id="关闭梯度计算">关闭梯度计算</h2>
<h2 id="迭代测试集加载器">迭代测试集加载器</h2>
<h2 id="将输入数据和标签移动到gpu上">将输入数据和标签移动到GPU上</h2>
<h2
id="使用模型进行前向传播得到输出">使用模型进行前向传播，得到输出</h2>
<h2
id="计算交叉熵损失并将损失累加到test_loss中">计算交叉熵损失，并将损失累加到<code>test_loss</code>中</h2>
<p>利用output和对应label之间计算交叉熵损失，并通过取.item()将张量转换成标量</p>
<h2
id="找到每个样本预测的类别即具有最大概率的类别">找到每个样本预测的类别，即具有最大概率的类别。</h2>
<p>通过argmax(dim =
1)获得一行的最大值，也就是这一行表示的数据被预测的类别</p>
<p>argmax函数：获得最大值下标</p>
<p>dim=0时获得的是每一列的最大值的下标</p>
<p>dim=1时获得的是每一行的最大值的下标</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213618509.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213640494.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240117213723361.png" /></p>
<h2
id="将预测结果与label比较其中正确预测的样本数累加到correct中">将预测结果与label比较，其中正确预测的样本数累加到<code>correct</code>中</h2>
<h2 id="计算平均测试损失">计算平均测试损失</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="完整代码">完整代码</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">BATCH_SIZE=<span class="number">512</span> <span class="comment">#大概需要2G的显存</span></span><br><span class="line">EPOCHS=<span class="number">20</span> <span class="comment"># 总共训练批次</span></span><br><span class="line">DEVICE = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>) <span class="comment"># 让torch判断是否使用GPU，建议使用GPU环境，因为会快很多</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 第一个卷积层，输入是1个通道（因为输入的是灰度图只有1个通道），输出根据图是6个通道</span></span><br><span class="line">        <span class="comment"># 卷积核大小是5 * 5</span></span><br><span class="line">        self.avgPool = nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)   <span class="comment"># 第一个汇聚层，汇聚层不改变通道数量</span></span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x : 1 * 28 * 28</span></span><br><span class="line">        out = self.conv1(x)     <span class="comment"># 28 - 5 + 2 * 2 + 1 = 28, 6 * 28 * 28</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (28 - 2) / 2 + 1 = 14, 6 * 14 * 14</span></span><br><span class="line">        out = self.conv2(out)   <span class="comment"># 14 - 5 + 1 = 10, 16 * 10 * 10</span></span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.avgPool(out) <span class="comment"># (10 - 2) / 2 + 1 = 5, 16 * 5 * 5</span></span><br><span class="line">        out = self.flatten(out)</span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        out = F.sigmoid(out)</span><br><span class="line">        out = self.fc3(out)</span><br><span class="line">        out = F.log_softmax(out, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, label = data.to(device), label.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(batch_idx + <span class="number">1</span>) % <span class="number">30</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据读取</span></span><br><span class="line"><span class="comment"># 建立训练集</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">	datasets.MNIST(</span><br><span class="line">    	<span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">        train = <span class="literal">True</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ]),</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 建立测试集</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    datasets.MNIST(</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">   		train = <span class="literal">False</span>,</span><br><span class="line">        download = <span class="literal">True</span>,</span><br><span class="line">        transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>))</span><br><span class="line">        ])</span><br><span class="line">    ),</span><br><span class="line">    batch_size = BATCH_SIZE,</span><br><span class="line">    shuffle = <span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化网络</span></span><br><span class="line">model = LeNet().to(DEVICE)</span><br><span class="line"><span class="comment">#定义优化器</span></span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, EPOCHS + <span class="number">1</span>):</span><br><span class="line">    train(model, DEVICE, train_loader, optimizer, epoch)</span><br><span class="line">    test(model, DEVICE, test_loader)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>注意力机制</title>
    <url>/posts/141d1667.html</url>
    <content><![CDATA[<h1 id="注意力提示">注意力提示</h1>
<h2 id="查询键和值">查询、键和值</h2>
<p>（参照下图理解定义）</p>
<p>是否包含自主性提示”将注意力机制与全连接层或汇聚层区别开来。
在注意力机制的背景下，自主性提示被称为<em>查询</em>（query）</p>
<p>给定任何查询，注意力机制通过<em>注意力汇聚</em>（attention pooling）
将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。</p>
<p>在注意力机制中，这些感官输入被称为<em>值</em>（value）
更通俗的解释，每个值都与一个<em>键</em>（key）配对，
这可以想象为感官输入的非自主提示。</p>
<p>如下图，可以通过设计注意力汇聚的方式，
便于给定的查询（自主性提示）与键（非自主性提示）进行匹配，
这将引导得出最匹配的值（感官输入）。或者说通过注意力汇聚将<em>查询</em>（自主性提示）和<em>键</em>（非自主性提示）结合在一起，实现对<em>值</em>（感官输入）的选择倾向</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/qkv.svg" /></p>
<h2 id="注意力的可视化">注意力的可视化</h2>
<p>平均汇聚层可以被视为输入的加权平均值， 其中各输入的权重是一样的</p>
<p>实际上，注意力汇聚得到的是加权平均的总和值，
其中权重是在给定的查询和不同的键之间计算得出的。</p>
<p>下图当且仅当查询和键相同时，注意力权重为1，否则为0。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/output_attention-cues_054b1a_36_0.svg" /></p>
<h2 id="注意力汇聚nadaraya-watson-核回归">注意力汇聚：Nadaraya-Watson
核回归</h2>
<p><strong>查询（自主提示）</strong>和<strong>键（非自主提示）</strong>之间的交互形成了<strong>注意力汇聚</strong></p>
<h3 id="非参数注意力汇聚">非参数注意力汇聚</h3>
<p><em>注意力汇聚</em>（attention pooling）公式：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119152405466.png" /></p>
<p>注意力汇聚是输出<span class="math inline">\(y_i\)</span>的加权平均。
将<strong>查询<span class="math inline">\(x\)</span>和键<span
class="math inline">\(x_i\)</span>之间的关系建模为
<em>注意力权重</em>（attention weight）<span
class="math inline">\(\alpha(x,x_i)\)</span></strong>，
<strong>这个权重将被分配给每一个对应值<span
class="math inline">\(y_i\)</span></strong>。 如果一个键<span
class="math inline">\(x_i\)</span>越是接近给定的查询x，
那么分配给这个键对应值<span
class="math inline">\(y_i\)</span>的注意力权重就会越大，
也就“获得了更多的注意力”。</p>
<p>对于任何查询，模型在所有键值对注意力权重都是一个有效的概率分布：
它们是非负的，并且总和为1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">n_train = <span class="number">50</span>  <span class="comment"># 训练样本数</span></span><br><span class="line">x_train, _ = torch.sort(torch.rand(n_train) * <span class="number">5</span>)   <span class="comment"># 排序后的训练样本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * torch.sin(x) + x**<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">y_train = f(x_train) + torch.normal(<span class="number">0.0</span>, <span class="number">0.5</span>, (n_train,))  <span class="comment"># 训练样本的输出</span></span><br><span class="line">x_test = torch.arange(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0.1</span>)  <span class="comment"># 测试样本</span></span><br><span class="line">y_truth = f(x_test)  <span class="comment"># 测试样本的真实输出</span></span><br><span class="line">n_test = <span class="built_in">len</span>(x_test)  <span class="comment"># 测试样本数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X_repeat的形状:(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着相同的测试输入（例如：同样的查询）</span></span><br><span class="line">X_repeat = x_test.repeat_interleave(n_train).reshape((-<span class="number">1</span>, n_train))</span><br><span class="line"><span class="comment"># x_train包含着键。attention_weights的形状：(n_test,n_train),</span></span><br><span class="line"><span class="comment"># 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重</span></span><br><span class="line">attention_weights = nn.functional.softmax(-(X_repeat - x_train)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重</span></span><br><span class="line">y_hat = torch.matmul(attention_weights, y_train)</span><br><span class="line">plot_kernel_reg(y_hat)</span><br></pre></td></tr></table></figure>
<h3 id="带参数注意力汇聚">带参数注意力汇聚</h3>
<p>带参数的模型加入可学习的参数后，
曲线在注意力权重较大的区域变得更不平滑。</p>
<p>在带参数的注意力汇聚模型中，
任何一个训练样本的输入都会和除自己以外的所有训练样本的“键－值”对进行计算，
从而得到其对应的预测输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NWKernelRegression</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**kwargs)</span><br><span class="line">        self.w = nn.Parameter(torch.rand((<span class="number">1</span>,), requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values</span>):</span><br><span class="line">        <span class="comment"># queries和attention_weights的形状为(查询个数，“键－值”对个数)</span></span><br><span class="line">        queries = queries.repeat_interleave(keys.shape[<span class="number">1</span>]).reshape((-<span class="number">1</span>, keys.shape[<span class="number">1</span>]))</span><br><span class="line">        self.attention_weights = nn.functional.softmax(</span><br><span class="line">            -((queries - keys) * self.w)**<span class="number">2</span> / <span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># values的形状为(查询个数，“键－值”对个数)</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.attention_weights.unsqueeze(<span class="number">1</span>),</span><br><span class="line">                         values.unsqueeze(-<span class="number">1</span>)).reshape(-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line"><span class="comment"># X_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输入</span></span><br><span class="line">X_tile = x_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># Y_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输出</span></span><br><span class="line">Y_tile = y_train.repeat((n_train, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># keys的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">keys = X_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># values的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)</span></span><br><span class="line">values = Y_tile[(<span class="number">1</span> - torch.eye(n_train)).<span class="built_in">type</span>(torch.<span class="built_in">bool</span>)].reshape((n_train, -<span class="number">1</span>))</span><br><span class="line">net = NWKernelRegression()</span><br><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line">animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, xlim=[<span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    trainer.zero_grad()</span><br><span class="line">    l = loss(net(x_train, keys, values), y_train)</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    trainer.step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(l.<span class="built_in">sum</span>()):<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    animator.add(epoch + <span class="number">1</span>, <span class="built_in">float</span>(l.<span class="built_in">sum</span>()))</span><br></pre></td></tr></table></figure>
<h1 id="注意力评分函数">注意力评分函数</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/attention-output.svg" /></p>
<p>高斯核指数部分可以视为<em>注意力评分函数</em>（attention scoring
function）， 简称<em>评分函数</em>（scoring function）</p>
<p>然后把这个函数的输出结果输入到softmax函数中进行运算。
通过上述步骤，将得到与键对应的值的概率分布（即注意力权重）</p>
<p>最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</p>
<p>由于注意力权重是概率分布， 因此加权和其本质上是加权平均值。</p>
<p>softmax操作用于输出一个概率分布作为注意力权重</p>
<h1 id="bahdanau-注意力">Bahdanau 注意力</h1>
<h1 id="自注意力和位置编码">自注意力和位置编码</h1>
<p>每个查询都会关注所有的键－值对并生成一个注意力输出。
由于查询、键和值来自同一组输入，因此被称为
<em>自注意力</em>（self-attention）</p>
<h1 id="transformer">Transformer</h1>
<p>Transformer的编码器和解码器是基于自注意力的模块叠加而成的，源（输入）序列和目标（输出）序列的<em>嵌入</em>（embedding）表示将加上<em>位置编码</em>（positional
encoding），再分别输入到编码器和解码器中。</p>
<p><img src="https://zh.d2l.ai/_images/transformer.svg" /></p>
<p>编码器</p>
<p>从宏观角度来看，Transformer的编码器是由多个相同的层叠加而成的，每个层都有两个子层（子层表示为sublayer）。第一个子层是<em>多头自注意力</em>（multi-head
self-attention）汇聚；第二个子层是<em>基于位置的前馈网络</em>（positionwise
feed-forward network）。</p>
<p>具体来说，在计算编码器的自注意力时，查询、键和值都来自前一个编码器层的输出</p>
<p>每个子层都采用了<em>残差连接</em>（residual connection）</p>
<p>在残差连接的加法计算之后，紧接着应用<em>层规范化</em>（layer
normalization）</p>
<p>解码器</p>
<p>由多个相同的层叠加而成的，并且层中使用了残差连接和层规范化。</p>
<p>除了编码器中描述的两个子层之外，解码器还在这两个子层之间插入了第三个子层，称为<em>编码器－解码器注意力</em>（encoder-decoder
attention）层</p>
<p>在编码器－解码器注意力中，查询来自前一个解码器层的输出，而键和值来自整个编码器的输出。在解码器自注意力中，查询、键和值都来自上一个解码器层的输出。</p>
<p>但是，解码器中的每个位置只能考虑该位置之前的所有位置。这种<em>掩蔽</em>（masked）注意力保留了<em>自回归</em>（auto-regressive）属性，确保预测仅依赖于已生成的输出词元。</p>
<h2 id="基于位置的前馈网络">基于位置的前馈网络</h2>
<h2 id="残差连接和层规范化">残差连接和层规范化</h2>
<h2 id="编码器">编码器</h2>
<h2 id="解码器">解码器</h2>
<h1 id="预训练">预训练</h1>
<p><strong>越浅的层学到的特征越通用（横竖撇捺），越深的层学到的特征和具体任务的关联性越强（人脸-人脸轮廓、汽车-汽车轮廓）</strong></p>
<p>上述利用网络上现有图片的思想就是预训练的思想，具体做法就是：</p>
<ol type="1">
<li>通过 ImageNet 数据集我们训练出一个模型 A</li>
<li>由于上面提到 CNN 的浅层学到的特征通用性特别强，我们可以对模型 A
做出一部分改进得到模型 B（两种方法）：
<ol type="1">
<li>冻结：浅层参数使用模型 A
的参数，高层参数随机初始化，<strong>浅层参数一直不变</strong>，然后利用领导给出的
30 张图片训练参数</li>
<li>微调：浅层参数使用模型 A
的参数，高层参数随机初始化，然后利用领导给出的 30
张图片训练参数，<strong>但是在这里浅层参数会随着任务的训练不断发生变化</strong></li>
</ol></li>
</ol>
<p>对于一个具有少量数据的任务 A，首先通过一个现有的大量数据搭建一个 CNN
模型 A，由于 CNN的浅层学到的特征通用性特别强，因此在搭建一个 CNN 模型
B，其中模型 B 的浅层参数使用模型 A 的浅层参数，模型 B
的高层参数随机初始化，然后通过冻结或微调的方式利用任务 A 的数据训练模型
B，模型 B 就是对应任务 A 的模型。</p>
<p>预训练的思想：任务 A 对应的模型 A
的参数不再是随机初始化的，而是通过任务 B 进行预先训练得到模型
B，然后利用模型 B 的参数对模型 A 进行初始化，再通过任务 A 的数据对模型 A
进行训练。</p>
<p>注：模型 B 的参数是随机初始化的。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习中过拟合和欠拟合及其解决方法</title>
    <url>/posts/807ee252.html</url>
    <content><![CDATA[<h1 id="专有名词解释">专有名词解释</h1>
<h2
id="用于对抗过拟合的技术称为正则化">用于对抗过拟合的技术称为<em>正则化</em></h2>
<h2 id="训练误差training-error"><em>训练误差</em>（training error）</h2>
<p>模型在训练数据集上计算得到的误差</p>
<h2 id="泛化误差generalization-error"><em>泛化误差</em>（generalization
error）</h2>
<p>模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。实际中，我们只能通过将模型应用于一个独立的测试集来估计泛化误差，
该测试集由随机选取的、未曾在训练集中出现的数据样本构成</p>
<span id="more"></span>
<h1 id="解决方法">解决方法</h1>
<h2 id="k折交叉验证">K折交叉验证</h2>
<p>原始训练数据被分成k个不重叠的子集。
然后执行k次模型训练和验证，每次在k−1个子集上进行训练，
并在剩余的一个子集（在该轮中没有用于训练的子集）上进行验证。
最后，通过对k次实验的结果取平均来估计训练和验证误差。</p>
<h2
id="应用最广泛的解决过拟合的正则化方法权重衰减">应用最广泛的解决过拟合的正则化方法：权重衰减</h2>
<p>通常也被称为L2<em>正则化</em></p>
<p>L2正则化线性模型构成经典的<em>岭回归</em>（ridge regression）算法</p>
<p>使用L2范数的一个原因是它对权重向量的大分量施加了巨大的惩罚。
这使得我们的学习算法偏向于在大量特征上均匀分布权重的模型</p>
<h2 id="暂退法dropout">暂退法(Dropout)</h2>
<h3 id="定义">定义</h3>
<p>在前向传播过程中，计算每一内部层的同时注入噪声</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116143311841.png" /></p>
<h3 id="应用">应用</h3>
<p>可以将暂退法应用于每个隐藏层的输出（在激活函数之后）），
并且可以为每一层分别设置暂退概率</p>
<p>常见的技巧是在靠近输入层的地方设置较低的暂退概率</p>
<p>对于深度学习框架的高级API，我们只需在每个全连接层之后添加一个<code>Dropout</code>层，
将暂退概率作为唯一的参数传递给它的构造函数。
在训练时，<code>Dropout</code>层将根据指定的暂退概率随机丢弃上一层的输出（相当于下一层的输入）。
在测试时，<code>Dropout</code>层仅传递数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">        nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout1),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout2),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br></pre></td></tr></table></figure>
<h2 id="批量规范化">批量规范化</h2>
<h3 id="基本原理">基本原理</h3>
<p>在每次训练迭代中，我们首先规范化输入，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。
接下来，我们应用比例系数和比例偏移。</p>
<h3 id="批量规范化层">批量规范化层</h3>
<h4 id="全连接层">全连接层</h4>
<p>将批量规范化层置于全连接层中的仿射变换和激活函数之间</p>
<h4 id="卷积层">卷积层</h4>
<p>在卷积层之后和非线性激活函数之前应用批量规范化</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), </span><br><span class="line">    BatchNorm(<span class="number">6</span>, num_dims=<span class="number">4</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    </span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), </span><br><span class="line">    BatchNorm(<span class="number">16</span>, num_dims=<span class="number">4</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), </span><br><span class="line">    </span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">120</span>), </span><br><span class="line">    BatchNorm(<span class="number">120</span>, num_dims=<span class="number">2</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    </span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), </span><br><span class="line">    BatchNorm(<span class="number">84</span>, num_dims=<span class="number">2</span>), </span><br><span class="line">    nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>现代卷积神经网络</title>
    <url>/posts/d17cd37c.html</url>
    <content><![CDATA[<h1 id="深度卷积神经网络alexnet">深度卷积神经网络AlexNet</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/alexnet.svg" /></p>
<h2 id="组成">组成</h2>
<ol type="1">
<li>AlexNet比相对较小的LeNet5要深得多。AlexNet由八层组成：五个卷积层、两个全连接隐藏层和一个全连接输出层。</li>
<li>AlexNet使用ReLU而不是sigmoid作为其激活函数</li>
<li>通过暂退法控制全连接层的模型复杂度</li>
</ol>
<h1 id="vgg网络">VGG网络</h1>
<h2 id="组成-1">组成</h2>
<p>经典卷积神经网络的基本组成部分是下面的这个序列：</p>
<ol type="1">
<li>带填充以保持分辨率的卷积层；</li>
<li>非线性激活函数，如ReLU；</li>
<li>汇聚层，如最大汇聚层。</li>
</ol>
<p>VGG网络可以分为两部分：</p>
<p>第一部分主要由卷积层和汇聚层组成</p>
<p>第二部分由全连接层组成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/vgg.svg" /></p>
<p>VGG神经网络连接
的几个VGG块（在<code>vgg_block</code>函数中定义）。其中有超参数变量<code>conv_arch</code>。该变量指定了每个VGG块里卷积层个数和输出通道数。</p>
<p>如下是一种VGG11网络</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1375095-20210521111000341-99893785.png" /></p>
<h2
id="运用在前向传播的过程中从之前层的拼接变成块的拼接">运用：在前向传播的过程中从之前层的拼接变成块的拼接</h2>
<p>就是常常用如下写法将卷积层，激活函数，池化层放到一个块中，全连接层，激活函数，Dropout函数放到另一个层，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">self.block1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(in_channel, out_channel, kernel_size),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size)</span><br><span class="line">)</span><br><span class="line">self.block2 = nn.Sequential(</span><br><span class="line">    nn.Linear(in_features, out_features),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Dropout2d(<span class="number">0.5</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="网络中的网络nin">网络中的网络NiN</h1>
<h2 id="设计思想">设计思想</h2>
<p>1.NiN的想法是在每个像素位置（针对每个高度和宽度）应用一个全连接层</p>
<p>2.将空间维度中的每个像素视为单个样本，将通道维度视为不同特征（feature）。</p>
<h2 id="组成-2">组成</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/nin.svg" /></p>
<h3 id="卷积块nin设计">卷积块NiN设计</h3>
<ol type="1">
<li><p>NiN块以一个普通卷积层开始，后面是两个1×1的卷积层。这两个1×1卷积层充当带有ReLU激活函数的逐像素全连接层。
第一层的卷积窗口形状通常由用户设置。
随后的卷积窗口形状固定为1×1。</p></li>
<li><p>上面这样的块设计三个，每个块的第一个卷积层窗口形状为11×11、5×5和3×3</p></li>
<li><p>每个NiN块后有一个最大汇聚层，汇聚窗口形状为3×3，步幅为2。</p></li>
</ol>
<h3 id="取消全连接层的替代设计">取消全连接层的替代设计</h3>
<ol type="1">
<li><p>NiN完全取消了全连接层，使用一个NiN块，其输出通道数等于标签类别的数量</p></li>
<li><p>通过一个<em>全局平均汇聚层</em>（global average pooling
layer），生成一个对数几率 （logits）</p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, strides, padding</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">        nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>), nn.ReLU())</span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标签类别数是10</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    <span class="comment"># 将四维的输出转成二维的输出，其形状为(批量大小,10)</span></span><br><span class="line">    nn.Flatten())</span><br></pre></td></tr></table></figure>
<h1 id="含并行连结的网络googlenet">含并行连结的网络（GoogLeNet）</h1>
<p>吸收了NiN中串联网络的思想，并在此基础上做了改进</p>
<p>解决了什么样大小的卷积核最合适的问题</p>
<h2 id="组成-3">组成</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/inception-full.svg" /></p>
<h3 id="卷积块inception块">卷积块Inception块</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/inception.svg" /></p>
<ol type="1">
<li><p>由四条并行路径组成</p></li>
<li><p>前三条路径使用窗口大小为1×1、3×3和5×5的卷积层，从不同空间大小中提取信息，其中1×1卷积层直接接到通道合并层，3×3和5×5的卷积层是先在输入上执行1×1卷积，以减少通道数，从而降低模型的复杂性，然后再分别接上，最后接到合并层</p></li>
<li><p>第四条路径使用3×3最大汇聚层，然后使用1×1卷积层来改变通道数</p></li>
<li><p>这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出</p></li>
</ol>
<p>注：通常调整的超参数是每层输出通道数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module):</span><br><span class="line">    <span class="comment"># c1--c4是每条路径的输出通道数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, c1, c2, c3, c4, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 线路1，单1x1卷积层</span></span><br><span class="line">        self.p1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c1, kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 线路2，1x1卷积层后接3x3卷积层</span></span><br><span class="line">        self.p2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c2[<span class="number">0</span>], kernel_size=<span class="number">1</span>),	<span class="comment">#c2[0]表示这一路1 x 1层的输出，也是3 x 3层的输入 	</span></span><br><span class="line">            nn.Conv2d(c2[<span class="number">0</span>], c2[<span class="number">1</span>], kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),	<span class="comment">#c2[0]表示这一路3 x 3层的输出</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 线路3，1x1卷积层后接5x5卷积层</span></span><br><span class="line">        self.p3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels, c3[<span class="number">0</span>], kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.Conv2d(c3[<span class="number">0</span>], c3[<span class="number">1</span>], kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 线路4，3x3最大汇聚层后接1x1卷积层</span></span><br><span class="line">        self.p4 = nn.Sequential(</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.Conv2d(in_channels, c4, kernel_size=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 在通道维度上连结输出</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat((p1, p2, p3, p4), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="其他块">其他块</h3>
<h4 id="b1">b1</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091329812.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b2">b2</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091422012.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b2 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b3">b3</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091547062.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b3 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">192</span>, <span class="number">64</span>, (<span class="number">96</span>, <span class="number">128</span>), (<span class="number">16</span>, <span class="number">32</span>), <span class="number">32</span>),</span><br><span class="line">    Inception(<span class="number">256</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">192</span>), (<span class="number">32</span>, <span class="number">96</span>), <span class="number">64</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b4">b4</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091624806.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b4 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">480</span>, <span class="number">192</span>, (<span class="number">96</span>, <span class="number">208</span>), (<span class="number">16</span>, <span class="number">48</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">160</span>, (<span class="number">112</span>, <span class="number">224</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">128</span>, (<span class="number">128</span>, <span class="number">256</span>), (<span class="number">24</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">512</span>, <span class="number">112</span>, (<span class="number">144</span>, <span class="number">288</span>), (<span class="number">32</span>, <span class="number">64</span>), <span class="number">64</span>),</span><br><span class="line">    Inception(<span class="number">528</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b5">b5</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119091759065.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">b5 = nn.Sequential(</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">256</span>, (<span class="number">160</span>, <span class="number">320</span>), (<span class="number">32</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    Inception(<span class="number">832</span>, <span class="number">384</span>, (<span class="number">192</span>, <span class="number">384</span>), (<span class="number">48</span>, <span class="number">128</span>), <span class="number">128</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">1024</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="残差网络resnet">残差网络（ResNet）</h1>
<p>## 组成</p>
<h3 id="残差块">残差块</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/residual-block.svg" /></p>
<h4 id="基本定义">基本定义：</h4>
<ol type="1">
<li><p>假设我们的原始输入为x，而希望学出的理想映射为f(x),上图左图虚线框中的部分需要直接拟合出该映射f(x)，而右图虚线框中的部分则需要拟合出残差映射f(x)
- x</p></li>
<li><p>在残差块中，输入可通过跨层数据线路更快地向前传播</p></li>
</ol>
<h4 id="组成-4">组成</h4>
<h5 id="基本结构">基本结构</h5>
<ol type="1">
<li><p>残差块里首先有2个有相同输出通道数的3×3卷积层。
每个卷积层后接一个批量规范化层和ReLU激活函数,然后通过跨层数据通路，跳过这2个卷积运算，将输入直接加在最后的ReLU激活函数前</p></li>
<li><p>要求2个卷积层的输出与输入形状一样，从而使它们可以相加</p></li>
</ol>
<h5 id="改变通道数">改变通道数</h5>
<p>通过引入一个额外的1×1卷积层来将输入变换成需要的形状（另一条正常计算的路已经改变通道数了）后再做相加运算</p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels, use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.block1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(input_channels, num_channels,kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(num_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = self.block1(X)</span><br><span class="line">        Y = self.block2(Y)</span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure>
<p>生成两种类型的网络：
一种是当<code>use_1x1conv=False</code>时，应用ReLU非线性函数之前，将输入添加到输出。
另一种是当<code>use_1x1conv=True</code>时，添加通过1×1卷积调整通道和分辨率。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/resnet-block.svg" /></p>
<h3 id="其他块以resnet-18为例">其他块(以ResNet-18为例)</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/resnet18.svg" /></p>
<h4 id="b1-1">b1</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119105305392.png" /></p>
<p>前两层在输出通道数为64、步幅为2的7×7卷积层后接批量规范化层，再接步幅为2的3×3的最大汇聚层</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.b1 = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">    nn.BatchNorm2d(<span class="number">64</span>), </span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="b2-b3-b4-b5">b2, b3, b4, b5</h4>
<p>使用4个由残差块组成的模块，</p>
<p>每个模块使用若干个残差块构成（下面举的例子是2个）。</p>
<p>第一个模块的通道数同输入通道数一致。
因为之前已经使用了步幅为2的最大汇聚层，所以无须减小高和宽。
之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="comment"># 第一个模块（b2）的resnet块我们不进行高宽减半、通道翻倍，不然减太多了</span></span><br><span class="line">        <span class="comment"># 如果不是第一个模块，就在该模块第一个resnet块进行一次高宽减半通道加倍操作,因此要用1x1conv处理变换残差项X       </span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block: <span class="comment"># i为bx模块中的第i个残差块，first_block表示为b2模块</span></span><br><span class="line">            blk.append(Residual(input_channels, num_channels, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line">self.b2 = nn.Sequential(resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">self.b3 = nn.Sequential(resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">self.b4 = nn.Sequential(resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">self.b5 = nn.Sequential(resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>在ResNet中加入全局平均汇聚层，以及全连接层输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>完整残差网络实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels, use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.block1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(num_channels, num_channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(num_channels),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        Y = self.block1(X)</span><br><span class="line">        Y = self.block2(Y)</span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X</span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet18</span>(nn.Module):</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals, first_block=<span class="literal">False</span></span>):</span><br><span class="line">        blk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">                blk.append(Residual(input_channels, num_channels, use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                blk.append(Residual(num_channels, num_channels))</span><br><span class="line">        <span class="keyword">return</span> blk</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet18, self).__init__()</span><br><span class="line">        self.b1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>), </span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.b2 = nn.Sequential(*self._resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">        self.b3 = nn.Sequential(*self._resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">        self.b4 = nn.Sequential(*self._resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">        self.b5 = nn.Sequential(*self._resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br><span class="line">        self.last = nn.Sequential(</span><br><span class="line">            nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            nn.Flatten(), </span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.b1(x)</span><br><span class="line">        output = self.b2(output)</span><br><span class="line">        output = self.b3(output)</span><br><span class="line">        output = self.b4(output)</span><br><span class="line">        output = self.b5(output)</span><br><span class="line">        output = self.last(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>自动编码器</title>
    <url>/posts/8ed365e4.html</url>
    <content><![CDATA[<h1 id="自动编码器特点">自动编码器特点</h1>
<p>1
跟数据相关程度很高，这意味着自动编码器只能压缩与训练数据相似的数据</p>
<p>2 压缩后数据是有损的</p>
<h1 id="自动编码器的构成">自动编码器的构成</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-e627f25d4e5766c8876ef6251291c3b8_r.jpg" /></p>
<p>第一个部分是编码器（Encoder），第二个部分是解码器（Decoder），编码器和解码器都可以是任意的模型，通常使用神经网络作为编码器和解码器</p>
<h1 id="自动编码器应用">自动编码器应用</h1>
<p>1 <strong>数据去噪</strong></p>
<p>噪声是测量中的随机误差或偏差，包括错误值或者偏离期望的孤立点。简单来说就是对任务或者模型没有帮助甚至有误导作用的数据。</p>
<p>编码器通过学习将潜在空间中的尽可能多的相关信息保留，丢弃不相关部分（噪声）。</p>
<p>解码器学习潜在空间信息重建与输入一致的，这样就达到了去噪。</p>
<p>2 <strong>可视化降维</strong></p>
<p>设置合适的维度和稀疏约束，自编码器可以学习到比PCA等技术更有意思的数据投影。因为自编码属于无监督学习，所以只需要训练数据就可以得到较好的特征</p>
<p>3 <strong>特征提取</strong></p>
<p>自动编码器学习到的特征h，可以作为有监督模型的输入，这样就起到了特征提取器的作用。</p>
<h1
id="自动编码器对深层网络分层训练的过程">自动编码器对深层网络分层训练的过程</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-986dfffa005ff2b3fae2d88e928d5e03_720w.webp" /></p>
<p>传递到一层，先通过这层的encode编码，再通过decode解码，将解码出来的结果output与原始input比较，相似到某种程度(专业点就是重构误差最小)，这时候可以将这一层的output传递作为下一层的input，否则继续调整参数，每一层操作都类似</p>
<h1
id="几种自动编码器基于pytorch的实现">几种自动编码器基于pytorch的实现</h1>
<h2 id="基于全连接层的实现">基于全连接层的实现</h2>
<h3 id="特点">特点</h3>
<p>1 上一层的输出通道等于下一层的输入</p>
<p>2 解码器正好与编码器对称</p>
<p>3 损失函数：均方误差损失函数
<code>nn.MSELoss()</code>，而不是交叉熵损失。这是因为自动编码器的任务是重建输入数据，而不是进行分类。</p>
<p>4 图片保存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;&#125;, loss is &#123;&#125;&quot;</span>.<span class="built_in">format</span>((epoch+<span class="number">1</span>), loss.data))</span><br><span class="line">    pic = to_img(output.cpu().data)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./simple_autoencoder&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./simple_autoencoder&#x27;</span>)</span><br><span class="line">    save_image(pic, <span class="string">&#x27;./simple_autoencoder/image_&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><code>to_img(output.cpu().data)</code>
将模型输出转换成图像格式，然后通过 <code>save_image</code>
函数将这个batch的图像拼接保存到一个文件中，文件名包含了该周期的信息。这样，就可以观察到每5个周期训练过程中模型生成的图像重建效果。</p>
<p>4 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122175827883.png" /></p>
<h3 id="代码">代码</h3>
<h2 id="基于卷积神经网络的实现">基于卷积神经网络的实现</h2>
<h3 id="特点-1">特点</h3>
<p>反卷积</p>
<p>1
卷积神经网络相对于全连接的实现要自由得多，<strong>解码器</strong>只需要在<strong>第一层反卷积输入通道数</strong>等于<strong>编码器最后一层卷积输出通道数</strong>，<strong>解码器最后一层反卷积输出通道数</strong>等于<strong>编码器第一层卷积输入通道数</strong></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123081036211.png" /></p>
<p>2 计算公式</p>
<p>解码器前面可以随便浪，但最后一层一定要将图片恢复到原来输入的样子，不仅包括通道，还有宽和高</p>
<p>常用公式的简化版本</p>
<p><span class="math inline">\(图像输出尺寸 = (图像输入尺寸 - 1) × 步长
- 2 × 填充 + 卷积核大小\)</span></p>
<h3 id="代码-1">代码</h3>
<h2 id="变分自动编码器">变分自动编码器</h2>
<h3 id="特点-2">特点</h3>
<p>一般的编码器只能“一对一”，给它什么它就会尽可能解码出什么</p>
<p>变分自动编码器通过给它一个标准正态分布的随机隐含向量，通过解码器就能够生成想要的图片，而不需要先给它一张原始图片编码。</p>
<p>在实际情况中，需要在模型的准确率和隐含向量服从标准正态分布之间做一个权衡，所谓模型的准确率就是指解码器生成的图片与原始图片的相似程度。可以让神经网络自己做这个决定，只需要将两者都做一个loss，然后求和作为总的loss，这样网络就能够自己选择如何做才能使这个总的loss下降</p>
<p>另外要衡量两种分布的相似程度，需要引入一个新的概念，KL
divergence，这是用来衡量两种分布相似程度的统计量，它越小，表示两种概率分布越接近。</p>
<p>本质上VAE就是在encoder的结果添加了高斯噪声，通过训练要使得decoder对噪声有一定的鲁棒性，这样的话我们生成一张图片就没有必须用一张图片先做编码了，可以想象，我们只需要利用训练好的encoder对一张图片编码得到其分布后，符合这个分布的隐含向量理论上都可以通过decoder得到类似这张图片的图片。</p>
<p>n.MSE()函数，需要声明的是nn.MSE(reduction='sum')求的是每个batchsize上的loss值，最后除以batchsize就可以得到每个输入的loss均值；nn.MSE(reduction='mean')求的是所有元素的均值，而非每个输入的均值，因为每个输入是28<em>28的向量，使用nn.MSE(reduction='mean')计算出来的是nn.MSE(reduction='sum')/(784
</em> batchsize)。所以我们这里用的是nn.MSE(reduction='sum'。)</p>
<h3 id="代码-2">代码</h3>
<p><a
href="https://zhuanlan.zhihu.com/p/34998569">关于VAE的详细解释</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/67742390">参考文章</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>自建数据集完成二分类任务</title>
    <url>/posts/8f9c7cbf.html</url>
    <content><![CDATA[<h1 id="自建数据集完成二分类任务参考文章">自建数据集完成二分类任务（<a
href="https://zhuanlan.zhihu.com/p/466699075">参考文章</a>）</h1>
<h2 id="图片预处理">1 图片预处理</h2>
<h3 id="统一图片格式">1 .1 统一图片格式</h3>
<p><strong>找到的图片需要首先做相同尺寸的裁剪，归一化</strong>，否则会因为图片大小不同报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RuntimeError: stack expects each tensor to be equal size,</span><br><span class="line">but got [3, 667, 406] at entry 0 and [3, 600, 400] at entry 1</span><br></pre></td></tr></table></figure>
<p>pytorch的<code>torchvision.transforms</code>模块提供了许多用于图片变换/增强的函数。</p>
<h4 id="把图片压缩为固定大小">1.1.1 把图片压缩为固定大小</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.Resize((600,600)),</span><br></pre></td></tr></table></figure>
<h4 id="裁剪保留核心区">1.1.2 裁剪保留核心区</h4>
<p>因为主体要识别的图像一般在中心位置，所以使用<code>CenterCrop</code>，这里设置为（400，
400）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.CenterCrop((400,400)),</span><br></pre></td></tr></table></figure>
<h4 id="处理成统一数据类型">1.1.3 处理成统一数据类型</h4>
<p>这里统一成<code>torch.float64</code>方便神经网络计算,也可以统一成其他比如uint32等类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.ConvertImageDtype(torch.float64),</span><br></pre></td></tr></table></figure>
<h4 id="归一化进一步缩小图片范围">1.1.4 归一化进一步缩小图片范围</h4>
<p>对于图片来说<code>0~255</code>的范围有点大，并不利于模型梯度计算，我们应该进行归一化。pytorch当中也提供了归一化的函数<code>torchvision.transforms.Normalize(mean,std)</code>，</p>
<ul>
<li>我们可以使用<code>[0.5,0.5,0.5]</code>的<code>mean,std</code>来把数据归一化至<code>[-1,1]</code></li>
<li>也可以手动计算出所有的图片<code>mean,std</code>来归一化至均值为0，标准差为1的正态分布，</li>
<li>一些深度学习代码常常使用<code>mean=[0.485, 0.456, 0.406]</code>
,<code>std=[0.229, 0.224, 0.225]</code>的归一化数据，这是在<code>ImageNet</code>的几百万张图片数据计算得出的结果</li>
<li><code>BN</code>等方法也具有很出色的归一化表现，我们也会使用到</li>
</ul>
<blockquote>
<p><a
href="https://zhuanlan.zhihu.com/p/33173246">Juliuszh：详解深度学习中的Normalization，BN/LN/WN</a>
<a
href="https://zhuanlan.zhihu.com/p/93643523">Algernon：【基础算法】六问透彻理解BN(Batch
Normalization）</a></p>
</blockquote>
<p>我们这里使用简单的<code>[0.5,0.5,0.5]</code>归一化方法，更新<code>cls_dataset</code>,加入<code>transform</code>操作
，作为图片裁剪的预处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transforms.Normalize([0.5,0.5,0.5],[0.5,0.5,0.5])</span><br></pre></td></tr></table></figure>
<p>关于<code>transforms</code>的操作大体分为裁剪/翻转和旋转/图像变换/transform自身操作，具体见<a
href="https://zhuanlan.zhihu.com/p/53367135">余霆嵩：PyTorch
学习笔记（三）：transforms的二十二个方法</a>，这里不进行详细展开。</p>
<h3 id="数据增强">1.2 数据增强</h3>
<p>当数据集较小时，可以通过对已有图片做数据增强，利用之前提到的<code>transforms</code>中的函数
，也可以混合使用来<strong>根据已有数据创造新数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.data_enhancement = transforms.Compose([</span><br><span class="line">    transforms.RandomHorizontalFlip(p=<span class="number">1</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">30</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="创建自制数据集">2 创建自制数据集</h2>
<h3 id="以dataset类接口为模版">2.1 以Dataset类接口为模版</h3>
<h4 id="构造函数__init__self">构造函数__init__(self)</h4>
<p>用于初始化对象。在这个方法中，可以进行一些必要的设置和准备工作，例如加载数据、指定数据集路径等
#### <strong>getitem</strong>(self, index) Dataset
类的一个必须实现的方法。在这个方法中，需要实现如何从数据集中获取数据和标签，并以返回数据样本(feature)对应的标签(label)。
#### <strong>len</strong>(self) Dataset
类的一个必须实现的方法。它用于返回数据集中样本的总数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.util.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cls_dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">       <span class="comment"># initialization</span></span><br><span class="line">      。</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># return data,label in set </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># return the length of the dataset</span></span><br></pre></td></tr></table></figure>
<h3 id="创建set">2.2 创建set</h3>
<h4
id="定义两个空列表data_list和target_list">2.2.1定义两个空列表data_list和target_list</h4>
<h4 id="遍历文件夹">2.2.2遍历文件夹</h4>
<h4
id="读取图片对象对每一个图片对象预处理后分别将图片对象和对应的标签加入data_list和target_list中">2.2.3读取图片对象，对每一个图片对象预处理后，分别将图片对象和对应的标签加入data_list和target_list中</h4>
<h4
id="将data_list和target_list加入h5dfile中">2.2.4将data_list和target_list加入h5dfile中</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">from</span> torchvision.io <span class="keyword">import</span> read_image</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bird_flower_dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path, train_dataset_path, test_dataset_path</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.labels = [<span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;flower&#x27;</span>]</span><br><span class="line">        self.file_path = file_path</span><br><span class="line">        self.train_dataset_path = train_dataset_path</span><br><span class="line">        self.test_dataset_path = test_dataset_path</span><br><span class="line">        <span class="comment"># 如果保存数据集的文件不存在,就创建这个文件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">            self._create_h5_file(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 如果对应下标的label是bird，返回的label是一维张量0，反之返回1</span></span><br><span class="line">            <span class="keyword">if</span> f[<span class="string">&#x27;label&#x27;</span>][index].decode() == <span class="string">&quot;bird&quot;</span>:</span><br><span class="line">                label = torch.tensor(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label = torch.tensor(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> f[<span class="string">&#x27;image&#x27;</span>][index], label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(f[<span class="string">&#x27;label&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果文件不存在，就创建文件的静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_create_h5_file</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> h5py.File(self.file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 定义转换图片格式的轨道</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">600</span>, <span class="number">600</span>)),</span><br><span class="line">                transforms.CenterCrop((<span class="number">400</span>, <span class="number">400</span>)),</span><br><span class="line">                transforms.ConvertImageDtype(torch.float64),    <span class="comment"># 这行代码的作用是将图片像素点的数据类型转换为double（float64就是double）</span></span><br><span class="line">                transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">            ])</span><br><span class="line">            <span class="comment"># 创建保存图片的列表</span></span><br><span class="line">            img_list = []</span><br><span class="line">            <span class="comment"># 创建保存每个index对应图片的label</span></span><br><span class="line">            label_list = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断是训练集还是测试集, 因为数据集文件名称要么是train.hdf5,要么是test.hdf5</span></span><br><span class="line">            dataset_kind = self.file_path.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> dataset_kind == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                dataset_path = self.train_dataset_path</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dataset_path = self.test_dataset_path</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                文件夹组成</span></span><br><span class="line"><span class="string">                | —— train</span></span><br><span class="line"><span class="string">                |   | —— flower</span></span><br><span class="line"><span class="string">                |   |   | —— 图片1</span></span><br><span class="line"><span class="string">                |   | —— bird</span></span><br><span class="line"><span class="string">                |   | —— | —— 图片2</span></span><br><span class="line"><span class="string">                | —— test</span></span><br><span class="line"><span class="string">                |   | —— flower</span></span><br><span class="line"><span class="string">                |   | —— bird</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历数据集</span></span><br><span class="line">            <span class="keyword">for</span> directory, _, images <span class="keyword">in</span> tqdm(os.walk(dataset_path)):</span><br><span class="line">                label = directory.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">                    img = read_image(os.path.join(directory, img))  <span class="comment">#以张量形式读取图片对象</span></span><br><span class="line">                    img = transform(img)    <span class="comment">#预处理图片</span></span><br><span class="line">                    img = np.array(img).astype(np.float64)  <span class="comment"># 这里的作用也是呼应之前转为64位</span></span><br><span class="line">                    img_list.append(img)    <span class="comment">#将图片对象添加到列表里</span></span><br><span class="line">                    label_list.append(label.encode())   <span class="comment">#将label编码后添加到列表里</span></span><br><span class="line">            f.create_dataset(<span class="string">&quot;image&quot;</span>, data=img_list)</span><br><span class="line">            <span class="comment"># 在一个 HDF5 文件中创建了一个名为 &quot;image&quot; 的数据集，并将 data_list 中的数据作为该数据集的内容</span></span><br><span class="line">            f.create_dataset(<span class="string">&quot;label&quot;</span>, data=label_list)</span><br><span class="line">            <span class="comment"># 在同一个HDF5文件中创建了一个名为 &quot;label&quot; 的数据集，并将 label_list 中的数据作为该数据集的内容，并且该数据集在index相同时与前面 data_list 是一一对应</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/微信图片_20231115173321.jpg" /></p>
<h3 id="创建loader">2.3 创建loader</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义加载训练集的loader</span></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    bird_flower_dataset(<span class="string">&quot;train.hdf5&quot;</span>, train_set_path, test_set_path),</span><br><span class="line">    batch_size=<span class="number">4</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定义加载测试集的loader</span></span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    bird_flower_dataset(<span class="string">&quot;test.hdf5&quot;</span>, train_set_path, test_set_path),</span><br><span class="line">    batch_size=<span class="number">4</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="搭建网络">3 搭建网络</h2>
<h3 id="网络结构">网络结构</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231115172005.jpg" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">conv_net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">16</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(in_features=<span class="number">64</span> * <span class="number">98</span> * <span class="number">98</span>, out_features=<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(in_features=<span class="number">500</span>, out_features=<span class="number">2</span>)</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__forward__</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.conv1(x)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.maxpool(output)</span><br><span class="line">        output = self.conv2(output)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.maxpool(output)</span><br><span class="line">        output = self.flatten(output)</span><br><span class="line">        output = self.fc1(output)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output = self.fc2(output)</span><br><span class="line">        <span class="keyword">return</span>  output</span><br></pre></td></tr></table></figure>
<h2 id="训练与测试">4 训练与测试</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义训练函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 这里将data加载到device前需要将其数据用type(torch.FloatTensor)自适应为网络可以接受的数据类型</span></span><br><span class="line">        data, label = data.<span class="built_in">type</span>(torch.FloatTensor).to(DEVICE), label.to(DEVICE)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.cross_entropy(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Train Epoch: <span class="subst">&#123;epoch&#125;</span> [<span class="subst">&#123;batch_idx * <span class="built_in">len</span>(data)&#125;</span>/<span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader):<span class="number">.0</span>f&#125;</span>%)]\tLoss: <span class="subst">&#123;loss.item():<span class="number">.6</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">model, device, test_loader</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, label = data.<span class="built_in">type</span>(torch.FloatTensor).to(device), label.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += criterion(output, label).item()</span><br><span class="line">            pred = output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">            correct += pred.eq(label).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nTest set: Average loss: <span class="subst">&#123;test_loss :<span class="number">.4</span>f&#125;</span>, Accuracy: <span class="subst">&#123;correct&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(test_loader.dataset)&#125;</span> (<span class="subst">&#123;<span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset) :<span class="number">.2</span>f&#125;</span> %)\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="保存模型">5 保存模型</h2>
<h3 id="训练好后保存模型">训练好后保存模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在训练完成,导出保存的模型，测试</span></span><br><span class="line">model = ConvNet().to(DEVICE)</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">f&#x27;model_weights/best_model.pth&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="使用之前保存好的模型">使用之前保存好的模型</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载并预处理测试图像</span></span><br><span class="line">test_image = load_and_preprocess_image(test_image_path)</span><br><span class="line"><span class="comment"># 利用训练好的模型进行预测</span></span><br><span class="line">prediction = predict_single_image(model, test_image, DEVICE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实践</category>
      </categories>
  </entry>
  <entry>
    <title>高斯模糊</title>
    <url>/posts/a45cef5f.html</url>
    <content><![CDATA[<h1 id="滤波">滤波</h1>
<p>1 滤波是对输入信号进行卷积处理的一个过程，分两步 1.1
<strong>计算掩膜</strong></p>
<p>1.2
将计算出的掩膜与原图<strong>卷积</strong>——掩膜上每一个位置的值和图像上对应位置的像素值的乘加运算</p>
<p>2 <strong>卷积模板/掩膜
的不同决定了不同的滤波方式</strong>，也因此产生了高通、低通、带通、带阻等基本的滤波方式。</p>
<p>低通滤波，就是保留将信号中的低频部分，抑制高频部分。要达到这个目的，可以利用均值掩膜、<a
href="https://www.zhihu.com/search?q=高斯掩膜&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142137732%7D">高斯掩膜</a>等对输入信号进行处理。
采用均值掩膜对输入信号进行卷积的滤波方式叫<a
href="https://www.zhihu.com/search?q=均值滤波&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A142137732%7D">均值滤波</a>；
采用高斯掩膜对输入信号进行卷积的滤波方式叫高斯滤波；</p>
<p>举个例子：<strong>均值掩膜</strong></p>
<p>3x3均值滤波的掩膜：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-2924c99c9034c212da82d089991efd8c_720w.webp" /></p>
<p>均值掩膜内所有<strong>系数均相等</strong>——为1/9，且他们的<strong>和为1</strong></p>
<h1
id="高斯滤波高斯滤波和高斯模糊指的是一个操作">高斯滤波（高斯滤波和高斯模糊指的是一个操作）</h1>
<h2 id="高斯分布">高斯分布</h2>
<p>正态分布,<span
class="math inline">\(\mu\)</span>决定了分布对称中心，<span
class="math inline">\(\sigma\)</span>决定了分布的形状——越小形状越瘦高，越大越矮胖</p>
<h3
id="作用计算高斯滤波用的掩膜mask">作用:<strong>计算高斯滤波用的掩膜(Mask)</strong></h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-0f390685117a9510871e3c241ce76d8a_720w.webp" /></p>
<h3 id="如何利用高斯分布求掩膜">如何利用高斯分布求掩膜</h3>
<p><em>高斯分布公式是一维的，但掩膜是二维的怎么办？</em>
很简单，只需要<strong>把数值<span
class="math inline">\(x\)</span>变为向量<span
class="math inline">\(\vec{x}\)</span>即可</strong>：</p>
<p><span class="math inline">\(\vec{x}\)</span>表示一个点的坐标</p>
<p><span
class="math inline">\(\vec{u}\)</span>表示这个mask中心的坐标</p>
<p>举例说明</p>
<p>对于图像中任意一点(x,y)，它周围的坐标为：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-177899f81dea69abe4f6bc7f818a4da8_720w.webp" /></p>
<h4 id="遍历所有点与均值做差后平方">遍历所有点与均值做差后平方</h4>
<p>中间的(x,y)就是<span class="math inline">\(\vec{u}\)</span>了，
当<span class="math inline">\(\vec{x}\)</span>遍历图中所有点时,计算<span
class="math inline">\((\vec{x}-\vec{u})^2\)</span>，其中x和y被消除，得到下面</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-c45553599da9cf3f2a5a612c3107ac9b_720w.webp" /></p>
<h4 id="带入正态分布公式">带入正态分布公式</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-b39cae58ca1a5f39c46ac5ba918787f5_720w.webp" /></p>
<h4 id="归一化">归一化</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-0d1b6a4c714641309b05a89343425cac_720w.webp" /></p>
<p><strong>利用高斯掩膜和图像进行卷积求解高斯模糊</strong></p>
<p>如下图所示，没有别的，就是卷积</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-87320686a30a2d0f682c144436e54704_720w.webp" /></p>
<p><a
href="https://www.zhihu.com/question/54918332/answer/142137732">参考文章</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更新github上过期的token</title>
    <url>/posts/499231f7.html</url>
    <content><![CDATA[<p>主要是为了更新picgo，git其实使用ssh就没必要（目前看来）</p>
<h1 id="生成新token">生成新token</h1>
<p><a
href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">参考文章</a></p>
<h1 id="更新picgo">更新picgo</h1>
<p><a href="https://zhuanlan.zhihu.com/p/489236769">参考文章</a></p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>清理c盘</title>
    <url>/posts/3d89e1fc.html</url>
    <content><![CDATA[<p>利用软链接</p>
<p>好处是既可以迁移到其他盘，也不会因为影响环境变量带来头疼的影响</p>
<p>比如我一开始少不懂事地把JetBrain撞到了C盘，后来发现这玩意能占用到5个G</p>
<p>先将整个目录从原来的盘剪切到其他盘（一定要剪切，原来的盘不能有这个文件了！）</p>
<p>然后再win窗口输入命令提示符选择以管理员身份运行</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123114108084.png" />
输入 mklink /D "原来的位置" "现在的位置"（引号不能省)就行了</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240123114222834.png" /></p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f.html</url>
    <content><![CDATA[<h1 id="主要参考">主要参考</h1>
<span id="more"></span>
<h2 id="hexo框架">hexo框架</h2>
<p>https://blog.csdn.net/yushuaigee/article/details/111465155</p>
<h2 id="github-page使用">Github Page使用</h2>
<p>https://blog.csdn.net/xq151750111/article/details/131101229</p>
<h2 id="picgo使用">PicGo使用</h2>
<h1 id="中文无法正常显示">中文无法正常显示</h1>
<p>用utf8保存配置文件</p>
<p>https://blog.csdn.net/Crazy_Diamond_/article/details/114902456</p>
<h1 id="主题优化">主题优化</h1>
<p>https://blog.csdn.net/xq151750111/article/details/131101229</p>
<h2 id="社交图标">社交图标</h2>
<p>https://blog.csdn.net/lhh2333/article/details/126935545</p>
<h2 id="字数统计和阅读时长">字数统计和阅读时长</h2>
<p>https://blog.csdn.net/mqdxiaoxiao/article/details/93670772</p>
<h2 id="修改永久链接">修改永久链接</h2>
<p>https://blog.luzy.top/posts/2424649425/</p>
<h1 id="hexo博客中添加categories分类">hexo博客中添加categories分类</h1>
<h1 id="hexo中配置mathjax">hexo中配置mathjax</h1>
<p>https://xingkunz.github.io/2020/01/13/hexo-%E8%A7%A3%E5%86%B3%E5%8D%9A%E5%AE%A2%E6%B8%B2%E6%9F%93%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98/</p>
<h1 id="站内搜索">站内搜索</h1>
<p>https://zhuanlan.zhihu.com/p/361143962</p>
<h1 id="如何让谷歌检索到自己博客">如何让谷歌检索到自己博客</h1>
<p>https://zhuanlan.zhihu.com/p/129022264</p>
<p>解释：导出的两个文件都放在项目source文件夹下，不是theme/source，并且都需要hexo
clean &amp;&amp; hexo g &amp;&amp; hexo d</p>
<h1 id="博客背景设置和文章透明度优化">博客背景设置和文章透明度优化</h1>
<p>https://www.snowmoon.top/2021/02/21/next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</p>
<p>目前博客配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">//  更改背景图片</span><br><span class="line">body &#123;</span><br><span class="line">	// 透明度 0.6 的黑色半透明遮罩</span><br><span class="line">	background-color: rgba(0, 0, 0, 0.5);</span><br><span class="line">	// 設置背景混和模式為相乘模式</span><br><span class="line">	background-blend-mode: multiply;</span><br><span class="line">	// 图片自适应剪裁,56.25%=1080/1920</span><br><span class="line">	// padding-top: 56.25%</span><br><span class="line">	background-image:url(https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/j20_girl_background.webp);</span><br><span class="line">	//这一行的括号里填背景图片的路径，将图片重命名为background.jpg放在\themes\next\source\images下</span><br><span class="line">	background-repeat: no-repeat;</span><br><span class="line">	background-attachment:fixed;</span><br><span class="line">	background-position:50% 50%;  //设置背景图像的起始位置</span><br><span class="line">	background-size:cover;</span><br><span class="line">&#125;</span><br><span class="line">.main-inner &#123; </span><br><span class="line">   //margin-top: 0px;</span><br><span class="line">   //padding: 0px 100px 100px 100px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-block &#123;</span><br><span class="line">    border-radius : 12px;</span><br><span class="line">    background: rgba(255,255,255,0.9) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.comments &#123;</span><br><span class="line">    border-radius : 12px;</span><br><span class="line">    background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="修改内容区域的宽度">修改内容区域的宽度</h1>
<p>https://lamirs.vercel.app/hexo-next-%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%AE%BD%E5%BA%A6</p>
<h1 id="文章圆角设置">文章圆角设置</h1>
<p>https://gis90.github.io/articles/3412/</p>
]]></content>
      <categories>
        <category>电脑小技巧</category>
      </categories>
  </entry>
  <entry>
    <title>中文数据库</title>
    <url>/posts/7ee29e1e.html</url>
    <content><![CDATA[<h1 id="cnki的使用">CNKI的使用</h1>
<span id="more"></span>
<h2 id="资源类型选择">资源类型选择</h2>
<p>（1）在首页勾选</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191151252.png" /></p>
<p>（2）在高级检索界面页头的检索设置里删除或添加资源类型</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191505385.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191548317.png" /></p>
<h2 id="文献检索的方式">文献检索的方式</h2>
<h3 id="框式检索">框式检索</h3>
<h4 id="步骤">步骤：</h4>
<ol type="1">
<li>选择所需的文献类型（如学术期刊、学位论文、会议等库）；</li>
<li>选择所需的检索字段（/检索项）（如主题、题名、作者、单位等）；</li>
<li>输入相应的检索词。</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405191958087.png" /></p>
<h4 id="检索项">检索项</h4>
<ol type="1">
<li><p><font color = "red">主题检索</font>
在中国知网标引出来的主题字段中进行检索，包含一篇文章的所有主题特征，同时在检索过程中嵌入了专业词典、主题词表、中英对照词典、停用词表等工具，并采用关键词截断算法，将低相关或微相关文献进行截断。</p></li>
<li><p><font color = "red">篇关摘检索</font>
在<font color = "yellow">篇名、关键词、摘要范围</font>内进行检索。</p></li>
<li><p><font color = "red">关键词检索</font>(相当于标签)
包括文献原文给出的中、英文关键词，以及对文献进行分析计算后机器标引出的关键词。机器标引的关键词基于对全文内容的分析，结合专业词典，解决了文献作者给出的关键词不够全面准确的问题。</p></li>
<li><p><font color = "red">篇名检索</font>
期刊、会议、学位论文、辑刊的篇名为文章的中、英文标题。报纸文献的篇名包括引题、正标题、副标题。年鉴的篇名为条目题名。专利的篇名为专利名称。标准的篇名为中、英文标准名称。成果的篇名为成果名称。古籍的篇名为卷名。</p></li>
<li><p>全文检索
在文献的全部文字范围内进行检索，包括文献篇名、关键词、摘要、正文、参考文献等。</p></li>
<li><p>作者检索
期刊、报纸、会议、学位论文、年鉴、辑刊的作者为文章中、英文作者。专利的作者为发明人。标准的作者为起草人或主要起草人。成果的作者为成果完成人。古籍的作者为整书著者。</p></li>
<li><p>第一作者检索
只有一位作者时，该作者即为第一作者。有多位作者时，将排在第一个的作者认定为文献的第一责任人。</p></li>
<li><p>通讯作者检索
期刊文献对原文的通讯作者进行了标引，可按通讯作者查找期刊文献。通讯作者指课题的总负责人，也是文章和研究材料的联系人。</p></li>
</ol>
<h4 id="检索词">检索词</h4>
<ol type="1">
<li>输入两个或两个以上的检索词，多个检索词之间的<font color = "red">空格代表了逻辑“与”(AND)。</font></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192521124.png" /></p>
<ol start="2" type="1">
<li><p>二次检索</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192659355.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192708567.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405192715170.png" /></p></li>
</ol>
<h4 id="匹配方式">匹配方式</h4>
<p>1、相关度匹配
主题、篇关摘、篇名、全文、摘要、小标题、参考文献、文献来源;根据检索词在该字段的匹配度，得到相关度高的结果。</p>
<p>2、精确匹配 关键词、作者、第一作者、通讯作者。</p>
<p>3、模糊匹配 作者单位、基金、分类号、DOI。</p>
<h4 id="同字段组合运算">同字段组合运算</h4>
<p>1、支持运算符*、+、-、‘’、""、()进行同一检索项内多个检索词的组合运算，检索框内输入的内容不得超过120个字符。</p>
<p>2、输入运算符*(与)、+(或)、-(非)时，前后要空一个字节，优先级需用英文半角括号确定。</p>
<p>3、若检索词本身含空格或*、+、-、()、/、%、=等特殊符号，进行多词组合运算时，为避免歧义，须将检索词用英文半角双引号引起来。</p>
<hr style = "border:2px solid yellow">
<p>例如： （1）篇名检索项后输入：神经网络 *<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
自然语言，可以检索到篇名包含“神经网络”及“自然语言”的文献。</p>
<p>（2）主题检索项后输入：(锻造 + 自由锻) *
裂纹，可以检索到主题为“锻造”或“自由锻”，且有关“裂纹”的文献。</p>
<p>（3）检索篇名包含“digital library”和“information
service”的文献，在篇名检索项后输入：“digital library” * “information
service”。</p>
<p>（4）检索篇名包含“2+3”和人才培养的文献，在篇名检索项后输入：“2+3” *
人才培养。</p>
<hr style = "border:2px solid yellow">
<h4 id="检索推荐引导功能">检索推荐/引导功能</h4>
<p>1、主题词智能提示</p>
<p>适用字段：主题、篇名、关键词、摘要、全文。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194018720.png" /></p>
<p>2、作者引导</p>
<p>检出所有暨南大学的刘增合所发表的文献，检索时精准定位所查找的作者，排除同名作者，并且不管原文机构是否含“暨南大学”字样，只要规范为暨南大学的，都可以被检到</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194144805.png" /></p>
<p>某作者同时有多个单位</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405194301775.png" /></p>
<h3 id="高级检索">高级检索</h3>
<h4 id="检索特点">检索特点</h4>
<ol type="1">
<li>由多个检索字段进行逻辑组合检索，并可通过选择精确或模糊的匹配方式、控制条件等方法完成较复杂的检索；</li>
<li>多字段组合检索的运算优先级，按从上到下的顺序依次进行；</li>
<li>通过“+” 、“-”来增加或减少检索项；</li>
<li>控制条件：匹配方式、时间范围、文献来源、基金文献、作者、作者单位、文献分类、网络首发、增强出版、数据论文、中英文扩展、同义词扩展等。</li>
</ol>
<h4 id="检索区">检索区</h4>
<p>① 检索条件输入区
默认显示主题、作者、文献来源三个检索框，可自由选择检索项、检索项间的逻辑关系、检索词的匹配方式。
点击检索框后的按钮可添加或删除检索项，最多支持10个检索项的组合检索。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195137905.png" /></p>
<p>② 检索控制区
主要作用是通过条件筛选、时间选择等，对检索结果进行范围控制。
控制条件包括：出版模式、基金文献、时间范围、检索扩展。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195230532.png" /></p>
<p>③ 切库区</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195327336.png" /></p>
<p>④ 文献导航</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195414849.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195421424.png" /></p>
<p>⑤匹配方式</p>
<p>除主题只提供相关度匹配外，其他检索项均提供精确、模糊两种匹配方式。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195459259.png" /></p>
<p>⑥词频选择</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195530621.png" /></p>
<p>⑦同字段组合运算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195627283.png" /></p>
<p>⑧结果中检索</p>
<p>举例：</p>
<p>例如：检索主题“人工智能”后，在结果中检索主题“机器人”</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195850189.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195813416.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405195644126.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>检索华北电力大学师生2000年1月1日-2023年1月1日发表的电力系统继电保护方面的学术期刊文献、学位论文、会议论文各有多少篇。</p>
<p>Step1：点击“检索设置”，选择学术期刊、学位论文、会议，保存设置；
Step2：选择检索项“主题”, 在检索框中输入：电力系统* 继电保护；
Step3：控制条件“发表时间”选择从“2000-01-01 ” –“2023-01-01”；
Step4：作者单位输入“华北电力大学”，默认为“模糊”匹配；
Step5：点击“检索”按钮。</p>
<hr style = "border:2px solid yellow">
<h4 id="作者发文检索">作者发文检索</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200404813.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200740897.png" /></p>
<hr style = "border:2px solid yellow">
<h4
id="句子检索用于查找论文中的事实信息">句子检索（用于查找论文中的事实信息）</h4>
<p>通过输入的两个检索词，在全文范围内查找同时包含这两个词的句子，找到有关事实的问题答案。</p>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>例如：检索同一句包含“人工智能”和“神经网络”的文献</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405200954786.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405201025767.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="专业检索">专业检索</h3>
<h4 id="构造专业检索式">构造专业检索式</h4>
<p>①查看检索字段代码。专业检索的检索字段用代码表示，如，主题用SU表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可检索字段和对应代码</span><br><span class="line"></span><br><span class="line">SU=主题,</span><br><span class="line"></span><br><span class="line">TKA=篇关摘,</span><br><span class="line"></span><br><span class="line">KY=关键词,</span><br><span class="line"></span><br><span class="line">TI=篇名,</span><br><span class="line"></span><br><span class="line">FT=全文,</span><br><span class="line"></span><br><span class="line">AU=作者,</span><br><span class="line"></span><br><span class="line">FI=第一作者,</span><br><span class="line"></span><br><span class="line">RP=通讯作者,</span><br><span class="line"></span><br><span class="line">AF=作者单位,</span><br><span class="line"></span><br><span class="line">FU=基金,</span><br><span class="line"></span><br><span class="line">AB=摘要,</span><br><span class="line"></span><br><span class="line">CO=小标题,</span><br><span class="line"></span><br><span class="line">RF=参考文献,</span><br><span class="line"></span><br><span class="line">CLC=分类号,</span><br><span class="line"></span><br><span class="line">LY=文献来源, </span><br><span class="line"></span><br><span class="line">DOI=DOI,</span><br><span class="line"></span><br><span class="line">CF=被引频次</span><br></pre></td></tr></table></figure>
<p>②查看检索表达式语法。注意CNKI专业检索中，不同检索字段之间的“与”“或”“非”用“AND”、“OR”、“NOT”表示，但同一检索字段中的不同检索词之间的“与”“或”“非”则用*、+、-表示；
③输入检索式。检索式的表达形式：</p>
<p><font color = "red">检索字段代码 = 检索式</font></p>
<hr style = "border:2px solid yellow;">
<p>举例</p>
<p>TI=信息素养，</p>
<p>含义是检索篇名(检索代码是TI)中含有信息素养的论文。</p>
<hr style = "border:2px solid yellow;">
<blockquote>
<p>注意：</p>
<p>检索式里的符号都必须使用英文半角字符；</p>
<p>检索词之间用：*、+、-；</p>
<p>字段之间用 AND、OR、 NOT 。</p>
<p>如：SU%=大学生 AND （信息素养 + 信息素质）</p>
</blockquote>
<h4 id="匹配运算符">匹配运算符</h4>
<p><font color = "yellow">下面这图表达什么意思呢</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405203647919.png" /></p>
<hr style = "border:2px solid yellow">
<p>例如： (1)精确检索关键词包含“数据挖掘”的文献：KY = 数据挖掘。
(2)模糊检索摘要包含“计算机教学”的文献：AB %
计算机教学，模糊匹配结果为摘要包含“计算机”和“教学”的文献，“计算机”和“教学”两词不分顺序和间隔。
(3)检索主题与“大数据”相关的文献：SU %=
大数据，主题检索推荐使用相关匹配运算符“%=”。</p>
<hr style = "border:2px solid yellow">
<h4 id="比较运算符">比较运算符</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405203847162.png" /></p>
<p>例如： (1)YE BETWEEN ('2010', ‘2020')
，检索出版年份在2010至2020年的文献。</p>
<p>(2)CF &gt; 0或CF &gt;=1 ，检索被引频次不为0的文献。</p>
<h4 id="逻辑运算符">逻辑运算符</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405204417802.png" /></p>
<hr style = "border:2px solid yellow">
<p>例如： (1)检索邱均平发表的关键词包含知识管理的文章，检索式：KY =
知识管理 AND AU = 邱均平。
(2)检索篇名包含大数据，但不是大数据集的文章，检索式：TI = 大数据 NOT TI
= 大数据集。 (4)检索钱伟长在清华大学或上海大学时发表的文章，检索式：AU =
钱伟长 AND (AF =清华大学 OR AF =上海大学)。
(5)检索钱伟长在清华大学期间发表的题名或摘要中都包含“物理”的文章，检索式：AU
=钱伟长 AND AF=清华大学 AND (TI =物理 OR AB = 物理)。</p>
<hr style = "border:2px solid yellow">
<h2 id="知网研学批量下载">知网研学批量下载</h2>
<ol type="1">
<li><p>规范每页显示文章数量、确定检索优先级（比如按照被索引高低），点击全选后批量下载</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406061749485.png" /></p></li>
<li><p>将下载的es6放入文件夹后从知网研学中导入题录</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406061852627.png" /></p></li>
</ol>
<h2 id="导出格式引文">导出格式引文</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406063236898.png" /></p>
<h1 id="万方">万方</h1>
<p>与CNKI差不多</p>
<p>万方不能用与或非，必须用and，or，not替代</p>
<blockquote>
<p>注：“分析”不能作为检索词</p>
</blockquote>
<h1 id="维普">维普</h1>
<p>也差不多，就是一个期刊导航可以找什么CSCD、北大核心、CSCCI</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>逻辑与<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>引文检索</title>
    <url>/posts/3a9d48aa.html</url>
    <content><![CDATA[<h1 id="中文">中文</h1>
<p>CSSCI</p>
<p>主要是用来查看核心期刊</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408203929253.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408203954962.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="外文">外文</h1>
<h1 id="web-of-science">Web of Science</h1>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>文献检索基础知识</title>
    <url>/posts/f1d400e4.html</url>
    <content><![CDATA[<h1 id="搜索引擎检索技巧">搜索引擎检索技巧</h1>
<span id="more"></span>
<h2 id="布尔逻辑运算">布尔逻辑运算</h2>
<h2 id="双引号进行精确检索">双引号“”进行精确检索</h2>
<p>加引号</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223002226.png" /></p>
<p>不加引号</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223124082.png" /></p>
<p>可以看出加引号的部分搜索结果都包含“大学生信息素质”，不加引号的部分则不一定</p>
<h2
id="书名号检索其中书名号会出现在检索结果中或书名号里的内容不会被拆分">书名号《》检索，其中书名号会出现在检索结果中或书名号里的内容不会被拆分。</h2>
<p><font color = "yellow">与""精确检索有什么区别？</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331223541730.png" /></p>
<h2 id="在特定站点中搜索关键词">在特定站点中搜索关键词</h2>
<p>在搜索引擎中，<font color = "yellow">使用"site:站点域名"的语法将会限制搜索结果仅显示来自指定站点的页面，并且包含了您指定的关键词</font>。这样做的效果是，搜索引擎会筛选出特定站点中与您输入的关键词相关的页面，而不会包括其他站点的页面。</p>
<p>在查询内容的后面加上“site:站点域名”，域名不要http://，
“site”和站点名之间不要带空格。</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224423269.png" /></p>
<h2 id="指定文档类型的检索">指定文档类型的检索</h2>
<p>关键词+filetype：文档类型”</p>
<p>举例：信息检索filetype:PPT</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331225931239.png" /></p>
<h2 id="搜索范围限定在url链接中">搜索范围限定在URL链接中</h2>
<p>方法：inurl：+关键词，如检索flash的学习技巧，检索式为：flash
inurl:jiqiao,表示“flash”可以出现在网页的任何位置，而“jiqiao”则必须出现在网页的URL中。</p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224750692.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224819975.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331224855825.png" /></p>
<h2 id="限定在网页的标题中的检索">限定在网页的标题中的检索</h2>
<p>用“intitle：”限定在网页标题范围内，
“intitle：”和后面的关键词不能有空格。</p>
<p><font color = "yellow">与前面“”和《》有什么区别</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331225246562.png" /></p>
<h1 id="web-of-science">Web of Science</h1>
<p>首页点击资源：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231104019.png" /></p>
<p>网页搜索“web of science"</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231147634.png" /></p>
<p>点击第一个链接，注意一定要关梯子</p>
<p>点击下拉菜单选择web of science核心合集</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231343472.png" /></p>
<p>选择合适年份</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231508309.png" /></p>
<p>选择合适索引</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331231526497.png" /></p>
<h1 id="布尔逻辑检索boolean-retrieval">布尔逻辑检索（Boolean
Retrieval）</h1>
<p>与—— AND 或—— OR 非—— NOT</p>
<h2 id="逻辑与">逻辑与</h2>
<p>运算符为 "AND"、"*" 或空格；
表达两个或两个以上检索词之间的相关关系或限定关系的运算；
用以缩小检索范围，减少输出结果，提高检准率</p>
<h2 id="逻辑或">逻辑或</h2>
<p>运算符为 OR 或 +<br />
用于表达两个或两个以上检索词之间的并列关系运算；<br />
常用于连接同一检索词的同义词、近义词；<br />
可扩大检索范围、增加输出结果，提高检全率。</p>
<h2 id="逻辑非">逻辑非</h2>
<p>运算符：NOT 或 "-"<br />
表达在两个或两个检索词之间排除不需要的检索词的运算；<br />
缩小命中信息的范围，提高检索的检准率。<br />
A NOT B——表示含有检索词A而不含有检索词B的文献才能被命中。</p>
<h2 id="综合应用andornot">综合应用：AND、OR、NOT</h2>
<p>运算顺序：NOT &gt; AND &gt; OR 可通过 () 来改变运算的优先顺序，()
必须是英文半角状态下的括号</p>
<h1 id="截词检索">截词检索</h1>
<p>截词符：？ 、 * $</p>
<p>computer * AND technology</p>
<h2 id="无限截词">无限截词</h2>
<p>举例：employ*，可以检索到employ, employer, employers……</p>
<h2 id="有限截词">有限截词</h2>
<p>？表示这个单词这个位置的字母可以任意变化</p>
<p>比如psych????ist*，检索到含有psychologist, psychologists等</p>
<h2 id="前截词">前截词</h2>
<p>*wave</p>
<h2 id="中截词">中截词</h2>
<p>organiza?ion</p>
<h2 id="后截词">后截词</h2>
<p>book？</p>
<p>lancaster*</p>
<p>biolog*</p>
<h1
id="词组检索快速精确找出需要的文献">词组检索快速精确找出需要的文献</h1>
<p>又称“精确检索”或“短语检索”。</p>
<p>将一个词组或短语用双引号“”括起来作为一个独立运算单元，进行严格匹配，即可检索出与“”内形式完全相同的短语，以提高检索的准确度。</p>
<h1 id="检索词">检索词</h1>
<h2 id="如何确定">如何确定</h2>
<h3 id="切分">切分</h3>
<p>如:“国内在线学习投入的研究进展”课题语句可切分为以下自由词：
国内|在线学习|投入|的|研究|进展
注：如果词组切分后失去原来的意思，则不能进行切分，切分要保证词组意思的完整性。如“在线学习”不能切分为“在线”和“学习”。</p>
<h3 id="删除">删除</h3>
<p>删除是将课题语句中不具有实质性检索意义的词语进行删除。包括虚词（如介词、连词、副词等），使用频率低的词，专指性太高或过于宽泛的词，过于具体的限定词、禁用词，不能表达课题实质性的高频词，存在蕴含关系可以合并的词。</p>
<p>如：可以将 国内|在线学习|投入|的|研究|进展
中的国内、的、研究、进展删除，得到在线学习、投入。</p>
<h3 id="替换和补充">替换和补充</h3>
<p>如：“在线学习”可补充同义词、近义词：网络学习、MOOC、慕课、大规模开放课程、E-learning、网络课程等；
“投入”替换为更具体的“学习投入”，并补充同义词、近义词“学习参与”。</p>
<h2 id="分类">分类</h2>
<h3 id="从规范性">从规范性</h3>
<p>① 受控词
经过规范化处理的检索语言，又叫人工语言。取自主题词表、叙词表、分类表等。如标题词、叙词。
② 非受控词 指非规范化的自然语言，如关键词。</p>
<p>Tips：规范化处理，是在文献存储时，对文献中的同义词、近义词、多义词等加以严格的控制和规范，使得同一主题概念的文献相对集中在一个主题词下。
<font color = "red">受控词
——&gt;主题词——&gt;专业，非受控词——&gt;关键词——&gt;不专业</font></p>
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401204254196.png" /></p>
<h1 id="词表">词表</h1>
<p>第一步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401204507761.png" /></p>
<p>第二步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401205130763.png" /></p>
<p>第三步</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401205338573.png" /></p>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>英文数据库</title>
    <url>/posts/c21d49b4.html</url>
    <content><![CDATA[<h1 id="elsevier-sdol">Elsevier SDOL</h1>
<span id="more"></span>
<h2 id="检索语言与检索技巧">检索语言与检索技巧</h2>
<h3 id="逻辑连接符">逻辑连接符</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406081348765.png" /></p>
<h3 id="单数检索">单数检索</h3>
<p>输入单词的单数形式，可检索单数、复数、所有格等多种形式　 输入ｃｉｔｙ
检索ｃｉｔｙ、ｃｉｔｉｅｓ、ｃｉｔｙ’ｓ</p>
<h3 id="词组检索">词组检索</h3>
<p>使用　“”　 “”较宽松精确检索，符号被忽略 　检索“heart-attack”
　或　“heart attack” 　结果一样</p>
<h3 id="停用词">停用词</h3>
<p>搜索引擎会自动忽略某些应用十分广泛，或者是助词、副词、介词等本身无意义的字或词，这些字或词即被称为stop
words(停用词)。</p>
<p>停用词不会被检索</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406081747403.png" /></p>
<h3 id="特殊检索项">特殊检索项</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>检索项</strong></th>
<th><strong>范例</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>希腊字符</td>
<td>检索　Ω 输入　omega 结果包含omega、Ω（大写）、ω（小写）</td>
</tr>
<tr class="even">
<td>上标与下标 直接写在同一行内</td>
<td>检索　Ｈ２Ｏ 输入　Ｈ２Ｏ</td>
</tr>
<tr class="odd">
<td>口音字母 输相近写法的英文字母</td>
<td>检索 Fürst 输入　Furst 或 Fürst</td>
</tr>
<tr class="even">
<td>非字母数字字符</td>
<td>箭头、加号等字符将被忽略</td>
</tr>
</tbody>
</table>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例1：搜索希腊字符</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406082224293.png" /></p>
<p>例2：搜索上下标</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406082235555.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="高级检索">高级检索</h2>
<h3 id="布尔逻辑运算符和cnki差不多">布尔逻辑运算符（和CNKI差不多）</h3>
<p>1、使用布尔运算符组合多个检索词： ①
支持的布尔运算符包括AND，OR，NOT和连字符（或减号-） ②
必须以全部大写形式输入布尔运算符 ③ 连字符（或减号）被解释为NOT运算符
如： black - hole将返回包含“black”的结果，但排除任何出现 ‘hole‘
的结果。</p>
<p>2、优先级 NOT 〉AND 〉OR</p>
<p>3、嵌套句子时可使用括号 如：对于a OR b AND c，输入(a OR b ) AND c
或输入(a OR b ) c</p>
<p>3、引号可用于指定必须彼此相邻的术语 如：("heart attack" OR
"myocardial infarction") AND diabetes AND NOT cancer
（"心脏病发作"或"心肌梗塞"）和糖尿病，而不是癌症</p>
<h3 id="快速检索某个主题相关的文献">快速检索某个主题相关的文献</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083059866.png" /></p>
<h3 id="利用高级检索功能准确定位">利用高级检索功能准确定位</h3>
<p>1、进入检索界面更多限定选择</p>
<p>2、确定检索字段</p>
<p>3、输入检索词</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083208306.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083413578.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406083446524.png" /></p>
<hr style = "border:2px solid yellow">
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401183611530.png" /></p>
<p>首页</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401183755411.png" /></p>
<h1 id="ebsco数据库">EBSCO数据库</h1>
<h2 id="检索技术">检索技术</h2>
<p>1、逻辑算符</p>
<ul>
<li><p>AND :逻辑与 如：information and safety可以检索到既包含information
也包含 safety的文献，在EBSCO中 and 可以省略，直接输入information
safety。</p></li>
<li><p>OR：逻辑或 如：college or university
可以检索到college或university的文献。</p></li>
<li><p>NOT：逻辑非 如：girl not boy 检索到只包含girl 的文献。</p></li>
</ul>
<p>2、通配符</p>
<ul>
<li>*:可替代多个字符 如：输入comput*，可检索到computer computers、
computing、 computed等以comput开头的一系列词。</li>
<li>？：可替代1个字符
如：organi?ation可以检索到organization或organisation的词。</li>
<li>#：可替代0或1个字符 如：colo＃r检索到color或colour 的词。</li>
</ul>
<p>3、位置算符</p>
<ul>
<li><p>N:Near
Operator，N后面加数字，如N3,表示两个检索词不但要出现，而且两者之间最多允许插入3个单词，但先后顺序没有要求。
如：tax N3 reform,可以检索到tax reform， tax police reform，reform of
income tax等，只要tax 和reform之间的距离不超过3个单词即可。</p></li>
<li><p>W：Within operator
,W后加数字，如W3表示两个检索词不但要出现，而且两者直接最多允许插入3个单词，同时规定了两个词的先后顺序。
如：tax W3 reform，可以检索到tax reform， tax police
reform，但不能检索reform of income
tax，因为先后顺序不符合要求。</p></li>
</ul>
<p>4、短语检索 “”:用于检索固定短语，如：“information
literacy”,可以检索到固定格式的词组，位置顺序保持不变。</p>
<p>5、公式检索</p>
<ul>
<li><p>Keyword and FM
T:可以检索到HTML格式的文献，实现全文翻译及在线朗读功能。 如：information
literacy and FM T</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406085951450.png" /></p></li>
<li><p>DT 3 and keyword：可以检索到最近3天发表的文献。 如： DT 30 and
information literacy</p></li>
<li><p>Keyword JN
“Education”:可以检索到指定期刊Education上发表的文献。</p></li>
</ul>
<h2 id="基本检索">基本检索</h2>
<h3 id="检索模式和扩展条件">检索模式和扩展条件</h3>
<p>（1）布尔逻辑/词组
支持3种逻辑运算和扩展运算（一般为截词运算和位置运算）
（2）查找全部检索词语 相当于逻辑“与” （3） 查找任何检索词语
相当于逻辑“或” （4）智能文本搜索
可输入或粘贴大段文字（包括空格最多5000个字符）进行检索</p>
<p>（5）运用相关词 调用数据库的同义词库 （6）同时在文章全文范围内搜索
在默认字段和全文中检索</p>
<h3 id="限制结果">限制结果</h3>
<p>（1）全文 只检索全文的文章 （2）学术（同行评审）期刊
只检索有专家评审的期刊 （3） 有参考 只检索有参考文献的文章 （4）出版物
在限定的出版物中检索</p>
<p>（5）出版日期 限定出版物的出版时间 （6）出版物类型 限定出版物的类型
（7）图像快速查看类型 限定图像类型</p>
<h2 id="asc">ASC</h2>
<h3 id="基本检索-1">基本检索</h3>
<h4 id="同行评审">同行评审</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091052223.png" /></p>
<h4 id="图表查询">图表查询</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091143531.png" /></p>
<h3 id="高级检索-1">高级检索</h3>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>练习2：检索最近300天内发表的有关高校图书馆信息素养方面的文献。
检索式：DT 300 and (college* or universit<em>) and librar</em> and
(“information literacy”or “information quality”) 检索字段：主题
检索方式：高级检索</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091307393.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="bsc">BSC</h2>
<p>首先要切换数据库</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406091459834.png" /></p>
<p>“公司信息”页面下提供详细的公司信息，包括分公司结构和公司简介等。</p>
<p>“叙词表”是一个商业术语词汇表，帮助更有效地搜索数据库中的文献。</p>
<h3 id="高级检索-2">高级检索</h3>
<p>公司可以作为一个字段，比如公司=sony</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>阅读索尼公司的SWOT分析，概述公司的优势，劣势，机遇和威胁</p>
<p>1、在搜索框中输入sony，然后从选择字段下拉菜单中选择“CO Company
Entity”，应用“Full Text”限制条件，然后单击Search
2、在结果列表页面左侧的“来源类型”下，单击“显示更多”。 找到“SWOT
分析”，然后单击“更新”。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401195345916.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401195408932.png" /></p>
<hr style = "border:2px solid yellow">
<p><font color = "yellow">主题词(可以用来判断关键词是不是主题词)是怎么做到的?</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401193948136.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401194016022.png" /></p>
<blockquote>
<p>注：查找统计数据可登录国研网</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401194400942.png" /></p>
</blockquote>
<h1 id="springerlink">SpringerLink</h1>
<h2 id="高级检索-3">高级检索</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406102853072.png" /></p>
<h1 id="pqdt数据库">PQDT数据库</h1>
<p>进入</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401202225043.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401202249086.png" /></p>
<p>高级检索中使用""不能表示精确检索，和基础检索一样</p>
<p>截词检索*不能与精确检索同时使用</p>
<p>精确检索中</p>
<h2 id="公式检索">公式检索</h2>
<p>DT 3 and keywork:检索最近3天</p>
<p>不要有停用词</p>
<p>比如of、in</p>
<blockquote>
<p>注：找同义词的技巧</p>
<p>kimi chat</p>
<p>文心一言</p>
<p>chatgpt</p>
</blockquote>
]]></content>
      <categories>
        <category>文献检索</category>
      </categories>
  </entry>
  <entry>
    <title>post</title>
    <url>/posts/5a8a6c8d.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>第一章</title>
    <url>/posts/b2041fc0.html</url>
    <content><![CDATA[<h1 id="信息就是位上下文">信息就是位+上下文</h1>
<p>8个位成一组，称为字节。每个字节表示程序中</p>
]]></content>
  </entry>
  <entry>
    <title>实验三-进程通信</title>
    <url>/posts/e62e4f7b.html</url>
    <content><![CDATA[<h1 id="pipe">pipe</h1>
<span id="more"></span>
<p>创建管道要在创建子进程之前</p>
<h2 id="创建管道">创建管道</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">pipe(fd);</span><br></pre></td></tr></table></figure>
<p>其中fd[1]用来往管道里写，fd[1]用来向管道中读</p>
<h2 id="向管道中写">向管道中写</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(fd1[<span class="number">1</span>], inLine, LENGTH);</span><br></pre></td></tr></table></figure>
<p>fd[1]表示现在是写，inLine是写入管道字符串的字符数组，LENGTH是写入的长度（一般和写入的长度相同）</p>
<h2 id="从管道中读">从管道中读</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read(fd2[0], outLine, LENGTH);</span><br></pre></td></tr></table></figure>
<p>fd2[0]表示现在是读，outLine是从保存从管道中读取的字符数组，LENGTH是从管道中读取的长度</p>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> outLine[LENGTH];</span><br><span class="line">    <span class="type">int</span> fd2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> inLine[LENGTH];</span><br><span class="line">    pipe(fd1);</span><br><span class="line">    <span class="type">pid_t</span> p1 = fork();</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create p1 failed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(inLine, <span class="string">&quot;Child 1 is sending a message!&quot;</span>);</span><br><span class="line">        write(fd1[<span class="number">1</span>], inLine, LENGTH);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fd1[<span class="number">0</span>], outLine, LENGTH);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, outLine);</span><br><span class="line">        pipe(fd2);</span><br><span class="line">        <span class="type">pid_t</span> p2 = fork();</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create p2 failed\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(inLine, <span class="string">&quot;Child 2 is sending a message!&quot;</span>);</span><br><span class="line">            write(fd2[<span class="number">1</span>], inLine, LENGTH);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(fd2[<span class="number">0</span>], outLine, LENGTH);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, outLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="消息队列">消息队列</h1>
<h2 id="写入消息队列">写入消息队列</h2>
<h3 id="创建消息队列">创建消息队列</h3>
<p>创建消息结构体,定义一个全局的消息结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[LENGTH];</span><br><span class="line">&#125;msgbuf;</span><br></pre></td></tr></table></figure>
<p>再在全局定义一个消息队列的键，这个键就是表示消息队列的编号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> MSG_KEY;</span><br></pre></td></tr></table></figure>
<p>然后利用msgget创建消息队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
<p>详细解释：</p>
<ul>
<li><p>MSG_KEY作用：</p>
<p><code>MSG_KEY</code>
应该是一个用于唯一标识消息队列的键值，但是它在代码中并没有被定义。通常情况下，可以使用
<code>ftok()</code> 函数来生成一个唯一的键值</p></li>
<li><p>IPC_CREAT作用</p>
<p><font color = "yellow"><code>IPC_CREAT</code>
表示如果消息队列不存在则创建</font></p></li>
<li><p>0666作用</p>
<p><font color = "yellow">表示消息队列的权限</font></p>
<p>在 Linux/Unix
中，文件权限通常以八进制数表示。每个权限对应的数值如下：</p>
<ul>
<li><code>0</code>：没有任何权限</li>
<li><code>1</code>：执行权限（可执行文件）</li>
<li><code>2</code>：写权限（写入文件）</li>
<li><code>4</code>：读权限（读取文件）</li>
</ul>
<p>这些权限可以组合使用，通过将对应的数值相加来表示多个权限的组合。例如：</p>
<ul>
<li><code>3</code>：执行权限和写权限（1 + 2）</li>
<li><code>5</code>：执行权限和读权限（1 + 4）</li>
<li><code>6</code>：写权限和读权限（2 + 4）</li>
<li><code>7</code>：执行权限、写权限和读权限（1 + 2 + 4）</li>
</ul>
<p>在 <code>0666</code> 中，表示的权限是：</p>
<ul>
<li><code>0</code>：表示特殊权限位，通常为文件类型或文件特性（如设备文件、管道、套接字等），在这里不涉及文件类型的权限，因此这个位置通常用0填充。</li>
<li><code>666</code>：表示读权限和写权限，即文件的所有者、所属组和其他用户都有读和写的权限。</li>
</ul></li>
</ul>
<p>整条语句的作用是<font color = "red">用来创建消息队列,
可以理解返回的是消息队列的地址</font></p>
<h3 id="将缓存中消息发送到消息队列">将缓存中消息发送到消息队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msNum</code>：消息队列的标识符，它是由 <code>msgget</code>
函数返回的值。</li>
<li><code>&amp;msgbuf</code>：一个指向消息缓冲区的指针，消息将从这个缓冲区中发送。</li>
<li><code>1024</code>：消息的大小，以字节为单位。在这里，消息的大小为
1024 字节。</li>
<li><code>0</code>：这是一个标志参数，用于指定在发送消息时的行为。在这里，它是一个控制参数，通常可以用来设置一些特殊的行为，但在这个例子中被设置为
0，表示没有设置特殊的行为。</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 上面语句用来创建消息队列, 可以理解返回的是消息队列的地址，注意与msgNum的区别</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上面语句用来将要发送的消息暂时存入缓冲区，并设置这种消息的类型为1</span></span><br><span class="line">    msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>); <span class="comment">// 将内存中消息发送到消息队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="从消息队列中读取">从消息队列中读取</h2>
<h3 id="获取消息队列">获取消息队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
<h3 id="从消息队列中读取-1">从消息队列中读取</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgNum</code>：消息队列的标识符，它是由 <code>msgget()</code>
函数返回的值。</li>
<li><code>&amp;msgbuf</code>：一个指向消息缓冲区的指针，用于存储接收到的消息。</li>
<li><code>LENGTH</code>：消息的最大长度，以字节为单位。在这里，消息的最大长度被设置为
1024 字节。</li>
<li><code>0</code>：这是一个消息的类型，它指定了要接收的消息的类型。在这里，设置为
0 表示接收队列中的第一个消息。</li>
<li><code>0</code>：这是一个标志参数，用于指定在接收消息时的行为。在这里，它是一个控制参数，表示没有设置特殊的行为。</li>
</ul>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The save line is %s\n&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgctl(msgNum, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by pilot on 24-4-11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_KEY 24</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[LENGTH];</span><br><span class="line">&#125;msgbuf;</span><br><span class="line"><span class="type">int</span> msgNum = <span class="number">0</span>;     <span class="comment">//利用全局变量定义消息队列的序号，这个是1个键，相当于消息队列的编号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 上面语句用来创建消息队列, 可以理解返回的是消息队列的地址，注意与msgNum的区别</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input a message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgbuf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上面语句用来将要发送的消息暂时存入缓冲区，并设置这种消息的类型为1</span></span><br><span class="line">    msgsnd(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>); <span class="comment">// 将内存中消息发送到消息队列中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">    msgNum = msgget(MSG_KEY, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    msgrcv(msgNum, &amp;msgbuf, LENGTH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The save line is %s\n&quot;</span>, msgbuf.mtext);</span><br><span class="line">    msgctl(msgNum, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> p1 = fork();</span><br><span class="line">    <span class="keyword">if</span>(p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create p1 failed\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p1 == <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child process1\n&quot;</span>);</span><br><span class="line">        server();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;process1 end\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">pid_t</span> p2 = fork();</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create p2 failed\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;this is child process2\n&quot;</span>);</span><br><span class="line">            client();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process2 end\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;task end\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>实验二-fork、wait、exec</title>
    <url>/posts/383d6a1d.html</url>
    <content><![CDATA[<h1 id="fork">fork</h1>
<span id="more"></span>
<p><code>fork()</code>被用于创建一个子进程。这个函数返回0代表创建成功，返回负数代表创建失败。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int apple = 5; //5个苹果</span><br><span class="line">  pid_t pid;</span><br><span class="line"></span><br><span class="line">  pid = fork(); //创建子进程</span><br><span class="line">  if(pid &lt; 0)&#123; //如果没有创建成功</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">    exit(EXIT_FAILURE); //退出</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;// 如果创建成功</span><br><span class="line">    //在这个if中的所有操作都是子进程的。</span><br><span class="line">    apple -= 4; //吃掉4个苹果</span><br><span class="line">  &#125;else if(pid &gt;= 0)&#123; // 如果不在子进程中</span><br><span class="line">    printf(&quot;There are %d apples&quot;, apple); //输出苹果的数量</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 C 语言中，<font color = "yellow"><code>pid_t</code>
是一种数据类型</font>，它用来表示进程 ID（Process ID），在头文件
<code>&lt;sys/types.h&gt;</code> 中定义。<code>pid_t</code> 不是
<code>int</code>，<font color = "yellow">尽管在许多系统上
<code>pid_t</code> 被定义为
<code>int</code>，</font>但这并不是必然的，因为它可以是不同平台上不同的类型。</p>
</blockquote>
<p>当我们创建一个子进程的时候，这段代码，包括它当前的所有参数都被复制给了子进程。这样一来，子进程的操作无论怎么更改都是在子进程里生效。见下图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/p1.svg" /></p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 5 apples</span><br></pre></td></tr></table></figure>
<p>这些参数里面，唯一不同的是<code>pid</code>，子进程的<code>pid</code>是0，而父进程的<code>pid</code>没有赋值。我们不能说，子进程的作用域只在那个if语句中，在if外面就不是子进程了。其实不然，我们可以试一下下面的代码来证明子进程和父进程都拥有苹果，而且互不干扰。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int apple = 5; //5个苹果</span><br><span class="line">  pid_t pid;</span><br><span class="line"></span><br><span class="line">  pid = fork(); //创建子进程</span><br><span class="line">  if(pid &lt; 0)&#123; //如果没有创建成功</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">    exit(EXIT_FAILURE); //退出</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;// 如果创建成功</span><br><span class="line">    //在这个if中的所有操作都是子进程的。</span><br><span class="line">    apple -= 4; //吃掉4个苹果</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;There are %d apples\n&quot;, apple); //输出苹果的数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 5 apples</span><br><span class="line">There are 1 apples</span><br></pre></td></tr></table></figure>
<p>前一个是父进程的苹果，没有被吃掉，后一个是子进程的苹果，吃掉了四个。即使是在if语句外面也是可以被执行的。<font color = "yellow">if仅仅只是用于辅助判断哪些代码可以在子进程执行，哪些代码可以在父进程执行而已</font></p>
<p><a
href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork的进一步了解</a></p>
<h1 id="wait">wait</h1>
<p>搭配<code>fork()</code>使用。<font color = "yellow">本质上就是为了回收已经执行完毕的子进程，释放子进程的资源</font></p>
<ol type="1">
<li><p>没有用wait()主进程不会受到影响，但是子进程即使终止了资源也不会被回收，从而会变成<strong>僵尸进程</strong></p></li>
<li><p>进程一旦调用了 wait，就
<font color = "red">立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出</font>，如果让它找到了这样一个已经变成僵尸的子进程，wait
就会收集这个子进程的信息，
并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p></li>
<li><p><code>wait()</code>的返回值是子进程的ID。</p></li>
</ol>
<p>如果你对第一次写 <em>hello world</em>
有印象，你一定记得代码最后的<code>return 0;</code>。课本上只会跟你说：“return
0代表这个函数的返回值是0”，但是你无法理解为什么要返回0，返回给谁。现在明白了父进程和子进程的概念，你就知道这个0是返回给父进程的,
是告诉父进程子进程的退出状态。</p>
<p>要接住这个返回值，我们要定义一个整型<code>status</code>。后面通过这个变量来确定子进程退出的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  //输入的是</span><br><span class="line">  if(pid &lt; 0)&#123;</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid == 0)&#123;</span><br><span class="line">    return 0; //尝试换掉这个返回值看看输出的结果。</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    int status;</span><br><span class="line">    int id = wait(&amp;status);</span><br><span class="line">    printf(&quot;%d\n&quot;, status);</span><br><span class="line">    printf(&quot;Child process return status is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">    printf(&quot;Child process id is %d&quot;, id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">Child process return status is 0</span><br><span class="line">Child process id is 99932</span><br></pre></td></tr></table></figure>
<p><code>WEXITSTATUS</code>是预设的函数，用来查看函数的返回值的。还有很多其他的函数可供使用，
详情<a href="https://linux.die.net/man/2/wait">点这里</a>。</p>
<p>这里有一个很大的问题，一定不要弄混淆了</p>
<ol type="1">
<li><p><code>wait()</code>的返回值不是子进程的返回值,
而是子进程的id。</p></li>
<li><p><code>status</code>不是子进程的返回值，而是进程的状态。所以子进程无论return什么，只要正常返回，status都是0</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240331193109603.png" /></p></li>
</ol>
<p>另外需要说明的是<code>wait()</code>函数并不仅仅是在等到子进程结束，而是在子进程<strong>状态转移</strong>的时候返回</p>
<h1 id="exec">exec</h1>
<p><code>exec()</code>是一系列函数的总称，主要的作用是执行某个文件。它们分别是<code>execl()</code>,
<code>execlp()</code>, <code>execle()</code>, <code>execv()</code>,
<code>execvp()</code>,
<code>execvpe()</code>。我后面会补充一期文件系统的复习。现在只要假设<code>exec()</code>可以用来跑一个程序就好。</p>
<p>这么多函数，我应该用哪一个？别慌。以<code>exec</code>作为前缀，我们可以这样确定要用哪一个函数：</p>
<ul>
<li><code>l</code>代表输入的是参数，而<code>v</code>代表输入的是数组。</li>
<li>带<code>e</code>表示需要设置环境，不带<code>e</code>表示不需要。</li>
<li>带<code>p</code>表示输入的是可执行文件的名字，不带表示输入的是可执行文件的路径（函数会根据<code>$PATH</code>的路径来判断可执行文件的位置）。
下面这段代码介绍了<code>execlp()</code>和<code>execvp()</code>的区别。
程序会输出两段一样的结果，分别是子进程和父进程的运行结果。不同的是，父进程用<code>execvp()</code>,
根据上面的判断这是一个接受参数数组和可执行文件名的函数。你可以试着自己换不同的函数来尝试他们的效果。</li>
<li><code>NULL</code>在函数中的作用是告诉函数参数到此为止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  char args1[] = &quot;ls&quot;;</span><br><span class="line">  char args2[] = &quot;-la&quot;;</span><br><span class="line"></span><br><span class="line">  char* command[] = &#123;args1, args2, NULL&#125;;</span><br><span class="line">  pid_t pid1;</span><br><span class="line"></span><br><span class="line">  pid1 = fork();</span><br><span class="line">  if(pid1 &lt; 0)&#123;</span><br><span class="line">    printf(&quot;Error: creating child process&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pid1 == 0)&#123;</span><br><span class="line">    //execlp 接收n个参数，其中第一个是可执行文件名，后面的都是可执行参数。</span><br><span class="line">    //最后一个参数必须为NULL。</span><br><span class="line">    execlp(args1, args1, args2, NULL);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    wait(NULL);</span><br><span class="line">    //execvp 接收两个参数，一个是可执行文件名，一个是执行参数的数组。</span><br><span class="line">    //数组最后的元素必须为NULL。</span><br><span class="line">    execvp(args1, command);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<ol type="1">
<li>要创建子进程我们要用<code>fork()</code>，这个函数的返回值告诉我们子进程是否创建成功。</li>
<li>要在子进程中运行可执行文件要用<code>exec()</code>，这个函数有多个变种，用哪一个根据手头有的变量确定。</li>
<li><code>wait()</code>被父进程用于等待子进程的状态。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>数据分析第一章-pandas基础</title>
    <url>/posts/c138cc70.html</url>
    <content><![CDATA[<h1 id="导入">导入</h1>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<h1 id="pandas的数据结构介绍">pandas的数据结构介绍</h1>
<h2 id="series">Series</h2>
<h3 id="创建最简单的series">创建最简单的series</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060409357.png" /></p>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。</p>
<h3
id="获取series的数组表示形式和索引对象">获取series的数组表示形式和索引对象</h3>
<p>可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.values</span><br><span class="line">obj.index</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060628380.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060655444.png" /></p>
<h3 id="指定创建的series的索引">指定创建的Series的索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">obj2</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228060854021.png" /></p>
<h3
id="通过索引的形式选取series中单个或者一组值">通过索引的形式选取Series中单个或者一组值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="修改series中数组对象里的值">修改Series中数组对象里的值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   -<span class="number">10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="与字典的关系">与字典的关系</h3>
<h4
id="可以将series看成是一个定长的有序字典因为它是索引值到数据值的一个映射它可以用在许多原本需要字典参数的函数中">可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="直接传入一个python字典">直接传入一个python字典</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4
id="通过传入一个python列表修改series中的索引从而修改series中的键值对排序">通过传入一个python列表，修改Series中的索引，从而修改Series中的键值对排序</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not
a
number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<h4
id="isnull和notnull函数可用于检测缺失数据">isnull和notnull函数可用于检测缺失数据：</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>Series也有类似的实例方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [34]: obj4.isnull()</span><br><span class="line">Out[34]: </span><br><span class="line">California     True</span><br><span class="line">Ohio          False</span><br><span class="line">Oregon        False</span><br><span class="line">Texas         False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h4 id="name属性">name属性</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>
<h4 id="修改索引">修改索引</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="dataframe">DataFrame</h2>
<h3
id="通过传入等长列表或numpy数组组成的字典建立dataframe">通过传入等长列表或Numpy数组组成的字典建立DataFrame</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304054932701.png" /></p>
<h3 id="head方法">head方法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.head()</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304055151225.png" /></p>
<h3 id="指定列的排列顺序">指定列的排列顺序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.DataFrame(data, columns = [<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304055531166.png" /></p>
<h3 id="指定行的编号">指定行的编号</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame2 = pd.DataFrame(data, columns = [<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>], index = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>])</span><br><span class="line">frame2</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304060033591.png" /></p>
<h3
id="从dataframe的列获取为一个series">从DataFrame的列获取为一个Series</h3>
<h4 id="类似字典标记的方式">类似字典标记的方式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h4 id="属性的方式">属性的方式</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure>
<p>注：
frame2[column]<font color = 'red'>适用于任何列的名</font>，但是frame2.column只有在<font color = "red">列名是一个合理的Python变量名</font>时才适用。</p>
<h3 id="用loc获取行">用loc获取行</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [53]: frame2.loc[&#x27;three&#x27;]</span><br><span class="line">Out[53]: </span><br><span class="line">year     2002</span><br><span class="line">state    Ohio</span><br><span class="line">pop       3.6</span><br><span class="line">Name: three, dtype: object</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304061850402.png" /></p>
<h3 id="给缺失值的列赋值">给缺失值的列赋值</h3>
<h4 id="赋同一个值">赋同一个值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br></pre></td></tr></table></figure>
<h4 id="赋不同的值">赋不同的值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">0.0</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>   <span class="number">1.0</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">2.0</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>   <span class="number">3.0</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>   <span class="number">4.0</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<p>注：将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。</p>
<h3
id="赋值的是一个series就会精确匹配dataframe的索引所有的空位都将被填上缺失值">赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: frame2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN</span><br></pre></td></tr></table></figure>
<h3
id="根据state是否为ohio添加一列名为eastern的列">根据state是否为'Ohio'添加一列名为eastern的列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: frame2[<span class="string">&#x27;eastern&#x27;</span>] = frame2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: frame2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>注意：不能用frame2.eastern创建新的列。</p>
<h3 id="用del删除列">用del删除列</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> frame2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3
id="通过嵌套字典创建dataframe最外层会作为行往内一层会作为列再往里作为行与列交叉对应空格的值">通过嵌套字典创建DataFrame，最外层会作为行，往内一层会作为列，再往里作为行与列交叉对应空格的值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: frame3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<h3 id="转置dataframe">转置DataFrame</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.T</span><br></pre></td></tr></table></figure>
<h3
id="截取一个dataframe前两行的两种写法">截取一个DataFrame前两行的两种写法</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>:frame3[<span class="string">&#x27;Ohio&#x27;</span>][:-<span class="number">1</span>],</span><br><span class="line">         <span class="string">&#x27;Nevada&#x27;</span>:frame3[<span class="string">&#x27;Nevada&#x27;</span>][:<span class="number">2</span>]&#125;</span><br><span class="line">pd.DataFrame(pdata)</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305063001812.png" /></p>
<h3
id="设置dataframe的index和columns属性">设置DataFrame的index和columns属性</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305063455936.png" /></p>
<h3 id="dataframe的values属性">DataFrame的values属性</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">2.4</span>,  <span class="number">1.7</span>],</span><br><span class="line">       [ <span class="number">2.9</span>,  <span class="number">3.6</span>]])</span><br></pre></td></tr></table></figure>
<p>注：如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型</p>
<h2 id="索引对象">索引对象</h2>
<p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: index</span><br><span class="line">Out[<span class="number">78</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><font color = "red">Index对象是不可变的，因此用户不能对其进行修改</font></p>
<p>pandas与python不同，可以包含重复的标签</p>
<h1 id="基本功能">基本功能</h1>
<h2 id="重新索引">重新索引</h2>
<h3
id="用series的reindex会根据新索引重排如果当前索引不存在就引入缺失值">用Series的reindex会根据新索引重排，如果当前索引不存在就引入缺失值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="用method进行插值处理">用method进行插值处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: obj3</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe中使用reindex修改行索引">DataFrame中使用reindex，修改行索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe使用columns修改列索引">DataFrame使用columns修改列索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: states = [<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;California&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="number">1</span>   NaN           <span class="number">2</span></span><br><span class="line">c      <span class="number">4</span>   NaN           <span class="number">5</span></span><br><span class="line">d      <span class="number">7</span>   NaN           <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h2 id="丢弃指定轴上的项">丢弃指定轴上的项</h2>
<h3
id="series中使用drop方法返回在指定轴上删除指定值的新对象">Series中使用Drop方法返回在指定轴上删除指定值的新对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: obj</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: new_obj</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe用标签序列调用drop会从行标签axis-0删除值">DataFrame用标签序列调用drop会从行标签（axis
0）删除值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h3
id="dataframe通过传递axis1或axiscolumns可以删除列的值">DataFrame通过传递axis=1或axis='columns'可以删除列的值：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">&#x27;two&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data.drop([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3
id="用inplace就地修改不返回新对象">用inplace就地修改不返回新对象</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: obj.drop(<span class="string">&#x27;c&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: obj</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="索引选取和过滤">索引、选取和过滤</h2>
<h3
id="series索引类似numpy索引可以切片但是这个切片是包含末端的还可以索引的对象不是整数而是字符">Series索引，类似numpy索引，可以切片,但是这个切片是包含末端的，还可以索引的对象不是整数而是字符</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3
id="用切片可以对series的相应部分进行设置">用切片可以对Series的相应部分进行设置</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308054828881.png" /></p>
<h3
id="通过一个值对dataframe进行索引">通过一个值对DataFrame进行索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br></pre></td></tr></table></figure>
<h3
id="通过一个序列对dataframe索引主要要套两层">通过一个序列对DataFrame索引，主要要套两层[]</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line">In [<span class="number">131</span>]: data[[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]]</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="number">2</span>    <span class="number">0</span></span><br><span class="line">Colorado      <span class="number">6</span>    <span class="number">4</span></span><br><span class="line">Utah         <span class="number">10</span>    <span class="number">8</span></span><br><span class="line">New York     <span class="number">14</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="通过切片索引选取行">通过切片索引选取行</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308055742644.png" /></p>
<h3 id="通过在列基础上条件判断索引">通过在列基础上条件判断索引</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308060054604.png" /></p>
<h3 id="通过对整体条件判断">通过对整体条件判断</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2
id="用loc和iloc从dataframe选择行和列的子集">用loc和iloc从DataFrame选择行和列的子集。</h2>
<h3 id="使用loc直接选取轴名称">使用loc直接选取轴名称</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308060814326.png" /></p>
<h3 id="使用iloc通过轴下标选取">使用iloc通过轴下标选取</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/31c156b894c83af0378386730f25873.jpg" /></p>
<h3 id="切片获取标签">切片获取标签</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: data.loc[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">141</span>]: </span><br><span class="line">Ohio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line">In [<span class="number">142</span>]: data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h2 id="算术运算和数据对齐">算术运算和数据对齐</h2>
<h3 id="series的数据对齐">Series的数据对齐</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="dataframe的对齐">DataFrame的对齐</h3>
<p>先取行标签和列标签的并集，然后两个DataFrame对象公共部分才会保留并运算，如果两个都没有或者只有1个有都是认为NAN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure>
<h3 id="在算术方法中填充值">在算术方法中填充值</h3>
<p>使用df1的add方法，传入df2以及一个fill_value参数，可以让原本产生NaN的值得到指定的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure>
<h3 id="dataframe和series之间的运算">DataFrame和Series之间的运算</h3>
<h4 id="广播">广播</h4>
<p>从arr减去arr[0]，每一行都会执行这个操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240311063147918.png" /></p>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis='index'
or axis=0）并进行广播。</p>
<h3 id="排序和排名">排序和排名</h3>
<h4 id="排序">排序</h4>
<h5 id="sort_index">sort_index</h5>
<p>在Series中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在DataFrame中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>降序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h5 id="sort_values">sort_values</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<p>根据某一列排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">214</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="排名">排名</h4>
<h5 id="按average排名">按“average”排名</h5>
<p>相同值的元素将被分配平均排名。例如，如果有n个元素并列，那么它们的排名将是：并列首行所在的行数+0.5*(n-1)。</p>
<p>举个例子：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3320338d6e68533862a5af71232b456.jpg" /></p>
<h5 id="按first排名">按“first”排名</h5>
<p>据出现顺序分配排名，按从小到大，排名等于行所在的行数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/62e313c1e197c77cf6b54978175b713.jpg" /></p>
<h5 id="max排名">max排名</h5>
<p>相同值的元素将被分配最高排名。例如，如果有n个元素并列，那么它们的排名将都是最后一个元素所在的行数。</p>
<h5
id="dataframe可以在行或列上计算排名">DataFrame可以在行或列上计算排名：</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240319062648290.png" /></p>
<h3 id="带有重复标签的轴索引">带有重复标签的轴索引</h3>
<h2 id="汇总和计算描述统计">汇总和计算描述统计</h2>
<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320054354757.png" /></p>
<p>传入axis='columns'或axis=1将会按行进行求和运算：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055013896.png" /></p>
<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055248960.png" /></p>
<p>求最大值与最小值的索引</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320055957031.png" /></p>
<p>累积求和</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240320060151721.png" /></p>
<p>到b那一层就是b = b + a</p>
<p>到c那一层就是c = c + b + a</p>
<h3 id="多个股票代码的demo">多个股票代码的demo</h3>
<h4 id="download模块">download模块。</h4>
<p>举例：一次性获取 Amazon、Apple 和 Google 的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = yf.download(<span class="string">&quot;AMZN AAPL GOOG&quot;</span>, start=<span class="string">&quot;2017-01-01&quot;</span>, end=<span class="string">&quot;2017-04-30&quot;</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-ef7734b928680d5172e82b910cba68f3_720w.webp" /></p>
<p>按股票代码而不是开盘价/最高价/最低价/收盘价进行分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = yf.download(<span class="string">&quot;AMZN AAPL GOOG&quot;</span>, start=<span class="string">&quot;2017-01-01&quot;</span>,</span><br><span class="line">                    end=<span class="string">&quot;2017-04-30&quot;</span>, group_by=<span class="string">&#x27;tickers&#x27;</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-359419adff58f22c6e0c1f2b4e6ef95e_720w.webp" /></p>
<h4 id="市盈率">市盈率</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aapl = yf.Ticker(<span class="string">&quot;aapl&quot;</span>)</span><br><span class="line">aapl.info[<span class="string">&#x27;forwardPE&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>yf.Ticker("aapl")</code> 创建了一个 <code>Ticker</code>
对象，该对象表示了苹果公司的股票。</li>
<li><code>aapl.info</code>
属性返回一个字典，包含了苹果公司股票的各种信息，如公司名称、市值、市盈率等。</li>
<li><code>aapl.info['forwardPE']</code> 从返回的字典中获取了键为
<code>'forwardPE'</code> 的值，该值代表了苹果公司的预测市盈率（forward
PE ratio）。</li>
</ol>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24.95391</span><br></pre></td></tr></table></figure>
<h4 id="股息">股息</h4>
<p>年度股息百分比：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aapl.info[<span class="string">&#x27;dividendRate&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.96</span><br></pre></td></tr></table></figure>
<p>在发生的日期对每笔股息支付进行细分</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date</span><br><span class="line">1987-05-11 00:00:00-04:00    0.000536</span><br><span class="line">1987-08-10 00:00:00-04:00    0.000536</span><br><span class="line">1987-11-17 00:00:00-05:00    0.000714</span><br><span class="line">1988-02-12 00:00:00-05:00    0.000714</span><br><span class="line">1988-05-16 00:00:00-04:00    0.000714</span><br><span class="line">                               ...   </span><br><span class="line">2023-02-10 00:00:00-05:00    0.230000</span><br><span class="line">2023-05-12 00:00:00-04:00    0.240000</span><br><span class="line">2023-08-11 00:00:00-04:00    0.240000</span><br><span class="line">2023-11-10 00:00:00-05:00    0.240000</span><br><span class="line">2024-02-09 00:00:00-05:00    0.240000</span><br><span class="line">Name: Dividends, Length: 82, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="相关系数和协方差">相关系数和协方差</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取股票数据</span></span><br><span class="line">all_data = &#123;ticker: yf.Ticker(ticker).history(period=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;GOOG&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建价格 DataFrame</span></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Close&#x27;</span>]</span><br><span class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建成交量 DataFrame</span></span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">                       <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure>
<p>相关系数</p>
<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].corr(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">244</span>]: <span class="number">0.49976361144151144</span></span><br></pre></td></tr></table></figure>
<p>协方差</p>
<p>cov用于计算协方差</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">245</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].cov(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">245</span>]: <span class="number">8.8706554797035462e-05</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">1.000000</span>  <span class="number">0.407919</span>  <span class="number">0.386817</span>  <span class="number">0.389695</span></span><br><span class="line">GOOG  <span class="number">0.407919</span>  <span class="number">1.000000</span>  <span class="number">0.405099</span>  <span class="number">0.465919</span></span><br><span class="line">IBM   <span class="number">0.386817</span>  <span class="number">0.405099</span>  <span class="number">1.000000</span>  <span class="number">0.499764</span></span><br><span class="line">MSFT  <span class="number">0.389695</span>  <span class="number">0.465919</span>  <span class="number">0.499764</span>  <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">0.000277</span>  <span class="number">0.000107</span>  <span class="number">0.000078</span>  <span class="number">0.000095</span></span><br><span class="line">GOOG  <span class="number">0.000107</span>  <span class="number">0.000251</span>  <span class="number">0.000078</span>  <span class="number">0.000108</span></span><br><span class="line">IBM   <span class="number">0.000078</span>  <span class="number">0.000078</span>  <span class="number">0.000146</span>  <span class="number">0.000089</span></span><br><span class="line">MSFT  <span class="number">0.000095</span>  <span class="number">0.000108</span>  <span class="number">0.000089</span>  <span class="number">0.000215</span></span><br></pre></td></tr></table></figure>
<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [249]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[249]: </span><br><span class="line">AAPL    0.386817</span><br><span class="line">GOOG    0.405099</span><br><span class="line">IBM     1.000000</span><br><span class="line">MSFT    0.499764</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [250]: returns.corrwith(volume)</span><br><span class="line">Out[250]: </span><br><span class="line">AAPL   -0.075565</span><br><span class="line">GOOG   -0.007067</span><br><span class="line">IBM    -0.204849</span><br><span class="line">MSFT   -0.092950</span><br><span class="line"></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入axis='columns'即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h3 id="唯一值值计数以及成员资格">唯一值、值计数以及成员资格</h3>
<h4 id="unique">unique</h4>
<p>它可以得到Series中的唯一值数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [251]: obj = pd.Series([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;])</span><br><span class="line">In [252]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [253]: uniques</span><br><span class="line">Out[253]: array([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;], dtype=object)</span><br></pre></td></tr></table></figure>
<h4 id="value_counts">value_counts</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [254]: obj.value_counts()</span><br><span class="line">Out[254]: </span><br><span class="line">c    3</span><br><span class="line">a    3</span><br><span class="line">b    2</span><br><span class="line">d    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="isin">isin</h4>
<p>用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [256]: obj</span><br><span class="line">Out[256]: </span><br><span class="line">0    c</span><br><span class="line">1    a</span><br><span class="line">2    d</span><br><span class="line">3    a</span><br><span class="line">4    a</span><br><span class="line">5    b</span><br><span class="line">6    b</span><br><span class="line">7    c</span><br><span class="line">8    c</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [257]: mask = obj.isin([&#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line"></span><br><span class="line">In [258]: mask</span><br><span class="line">Out[258]: </span><br><span class="line">0     True</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5     True</span><br><span class="line">6     True</span><br><span class="line">7     True</span><br><span class="line">8     True</span><br><span class="line">dtype: bool</span><br><span class="line"></span><br><span class="line">In [259]: obj[mask]</span><br><span class="line">Out[259]: </span><br><span class="line">0    c</span><br><span class="line">5    b</span><br><span class="line">6    b</span><br><span class="line">7    c</span><br><span class="line">8    c</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h4 id="index.get_indexer">Index.get_indexer</h4>
<p>给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [260]: to_match = pd.Series([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;])</span><br><span class="line"></span><br><span class="line">In [261]: unique_vals = pd.Series([&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;])</span><br><span class="line"></span><br><span class="line">In [262]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[262]: array([0, 2, 1, 1, 0, 2])</span><br></pre></td></tr></table></figure>
<h4 id="apply">apply</h4>
<p>产生柱状图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [265]: result = data.apply(pd.value_counts).fillna(0)</span><br><span class="line"></span><br><span class="line">In [266]: result</span><br><span class="line">Out[266]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line">1  1.0  1.0  1.0</span><br><span class="line">2  0.0  2.0  1.0</span><br><span class="line">3  2.0  2.0  0.0</span><br><span class="line">4  2.0  0.0  2.0</span><br><span class="line">5  0.0  0.0  1.0</span><br></pre></td></tr></table></figure>
<p>结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>jupyter-notebook的安装与卸载</title>
    <url>/posts/d50567ed.html</url>
    <content><![CDATA[<p>参考文章 安装
https://blog.csdn.net/Withadream/article/details/125440035 卸载
https://www.cnblogs.com/kaerxifa/p/12963733.html</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-数据加载</title>
    <url>/posts/963d95c9.html</url>
    <content><![CDATA[<h1 id="一读取文本格式数据">一、读取文本格式数据</h1>
<span id="more"></span>
<h2 id="read_csv">read_csv</h2>
<p>将以逗号分隔的csv文件读入DataFrame中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [9]: df = pd.read_csv(&#x27;examples/ex1.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [10]: df</span><br><span class="line">Out[10]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="处理没有标题行的文件">处理没有标题行的文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,hello</span><br><span class="line">5,6,7,8,world</span><br><span class="line">9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="分配默认的列名">分配默认的列名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [13]: pd.read_csv(&#x27;examples/ex2.csv&#x27;, header=None)</span><br><span class="line">Out[13]: </span><br><span class="line">   0   1   2   3      4</span><br><span class="line">0  1   2   3   4  hello</span><br><span class="line">1  5   6   7   8  world</span><br><span class="line">2  9  10  11  12    foo</span><br></pre></td></tr></table></figure>
<h4 id="自己定义列名">自己定义列名</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [14]: pd.read_csv(&#x27;examples/ex2.csv&#x27;, names=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;message&#x27;])</span><br><span class="line">Out[14]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="将多个列做成一个层次化索引">将多个列做成一个层次化索引</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,1,2</span><br><span class="line">one,b,3,4</span><br><span class="line">one,c,5,6</span><br><span class="line">one,d,7,8</span><br><span class="line">two,a,9,10</span><br><span class="line">two,b,11,12</span><br><span class="line">two,c,13,14</span><br><span class="line">two,d,15,16</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [18]: parsed = pd.read_csv(&#x27;examples/csv_mindex.csv&#x27;,</span><br><span class="line">   ....:                      index_col=[&#x27;key1&#x27;, &#x27;key2&#x27;])</span><br><span class="line"></span><br><span class="line">In [19]: parsed</span><br><span class="line">Out[19]: </span><br><span class="line">           value1  value2</span><br><span class="line">key1 key2                </span><br><span class="line">one  a          1       2</span><br><span class="line">     b          3       4</span><br><span class="line">     c          5       6</span><br><span class="line">     d          7       8</span><br><span class="line">two  a          9      10</span><br><span class="line">     b         11      12</span><br><span class="line">     c         13      14</span><br><span class="line">     d         15      16</span><br></pre></td></tr></table></figure>
<h3 id="处理不固定分隔符">处理不固定分隔符</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [20]: list(open(&#x27;examples/ex3.txt&#x27;))</span><br><span class="line">Out[20]: </span><br><span class="line">[&#x27;            A         B         C\n&#x27;,</span><br><span class="line"> &#x27;aaa -0.264438 -1.026059 -0.619500\n&#x27;,</span><br><span class="line"> &#x27;bbb  0.927272  0.302904 -0.032399\n&#x27;,</span><br><span class="line"> &#x27;ccc -0.264273 -0.386314 -0.217601\n&#x27;,</span><br><span class="line"> &#x27;ddd -0.871858 -0.348382  1.100491\n&#x27;]</span><br></pre></td></tr></table></figure>
<p>上面不是txt文档中不是像csv统一同逗号分隔，而是用不等长空格分隔，所以使用read_table方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [21]: result = pd.read_table(&#x27;examples/ex3.txt&#x27;, sep=&#x27;\s+&#x27;)</span><br><span class="line"></span><br><span class="line">In [22]: result</span><br><span class="line">Out[22]: </span><br><span class="line">            A         B         C</span><br><span class="line">aaa -0.264438 -1.026059 -0.619500</span><br><span class="line">bbb  0.927272  0.302904 -0.032399</span><br><span class="line">ccc -0.264273 -0.386314 -0.217601</span><br><span class="line">ddd -0.871858 -0.348382  1.100491</span><br></pre></td></tr></table></figure>
<h3 id="跳过指定行">跳过指定行</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hey!</span><br><span class="line">a,b,c,d,message</span><br><span class="line"># just wanted to make things more difficult for you</span><br><span class="line"># who reads CSV files with computers, anyway?</span><br><span class="line">1,2,3,4,hello</span><br><span class="line">5,6,7,8,world</span><br><span class="line">9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [24]: pd.read_csv(&#x27;examples/ex4.csv&#x27;, skiprows=[0, 2, 3])</span><br><span class="line">Out[24]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="缺失值处理">缺失值处理</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">something,a,b,c,d,message</span><br><span class="line">one,1,2,3,4,NA</span><br><span class="line">two,5,6,,8,world</span><br><span class="line">three,9,10,11,12,foo</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: result = pd.read_csv(&#x27;examples/ex5.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [27]: result</span><br><span class="line">Out[27]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line">0       one  1   2   3.0   4     NaN</span><br><span class="line">1       two  5   6   NaN   8   world</span><br><span class="line">2     three  9  10  11.0  12     foo</span><br><span class="line"></span><br><span class="line">In [28]: pd.isnull(result)</span><br><span class="line">Out[28]: </span><br><span class="line">   something      a      b      c      d  message</span><br><span class="line">0      False  False  False  False  False     True</span><br><span class="line">1      False  False  False   True  False    False</span><br><span class="line">2      False  False  False  False  False    False</span><br></pre></td></tr></table></figure>
<h4
id="用一个列表或集合的字符串表示缺失值指定原来文件中特定的值是缺失值">用一个列表或集合的字符串表示缺失值，指定原来文件中特定的值是缺失值</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentials = &#123;&#x27;something&#x27;:[&#x27;two&#x27;], &#x27;message&#x27;:[&#x27;foo&#x27;, &#x27;NA&#x27;]&#125;</span><br><span class="line">result = pd.read_csv(&#x27;examples/ex5.csv&#x27;, na_values=sentials)</span><br><span class="line">result</span><br><span class="line">something  a   b     c   d message</span><br><span class="line">0       one  1   2   3.0   4     NaN</span><br><span class="line">1       NaN  5   6   NaN   8   world</span><br><span class="line">2     three  9  10  11.0  12     NaN</span><br></pre></td></tr></table></figure>
<p>其中'something':['two']表示针对something这一列，其中值为two的值替换成缺失值</p>
<h2 id="逐块读取文本文件">逐块读取文本文件</h2>
<h3 id="读取文件中指定行数">读取文件中指定行数</h3>
<p>通过nrows进行指定读取行数即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [36]: pd.read_csv(&#x27;examples/ex6.csv&#x27;, nrows=5)</span><br><span class="line">Out[36]: </span><br><span class="line">        one       two     three      four key</span><br><span class="line">0  0.467976 -0.038649 -0.295344 -1.824726   L</span><br><span class="line">1 -0.358893  1.404453  0.704965 -0.200638   B</span><br><span class="line">2 -0.501840  0.659254 -0.421691 -0.057688   G</span><br><span class="line">3  0.204886  1.074134  1.388361 -0.982404   R</span><br><span class="line">4  0.354628 -0.133116  0.283763 -0.837063   Q</span><br></pre></td></tr></table></figure>
<h3 id="逐块读取文件">逐块读取文件</h3>
<p>可以指定chunksize（行数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [874]: chunker = pd.read_csv(&#x27;ch06/ex6.csv&#x27;, chunksize=1000)</span><br><span class="line"></span><br><span class="line">In [875]: chunker</span><br><span class="line">Out[875]: &lt;pandas.io.parsers.TextParser at 0x8398150&gt;</span><br></pre></td></tr></table></figure>
<h3 id="逐块迭代文件">逐块迭代文件</h3>
<p>比如说，我们可以迭代处理ex6.csv，将值计数聚合到"key"列中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunker = pd.read_csv(&#x27;examples/ex6.csv&#x27;, chunksize=1000)</span><br><span class="line"></span><br><span class="line">tot = pd.Series([])</span><br><span class="line">for piece in chunker:</span><br><span class="line">    tot = tot.add(piece[&#x27;key&#x27;].value_counts(), fill_value=0)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=False)</span><br><span class="line">In [40]: tot[:10]</span><br><span class="line">Out[40]: </span><br><span class="line">E    368.0</span><br><span class="line">X    364.0</span><br><span class="line">L    346.0</span><br><span class="line">O    343.0</span><br><span class="line">Q    340.0</span><br><span class="line">M    338.0</span><br><span class="line">J    337.0</span><br><span class="line">F    335.0</span><br><span class="line">K    334.0</span><br><span class="line">H    330.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="将数据写出到文本格式">将数据写出到文本格式</h2>
<h3 id="to_csv">to_csv</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [43]: data.to_csv(&#x27;examples/out.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [44]: !cat examples/out.csv</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line">0,one,1,2,3.0,4,</span><br><span class="line">1,two,5,6,,8,world</span><br><span class="line">2,three,9,10,11.0,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="使用其他分隔符">使用其他分隔符</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [45]: import sys</span><br><span class="line"></span><br><span class="line">In [46]: data.to_csv(sys.stdout, sep=&#x27;|&#x27;)</span><br><span class="line">|something|a|b|c|d|message</span><br><span class="line">0|one|1|2|3.0|4|</span><br><span class="line">1|two|5|6||8|world</span><br><span class="line">2|three|9|10|11.0|12|foo</span><br></pre></td></tr></table></figure>
<h4 id="禁用行和列的标签">禁用行和列的标签</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [48]: data.to_csv(sys.stdout, index=False, header=False)</span><br><span class="line">one,1,2,3.0,4,</span><br><span class="line">two,5,6,,8,world</span><br><span class="line">three,9,10,11.0,12,foo</span><br></pre></td></tr></table></figure>
<h4 id="操作指定列">操作指定列</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [49]: data.to_csv(sys.stdout, index=False, columns=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line">a,b,c</span><br><span class="line">1,2,3.0</span><br><span class="line">5,6,</span><br><span class="line">9,10,11.0</span><br></pre></td></tr></table></figure>
<h2 id="处理分隔符格式">处理分隔符格式</h2>
<p>对于任何单字符分隔符文件，可以直接使用Python内置的csv模块。将任意已打开的文件或文件型的对象传给csv.reader：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import csv</span><br><span class="line">f = open(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">reader = csv.reader(f)</span><br></pre></td></tr></table></figure>
<p><font color = "red">对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In [56]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">   ....:     <span class="built_in">print</span>(line)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="创建数据列的字典">创建数据列的字典</h3>
<p>首先解释zip的作用：</p>
<p>zip()
函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p>
<p>举例1：</p>
<p>a = [1,2,3]</p>
<p>b = [4,5,6]</p>
<p>c = [4,5,6,7,8]</p>
<p>ipped = zip(a,b) # 打包为元组的列表</p>
<p>输出：[(1, 4), (2, 5), (3, 6)]</p>
<p>举例2：</p>
<p><code>zip(*values)</code>的作用是将<code>values</code>列表中的元素解压缩为多个独立的元组，然后将这些元组组合在一起成为一个迭代器。</p>
<p>具体来说，假设<code>values</code>列表是一个包含多个元组的列表，例如<code>[(v1_1, v2_1, ...), (v1_2, v2_2, ...), ...]</code>，<code>zip(*values)</code>会将这些元组解压缩并重新组合，将它们的第一个元素组成一个元组，第二个元素组成一个元组，依此类推</p>
<p>具体使用：</p>
<p>首先，读取文件到一个多行的列表中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [57]: with open(&#x27;examples/ex7.csv&#x27;) as f:</span><br><span class="line">   ....:     lines = list(csv.reader(f))</span><br></pre></td></tr></table></figure>
<p>然后，我们将这些行分为标题行和数据行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [58]: header, values = lines[0], lines[1:]</span><br></pre></td></tr></table></figure>
<p>接着，我们可以用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [59]: data_dict = &#123;h: v for h, v in zip(header, zip(*values))&#125;</span><br><span class="line"></span><br><span class="line">In [60]: data_dict</span><br><span class="line">Out[60]: &#123;&#x27;a&#x27;: (&#x27;1&#x27;, &#x27;1&#x27;), &#x27;b&#x27;: (&#x27;2&#x27;, &#x27;2&#x27;), &#x27;c&#x27;: (&#x27;3&#x27;, &#x27;3&#x27;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义新格式的csv文件">定义新格式的csv文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_dialect(csv.Dialect):</span><br><span class="line">    lineterminator = &#x27;\n&#x27;</span><br><span class="line">    delimiter = &#x27;;&#x27;</span><br><span class="line">    quotechar = &#x27;&quot;&#x27;</span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>lineterminator = '\n'</code>：定义行终止符为换行符
<code>\n</code>。</li>
<li><code>delimiter = ';'</code>：定义字段之间的分隔符为分号
<code>;</code>。</li>
<li><code>quotechar = '"'</code>：定义引号字符为双引号
<code>"</code>，用于包围包含特殊字符的字段。</li>
<li><code>quoting = csv.QUOTE_MINIMAL</code>：定义引用约定为最小引用，表示只在必要时才使用引号。</li>
</ol>
<h2 id="json数据">JSON数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj = &quot;&quot;&quot;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Wes&quot;,</span><br><span class="line"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span><br><span class="line"> &quot;pet&quot;: null,</span><br><span class="line"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span><br><span class="line">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span><br><span class="line">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="json.loads">json.loads</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [62]: import json</span><br><span class="line"></span><br><span class="line">In [63]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [64]: result</span><br><span class="line">Out[64]: </span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;Wes&#x27;,</span><br><span class="line"> &#x27;pet&#x27;: None,</span><br><span class="line"> &#x27;places_lived&#x27;: [&#x27;United States&#x27;, &#x27;Spain&#x27;, &#x27;Germany&#x27;],</span><br><span class="line"> &#x27;siblings&#x27;: [&#123;&#x27;age&#x27;: 30, &#x27;name&#x27;: &#x27;Scott&#x27;, &#x27;pets&#x27;: [&#x27;Zeus&#x27;, &#x27;Zuko&#x27;]&#125;,</span><br><span class="line">  &#123;&#x27;age&#x27;: 38, &#x27;name&#x27;: &#x27;Katie&#x27;, &#x27;pets&#x27;: [&#x27;Sixes&#x27;, &#x27;Stache&#x27;, &#x27;Cisco&#x27;]&#125;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="json.dumps">json.dumps</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [65]: asjson = json.dumps(result)</span><br></pre></td></tr></table></figure>
<h3 id="将json转换为dataframe">将json转换为DataFrame</h3>
<p>最简单方便的方式是：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [66]: siblings = pd.DataFrame(result[&#x27;siblings&#x27;], columns=[&#x27;name&#x27;, &#x27;age&#x27;])</span><br><span class="line"></span><br><span class="line">In [67]: siblings</span><br><span class="line">Out[67]: </span><br><span class="line">    name  age</span><br><span class="line">0  Scott   30</span><br><span class="line">1  Katie   38</span><br></pre></td></tr></table></figure>
<h3 id="read_json">read_json</h3>
<p>特别格式的JSON数据集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3&#125;,//里面字典,字典之间用“,”分割</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;]//外边整体列表</span><br></pre></td></tr></table></figure>
<p>自动将特别格式的JSON数据集转换为Series或DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [69]: data = pd.read_json(&#x27;examples/example.json&#x27;)</span><br><span class="line"></span><br><span class="line">In [70]: data</span><br><span class="line">Out[70]: </span><br><span class="line">   a  b  c</span><br><span class="line">0  1  2  3</span><br><span class="line">1  4  5  6</span><br><span class="line">2  7  8  9</span><br></pre></td></tr></table></figure>
<h3 id="to_json">to_json</h3>
<p>将数据从pandas输出到JSON</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [71]: print(data.to_json())</span><br><span class="line">&#123;&quot;a&quot;:&#123;&quot;0&quot;:1,&quot;1&quot;:4,&quot;2&quot;:7&#125;,&quot;b&quot;:&#123;&quot;0&quot;:2,&quot;1&quot;:5,&quot;2&quot;:8&#125;,&quot;c&quot;:&#123;&quot;0&quot;:3,&quot;1&quot;:6,&quot;2&quot;:9&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [72]: print(data.to_json(orient=&#x27;records&#x27;))</span><br><span class="line">[&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;,&#123;&quot;a&quot;:4,&quot;b&quot;:5,&quot;c&quot;:6&#125;,&#123;&quot;a&quot;:7,&quot;b&quot;:8,&quot;c&quot;:9&#125;]</span><br></pre></td></tr></table></figure>
<h1 id="二二进制数据格式">二、二进制数据格式</h1>
<p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p>
<p>to_pickle:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [87]: frame = pd.read_csv(&#x27;examples/ex1.csv&#x27;)</span><br><span class="line"></span><br><span class="line">In [88]: frame</span><br><span class="line">Out[88]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br><span class="line"></span><br><span class="line">In [89]: frame.to_pickle(&#x27;examples/frame_pickle&#x27;)</span><br></pre></td></tr></table></figure>
<p>read_pickle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [90]: pd.read_pickle(&#x27;examples/frame_pickle&#x27;)</span><br><span class="line">Out[90]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h2 id="使用hdf5格式">使用HDF5格式</h2>
<h3 id="准备数据集">准备数据集</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;&#x27;a&#x27;: np.random.randn(100)&#125;)</span><br></pre></td></tr></table></figure>
<p>创建了一个名为<code>frame</code>的Pandas
DataFrame对象，其中包含一个名为<code>a</code>的列，该列包含了随机生成的100个标准正态分布（均值为0，标准差为1）的随机数值</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325061822293.png" /></p>
<h3 id="创建">创建</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store = pd.HDFStore(&#x27;mydata.h5&#x27;)</span><br></pre></td></tr></table></figure>
<p>创建了一个名为<code>store</code>的Pandas
HDFStore对象，并打开了一个名为<code>mydata.h5</code>的HDF5文件。</p>
<h3 id="像python中键值对一样存取">像python中键值对一样存取</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store[&#x27;obj1&#x27;] = frame</span><br><span class="line">store[&#x27;obj1_col&#x27;] = frame[&#x27;a&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="table存储方式">table存储方式</h3>
<p>obj2表示存储的键，frame表示存储的值，format定义存储形式，用table形式存储好处在于可以用特殊语法查询</p>
<h3 id="read_hdf和to_hdf">read_hdf和to_hdf</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame.to_hdf(&#x27;mydata.h5&#x27;, &#x27;obj3&#x27;, format=&#x27;table&#x27;)</span><br></pre></td></tr></table></figure>
<p>将frame中内容保存在mydata.h5的hdf5文件中，对应的键是obj3，形式是table</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [102]: pd.read_hdf(&#x27;mydata.h5&#x27;, &#x27;obj3&#x27;, where=[&#x27;index &lt; 5&#x27;])</span><br><span class="line">Out[102]: </span><br><span class="line">          a</span><br><span class="line">0 -0.204708</span><br><span class="line">1  0.478943</span><br><span class="line">2 -0.519439</span><br><span class="line">3 -0.555730</span><br><span class="line">4  1.965781</span><br></pre></td></tr></table></figure>
<h2 id="读写microsoft-excel文件">读写Microsoft Excel文件</h2>
<h3 id="读取excel文件">读取excel文件</h3>
<h4 id="创建实例">创建实例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [104]: xlsx = pd.ExcelFile(&#x27;examples/ex1.xlsx&#x27;)</span><br></pre></td></tr></table></figure>
<h4
id="通过read_excel读取到dataframe">通过read_excel读取到DataFrame</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [105]: pd.read_excel(xlsx, &#x27;Sheet1&#x27;)</span><br><span class="line">Out[105]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h4 id="根据表单sheet读取">根据表单（sheet）读取</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [106]: frame = pd.read_excel(&#x27;examples/ex1.xlsx&#x27;, &#x27;Sheet1&#x27;)</span><br><span class="line"></span><br><span class="line">In [107]: frame</span><br><span class="line">Out[107]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line">0  1   2   3   4   hello</span><br><span class="line">1  5   6   7   8   world</span><br><span class="line">2  9  10  11  12     foo</span><br></pre></td></tr></table></figure>
<h3 id="写入excel文件">写入excel文件</h3>
<h4 id="创建实例-1">创建实例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(&#x27;examples/ex2.xlsx&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="写入">写入</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame.to_excel(writer, &#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="保存">保存</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<h2 id="web-apis交互">Web APIs交互</h2>
<h3 id="发送http-get请求">发送HTTP GET请求</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [113]: import requests</span><br><span class="line"></span><br><span class="line">In [114]: url = &#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span><br><span class="line"></span><br><span class="line">In [115]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [116]: resp</span><br><span class="line">Out[116]: &lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>
<h3
id="将相应返回的json字典加载到python对象中">将相应返回的json字典加载到python对象中</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [117]: data = resp.json()</span><br><span class="line"></span><br><span class="line">In [118]: data[0][&#x27;title&#x27;]</span><br><span class="line">Out[118]: &#x27;Period does not round down for frequencies less that 1 hour&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="通过dataframe提取感兴趣字段">通过DataFrame提取感兴趣字段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">issues = pd.DataFrame(data, columns=[&#x27;number&#x27;, &#x27;title&#x27;, &#x27;labels&#x27;, &#x27;state&#x27;])</span><br><span class="line">issues</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 4%" />
<col style="width: 43%" />
<col style="width: 43%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">number</th>
<th style="text-align: right;">title</th>
<th style="text-align: right;">labels</th>
<th style="text-align: right;">state</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">58019</td>
<td style="text-align: right;">CLN/PERF: Simplify argmin/argmax</td>
<td style="text-align: right;">[{'id': 2822342, 'node_id':
'MDU6TGFiZWwyODIyM...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">58018</td>
<td style="text-align: right;">PERF: Allow Index.to_frame to return
RangeInde...</td>
<td style="text-align: right;">[{'id': 8935311, 'node_id':
'MDU6TGFiZWw4OTM1M...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">58017</td>
<td style="text-align: right;">Docs: Add note about exception for
integer sli...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">58016</td>
<td style="text-align: right;">PERF: Allow np.integer Series/Index to
convert...</td>
<td style="text-align: right;">[{'id': 8935311, 'node_id':
'MDU6TGFiZWw4OTM1M...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">4</td>
<td style="text-align: right;">58015</td>
<td style="text-align: right;">BUG: Behaviour of sum/mean on sparse
boolean a...</td>
<td style="text-align: right;">[{'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td style="text-align: right;">58013</td>
<td style="text-align: right;">Potential regression induced by "CLN:
Enforce ...</td>
<td style="text-align: right;">[{'id': 2822342, 'node_id':
'MDU6TGFiZWwyODIyM...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td style="text-align: right;">58012</td>
<td style="text-align: right;">Add tests for transform sum with
series</td>
<td style="text-align: right;">[{'id': 127685, 'node_id':
'MDU6TGFiZWwxMjc2OD...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">7</td>
<td style="text-align: right;">58011</td>
<td style="text-align: right;">DEPR: enforce deprecation of non-standard
argu...</td>
<td style="text-align: right;">[{'id': 211029535, 'node_id':
'MDU6TGFiZWwyMTE...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8</td>
<td style="text-align: right;">58008</td>
<td style="text-align: right;">Backport PR #57553 on branch 2.2.x (API:
avoid...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">9</td>
<td style="text-align: right;">58007</td>
<td style="text-align: right;">API: Make <code>Series.array</code> a
read-only NumpyExte...</td>
<td style="text-align: right;">[{'id': 2085877452, 'node_id':
'MDU6TGFiZWwyMD...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">10</td>
<td style="text-align: right;">58006</td>
<td style="text-align: right;">CLN: remove unnecessary check
<code>needs_i8_conver... | [&#123;'id': 1218227310, 'node_id': 'MDU6TGFiZWwxMj... | open | |     11 | 58001 |     BUG: Implement</code>fillna(...,
limit=x)<code>for EAs | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     12 | 57999 |           DEPR: Enforce datetimelike deprecations | [&#123;'id': 211029535, 'node_id': 'MDU6TGFiZWwyMTE... | open | |     13 | 57995 | FIX #57645: Cannot use numpy FLS as indicies s... |                                                [] | open | |     14 | 57994 | DOC: DataFrame.reset_index names param can't b... | [&#123;'id': 134699, 'node_id': 'MDU6TGFiZWwxMzQ2OT... | open | |     15 | 57993 | BUG: Nones in pd.concat MultiIndex keys are no... | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     16 | 57990 | DOC: ecosystem.md: add pygwalker, add seaborn ... | [&#123;'id': 134699, 'node_id': 'MDU6TGFiZWwxMzQ2OT... | open | |     17 | 57989 |  BUG: CONTAINS_OP run on pd.NA results in pd.N... | [&#123;'id': 76811, 'node_id': 'MDU6TGFiZWw3NjgxMQ=... | open | |     18 | 57988 | PERF: (partial) fix for np_datetime.c performa... | [&#123;'id': 8935311, 'node_id': 'MDU6TGFiZWw4OTM1M... | open | |     19 | 57987 |              DEPR: 'epoch' date format in to_json | [&#123;'id': 49379259, 'node_id': 'MDU6TGFiZWw0OTM3... | open | |     20 | 57986 | CLN: enforce deprecation of frequencies deprec... | [&#123;'id': 53181044, 'node_id': 'MDU6TGFiZWw1MzE4... | open | |     21 | 57985 | BUG: Fix error for</code>boxplot<code>when using a pre-... |                                                [] | open | |     22 | 57984 | Fix</code>to_timedelta<code></code>np.int32`
casting bug with...</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">23</td>
<td style="text-align: right;">57980</td>
<td style="text-align: right;">BUG: Unexpected Styler.format
behavior</td>
<td style="text-align: right;">[&#123;'id': 1728592794, 'node_id':
'MDU6TGFiZWwxNz...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">24</td>
<td style="text-align: right;">57979</td>
<td style="text-align: right;">ENH: Add leftsemi merge</td>
<td style="text-align: right;">[&#123;'id': 76812, 'node_id':
'MDU6TGFiZWw3NjgxMg=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">25</td>
<td style="text-align: right;">57976</td>
<td style="text-align: right;">ENH: set <strong>module</strong> for
objects in pandas Scal...</td>
<td style="text-align: right;">[&#123;'id': 13101118, 'node_id':
'MDU6TGFiZWwxMzEw...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">26</td>
<td style="text-align: right;">57974</td>
<td style="text-align: right;">BUG: Fixed ADBC to_sql creation of table
when ...</td>
<td style="text-align: right;">[&#123;'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">27</td>
<td style="text-align: right;">57972</td>
<td style="text-align: right;">BUG: Wrong kurtosis outcome due to
inadequate ...</td>
<td style="text-align: right;">[&#123;'id': 76811, 'node_id':
'MDU6TGFiZWw3NjgxMQ=...</td>
<td>open</td>
</tr>
<tr class="odd">
<td style="text-align: right;">28</td>
<td style="text-align: right;">57968</td>
<td style="text-align: right;">BUG: #57954 encoding ignored for
filelike</td>
<td style="text-align: right;">[&#123;'id': 42670965, 'node_id':
'MDU6TGFiZWw0MjY3...</td>
<td>open</td>
</tr>
<tr class="even">
<td style="text-align: right;">29</td>
<td style="text-align: right;">57967</td>
<td style="text-align: right;">BUG: 7023 allow style when using error
bars</td>
<td style="text-align: right;">[]</td>
<td>open</td>
</tr>
</tbody>
</table>
<h2 id="数据库交互">数据库交互</h2>
<h3 id="将数据从sql加载到dataframe">将数据从SQL加载到DataFrame</h3>
<h4 id="创建表">创建表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query = &quot;&quot;&quot;</span><br><span class="line">CREATE TABLE test</span><br><span class="line">(a VARCHAR(20), b VARCHAR(20),</span><br><span class="line">c REAL,        d INTEGER</span><br><span class="line">);</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>一个SQL查询语句，用于创建一个名为<code>test</code>的表。该表包含了四个列，分别是<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>，对应的数据类型分别为VARCHAR(20)、VARCHAR(20)、REAL和INTEGER。</p>
<h4 id="创建到数据库的连接">创建到数据库的连接</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con = sqlite3.connect(&#x27;mydata.sqlite&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="执行在sql中创建表">执行在sql中创建表</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.execute(query)</span><br></pre></td></tr></table></figure>
<h4 id="将修改提交到数据库">将修改提交到数据库</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.commit()</span><br></pre></td></tr></table></figure>
<h4 id="创建用于插入的数据">创建用于插入的数据</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = [(&#x27;Atlanta&#x27;, &#x27;Georgia&#x27;, 1.25, 6),</span><br><span class="line">(&#x27;Tallahassee&#x27;, &#x27;Florida&#x27;, 2.6, 3),</span><br><span class="line">(&#x27;Sacramento&#x27;, &#x27;California&#x27;, 1.7, 5)]</span><br></pre></td></tr></table></figure>
<h4 id="sql-插入语句的模板">SQL 插入语句的模板</h4>
<p>使用了参数化查询的形式，其中 <code>?</code>
是占位符，表示待插入的值将在执行查询时动态地填充到相应的位置上。这种参数化查询的方式可以防止
SQL 注入攻击，并且使得查询更加灵活和可维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stmt = &quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="sql插入操作">SQL插入操作</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">con.executemany(stmt, data)</span><br></pre></td></tr></table></figure>
<h4 id="sql-查询">SQL 查询</h4>
<p>创建了一个游标对象 <code>cursor</code>，并使用 <code>execute</code>
方法执行了一个 SQL 查询操作，从 <code>test</code>
表中选择所有的行和列。执行这个操作后，游标 <code>cursor</code>
将会指向查询结果的第一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor = con.execute(&#x27;select * from test&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="获取查询结果">获取查询结果</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rows = cursor.fetchall()</span><br><span class="line">rows</span><br></pre></td></tr></table></figure>
<p>调用了游标对象 <code>cursor</code> 的 <code>fetchall()</code>
方法，用于获取执行 SQL
查询后返回的所有结果行。这将返回一个包含所有结果行的列表
<code>rows</code>。</p>
<h4 id="返回描述列的元祖项的集合">返回描述列的元祖项的集合</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cursor.description</span><br></pre></td></tr></table></figure>
<p>返回一个包含查询结果的元数据的元组，其中每个元组项描述了结果集中的一个列。每个元组项通常包含列的名称、数据类型、宽度、精度</p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-数据清洗</title>
    <url>/posts/ad398b17.html</url>
    <content><![CDATA[<h1 id="处理缺失数据">处理缺失数据</h1>
<span id="more"></span>
<p>对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据</p>
<h2 id="初始化数据">初始化数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [10]: string_data = pd.Series([&#x27;aardvark&#x27;, &#x27;artichoke&#x27;, np.nan, &#x27;avocado&#x27;])</span><br><span class="line"></span><br><span class="line">In [11]: string_data</span><br><span class="line">Out[11]:</span><br><span class="line">0     aardvark</span><br><span class="line">1    artichoke</span><br><span class="line">2          NaN</span><br><span class="line">3      avocado</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h2 id="isnull">isnull()</h2>
<p>判断当前数据是否是缺失值，是就返回true，否就返回false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [12]: string_data.isnull()</span><br><span class="line">Out[12]: </span><br><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h2 id="利用索引直接置为none">利用索引直接置为None</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [13]: string_data[0] = None</span><br><span class="line"></span><br><span class="line">In [14]: string_data.isnull()</span><br><span class="line">Out[14]: </span><br><span class="line">0     True</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h2 id="滤除缺失数据">滤除缺失数据</h2>
<h3 id="dropna">dropna</h3>
<h4 id="对于series">对于Series</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330064314334.png" /></p>
<p>等价于data[data.notnull()]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [18]: data[data.notnull()]</span><br><span class="line">Out[18]: </span><br><span class="line">0    1.0</span><br><span class="line">2    3.5</span><br><span class="line">4    7.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h4 id="对于dataframe">对于DataFrame</h4>
<h5 id="默认丢弃任何含有缺失值的行">默认丢弃任何含有缺失值的行：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [19]: data = pd.DataFrame([[1., 6.5, 3.], [1., NA, NA],</span><br><span class="line">   ....:                      [NA, NA, NA], [NA, 6.5, 3.]])</span><br><span class="line"></span><br><span class="line">In [20]: cleaned = data.dropna()</span><br><span class="line"></span><br><span class="line">In [21]: data</span><br><span class="line">Out[21]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br><span class="line"></span><br><span class="line">In [22]: cleaned</span><br><span class="line">Out[22]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br></pre></td></tr></table></figure>
<h5
id="传入howall将只丢弃全为na的那些行">传入how='all'将只丢弃全为NA的那些行：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [23]: data.dropna(how=&#x27;all&#x27;)</span><br><span class="line">Out[23]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
<h5 id="丢弃全为na的列传入axis1即可">丢弃全为NA的列，传入axis=1即可</h5>
<p>先添加第四列为全NA的列：data[4] = NA</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330065154332.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [26]: data.dropna(axis=1, how=&#x27;all&#x27;)</span><br><span class="line">Out[26]: </span><br><span class="line">     0    1    2</span><br><span class="line">0  1.0  6.5  3.0</span><br><span class="line">1  1.0  NaN  NaN</span><br><span class="line">2  NaN  NaN  NaN</span><br><span class="line">3  NaN  6.5  3.0</span><br></pre></td></tr></table></figure>
<p>利用thresh参数删除指定确实个数的行</p>
<p>用切片将不用观察的行和列之间赋值NA，然后再用默认dropna丢弃</p>
<p>切片赋值NA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n [27]: df = pd.DataFrame(np.random.randn(7, 3))</span><br><span class="line"></span><br><span class="line">In [28]: df.iloc[:4, 1] = NA</span><br><span class="line"></span><br><span class="line">In [29]: df.iloc[:2, 2] = NA</span><br><span class="line"></span><br><span class="line">In [30]: df</span><br><span class="line">Out[30]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708       NaN       NaN</span><br><span class="line">1 -0.555730       NaN       NaN</span><br><span class="line">2  0.092908       NaN  0.769023</span><br><span class="line">3  1.246435       NaN -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [31]: df.dropna()</span><br><span class="line">Out[31]: </span><br><span class="line">          0         1         2</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h2 id="填充缺失数据">填充缺失数据</h2>
<p>主要使用fillna这个方法</p>
<h3 id="将缺失值替换为指定的常数值">将缺失值替换为指定的常数值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [33]: df.fillna(0)</span><br><span class="line">Out[33]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.000000  0.000000</span><br><span class="line">1 -0.555730  0.000000  0.000000</span><br><span class="line">2  0.092908  0.000000  0.769023</span><br><span class="line">3  1.246435  0.000000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="通过字典对不同的列填充不同的值">通过字典对不同的列填充不同的值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [34]: df.fillna(&#123;1: 0.5, 2: 0&#125;)</span><br><span class="line">Out[34]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.500000  0.000000</span><br><span class="line">1 -0.555730  0.500000  0.000000</span><br><span class="line">2  0.092908  0.500000  0.769023</span><br><span class="line">3  1.246435  0.500000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="默认会返回新对象但也可以对现有对象进行就地修改">默认会返回新对象，但也可以对现有对象进行就地修改</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [35]: _ = df.fillna(0, inplace=True)</span><br><span class="line"></span><br><span class="line">In [36]: df</span><br><span class="line">Out[36]: </span><br><span class="line">          0         1         2</span><br><span class="line">0 -0.204708  0.000000  0.000000</span><br><span class="line">1 -0.555730  0.000000  0.000000</span><br><span class="line">2  0.092908  0.000000  0.769023</span><br><span class="line">3  1.246435  0.000000 -1.296221</span><br><span class="line">4  0.274992  0.228913  1.352917</span><br><span class="line">5  0.886429 -2.001637 -0.371843</span><br><span class="line">6  1.669025 -0.438570 -0.539741</span><br></pre></td></tr></table></figure>
<h3
id="对reindexing有效的那些插值方法也可用于fillna">对reindexing有效的那些插值方法也可用于fillna：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [37]: df = pd.DataFrame(np.random.randn(6, 3))</span><br><span class="line"></span><br><span class="line">In [38]: df.iloc[2:, 1] = NA</span><br><span class="line"></span><br><span class="line">In [39]: df.iloc[4:, 2] = NA</span><br><span class="line"></span><br><span class="line">In [40]: df</span><br><span class="line">Out[40]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772       NaN  1.343810</span><br><span class="line">3 -0.713544       NaN -2.370232</span><br><span class="line">4 -1.860761       NaN       NaN</span><br><span class="line">5 -1.265934       NaN       NaN</span><br><span class="line"></span><br><span class="line">In [41]: df.fillna(method=&#x27;ffill&#x27;)</span><br><span class="line">Out[41]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772  0.124121  1.343810</span><br><span class="line">3 -0.713544  0.124121 -2.370232</span><br><span class="line">4 -1.860761  0.124121 -2.370232</span><br><span class="line">5 -1.265934  0.124121 -2.370232</span><br><span class="line"></span><br><span class="line">In [42]: df.fillna(method=&#x27;ffill&#x27;, limit=2)</span><br><span class="line">Out[42]: </span><br><span class="line">          0         1         2</span><br><span class="line">0  0.476985  3.248944 -1.021228</span><br><span class="line">1 -0.577087  0.124121  0.302614</span><br><span class="line">2  0.523772  0.124121  1.343810</span><br><span class="line">3 -0.713544  0.124121 -2.370232</span><br><span class="line">4 -1.860761       NaN -2.370232</span><br><span class="line">5 -1.265934       NaN -2.370232</span><br></pre></td></tr></table></figure>
<h3 id="传入series的平均值或中位数">传入Series的平均值或中位数：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [43]: data = pd.Series([1., NA, 3.5, NA, 7])</span><br><span class="line"></span><br><span class="line">In [44]: data.fillna(data.mean())</span><br><span class="line">Out[44]: </span><br><span class="line">0    1.000000</span><br><span class="line">1    3.833333</span><br><span class="line">2    3.500000</span><br><span class="line">3    3.833333</span><br><span class="line">4    7.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h1 id="数据转换">数据转换</h1>
<h2 id="移除重复数据">移除重复数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [45]: data = pd.DataFrame(&#123;&#x27;k1&#x27;: [&#x27;one&#x27;, &#x27;two&#x27;] * 3 + [&#x27;two&#x27;],</span><br><span class="line">   ....:                      &#x27;k2&#x27;: [1, 1, 2, 3, 3, 4, 4]&#125;)</span><br><span class="line"></span><br><span class="line">In [46]: data</span><br><span class="line">Out[46]: </span><br><span class="line">    k1  k2</span><br><span class="line">0  one   1</span><br><span class="line">1  two   1</span><br><span class="line">2  one   2</span><br><span class="line">3  two   3</span><br><span class="line">4  one   3</span><br><span class="line">5  two   4</span><br><span class="line">6  two   4</span><br></pre></td></tr></table></figure>
<h3 id="duplicated方法">duplicated方法</h3>
<p>表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [47]: data.duplicated()</span><br><span class="line">Out[47]: </span><br><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2    False</span><br><span class="line">3    False</span><br><span class="line">4    False</span><br><span class="line">5    False</span><br><span class="line">6     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<h3 id="drop_duplicates方法">drop_duplicates方法</h3>
<p>指定部分列进行重复项判断。假设我们还有一列值，且只希望根据k1列过滤重复项：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240401064533732.png" /></p>
<p>duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [51]: data.drop_duplicates([&#x27;k1&#x27;, &#x27;k2&#x27;], keep=&#x27;last&#x27;)</span><br><span class="line">Out[51]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line">0  one   1   0</span><br><span class="line">1  two   1   1</span><br><span class="line">2  one   2   2</span><br><span class="line">3  two   3   3</span><br><span class="line">4  one   3   4</span><br><span class="line">6  two   4   6</span><br></pre></td></tr></table></figure>
<h2
id="利用函数或映射进行数据转换主要使用map">利用函数或映射进行数据转换(主要使用map)</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [52]: data = pd.DataFrame(&#123;&#x27;food&#x27;: [&#x27;bacon&#x27;, &#x27;pulled pork&#x27;, &#x27;bacon&#x27;,</span><br><span class="line">   ....:                               &#x27;Pastrami&#x27;, &#x27;corned beef&#x27;, &#x27;Bacon&#x27;,</span><br><span class="line">   ....:                               &#x27;pastrami&#x27;, &#x27;honey ham&#x27;, &#x27;nova lox&#x27;],</span><br><span class="line">   ....:                      &#x27;ounces&#x27;: [4, 3, 12, 6, 7.5, 8, 3, 5, 6]&#125;)</span><br><span class="line"></span><br><span class="line">In [53]: data</span><br><span class="line">Out[53]: </span><br><span class="line">          food  ounces</span><br><span class="line">0        bacon     4.0</span><br><span class="line">1  pulled pork     3.0</span><br><span class="line">2        bacon    12.0</span><br><span class="line">3     Pastrami     6.0</span><br><span class="line">4  corned beef     7.5</span><br><span class="line">5        Bacon     8.0</span><br><span class="line">6     pastrami     3.0</span><br><span class="line">7    honey ham     5.0</span><br><span class="line">8     nova lox     6.0</span><br></pre></td></tr></table></figure>
<p>添加一列表示该肉类食物来源的动物类型</p>
<p>编写一个不同肉类到动物的映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  &#x27;bacon&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;pulled pork&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;pastrami&#x27;: &#x27;cow&#x27;,</span><br><span class="line">  &#x27;corned beef&#x27;: &#x27;cow&#x27;,</span><br><span class="line">  &#x27;honey ham&#x27;: &#x27;pig&#x27;,</span><br><span class="line">  &#x27;nova lox&#x27;: &#x27;salmon&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用map前，有些肉类肉类首字母大写，比如前面0 bacon和5
Bacon，所以需要先转换成小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [55]: lowercased = data[&#x27;food&#x27;].str.lower()</span><br><span class="line"></span><br><span class="line">In [56]: lowercased</span><br><span class="line">Out[56]: </span><br><span class="line">0          bacon</span><br><span class="line">1    pulled pork</span><br><span class="line">2          bacon</span><br><span class="line">3       pastrami</span><br><span class="line">4    corned beef</span><br><span class="line">5          bacon</span><br><span class="line">6       pastrami</span><br><span class="line">7      honey ham</span><br><span class="line">8       nova lox</span><br><span class="line">Name: food, dtype: object</span><br></pre></td></tr></table></figure>
<p>然后使用字典形式在原先data基础上再加1列，用map实现肉类与肉类动物来源一一对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [57]: data[&#x27;animal&#x27;] = lowercased.map(meat_to_animal)</span><br><span class="line"></span><br><span class="line">In [58]: data</span><br><span class="line">Out[58]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line">0        bacon     4.0     pig</span><br><span class="line">1  pulled pork     3.0     pig</span><br><span class="line">2        bacon    12.0     pig</span><br><span class="line">3     Pastrami     6.0     cow</span><br><span class="line">4  corned beef     7.5     cow</span><br><span class="line">5        Bacon     8.0     pig</span><br><span class="line">6     pastrami     3.0     cow</span><br><span class="line">7    honey ham     5.0     pig</span><br><span class="line">8     nova lox     6.0  salmon</span><br></pre></td></tr></table></figure>
<p>一个能够完成全部这些工作的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [59]: data[&#x27;food&#x27;].map(lambda x: meat_to_animal[x.lower()])</span><br><span class="line">Out[59]: </span><br><span class="line">0       pig</span><br><span class="line">1       pig</span><br><span class="line">2       pig</span><br><span class="line">3       cow</span><br><span class="line">4       cow</span><br><span class="line">5       pig</span><br><span class="line">6       cow</span><br><span class="line">7       pig</span><br><span class="line">8    salmon</span><br><span class="line">Name: food, dtype: object</span><br></pre></td></tr></table></figure>
<h2 id="替换值主要使用replace">替换值(主要使用replace)</h2>
<p>map可用于修改对象的数据子集，而replace则提供了一种实现该功能的更简单、更灵活的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [60]: data = pd.Series([1., -999., 2., -999., -1000., 3.])</span><br><span class="line"></span><br><span class="line">In [61]: data</span><br><span class="line">Out[61]: </span><br><span class="line">0       1.0</span><br><span class="line">1    -999.0</span><br><span class="line">2       2.0</span><br><span class="line">3    -999.0</span><br><span class="line">4   -1000.0</span><br><span class="line">5       3.0</span><br></pre></td></tr></table></figure>
<p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为pandas能够理解的NA值，我们可以利用replace来产生一个新的Series（除非传入inplace=True）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [62]: data.replace(-999, np.nan)</span><br><span class="line">Out[62]: </span><br><span class="line">0       1.0</span><br><span class="line">1       NaN</span><br><span class="line">2       2.0</span><br><span class="line">3       NaN</span><br><span class="line">4   -1000.0</span><br><span class="line">5       3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="一次性替换多个值">一次性替换多个值</h3>
<p>可以传入一个由待替换值组成的列表以及一个替换值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [63]: data.replace([-999, -1000], np.nan)</span><br><span class="line">Out[63]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    NaN</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="每个值有不同的替换值">每个值有不同的替换值</h3>
<p>可以传递一个替换列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [64]: data.replace([-999, -1000], [np.nan, 0])</span><br><span class="line">Out[64]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入的参数也可以是字典：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [65]: data.replace(&#123;-999: np.nan, -1000: 0&#125;)</span><br><span class="line">Out[65]: </span><br><span class="line">0    1.0</span><br><span class="line">1    NaN</span><br><span class="line">2    2.0</span><br><span class="line">3    NaN</span><br><span class="line">4    0.0</span><br><span class="line">5    3.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换。我们会在后面学习Series的字符串方法。</p>
</blockquote>
<h2 id="重命名轴索引">重命名轴索引</h2>
<p>跟Series中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构</p>
<h3 id="data.index中map">data.index中map</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [66]: data = pd.DataFrame(np.arange(12).reshape((3, 4)),</span><br><span class="line">   ....:                     index=[&#x27;Ohio&#x27;, &#x27;Colorado&#x27;, &#x27;New York&#x27;],</span><br><span class="line">   ....:                     columns=[&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;])</span><br></pre></td></tr></table></figure>
<h4 id="使用匿名函数实现修改所有列">使用匿名函数实现修改所有列</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">one</th>
<th style="text-align: right;">two</th>
<th style="text-align: right;">three</th>
<th style="text-align: right;">four</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Ohio</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td>3</td>
</tr>
<tr class="even">
<td style="text-align: right;">Colorado</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td>7</td>
</tr>
<tr class="odd">
<td style="text-align: right;">New York</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td>11</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [67]: transform = lambda x: x[:4].upper()</span><br><span class="line"></span><br><span class="line">In [68]: data.index.map(transform)</span><br><span class="line">Out[68]: Index([&#x27;OHIO&#x27;, &#x27;COLO&#x27;, &#x27;NEW &#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="就地修改">就地修改</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [69]: data.index = data.index.map(transform)</span><br><span class="line"></span><br><span class="line">In [70]: data</span><br><span class="line">Out[70]:</span><br><span class="line">one  two  three  four</span><br><span class="line">OHIO    0    1      2     3</span><br><span class="line">COLO    4    5      6     7</span><br><span class="line">NEW     8    9     10    11</span><br></pre></td></tr></table></figure>
<h3 id="rename">rename</h3>
<h4 id="创建转换版不修改原式数据">创建转换版不修改原式数据</h4>
<p>创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [71]: data.rename(index=str.title, columns=str.upper)</span><br><span class="line">Out[71]: </span><br><span class="line">      ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio    0    1      2     3</span><br><span class="line">Colo    4    5      6     7</span><br><span class="line">New     8    9     10    11</span><br></pre></td></tr></table></figure>
<h4 id="部分轴标签的更新">部分轴标签的更新：</h4>
<p>用字典指明将原来换成对应的什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [72]: data.rename(index=&#123;&#x27;OHIO&#x27;: &#x27;INDIANA&#x27;&#125;,</span><br><span class="line">   ....:             columns=&#123;&#x27;three&#x27;: &#x27;peekaboo&#x27;&#125;)</span><br><span class="line">Out[72]:</span><br><span class="line">one  two  peekaboo  four</span><br><span class="line">INDIANA    0    1         2     3</span><br><span class="line">COLO       4    5         6     7</span><br><span class="line">NEW        8    9        10    11</span><br></pre></td></tr></table></figure>
<h4 id="就地修改-1">就地修改</h4>
<p>inplace=True</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [73]: data.rename(index=&#123;&#x27;OHIO&#x27;: &#x27;INDIANA&#x27;&#125;, inplace=True)</span><br><span class="line"></span><br><span class="line">In [74]: data</span><br><span class="line">Out[74]: </span><br><span class="line">         one  two  three  four</span><br><span class="line">INDIANA    0    1      2     3</span><br><span class="line">COLO       4    5      6     7</span><br><span class="line">NEW        8    9     10    11</span><br></pre></td></tr></table></figure>
<h2 id="检测和过滤异常值">检测和过滤异常值</h2>
<p>一个含有正态分布数据的DataFrame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [92]: data = pd.DataFrame(np.random.randn(1000, 4))</span><br><span class="line"></span><br><span class="line">In [93]: data.describe()</span><br><span class="line">Out[93]: </span><br><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean      0.049091     0.026112    -0.002544    -0.051827</span><br><span class="line">std       0.996947     1.007458     0.995232     0.998311</span><br><span class="line">min      -3.645860    -3.184377    -3.745356    -3.428254</span><br><span class="line">25%      -0.599807    -0.612162    -0.687373    -0.747478</span><br><span class="line">50%       0.047101    -0.013609    -0.022158    -0.088274</span><br><span class="line">75%       0.756646     0.695298     0.699046     0.623331</span><br><span class="line">max       2.653656     3.525865     2.735527     3.366626</span><br></pre></td></tr></table></figure>
<h3 id="在列中找指定范围的值">在列中找指定范围的值</h3>
<p>找出某列中绝对值大小超过3的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [94]: col = data[2]</span><br><span class="line"></span><br><span class="line">In [95]: col[np.abs(col) &gt; 3]</span><br><span class="line">Out[95]: </span><br><span class="line">41    -3.399312</span><br><span class="line">136   -3.745356</span><br><span class="line">Name: 2, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="挑选指定行any">挑选指定行，any</h3>
<p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型DataFrame中使用any方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [96]: data[(np.abs(data) &gt; 3).any(1)]</span><br><span class="line">Out[96]: </span><br><span class="line">            0         1         2         3</span><br><span class="line">41   0.457246 -0.025907 -3.399312 -0.974657</span><br><span class="line">60   1.951312  3.260383  0.963301  1.201206</span><br><span class="line">136  0.508391 -0.196713 -3.745356 -1.520113</span><br><span class="line">235 -0.242459 -3.056990  1.918403 -0.578828</span><br><span class="line">258  0.682841  0.326045  0.425384 -3.428254</span><br><span class="line">322  1.179227 -3.184377  1.369891 -1.074833</span><br><span class="line">544 -3.548824  1.553205 -2.186301  1.277104</span><br><span class="line">635 -0.578093  0.193299  1.397822  3.366626</span><br><span class="line">782 -0.207434  3.525865  0.283070  0.544635</span><br><span class="line">803 -3.645860  0.255475 -0.549574 -1.907459</span><br></pre></td></tr></table></figure>
<p>any(1)表示每一行，any(0)表示每一列</p>
<h3 id="限制值的范围">限制值的范围</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [97]: data[np.abs(data) &gt; 3] = np.sign(data) * 3</span><br><span class="line"></span><br><span class="line">In [98]: data.describe()</span><br><span class="line">Out[98]: </span><br><span class="line">                 0            1            2            3</span><br><span class="line">count  1000.000000  1000.000000  1000.000000  1000.000000</span><br><span class="line">mean      0.050286     0.025567    -0.001399    -0.051765</span><br><span class="line">std       0.992920     1.004214     0.991414     0.995761</span><br><span class="line">min      -3.000000    -3.000000    -3.000000    -3.000000</span><br><span class="line">25%      -0.599807    -0.612162    -0.687373    -0.747478</span><br><span class="line">50%       0.047101    -0.013609    -0.022158    -0.088274</span><br><span class="line">75%       0.756646     0.695298     0.699046     0.623331</span><br><span class="line">max       2.653656     3.000000     2.735527     3.000000</span><br></pre></td></tr></table></figure>
<p>根据数据的值是正还是负，np.sign(data)可以生成1和-1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [99]: np.sign(data).head()</span><br><span class="line">Out[99]: </span><br><span class="line">     0    1    2    3</span><br><span class="line">0 -1.0  1.0 -1.0  1.0</span><br><span class="line">1  1.0 -1.0  1.0 -1.0</span><br><span class="line">2  1.0  1.0  1.0 -1.0</span><br><span class="line">3 -1.0 -1.0  1.0 -1.0</span><br><span class="line">4 -1.0  1.0 -1.0 -1.0</span><br></pre></td></tr></table></figure>
<h2 id="计算指标哑变量">计算指标/哑变量</h2>
<h3 id="get_dummies">get_dummies</h3>
<h4 id="实现独热编码">实现独热编码</h4>
<p>独热编码就是用来表示当前这个数据点属于什么类，如果是这个类对应位置就是1，不是这个类对应位置就是0.</p>
<p>下面这个例子是对key这一列进行独热编码。以第0行为例。第0行是b，所以在独热矩阵中第0行，b对应的列是1，a和c对应的列是0，表示第一行表示的数是b</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403055529559.png" /></p>
<h4 id="加前缀">加前缀</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403060851823.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [112]: df_with_dummy = df[[&#x27;data1&#x27;]].join(dummies)</span><br><span class="line"></span><br><span class="line">In [113]: df_with_dummy</span><br><span class="line">Out[113]: </span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line">0      0      0      1      0</span><br><span class="line">1      1      0      1      0</span><br><span class="line">2      2      1      0      0</span><br><span class="line">3      3      0      0      1</span><br><span class="line">4      4      1      0      0</span><br><span class="line">5      5      0      1      0</span><br></pre></td></tr></table></figure>
<h3 id="movielens-1m数据集">MovieLens 1M数据集：</h3>
<h4 id="读取">读取</h4>
<p>利用read_table，从路径下读取文件，其中以"::"作为分隔符，列名不用原来的列名，而用之前规定好的列名</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403063124153.png" /></p>
<h4
id="从数据集中抽取出不同的genre值">从数据集中抽取出不同的genre值</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: all_genres = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">   .....:     all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: genres = pd.unique(all_genres)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [120]: genres</span><br><span class="line">Out[120]: </span><br><span class="line">array([&#x27;Animation&#x27;, &quot;Children&#x27;s&quot;, &#x27;Comedy&#x27;, &#x27;Adventure&#x27;, &#x27;Fantasy&#x27;,</span><br><span class="line">       &#x27;Romance&#x27;, &#x27;Drama&#x27;, &#x27;Action&#x27;, &#x27;Crime&#x27;, &#x27;Thriller&#x27;,&#x27;Horror&#x27;,</span><br><span class="line">       &#x27;Sci-Fi&#x27;, &#x27;Documentary&#x27;, &#x27;War&#x27;, &#x27;Musical&#x27;, &#x27;Mystery&#x27;, &#x27;Film-Noir&#x27;,</span><br><span class="line">       &#x27;Western&#x27;], dtype=object)</span><br></pre></td></tr></table></figure>
<h4 id="构建指标dataframe">构建指标DataFrame</h4>
<h5 id="首先从全零开始">首先从全零开始</h5>
<p>全零矩阵的行是之前读取的电影部数，列是之前抽取的genre值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zero_matrix = np.zeros((len(movies), len(genres)))</span><br><span class="line">dummies = pd.DataFrame(zero_matrix, columns=genres)</span><br><span class="line">dummies</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403064032847.png" /></p>
]]></content>
      <categories>
        <category>数模</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>汇编常用脚本</title>
    <url>/posts/4e8adcf4.html</url>
    <content><![CDATA[<h1 id="通用启动模版">通用启动模版</h1>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    STR DB &#x27;Hello world&#x27;, &#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:                       </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="判断一个数的正负">判断一个数的正负</h1>
<p><strong>使用指令TEST</strong></p>
<p>TEST功能简介：将两个操作数<font color = "red">进行逻辑与运算，并根据运算结果设置相关的标志位</font>。但是，Test命令的<font color = "yellow">两个操作数<strong>不会</strong>被改变</font>。运算结果在设置过相关标记位后会被丢弃。</p>
<p>作用详细说明</p>
<p>将两个操作数进行按位AND,设结果是TEMP</p>
<ol type="1">
<li>SF =
<font color = "red">将结果的最高位赋给SF标志位</font>，例如结果最高位是1，SF就是1</li>
<li><font color = "red">看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0</font></li>
</ol>
<p>指令书写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEST AL 80H</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>根据补码表示，最高位是符号位，如果符号位是1，那么这个数就是负数。所以选择十六进制中8（二进制表示1000H）作为测试数据。如果寄存器中数据第一位不是1，那么SF=0，ZF
= 1。反之SF=1，ZF = 0</p>
<p><font color = "yellow">上面这个例子体现的是TEST可以比较指定位（设置测试数据中指定位为1），</font>但只能测试1位，多位目前没碰到</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422144353872.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422144420203.png" /></p>
<hr style = "border:2px solid yellow">
<h1 id="求一个数的相反数">求一个数的相反数</h1>
<p>所用指令：NEG</p>
<p>指令语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG AX</span><br></pre></td></tr></table></figure>
<h1 id="高精度数的运算">高精度数的运算</h1>
<p>所用指令：ADD,ADC;SUB, SBB</p>
<p>总结</p>
<ol type="1">
<li>用DX、AX表示双精度数</li>
<li>低位用AX，高位用DX</li>
<li>先用非进位运算低位，再用进位运算高位</li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>题1：高精度加减</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX，X       ；用DX，AX来表示双精度数</span><br><span class="line">MOV   DX，X+2     ；低位用AX，高位用DX</span><br><span class="line">ADD    AX，Y       ；先低位运算</span><br><span class="line">ADC    DX，Y+2    ；完成X+Y </span><br><span class="line">ADD    AX，24      ；低位运算</span><br><span class="line">ADC    DX，0       ；高位运算，该语句不能少</span><br><span class="line">SUB     AX，Z      ；先低位减法</span><br><span class="line">SBB      DX，Z+2   ；完成运算</span><br><span class="line">MOV    W，AX      ；存储结果</span><br><span class="line">MOV    W+2，DX</span><br></pre></td></tr></table></figure>
<p>题2：高精度取反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG AX            ; Negate AX if negative</span><br><span class="line">NEG DX            ; Negate DX since DX is higher order word</span><br><span class="line">SBB DX, 0         ; Subtract 1 from DX if borrow occurred from AX</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：最后一行很关键，因为取反的本质是用0减，所以存在借位，高精度计算就需要考虑这点</p>
</blockquote>
<hr style = "border:2px solid yellow">
<h1 id="寻址">寻址</h1>
<p>寻址没有什么特别的脚本，但是有一点需要注意</p>
<p>内存与[内存]没有区别</p>
<p>寄存器与[寄存器]有区别</p>
<p>寄存器表示取的是寄存器的地址值</p>
<p>[寄存器]表示取的是寄存器里面的值</p>
<h1 id="寻找最值">寻找最值</h1>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>实验1：熟悉emu8086</title>
    <url>/posts/558433c7.html</url>
    <content><![CDATA[<h1 id="快速入门">快速入门</h1>
<span id="more"></span>
<h2 id="熟悉主控界面">熟悉主控界面</h2>
<h3 id="寄存器栏">寄存器栏</h3>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,1200H</span><br><span class="line">MOV DS,AX </span><br><span class="line">MOV BX,AX</span><br><span class="line">MOV CX,2</span><br><span class="line">MOV DX,09H</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Df421d7aV/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h3 id="观察内存的变化">观察内存的变化</h3>
<p>例代码功能：将4行小写字母使用2层循环变成大写</p>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;原理：因为小写字母比大写字母的ASCII值大32，32是2的5次方，即00100000b，</span><br><span class="line">;那么我们就可以将小写字母和11011111b进行and操作，实现小写字母转换成大写。</span><br><span class="line">assume cd:codesg,ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#x27;ibm             &#x27;</span><br><span class="line">    db &#x27;dec             &#x27;</span><br><span class="line">    db &#x27;dos             &#x27;</span><br><span class="line">    db &#x27;vax             &#x27;  </span><br><span class="line">    dw 0        ;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    start:</span><br><span class="line">        mov ax,datasg</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line">        </span><br><span class="line">        mov cx,4</span><br><span class="line">     s0:</span><br><span class="line">    mov ds:[40h],cx  ;将外层循环的cx值保存在datasg：40h单元中</span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,3         ;cx设置为内层循环的次数</span><br><span class="line">        </span><br><span class="line">      s:</span><br><span class="line">    mov al,[bx+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">        </span><br><span class="line">        loop s</span><br><span class="line">        </span><br><span class="line">        add bx,16</span><br><span class="line">        mov cx,ds:[40h]     ;用datasg：40h单元中的值恢复cx</span><br><span class="line">        loop s0  </span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mm421n7PQ/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h3 id="有条件终止">有条件终止</h3>
<p>实验代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX，1                     </span><br><span class="line">MOV CX,5</span><br><span class="line"></span><br><span class="line">text:</span><br><span class="line">    ADD AX,1</span><br><span class="line">    </span><br><span class="line">LOOP text</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mj42197Zh/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><a
href="http://www.sund-xys.cn/emu8086%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%EF%BC%88%E7%82%92%E9%B8%A1%E6%96%B0%E6%89%8B%E5%8F%8B%E5%A5%BD%E5%90%91%EF%BC%89/">参考文章</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第二部分_寄存器</title>
    <url>/posts/8e5029c4.html</url>
    <content><![CDATA[<h1 id="逻辑地址和物理地址">逻辑地址和物理地址</h1>
<span id="more"></span>
<p>物理地址 = 逻辑地址 * 16 + 偏移地址</p>
<p>如果有[]，默认情况下相当于将[]里面的地址加到DS上，形成物理地址</p>
<p><a
href="https://www.youtube.com/watch?v=Ayyrrxe8e7M">视频讲解</a></p>
<h1 id="csip寄存器和jmp指令">CS、IP寄存器和JMP指令</h1>
<p>CS、IP表示代码要执行的位置的指针，其中CS是段地址，IP是偏移地址</p>
<p><a
href="https://www.youtube.com/watch?v=k8HAgmXat8w">视频讲解</a></p>
<p>JMP 1000, 0：表示将CS修改为1000H， IP修改为0000H</p>
<p>JMP BX：表示CS不变，IP修改为BX里所包含的值</p>
<p><a
href="https://www.youtube.com/watch?v=Xgmz731YnUQ">视频讲解</a></p>
<h1 id="sssp寄存器和pushpop">SS、SP寄存器和PUSH，POP</h1>
<p>栈的下面地址大，上面地址小</p>
<p>SP始终指向栈顶元素</p>
<p>PUSH是先存元素，然后SP减2</p>
<p>POP是先读元素，然后SP加2</p>
<p><a
href="https://www.youtube.com/watch?v=rjnNvXgbMiY">视频讲解</a></p>
<h1 id="不同寻址方式">不同寻址方式</h1>
<p>带方括号表示里面的值作为偏移地址</p>
<p>不带方括号就是直接取里面的值</p>
<p><a
href="https://www.youtube.com/watch?v=m2ZV6Z8pi2E">视频讲解</a></p>
<h1 id="di和si寄存器">DI和SI寄存器</h1>
<p>[BX + AX] 错</p>
<p>[BX + DI] 对</p>
<p>[BX + SI + DI] 错，SI和DI只能出现1个</p>
<h1 id="bp寄存器">BP寄存器</h1>
<p>BP寄存器默认段地址是SS</p>
<p>BX与BP只能出现1个</p>
<p><a
href="https://www.youtube.com/watch?v=xconC5zUGOY">视频讲解</a></p>
<h1 id="标志寄存器">标志寄存器</h1>
<p><a
href="https://www.bilibili.com/video/BV1uT421C7rz/?spm_id_from=333.999.0.0">视频讲解：关于溢出和进位区别</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第三部分_高级函数</title>
    <url>/posts/d5498d98.html</url>
    <content><![CDATA[<h1 id="循环loop">循环loop</h1>
<span id="more"></span>
<p>先CX -
1，然后判断CX是否为0，如果不是0跳转到之前设置的LABEL出，如果是0继续向下执行</p>
<p>公式化记忆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV CX NUM	; NUM表示循环次数</span><br><span class="line">LABEL:		; 循环跳回的位置</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	LOOP LABEL	; 循环</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：等差数列求和，第一项是1，公差是2，一共有5项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:</span><br><span class="line">    MOV CX, 4</span><br><span class="line">    MOV AX, 1  </span><br><span class="line">    MOV BX, 1</span><br><span class="line">    LABEL: </span><br><span class="line">        ADD BX, 2 </span><br><span class="line">        ADD AX, BX </span><br><span class="line">        LOOP LABEL   </span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h1 id="汇编中函数的封装">汇编中函数的封装</h1>
<h2 id="call和ret">CALL和RET</h2>
<p>CALL相当于压栈，压入的是IP,这个IP是CALL的下一个语句的IP，否则就死循环了</p>
<p>RET相当于弹栈，弹出的是IP</p>
<p><a href="https://youtube.com/watch?v=P-ppy8iRcEY">视频讲解</a></p>
<h2 id="call-far-和-retf">CALL FAR 和 RETF</h2>
<p>相对于上面同时压/弹CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=MdKNEJp09L8">视频讲解</a></p>
<p><a
href="https://www.youtube.com/watch?v=9Nyugxx2_gw">视频讲解：单独使用RET会陷入死循环</a></p>
<p><a
href="https://www.youtube.com/watch?v=OSla3HtKmeQ">视频讲解：单独使用CALL程序会跳转后顺序执行</a></p>
<p>一个段的大小是16字节，从物理地址 = 段地址 * 16 +
偏移地址就可以看出来</p>
<h1 id="offset">OFFSET</h1>
<p>取偏移地址</p>
<hr style = "border:2px solid yellow">
<p>举例：将s处一条指令复制到s0</p>
<p><a
href="https://www.youtube.com/watch?v=rV23Eewgdu8">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h1 id="jmp">JMP</h1>
<h2 id="短跳转和长跳转">短跳转和长跳转</h2>
<p>短跳转只修改IP，且只存储相对距离（从JMP的下一条指令开始计算）</p>
<p>长跳转修改CS和IP，同时存储目标跳转的CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=OwuuAYreMho">视频讲解</a></p>
<h2 id="word-ptr-和-dword-ptr">word ptr 和 dword ptr</h2>
<p>word ptr读1个字，所以作为IP</p>
<p>dword ptr 读2个字，所以作为CS和IP</p>
<p><a
href="https://www.youtube.com/watch?v=6-PeurxPXMs">视频讲解</a></p>
<h1 id="数组">数组</h1>
<ol type="1">
<li><p>arr[2]:这个表示先找到arr对应地址，再在这个地址基础上加2个字节，而不是表示找arr数字第三个元素</p></li>
<li><p>虽然ASSUME DS:DATA表示将DATA段映射到DS寄存器，但是如果没有MOV AX,
DATA MOV DS,
AX依然无效。因为此时DS寄存器里的值和代码段DATA不一样</p></li>
<li><p>可以在一个数组前添上1个标号表示这个数组（相当于变量名）ARR DB
01H, 02H, 03H ARR就是标号</p>
<p><a
href="https://www.youtube.com/watch?v=C70HwHfBURc">视频讲解</a></p></li>
</ol>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第一部分_指令讲解</title>
    <url>/posts/a9d0efb2.html</url>
    <content><![CDATA[<h1 id="add-sub">add， sub</h1>
<span id="more"></span>
<p>这一类进位是直接扔掉</p>
<h1 id="muldiv">mul，div</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240426112624542.png" /></p>
<p><a
href="https://www.youtube.com/watch?v=4DJLf9CcL1o">总结：视频讲解</a></p>
<h1 id="左右移">左右移</h1>
<p>记住左右移就可以了，下面这个了解即可</p>
<p><a
href="https://www.youtube.com/watch?v=DOsO44x0ZZM">视频讲解：循环左移和左移区别</a></p>
<h1 id="交换">交换</h1>
<p><a
href="https://www.youtube.com/watch?v=CEdLcWrOtMw">视频讲解</a></p>
<h1 id="取反">取反</h1>
<p><a
href="https://www.youtube.com/watch?v=j7LAWs8ZwvA">视频讲解</a></p>
<h1 id="强转">强转</h1>
<p><a
href="https://www.youtube.com/watch?v=ZSv3Wb5tCfo">视频讲解</a></p>
<h1 id="中断">中断</h1>
<p>大意就是运行到终端指令后跳转到另一个地址执行这个地址指向的代码</p>
<p><a
href="https://www.youtube.com/watch?v=TlMCO0tEY6s">视频讲解</a></p>
<h1 id="cmp">CMP</h1>
<p>CMP AX, BX</p>
<p>AX - BX</p>
<p>如果AX &lt; BX， 借位， CF = 1</p>
<p>如果AX &gt; BX，不用借位， CF = 0</p>
<p>如果AX = BX，ZF = 1</p>
<p><a
href="https://www.youtube.com/watch?v=zgTDIypy7II">视频讲解</a></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第四部分_实战代码</title>
    <url>/posts/1e229983.html</url>
    <content><![CDATA[<h1 id="通用启动模版">通用启动模版</h1>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    STR DB &#x27;Hello world&#x27;, &#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:                       </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="输出hello-world">输出hello world</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    STR DB &#x27;Hello world&#x27;, &#x27;$&#x27;	; &#x27;$&#x27;表示结尾</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:                       </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    MOV DX, OFFSET STR	; 将要打印的东西的首地址的偏移地址移入寄存器DX</span><br><span class="line">    MOV AH, 9H</span><br><span class="line">    INT 21H</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="字符串大小写转换">字符串大小写转换</h1>
<p>难点1：大小写转换</p>
<p>小写转大写</p>
<p>小写字母 - 20H = 大写字母</p>
<p>大写转小写</p>
<p>大写字母 + 20H = 小写字母</p>
<p>难点2：写for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV [0] 1	; 错误，不可以把立即数写到内存里面</span><br></pre></td></tr></table></figure>
<p>难点3：</p>
<p>判断字母是大写还是小写，判断空格</p>
<p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    STR DB &#x27;HEllo World&#x27;,32,&#x27;$&#x27; </span><br><span class="line">    CHARA DB &#x27;a&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:                       </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX     </span><br><span class="line">    ;   全部转为大写   </span><br><span class="line">    ; for(int i = 0; i &lt; str.lentth; i++)</span><br><span class="line">    ;   if(str[i]是小写) str 转大写</span><br><span class="line">    ;</span><br><span class="line">    MOV CX, 11          ;11表示字符串长度</span><br><span class="line">    MOV SI, OFFSET STR</span><br><span class="line">    LABEL1:        </span><br><span class="line">        MOV AL, [SI]    ;将指针BI当前指向的字母放到AL</span><br><span class="line">        CMP AL, 32      ;如果AL里面是空格</span><br><span class="line">        JE LABEL2       ;直接跳到LABEL2</span><br><span class="line">        CMP AL, CHARA   ;将AL和CHARA比较</span><br><span class="line">        JB LABEL2       ;如果AL比CHARA小，说明AL是大写</span><br><span class="line">        ; 如果AX比CHARA大，说明是小写，需要转大写</span><br><span class="line">        SUB AX, 20H</span><br><span class="line">    LABEL2:             ;如果是大写，直接写回并递增</span><br><span class="line">        MOV [SI],AL</span><br><span class="line">        INC SI    </span><br><span class="line">        LOOP LABEL1</span><br><span class="line">    MOV AH, 9H</span><br><span class="line">    INT 21H                              </span><br><span class="line">    </span><br><span class="line">    ; 全部转为小写</span><br><span class="line">    MOV CX, 11</span><br><span class="line">    MOV SI, OFFSET STR   </span><br><span class="line">    LABEL3:              </span><br><span class="line">        MOV AL, [SI] </span><br><span class="line">        CMP AL, 32</span><br><span class="line">        JE LABEL4</span><br><span class="line">        CMP AL, CHARA</span><br><span class="line">        JNB LABEL4</span><br><span class="line">        ADD AL, 20H</span><br><span class="line">    LABEL4:     </span><br><span class="line">        MOV [SI], AL</span><br><span class="line">        INC SI</span><br><span class="line">        LOOP LABEL3</span><br><span class="line">    MOV AH, 9</span><br><span class="line">    INT 21H      </span><br><span class="line">    </span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="求数组最值">求数组最值</h1>
<h2 id="遍历数组">遍历数组</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    BUF DB 08AH,093H,02EH,037H,019H,040H,074H,055H,0H,0A2H</span><br><span class="line">    PLUS DB 100H DUP(0)  </span><br><span class="line">    TMP DB 100H DUP(0)</span><br><span class="line">    POS_NUM DB 0</span><br><span class="line">DATA ENDS</span><br><span class="line">MOV SI, OFFSET BUF	;将数组偏移地址移入SI，SI作为遍历数组的指针</span><br></pre></td></tr></table></figure>
<h2 id="判断正负">判断正负</h2>
<h3
id="注意有符号数和无符号数使用不同跳转">注意有符号数和无符号数使用不同跳转</h3>
<ol type="1">
<li><strong>无符号数比较</strong>：
<ul>
<li><code>JB</code> (Jump if
Below)：如果前一个操作数小于后一个操作数，则跳转。</li>
<li><code>JAE</code> (Jump if Above or
Equal)：如果前一个操作数大于等于后一个操作数，则跳转。</li>
<li>这些指令适用于无符号整数比较，因为它们直接比较数值的大小。</li>
</ul></li>
<li><strong>有符号数比较</strong>：
<ul>
<li><code>JL</code> (Jump if
Less)：如果前一个操作数小于后一个操作数，则跳转。</li>
<li><code>JGE</code> (Jump if Greater or
Equal)：如果前一个操作数大于等于后一个操作数，则跳转。</li>
<li>这些指令适用于有符号整数比较，因为它们考虑了数的符号</li>
</ul></li>
</ol>
<h1 id="十进制转十六进制并打印输出">十进制转十六进制并打印输出</h1>
<p>字符串表示的十进制“12345” --&gt; 十六进制并在寄存器中3039H --&gt;
字符串表示的十六进制“3039”</p>
<p>第一个箭头</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240507203936568.png" /></p>
<p>上面这个图就是得到10进制，但是只要存放在寄存器中会自动转为十六进制</p>
<h2
id="实现string类型转int类型用宏实现">实现string类型转int类型，用宏实现</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 宏定义</span><br><span class="line">STRDIGIT2INTDIGIT MACRO STRING_NAME, LENGTH</span><br><span class="line">    LOCAL FOR</span><br><span class="line">    PUSHF</span><br><span class="line">    LEA SI, STRING_NAME  ; 获取字符串的首地址</span><br><span class="line">    XOR DX, DX</span><br><span class="line">    XOR AX, AX</span><br><span class="line">    XOR CX, CX</span><br><span class="line">    MOV CL, LENGTH</span><br><span class="line">    FOR:</span><br><span class="line">        ; AX = 10 * AX --&gt; AX = 8 * AX + AX  --&gt; AX &lt;&lt; 3 + AX &lt;&lt; 1</span><br><span class="line">        ; 实现乘10</span><br><span class="line">        MOV DX, AX</span><br><span class="line">        PUSH CX</span><br><span class="line">        MOV CX, 3</span><br><span class="line">        SHL AX, CL</span><br><span class="line">        POP CX</span><br><span class="line">        SHL DX, 1</span><br><span class="line">        ADD AX, DX</span><br><span class="line">        ; 加上当前的字符值</span><br><span class="line">        ADD AL, [SI]</span><br><span class="line">        ADC AH, 0</span><br><span class="line">        ; - ‘0’</span><br><span class="line">        SUB AX, &#x27;0&#x27;</span><br><span class="line">        INC SI</span><br><span class="line">    LOOP FOR</span><br><span class="line">    POPF</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：宏需要放在start里面</p>
</blockquote>
<h2
id="将int类型转str类型大写字母并在屏幕上打印">将int类型转str类型（大写字母）并在屏幕上打印</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240507202358412.png" /></p>
<p>十六进制0~9加30H得到对应ASCII码</p>
<p>十六进制A~z加37H得到对应ASCII码</p>
<p>十六进制a~z加57H得到对应ASCII码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 将十六进制转ASCII码打印输出,当前结果保存在AX中</span><br><span class="line">FOR1:</span><br><span class="line">    ; 将AX中数保存到DX中         </span><br><span class="line">    MOV DX, AX </span><br><span class="line">    ; 将DX与0FH相与，那么前面都清0，就保留最后1位         </span><br><span class="line">    AND DX, 0FH</span><br><span class="line">    ; 将当前DX中的数先加上30H看得到的数与40H关系</span><br><span class="line">    ADD DX, 30H</span><br><span class="line">    CMP DX, 39H</span><br><span class="line">    ; 如果比40H小，说明目前得到的就是0~9的ASCII码，否则还要加7H才能得到A~F的ASCII码</span><br><span class="line">    JB DIGIT</span><br><span class="line">    ADD DX, 7H</span><br><span class="line">    DIGIT:    </span><br><span class="line">        ; 将DX中保存的ASCII码保存到内存中</span><br><span class="line">        MOV RES[BX], DL</span><br><span class="line">        DEC BX</span><br><span class="line">        ; 通过将AX右移1位，去掉AX中最后一个数</span><br><span class="line">        SHR AX, 4</span><br><span class="line">        LOOP FOR1</span><br><span class="line"></span><br><span class="line">MOV AH, 9H</span><br><span class="line">; 通过将RES字符串首地址赋给DX从而打印字符串</span><br><span class="line">MOV DX, OFFSET RES</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>
<h1 id="含字母的ascii码转int类型">含字母的ASCII码转int类型</h1>
<p>0 ~ 9对应的ASCII码：31H到39H</p>
<p>A ~ Z对应的ASCII码：41H到5AH</p>
<p>a ~ z 对应的ASCII码：61H到7AH</p>
<p>用了宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASCII2INT MACRO TMPBUF</span><br><span class="line">    LOCAL LABEL1, LABEL2, END0</span><br><span class="line">    PUSHF</span><br><span class="line">    XOR AX, AX</span><br><span class="line">    MOV AL, TMPBUF</span><br><span class="line">    ; 先看是不是数字</span><br><span class="line">    CMP AL, 39H</span><br><span class="line">    JG LABEL1</span><br><span class="line">        SUB AL, 30H</span><br><span class="line">    JMP END0</span><br><span class="line">    LABEL1:</span><br><span class="line">    ; 再看是不是大写字母</span><br><span class="line">    CMP AL, 5AH</span><br><span class="line">    JG LABEL2</span><br><span class="line">        SUB AL, 37H</span><br><span class="line">    JMP END0</span><br><span class="line">    ; 最后判断是不是小写字母</span><br><span class="line">    LABEL2:</span><br><span class="line">        SUB AL, 57H</span><br><span class="line">    END0:</span><br><span class="line">    POPF</span><br><span class="line">    PUSH AX</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<h1 id="字符串">字符串</h1>
<h2 id="stos">STOS</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    BUFFER DB 10H DUP(0)  ; 假设有一个10字节的缓冲区</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA           ; 将数据段地址加载到 AX 中</span><br><span class="line">    MOV DS, AX             ; 将 AX 中的数据段地址复制到 DS 中</span><br><span class="line">    MOV ES, AX             ; 将 AX 中的数据段地址复制到 ES 中</span><br><span class="line">    XOR DI, DI             ; 清零 DI 寄存器</span><br><span class="line">    </span><br><span class="line">    CLD</span><br><span class="line">    MOV CX, 10             ; 循环10次</span><br><span class="line">    MOV AL, &#x27;A&#x27;            ; 将 &#x27;A&#x27; 存储到 AL 中</span><br><span class="line"></span><br><span class="line">STORE_LOOP:</span><br><span class="line">    STOSB                  ; 将 AL 寄存器中的数据存储到 ES:DI 指定的内存地址中，并递增 DI 寄存器</span><br><span class="line">    LOOP STORE_LOOP        ; 循环</span><br><span class="line"></span><br><span class="line">    ; 这里可以继续添加其他代码</span><br><span class="line">    </span><br><span class="line">    MOV AH, 4Ch            ; 退出程序</span><br><span class="line">    INT 21h</span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h2 id="movs">MOVS</h2>
<p>CX中设置为多少就会遍历字符串中多少位</p>
<h1 id="si">SI</h1>
<p>SI是16位寄存器，也就是与AX,BX这类大小相同，所以移动SI要与AX等一个字相加</p>
<p>SI可以指向一个字MOV AX, <a href="#si">SI</a>也可以指向一个字节MOV AL,
<a href="#si">SI</a></p>
<h1 id="寻址">寻址</h1>
<p>内存寻址的时候必须是与AX这种16位寄存器搭配使用，不能与AL这类8位寄存器搭配使用</p>
<p>ADD AL, RES_INT[BX]</p>
<h1 id="字变量的原反补码转换">字变量的原，反，补码转换</h1>
<h2 id="理论">理论</h2>
<p>正数的原码 = 反码 = 补码</p>
<p>负数的反码 = 原码符号位不变，其他取反</p>
<p>负数的补码 = 原码符号位不变，其他位取反，末尾加1</p>
<h2 id="设计">设计</h2>
<ol type="1">
<li>TEST指令是用来将target和source想与，结果存放在CF里，这里是将AH与80H想与</li>
<li>这里符号位不变是在用NOT取反后加1</li>
<li>补码的取反加1是对低位用ADD，高位考虑进位用ADC</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    BUF1 DW 0FF23H</span><br><span class="line">    BUF2 DW 0</span><br><span class="line">    BUF3 DW 0</span><br><span class="line">DATA ENDS</span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:                       </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    </span><br><span class="line">    MOV AX, BUF1</span><br><span class="line">    TEST AH, 80H</span><br><span class="line">    MOV BX, AX</span><br><span class="line">    JZ POSTIVE</span><br><span class="line">    NOT AX   </span><br><span class="line">    ADD AH, 80H</span><br><span class="line">    ADD AL, 1</span><br><span class="line">    ADC AH, 0</span><br><span class="line">    NOT BX</span><br><span class="line">    ADD BH, 80H</span><br><span class="line">    POSTIVE:</span><br><span class="line">        MOV BUF2, AX</span><br><span class="line">        MOV BUF3, BX</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="用宏定义写的询问输入">用宏定义写的询问输入</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASK_INPUT MACRO STR_ADDRESS</span><br><span class="line">    LEA DX, STR_ADDRESS</span><br><span class="line">    MOV AH, 09H</span><br><span class="line">    INT 21H</span><br><span class="line">    LEA DX, NEW_LINE</span><br><span class="line">    INT 21H</span><br><span class="line">    XOR AX, AX</span><br><span class="line">    MOV AH, 01H</span><br><span class="line">    INT 21H</span><br><span class="line">    MOV TMPBUF, AL</span><br><span class="line">    LEA DX, NEW_LINE</span><br><span class="line">    MOV AH, 09H</span><br><span class="line">    INT 21H</span><br><span class="line">ENDM</span><br><span class="line">; 其中NEW_LINE是NEW_LINE DB 0AH, 0DH, &#x27;$&#x27;</span><br><span class="line">; STR_ADDRESS是询问输入的语句</span><br></pre></td></tr></table></figure>
<h1 id="冒泡排序">冒泡排序</h1>
<ol type="1">
<li>用JCXZ防止一开始CX里面就是0陷入死循环</li>
<li>如果MOV DX <a
href="#si">SI</a>，那么从SI中取出的就是1个字，如果是MOV DL, <a
href="#si">SI</a>，那么从SI中取出的就是1个字节</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUBBLE_SORT MACRO WAIT_SORT_ARRAY, ARRAY_LENGTH</span><br><span class="line">    LOCAL FOR, FOR2, END0, END1</span><br><span class="line">    PUSHF</span><br><span class="line">    PUSH CX</span><br><span class="line">    XOR CX, CX</span><br><span class="line">    MOV CL, ARRAY_LENGTH</span><br><span class="line">    FOR:</span><br><span class="line">        PUSH CX</span><br><span class="line">        DEC CX   </span><br><span class="line">        CMP CX, 0</span><br><span class="line">        JCXZ END0</span><br><span class="line">        LEA DI, WAIT_SORT_ARRAY</span><br><span class="line">        MOV AX, 0</span><br><span class="line">        FOR2:</span><br><span class="line">            MOV DL, [DI]</span><br><span class="line">            CMP DL, [DI + 1]</span><br><span class="line">            JL END1</span><br><span class="line">            XCHG DL, [DI + 1]</span><br><span class="line">            XCHG [DI], DL</span><br><span class="line">            MOV AX, 1</span><br><span class="line">            END1:</span><br><span class="line">                INC DI</span><br><span class="line">        LOOP FOR2</span><br><span class="line">        CMP AX, 0</span><br><span class="line">        JE END0</span><br><span class="line">        POP CX</span><br><span class="line">        LOOP FOR</span><br><span class="line">    END0:</span><br><span class="line">    POP CX </span><br><span class="line">    POPF    </span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<h1 id="将十进制数转换成指定进制">将十进制数转换成指定进制</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jinzhizhuanhuan MACRO TMP_INT_HIGH, TMP_INT_LOW, TMP_RADIX, STR_TAR, BITS</span><br><span class="line">    LOCAL WHILE, BREAK, FOR, DIGIT1</span><br><span class="line">         ;将待转换的数保存回AX</span><br><span class="line">        XOR AX, AX</span><br><span class="line">        MOV AH, TMP_INT_HIGH</span><br><span class="line">        MOV AL, TMP_INT_LOW</span><br><span class="line">        ; 将目标进制保存到BX    </span><br><span class="line">        MOV BL, TMP_RADIX</span><br><span class="line">        </span><br><span class="line">        WHILE:</span><br><span class="line">            CMP AX, 0 </span><br><span class="line">            JE BREAK</span><br><span class="line">            XOR DX, DX</span><br><span class="line">            DIV BX </span><br><span class="line">            PUSH DX</span><br><span class="line">            INC BITS</span><br><span class="line">            JMP WHILE</span><br><span class="line">        BREAK:      </span><br><span class="line">        XOR CX, CX</span><br><span class="line">        MOV CL, BITS</span><br><span class="line">       </span><br><span class="line">        ; 转ASCII码</span><br><span class="line">        LEA SI, STR_TAR</span><br><span class="line">        ADD SI, 2</span><br><span class="line">        FOR:        </span><br><span class="line">            POP AX</span><br><span class="line">            CMP AX, 9</span><br><span class="line">            JBE DIGIT1     </span><br><span class="line">            ADD AX, 7H</span><br><span class="line">        DIGIT1:</span><br><span class="line">            ADD AX, 30H</span><br><span class="line">            MOV [SI], AL</span><br><span class="line">            INC SI</span><br><span class="line">            LOOP FOR    </span><br><span class="line">ENDM  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第一章_汇编语言基础</title>
    <url>/posts/cfbc6a45.html</url>
    <content><![CDATA[<h1 id="数据表示">数据表示</h1>
<span id="more"></span>
<h2 id="bcd码">BCD码</h2>
<p><a
href="https://www.bilibili.com/video/BV1Ga4y1N7F6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：BCD码讲解</a></p>
<p>BCD码在加法运算超过10的时候需要矫正，在原先运算基础上加6</p>
<p>举例</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/984017b6ecc5d609438bb184f04daf8.jpg" style="zoom:50%;" /></p>
<h2 id="有符号数的表示方法">有符号数的表示方法</h2>
<h3 id="原码">原码：</h3>
<p>符号位1表示负数，0表示正数</p>
<h3 id="反码">反码</h3>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<h3 id="补码">补码</h3>
<p>正数的补码就是其本身</p>
<p>负数的补码是在反码的基础上+1</p>
<p><font color = "yellow">取反加1得到负数的绝对值，正数的相反数</font></p>
<hr style = "border:2px solid yellow">
<p>举例：
<img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/630ba071fb63fe371f7f4559de2ab93.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<h1 id="寄存器">8086寄存器</h1>
<p>下面这张图要能背下来</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309105501021.png" /></p>
<h2 id="通用寄存器">通用寄存器</h2>
<h3
id="数据寄存器保存操作数或运算结果">数据寄存器(保存操作数或运算结果)</h3>
<ol type="1">
<li>累加器AX</li>
<li>基址寄存器BX</li>
<li>计数器CX</li>
<li>数据寄存器DX</li>
</ol>
<h3
id="指针寄存器存放某个存储单元的偏移地址">指针寄存器(存放某个存储单元的偏移地址)</h3>
<ol type="1">
<li>SP堆栈指针寄存器(存放堆栈段中栈顶的偏移地址)</li>
<li>BP基址指针寄存器(存放堆栈段中某一存储单元的偏移地址)</li>
</ol>
<h3
id="变址寄存器存放某个存储单元的偏移地址">变址寄存器(存放某个存储单元的偏移地址)</h3>
<ol type="1">
<li>SI源地址变址指针寄存器</li>
<li>DI目标地址变址寄存器</li>
</ol>
<h2 id="控制寄存器">控制寄存器</h2>
<h3 id="ip指令指针寄存器">IP指令指针寄存器</h3>
<h3 id="flags标志寄存器">FLAGS标志寄存器</h3>
<ol type="1">
<li>AF(Auxiliary carry Flag)辅助进位标志</li>
<li>CF：（Carry Flag）进位标志</li>
<li>OF（Overflow Flag）溢出标志</li>
<li>PF：（Parity Flag）奇偶标志</li>
<li>SF（Sign Flag）符号标志</li>
<li>ZF（Zero Flag）零标志</li>
</ol>
<h2 id="段寄存器">段寄存器</h2>
<p><font color = "red">段寄存器，不是用于提供偏移地址的寄存器，而是用于定义段的起始地址</font></p>
<p>CS代码段段寄存器</p>
<p>DS数据段段寄存器</p>
<p>ES附加段段寄存器</p>
<p>SS堆栈段段寄存器</p>
<h1 id="的存储器组织">8086的存储器组织</h1>
<h2 id="存储单元的地址">存储单元的地址</h2>
<p>每一个字节单元都有一个与之对应的单元地址。</p>
<p>对于<font color = "red">多字节单元（字，双字，4字等），其地址同样是采用最低位字节地址</font>来表示的。</p>
<h2 id="存储单元内容">存储单元内容</h2>
<p>如果X是地址，(X)表示从X地址从取内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3ce32cf4927c2ff47e2c099d44e73ec.jpg" style="zoom:50%;" /></p>
<p>如果X是地址的地址，取内容用((X))</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9797900060a9c41f8aed43cee8b8465.jpg" style="zoom:50%;" /></p>
<p>举个例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240308210519536.png" style="zoom:50%;" /></p>
<h2 id="存储器地址的分段">存储器地址的分段</h2>
<h3
id="分段基本规则从0地址开始每16个字节为一小段">分段基本规则：从0地址开始，每16个字节为一小段。</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/98860d01c0511f26de2dfa18b5e9051.jpg" /></p>
<h3 id="段地址和偏移地址">段地址和偏移地址</h3>
<p>段地址：表示一个段的开始</p>
<p>偏移地址：在段内相对于段起始地址的偏移值。如当偏移量为‘0’时，就在这个段的起始单元，当偏移量为0FFFFH时，就是这个段（最大）最末一个字节单元。</p>
<h3
id="物理地址和逻辑地址的关系重点">物理地址和逻辑地址的关系(重点)</h3>
<p>常见的组合形式：</p>
<p>段地址：偏移地址(IP)</p>
<p>其中段地址保存的是起始段的首地址，偏移地址(IP)里面保存的是相对于段地址的数据偏移地址空间</p>
<p>段地址有：CS, DS, ES, SS</p>
<p><font color = "red">物理地址=段地址×10H+偏移地址</font></p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309093717036.png" /></p>
<h3 id="段地址与段寄存器">段地址与段寄存器</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/685f27bbbf97e9c4ca1d29071730ad2.jpg" /></p>
<h3 id="段分配"><font color = "red">段分配</font></h3>
<p>举例1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/32bbea229e905b0430279f328aaa050.jpg" /></p>
<p>举例2</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/316ac3958e20793b38dea949f3d5969.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/354ddb143d764b0e56bb9d6b116a99d.jpg" /></p>
<h3 id="隐含段和偏移寄存器">隐含段和偏移寄存器</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240309105258368.png" /></p>
<h1 id="的寻址方式">8086的寻址方式</h1>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="基本格式">基本格式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321105752191.png" /></p>
<p>操作数字段可以为0个、一个、二个或三个。对应的称为零地址指令、一地址指令、二地址指令或三地址指令</p>
<p>典型二地址指令，源操作数和目标操作数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321111124457.png" /></p>
<p>执行的操作： （DST）←（SRC）</p>
<h2 id="数据寻址方式">数据寻址方式</h2>
<p><font color = "red">从最本质的出发看，MOV指令就3种用法</font></p>
<p><font color = "yellow">1. 直接将数据保存到目标寄存器中</font></p>
<p><font color = "yellow">2.
直接将源寄存器中保存的内容转移保存到目标寄存器中</font></p>
<p><font color = "yellow">3.
根据偏移地址计算物理地址再放入寄存器中，只要源操作数带[]，就是这种方法</font></p>
<p><font color = "red">综上，MOV之后目标寄存器里保存的是内容而不是地址！</font></p>
<p><font color = "red">比较重要的点：</font></p>
<p><font color = "yellow">1.
8086CPU中是不支持将数据直接保存到段寄存器的，需要先保存到通用寄存器(AX,
BX, CX, DX), 再保存到段寄存器(CS,DS, ES, SS)</font></p>
<p><font color = "yellow">2.
直接MOV立即数进内存的时候要在内存前加前缀，来指明立即数的位数</font></p>
<p><font color = "yellow">3. MOV不能修改CS和IP这两个寄存器</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321105958351.png" /></p>
<h3 id="立即寻址方式">立即寻址方式：</h3>
<p>操作数直接存放在指令中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL, 5</span><br><span class="line">MOV  AX, 3064H</span><br><span class="line">MOV  EBX,12345678H</span><br></pre></td></tr></table></figure>
<p><font color = "yellow">其中AL表示的意思是数据寄存器中累加器的低八位</font></p>
<p><font color = "yellow">EBX表示比8086更高级寄存器中拓展的累加器，8086是16位，拓展后是32位</font></p>
<blockquote>
<p>注意：源 和 目标 的字长（位数）要一致。</p>
</blockquote>
<p>错误指令事例</p>
<ol type="1">
<li><p>位置放反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    2000H，AX     源操作数和目标操作数位置反了</span><br></pre></td></tr></table></figure></li>
<li><p>长度不等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    DL，300H      DL是低8位，两个字节，300H，一个数字由4个字节组成，所以说是16进制，3个数字说明是3个字节，长度不等</span><br></pre></td></tr></table></figure></li>
<li><p>超过范围</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    AH，257       AH是累加器中高八位，最大可以放大数字在不考虑符号情况下是255(2^8 = 256)</span><br></pre></td></tr></table></figure>
<p>执行指令举例</p>
<p>【例】：执行指令 MOV AX，5678H</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321112102379.png" style="zoom:50%;" /></p>
<h3 id="寄存器寻址方式">寄存器寻址方式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL, CL</span><br><span class="line">MOV  CX, DX</span><br><span class="line">MOV  EAX,EBX </span><br></pre></td></tr></table></figure>
<p>注意： ● SRC 和 DST 的字长（位数）要一致。 ●
<font color = "red">DST不能为CS（代码段寄存器）</font></p>
<p>错误举例</p>
<ol type="1">
<li><p>CS不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    CS，AX  		CS不能作为目标操作数</span><br></pre></td></tr></table></figure></li>
<li><p>长度不等</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV    DL，BX			长度不等</span><br><span class="line">MOV    SI，EAX		长度不等</span><br></pre></td></tr></table></figure>
<h3 id="直接寻址方式">直接寻址方式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321114357850.png" /></p>
<p>默认情况： 物理地址=DS×10H+EA</p>
<p>举例</p>
<pre><code>例如，若指令为  MOV  AX，ES：[VALUE]
则对应该SRC的物理地址为 ES×10H+EA</code></pre>
<p>例题</p>
<p>【例】： 指令 MOV AX, [ 2000H ] ，其中DS=3000H。（32000H） =
3050，该指令执行完后，AX的值。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321115541141.png" /></p>
<p><font color = "red">一种比较容易犯的经典错误</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ce90479ea367fbeef3267fd2ff0b770.jpg" style="zoom:50%;" /></p>
<h3 id="寄存器间接寻址方式">寄存器间接寻址方式：</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321205557045.png" /></p>
<p>计算物理地址公式：</p>
<p><font color = "yellow">除了BP寄存器默认段地址是SS，其他寄存器默认的段地址都是DS</font></p>
<p>如果<font color = "red">指令中指定的寄存器是BX</font>，没有指出段跨越前缀，则操作数默认放在数据段中，所以用DS寄存器的内容作为段地址，即操作数的物理地址（PA）为：
<font color = "red">PA=DS×10H十BX或SI或DI </font></p>
<p>如果<font color = "red">指令指定BP寄存器</font>，则操作数默认放在堆栈段中，段地址在SS中，即操作数的物理地址为：
<font color = "red">PA=SS×10H十BP</font></p>
<p>与直接寻址方式一样，寄存器间接寻址指令也可<font color = "red">指定段跨越前缀</font>来取得其它段中的数据。对于指定段跨越前缀（如使用ES），则操作数的物理地址为：
<font color = "red">PA=ES×10H十BX或SI或DI </font></p>
<p>举例：</p>
<p>【例】: 分析指令① MOV AX，ES：[BX] ② MOV AX，[BX]<br />
执行后AX的值各是多少？ 已知 DS=2000H，
ES=4000H，BX=0300H，(40300H)=0DE10H ，（20300H）=27ABH 【解】： ①
（确定是ES）源操作数对应的物理地址 =4000H×10H十0300H = 40300H
则执行指令后， AX=0DE10H。 ② （默认是DS）源操作数对应的物理地址
=2000H×10H十0300H = 20300H 则执行指令后， AX=27ABH。</p>
<p>【例】: ADD AX，[BP]<br />
指令执行前： AX=50A0H，BP=0025H， SS=3000H，（30025H）=471AH。
<font color = "red">源操作数对应的物理地址</font> =SS× 10H 十 BP
=3000H×10H十0025H =30025H
<font color = "red">执行指令:(注意，是ADD，要将之前计算出的物理地址内存储的数取出与目标地址原来保存的数相加)</font>
（30025H）+ AX<br />
=471AH+50A0H =97BAH 则指令执行完后，AX=97BAH。</p>
<h3 id="寄存器相对寻址方式">寄存器相对寻址方式</h3>
<p><font color = "red">注意：对于8位位移量，计算时要扩展到16位（带符号）。即：对于00H---7FH的数，扩展成16位带符号数时，高8位直接填零，为：0000H---007FH；若为8XH以上的数，扩展后为0FF8XH。</font></p>
<p>举例：</p>
<p>【例】 分析指令 MOV AX，DISP[DI] （或写成MOV AX，[DI+DISP]）
执行后，AX的值。 已知 DS=4000H，DI=2000H，DISP=1000H；设指令执行前：
AX=7C69H，（43000H）=55H，（43001H）=66H。</p>
<p><font color = "red">计算有效地址EA：</font> EA=2000H+1000H=3000H
<font color = "red">对应物理地址=DS×10H+EA</font> =40000H+3000H=43000H。
指令执行后： AX=6655H，（43000H）=55H，（43001H）=66H，
DS=4000H，DI=2000H。</p>
<h3 id="基址变址寻址方式">基址变址寻址方式</h3>
<p><strong>基址2个：BP和BX</strong></p>
<p><font color = "red">其中BP指针寄存器默认对应SS段寄存器，BX指针寄存器默认对应BS段寄存器</font></p>
<p><strong>变址2个：SI和DI</strong></p>
<pre><code>      EA=(RB)+(RI)</code></pre>
<p>RB为基址寄存器,RI为变址寄存器.</p>
<p>【例】分析指令MOV DX，[BP+DI] （ MOV DX，[BP][DI]）指令执行结果。
设SS=3000H，DS=2000H，BP=2000H，DI=0500H；指令执行前：DX=1234H，（32500H）=78H，(32501H)=56H</p>
<p>【解】：源操作数有效地址： EA=BP+DI=2000H+0500H=2500H；
源操作数的物理地址 PA=SS×10H+EA=30000H+2500H=32500H。 指令执行后：
DX=5678H</p>
<h3 id="相对基址变址寻址方式">相对基址变址寻址方式</h3>
<p><font color = "red">物理地址表示：若无段前缀，使用BX时，默认使用段寄存器为DS，使用BP时，默认使用的段寄存器为SS。</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321215207910.png" style="zoom:50%;" /></p>
<h2 id="程序存储器寻址方式">程序存储器寻址方式</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240321224843342.png" /></p>
<h3 id="jmp指令">JMP指令</h3>
<p>jmp 是无条件转移指令，</p>
<p>无条件转移指令可转到内存中任何程序段，</p>
<p>转移地址可在指令中给出，也可以在寄存器中给出，或在储存器中指出。</p>
<p>它可以只修改 <strong>IP</strong> ，也可以同时修改 <strong>CS</strong>
和 <strong>IP</strong></p>
<p><font color = "red">只修改IP的称为段内转移</font>：<code>jmp ax</code>
相当于 <code>mov ax,ip</code></p>
<p><font color = "red">同时修改 <code>cs:ip</code> 的叫
<strong>段间转移</strong></font>：<code>jmp 1000:0</code></p>
<p><font color = "red">jmp 指令要给出两种信息：</font></p>
<p><font color = "yellow">1. 转移的目的地址</font>
<font color = "yellow">2.
转移的距离(段间转移、段内转移、段内近转移)</font></p>
<h3
id="转移的目的地址在指令中的jmp指令">转移的目的地址在指令中的jmp指令：</h3>
<h4 id="段内转移近转移">段内转移，近转移</h4>
<p>语法： <code>jmp short 标号</code>（转到标号处执行指令）</p>
<p>这种格式的 <strong>jmp</strong> 指令实现的是段内短转移</p>
<p>它对 <strong>IP</strong> 的修改范围为 <code>-128~127</code></p>
<p><font color = "red"><code>short</code>
符号表示指令进行的是短转移</font></p>
<p><code>标号</code> 指明了指令要转移的目的地</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	start:mov ax,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>程序执行后，<strong>ax</strong> 中的值为 <strong>1</strong></p>
<p>因为执行 <code>jmp short s</code> 后，越过了
<code>add ax,1</code></p>
<p><strong>IP</strong> 指向了 标号 <strong>s</strong> 处的
<code>inc ax</code></p>
<p>也就是说，程序只进行了一次 <strong>ax</strong> 加 <strong>1</strong>
操作</p>
<p>此种转移方式并没有转移的目的地址，而是相对于当前 <strong>IP</strong>
的转移位移</p>
<p>另外，近转移ip修改范围： <code>-32768~32767</code></p>
<h4 id="段间转移远转移">段间转移，远转移</h4>
<p>语法： <code>jmp far ptr 标号</code></p>
<p>这种实现的是 <strong>段间转移</strong> ，又称为远转移</p>
<p><strong>(CS)=标号所在段的段地址</strong>；
<strong>(IP)=标号在段中的偏移地址</strong></p>
<p><font color = "red"><strong>far ptr</strong>
指明了指令用标号的段地址和偏移地址修改 <strong>CS 和
IP</strong></font></p>
<p><font color = "yellow">上面只是解释jmp过程中cpu执行了什么，实际写程序直到jmp就是往设置的标号跳就行</font></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	start:mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp far ptr s</span><br><span class="line">		db 256 dup (0)</span><br><span class="line">	s:add ax,1</span><br><span class="line">		inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="转移地址在寄存器中的jmp指令">转移地址在寄存器中的jmp指令</h3>
<p>指令格式： <code>jmp 16 位 reg</code></p>
<p>功能： <code>(IP)=(16 位 reg)</code></p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令执行前： ax=1000H ，CS=2000H ，IP=0003H</span><br><span class="line">jmp ax</span><br><span class="line">指令执行后： ax=1000H ，CS=2000H ，IP=1000H</span><br></pre></td></tr></table></figure>
<p>jmp ax ，相当于： mov IP,ax ### 转移地址在内存中的jmp指令：</p>
<p>转移地址在内存中的jmp指令有两种格式</p>
<h4 id="jmp-word-ptr-内存单元地址段内转移">(1) jmp word ptr
内存单元地址（段内转移）</h4>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</p>
<p>内存单元地址执行后， (IP)=0123H可用寻址方式的任一格式给出。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax	;将寄存器 AX 中的值移动到数据段（DS）中偏移量为 0 的位置处。</span><br><span class="line"></span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后， (IP)=0123H</p>
<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov [bx],ax</span><br><span class="line"></span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure>
<p>执行后， (IP)=0123H</p>
<h4 id="jmp-dword-ptr-内存单元地址段间转移">(2) jmp dword ptr
内存单元地址（段间转移）</h4>
<p>功能：从内存单元地址处开始存放着两个字，</p>
<p>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(CS) = (内存单元地址+2)</span><br><span class="line">(IP) = (内存单元地址)</span><br></pre></td></tr></table></figure>
<p>内存单元地址可用寻址方式的任一格式给出</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax</span><br><span class="line"></span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line"></span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后， (CS)=0 ，(IP)=0123H ，CS:IP 指向 0000:0123</p>
<p>再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line"></span><br><span class="line">mov [bx],ax</span><br><span class="line"></span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line"></span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>
<p>执行后， (CS)=0 ，(IP)=0123H ，CS:IP 指向 0000:0123</p>
<p>小结：</p>
<p><code>jmp short 标号</code> 功能为：段内短转移</p>
<p><strong>(IP)=(IP)+8位位移</strong></p>
<ol type="1">
<li>8位位移 <strong>=</strong> 标号处的地址 <strong>-</strong>
jmp指令后的第一个字节地址</li>
<li>short指明的此处是8位位移</li>
<li>8位位移的范围为-128-127，用补码表示</li>
<li>8位位移是编译程序时在编译时算出的</li>
</ol>
<hr />
<p><code>jmp near ptr 标号</code> 功能为：段内近转移</p>
<p><strong>(IP)=(IP)+16位位移</strong></p>
<ol type="1">
<li>16位位移 <strong>=</strong> 标号处的地址 <strong>-</strong>
jmp指令后的第一个字节地址</li>
<li>short指明的此处是8位位移</li>
<li>16位位移的范围为-32768-32767，用补码表示</li>
<li>16位位移是编译程序时在编译时算出的</li>
</ol>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章_8086的指令系统</title>
    <url>/posts/f42d18b1.html</url>
    <content><![CDATA[<p><font color = "red">所有指令都有1个共同特点，就是如果有2个操作数的话，两个操作数不能同时在内存</font></p>
<h1 id="数据传送类指令">数据传送类指令</h1>
<p><font color = "red">数据传送指令都不影响标志位</font></p>
<span id="more"></span>
<h2 id="通用数据传送指令">通用数据传送指令</h2>
<h3 id="传送指令mov">传送指令MOV</h3>
<p>定义：</p>
<ol type="1">
<li>把一个字节或字的操作数从源地址传送至目的地址</li>
<li>MOV不影响标志位</li>
</ol>
<p>举例：</p>
<p>例1：立即数传送</p>
<ul>
<li>mov al,4
；al←4，字节传送，是一条将立即数4（十进制）移动到寄存器AL（即8位的累加器）的指令</li>
<li>mov cx,0ffh
；cx←00ffh，字传送，<font color = "red">传送前要根据高位补齐</font>一条将立即数0xFF（十六进制）移动到寄存器CX（即16位的计数器）的指令</li>
<li>mov si,200h ；si←0200h，字传送</li>
<li>mov byte ptr [si],0ah ；byte ptr
说明是字节操作，将立即数0x0A（十六进制）移动到以SI寄存器作为基址的内存位置。这里的<font color = "red"><code>byte ptr</code>指定了操作数的大小为一个字节，</font><code>[si]</code>表示SI寄存器中的地址处。因此，这条指令<font color = "red">将0x0A写入到SI寄存器指向的内存地址中。</font></li>
<li>mov word ptr [si+2],0bh ；word ptr 说明是字操作</li>
</ul>
<blockquote>
<p>注： 注意立即数是字节量还是字量,明确指令是字节操作还是字操作</p>
</blockquote>
<p>例2：寄存器传送</p>
<p>mov ax,bx ；ax←bx，字传送 mov ah,al ；ah←al，字节传送 mov ds,ax
；ds←ax，字传送 mov [bx],al ；[bx]←al，字节传送</p>
<p>例3：存储器传送</p>
<p>mov al,[bx] mov dx,[bp] ；dx←ss:[bp] mov es,[si] ；es←ds:[si]</p>
<p><font color = "red"> 不存在存储器向存储器的传送指令</font></p>
<p>小结</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322195241486.png" style="zoom:50%;" /></p>
<p>非法传送</p>
<ul>
<li><p>两个操作数的类型不一致
例如源操作数是字节，而目的操作数是字；或相反</p>
<p>常见错误：对于存储器单元与立即数同时作为操作数的情况，必须显式指明；byte
ptr指示字节类型，word ptr指示字类型</p>
<p>就是想MOV word ptr[ax] 000AH</p></li>
<li><p>两个操作数不能都是存储器
传送指令很灵活，但主存之间的直接传送却不允许</p></li>
<li><p>段寄存器的操作有一些限制
段寄存器属专用寄存器，对他们的操作能力有限</p>
<ol type="1">
<li>不允许立即数传送给段寄存器 MOV DS,100H
；非法指令：立即数不能传送段寄存器</li>
<li>不允许直接改变CS值 MOV CS,[SI] ；不允许使用的指令</li>
<li>不允许段寄存器之间的直接数据传送 MOV DS,ES
；非法指令：不允许段寄存器间传送</li>
</ol></li>
</ul>
<h3 id="交换指令xchg">交换指令XCHG</h3>
<p>XCHG不影响标志位</p>
<h4 id="寄存器与寄存器之间对换数据">寄存器与寄存器之间对换数据</h4>
<p>mov ax,1234h ；ax=1234h mov bx,5678h ；bx=5678h xchg ax,bx
；ax=5678h，bx=1234h xchg ah,al ；ax=7856h</p>
<h4 id="寄存器与存储器之间对换数据">寄存器与存储器之间对换数据</h4>
<p>xchg ax,[2000h] ；字交换 等同于 xchg [2000h],ax xchg al,[2000h]
；字节交换 等同于 xchg [2000h],al</p>
<h4
id="不能在存储器与存储器之间对换数据">不能在存储器与存储器之间对换数据</h4>
<h3 id="换码指令xlat">换码指令XLAT</h3>
<p>定义</p>
<ol type="1">
<li>将BX指定的缓冲区中、AL指定的位移处的一个字节数据取出赋给AL</li>
<li>XLAT不影响标志位</li>
</ol>
<h2 id="堆栈操作指令">堆栈操作指令</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240322201903196.png" style="zoom:50%;" /></p>
<p><font color = "red">SS指向的基准量，SP指向的是“偏移量”，计算SP指向的物理地址需要加上SS*
10H</font></p>
<h3 id="堆栈的操作">堆栈的操作</h3>
<p>PUSH ；进栈指令先使堆栈指针SP减2，然后把一个字操作数存入堆栈顶部</p>
<p>【例】 PUSH BX 指令执行前： SS＝4000H，SP＝2000H，BX＝3248H</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/73300a8f811300979366c931b4109d6.png" /></p>
<p>POP
；出栈指令把栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP加2</p>
<p>注</p>
<ul>
<li>堆栈操作的单位是字，进栈和出栈只对字量</li>
<li>字量数据从栈顶压入和弹出时，都是低地址字节送低字节，高地址字节送高字节</li>
<li>堆栈操作遵循先进后出原则，但可用存储器寻址方式随机存取堆栈中的数据</li>
<li>堆栈常用来
<ol type="1">
<li>临时存放数据</li>
<li>传递参数</li>
<li>保存和恢复寄存器</li>
</ol></li>
</ul>
<h2 id="标志传送指令">标志传送指令</h2>
<h3 id="定义">定义</h3>
<ul>
<li>标志寄存器传送指令用来传送标志寄存器FLAGS的内容</li>
<li>标志位操作指令直接对CF、DF、IF标志进行复位或置位</li>
</ul>
<h3 id="标志寄存器传送">标志寄存器传送</h3>
<h4 id="标志低字节进出ah指令">标志低字节进出AH指令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LAHF	;AH←FLAGS的低字节</span><br></pre></td></tr></table></figure>
<p>LAHF指令将标志寄存器的低字节送寄存器AH
SF/ZF/AF/PF/CF状态标志位分别送入AH的第7/6/4/2/0位，而AH的第5/3/1位任意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAHF	;FLAGS的低字节←AH</span><br></pre></td></tr></table></figure>
<p>SAHF将AH寄存器内容送FLAGS的低字节
用AH的第7/6/4/2/0位相应设置SF/ZF/AF/ PF/CF标志</p>
<h4 id="标志寄存器进出堆栈指令">标志寄存器进出堆栈指令</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSHF	 ；SP←SP－2</span><br><span class="line">		 ；SS:[SP]←FLAGS</span><br></pre></td></tr></table></figure>
<p>PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POPF</span><br><span class="line">；FLAGS←SS:[SP]</span><br><span class="line">；SP←SP＋2</span><br></pre></td></tr></table></figure>
<p>POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2</p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushf	；保存全部标志到堆栈</span><br><span class="line">pop ax	；堆栈中取出全部标志</span><br><span class="line">or ax,0100h	；设置D8=TF=1，</span><br><span class="line">	；ax其他位不变</span><br><span class="line">push ax	；将ax压入堆栈</span><br><span class="line">popf	；FLAGS←AX</span><br><span class="line">；将堆栈内容取到标志寄存器</span><br></pre></td></tr></table></figure>
<h3 id="标志位操作">标志位操作</h3>
<h4 id="进位标志操作指令">进位标志操作指令</h4>
<p>用于任意设置进位标志 CLC ；复位进位标志：CF←0 STC
；置位进位标志：CF←1 CMC ；求反进位标志：CF←～CF</p>
<h4 id="方向标志操作指令">方向标志操作指令</h4>
<p>串操作指令中，需要使用 CLD ；复位方向标志：DF←0 STD
；置位方向标志：DF←1</p>
<h4 id="中断标志操作指令">中断标志操作指令</h4>
<p>在编写中断服务程序时，需要控制可屏蔽中断的允许和禁止 CLI
；复位中断标志：DF←0 STI ；置位中断标志：DF←1</p>
<h2 id="地址传送指令">地址传送指令</h2>
<p>定义：</p>
<ol type="1">
<li>地址传送指令将存储器单元的逻辑地址送至指定的寄存器
<ul>
<li>有效地址传送指令 LEA</li>
<li>指针传送指令 LDS和LES</li>
</ul></li>
<li>注意不是获取存储器单元的内容</li>
</ol>
<h3 id="有效地址传送指令leaload-ea">有效地址传送指令LEA（load EA）</h3>
<p>定义：</p>
<p>将存储器操作数的有效地址传送至指定的16位寄存器中</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bx,0400h</span><br><span class="line">mov si,3ch</span><br><span class="line">lea bx,[bx+si+0f62h]  </span><br><span class="line">；BX＝0400h＋003ch＋0f62h＝139EH</span><br></pre></td></tr></table></figure>
<p>注</p>
<ul>
<li><font color = "red">
获得主存单元的有效地址；不是物理地址，也不是该单元的内容</font></li>
<li>可以实现计算功能</li>
</ul>
<h1 id="算术运算类指令">算术运算类指令</h1>
<h2 id="状态标志">状态标志</h2>
<p>常用状态标志： 进位标志CF、溢出标志OF 零位标志ZF、符号标志SF
奇偶标志PF</p>
<h3 id="进位标志cfcarry-flag">进位标志CF（Carry Flag）</h3>
<p>定义：</p>
<p>当运算结果的<font color = "red">最高有效位有进位（加法）或借位（减法）</font>时，进位标志置1，即CF
= 1；否则CF = 0。</p>
<blockquote>
<p>注：最高有效位不一定非要是16位寄存器AX等的最高位</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3AH + 7CH＝B6H	;没有进位：CF = 0</span><br><span class="line">AAH + 7CH＝（1）26H	;有进位：CF = 1</span><br></pre></td></tr></table></figure>
<h3 id="溢出标志ofoverflow-flag">溢出标志OF（Overflow Flag）</h3>
<p>若算术运算的结果有溢出，则OF＝1； 否则 OF＝0</p>
<p><font color = "red">溢出和进位的区别</font></p>
<p>首先什么是溢出</p>
<p>处理器内部以补码表示有符号数 8位表示的整数范围是：－128～＋127
16位表示的整数范围是：－32768～＋32767
如果运算结果超出这个范围，就产生了溢出
有溢出，说明有符号数的运算结果不正确</p>
<p>举例：</p>
<p>3AH＋7CH＝B6H，就是58＋124＝182，
已经超出－128～＋127范围，产生溢出，故OF＝1；
另一方面，补码B6H表达真值是-74， 显然运算结果也不正确</p>
<p><font color = "red">本质区别</font></p>
<p><font color = "red">进位</font>标志表示<font color = "red">无符号数</font>运算结果是否超出范围，超出范围后加上进位或借位运算结果仍然正确；
<font color = "red">溢出</font>标志表示<font color = "red">有符号数</font>运算结果是否超出范围，超出范围后运算结果不正确。</p>
<p><font color = "red">溢出和进位的对比</font></p>
<p>举例：</p>
<p>例1：3AH + 7CH＝B6H 无符号数运算： 58＋124＝182 范围内，无进位
有符号数运算： 58＋124＝182 范围外，有溢出</p>
<p>用二进制运算表示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ec451bff30b7466d36ba1ce30ef05dc.jpg" /></p>
<p>例2：AAH + 7CH＝（1）26H 无符号数运算： 170＋124＝294 范围外，有进位
有符号数运算： －86＋124＝38 范围内，无溢出</p>
<p>二进制表示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dbcdf8d7466a93840c23d3aaa7be99e.jpg" /></p>
<p>如何运用溢出和进位</p>
<p>如果将参加运算的操作数认为是无符号数，就应该关心进位；</p>
<p>认为是有符号数，则要注意是否溢出</p>
<p><font color = "red">溢出的判断</font></p>
<p>当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出</p>
<h3 id="零标志zfzero-flag">零标志ZF（Zero Flag）</h3>
<p>若运算结果为0，则ZF = 1； 否则ZF = 0</p>
<h3 id="符号标志sfsign-flag">符号标志SF（Sign Flag）</h3>
<p>运算结果最高位为1，则SF = 1；否则SF = 0</p>
<h3 id="奇偶标志pfparity-flag">奇偶标志PF（Parity Flag）</h3>
<p>当运算结果最低字节中“1”的个数为零或偶数时，PF = 1；否则PF = 0</p>
<h3 id="辅助进位标志afauxiliary-carry-flag">辅助进位标志AF（Auxiliary
Carry Flag）</h3>
<p>运算时<font color = "red">第3位（低半字节）</font>有进位或借位时，AF
= 1；否则AF = 0。</p>
<h2 id="加法">加法</h2>
<h3 id="加法指令add">加法指令ADD</h3>
<p>定义：</p>
<p>ADD指令将源与目的操作数相加，结果送到目的操作数</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0fbh	；al=0fbh</span><br><span class="line">add al,07h	；00FB + 0007 = 0102H, AL = 02H</span><br><span class="line">mov word ptr [200h],4652h	；[200h]=4652h(重复就是重要，涉及到内存的时候必须要告知是wordptr还是byteptr)</span><br><span class="line">mov bx,1feh	；bx=1feh</span><br><span class="line">add al,bl	；al=00h</span><br><span class="line">add word ptr [bx+2],0f0f0h	；[200h]=3742h</span><br></pre></td></tr></table></figure>
<h3 id="带进位加法指令adc">带进位加法指令ADC</h3>
<p>定义：</p>
<ul>
<li><p>ADC指令将源与目的操作数相加，再加上进位CF标志，结果送到目的操作数</p></li>
<li><p>ADC指令主要与ADD配合，实现多精度加法运算</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4652h	；ax=4652h</span><br><span class="line">add ax,0f0f0h	；ax=3742h，CF=1</span><br><span class="line">mov dx,0234h	；dx=0234h</span><br><span class="line">adc dx,0f0f0h	；dx=f324h，CF=0</span><br><span class="line">；DX.AX＝ 0234 4652H</span><br><span class="line">	   ＋F0F0 F0F0H</span><br><span class="line">	   ＝F325 3742H</span><br></pre></td></tr></table></figure>
<h3 id="增量指令incincrement">增量指令INC（increment）</h3>
<ol type="1">
<li>INC指令对操作数加1（增量）</li>
<li>INC指令不影响进位CF标志，按定义设置其他状态标志</li>
</ol>
<h2 id="减法">减法</h2>
<h3 id="减法指令subsubtract">减法指令SUB（subtract）</h3>
<p>定义：</p>
<p>SUB指令将目的操作数减去源操作数，结果送到目的操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0fbh	；al=0fbh</span><br><span class="line">sub al,07h	；al=0f4h，CF＝0</span><br><span class="line">mov word ptr [200h],4652h	；[200h]=4652h</span><br><span class="line">mov bx,1feh	；bx=1feh</span><br><span class="line">sub al,bl	；al=0f6h</span><br><span class="line">sub word ptr [bx+2],0f0f0h</span><br><span class="line">；[200h]=5562h，CF＝1</span><br></pre></td></tr></table></figure>
<h3 id="带借位减法指令sbb">带借位减法指令SBB</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4652h	；ax=4652h</span><br><span class="line">sub ax,0f0f0h	；ax=5562h，CF=1</span><br><span class="line">mov dx,0234h	；dx=0234h</span><br><span class="line">sbb dx,0f0f0h	；dx=1143h，CF=1</span><br><span class="line">；DX.AX＝  0234 4652H</span><br><span class="line">		－F0F0 F0F0H</span><br><span class="line">		＝1143 5562H</span><br></pre></td></tr></table></figure>
<h3 id="减量指令decdecrement">减量指令DEC（decrement）</h3>
<p>定义</p>
<ul>
<li>DEC指令对操作数减1（减量）</li>
<li>DEC指令不影响进位CF标志，按定义设置其他状态标志</li>
</ul>
<h2 id="求补指令negnegative">求补指令NEG（negative）</h2>
<p>定义：</p>
<ul>
<li><p>NEG指令对操作数执行求补运算：用零减去操作数，然后结果返回操作数</p></li>
<li><p>求补运算也可以表达成：将操作数按位取反后加1</p></li>
<li><p>NEG指令对标志的影响与用零作减法的SUB指令一样</p>
<p><font color = "red">NEG对CF和OF的影响</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240324091424121.png" style="zoom:50%;" /></p>
<p><font color = "red">根本原因：虽然人在计算的时候是求反加1，但CPU运算是用0-操作数</font></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0ff64h</span><br><span class="line">neg al	；ax=ff9ch，OF=0、SF=1、ZF=0、PF=1、CF=1</span><br><span class="line">sub al,9dh	；ax=ffffh，OF=0、SF=1、ZF=0、PF=1、CF=1</span><br><span class="line">neg ax	；ax=0001h，OF=0、SF=0、ZF=0、PF=0、CF=1</span><br><span class="line">dec al	；ax=0000h，OF=0、SF=0、ZF=1、PF=1、CF=1</span><br><span class="line">neg ax	；ax=0000h，OF=0、SF=0、ZF=1、PF=1、CF=0</span><br></pre></td></tr></table></figure>
<h2 id="比较指令cmpcompare">比较指令CMP（compare）</h2>
<ol type="1">
<li>CMP指令将目的操作数减去源操作数，按照定义相应设置状态标志</li>
<li>CMP指令执行的功能与SUB指令相同，但结果不回送目的操作数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	cmp al,100	；al-100</span><br><span class="line">	jb below	；al&lt;100，跳转到below执行</span><br><span class="line">	sub al,100	；al≥100，al←al-100</span><br><span class="line">	inc ah	；ah←ah+1</span><br><span class="line">below:	...</span><br></pre></td></tr></table></figure>
<p><font color = "red">经典例题</font></p>
<p>题1：</p>
<p>【例】：
设X、Y、Z均为双精度数。其存放地址为：X，X+2，Y，Y+2，Z，Z+2。存放时，高位字在高位地址，低位字存放在低地址中。
试编程完成 W←X+Y+24-Z ，结果存放在W和W+2单元。</p>
<p><font color = "red">总结</font></p>
<p><font color = "red">1. 用DX、AX表示双精度数</font></p>
<p><font color = "red">2. 低位用AX，高位用DX</font></p>
<p><font color = "red">3.
先用非进位运算低位，再用进位运算高位</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX，X       ；用DX，AX来表示双精度数</span><br><span class="line">MOV   DX，X+2     ；低位用AX，高位用DX</span><br><span class="line">ADD    AX，Y       ；先低位运算</span><br><span class="line">ADC    DX，Y+2    ；完成X+Y </span><br><span class="line">ADD    AX，24      ；低位运算</span><br><span class="line">ADC    DX，0       ；高位运算，该语句不能少</span><br><span class="line">SUB     AX，Z      ；先低位减法</span><br><span class="line">SBB      DX，Z+2   ；完成运算</span><br><span class="line">MOV    W，AX      ；存储结果</span><br><span class="line">MOV    W+2，DX</span><br></pre></td></tr></table></figure>
<h2 id="乘法指令mulimul">乘法指令(MUL/IMUL)</h2>
<ol type="1">
<li><p><strong>乘法指令的源操作数显式给出，隐含使用另一个操作数AX和DX</strong></p>
<ul>
<li>字节量相乘：AL与r8/m8相乘，得到16位的结果，存入AX</li>
<li>字量相乘：AX与r16/m16相乘，得到32位的结果，其高字存入DX，低字存入AX</li>
</ul></li>
<li><p><strong>乘法指令如下影响OF和CF标志</strong>：</p>
<ul>
<li><p>MUL指令——若乘积的高一半（AH或DX）为0，则OF=CF=0；否则OF=CF=1</p>
<p>解释：</p>
<ol type="1">
<li><p>OF =
1表示溢出，因为原来是8（或者16位），高一半不为0说明现在的乘积超过8位（或者16位）。原来是8位现在就是16位，原来是16位现在就是32位</p></li>
<li><p>CF =
1表示进位，因为原来是8位（或者16位），高一半不为0说明原来的8位（或者16位）的有效位的最高位发生进位</p></li>
</ol></li>
<li><p>IMUL指令——若乘积的高一半是低一半的符号扩展，则OF=CF=0；否则均为1</p></li>
</ul></li>
</ol>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0b4h	；al=b4h=180</span><br><span class="line">mov bl,11h	；bl=11h=17</span><br><span class="line">mul bl	；ax=Obf4h=3060</span><br><span class="line">；OF=CF=1，AX高8位不为0</span><br><span class="line">mov al,0b4h	；al=b4h=－76</span><br><span class="line">mov bl,11h	；bl=11h=17</span><br><span class="line">imul bl	；ax=faf4h=－1292</span><br><span class="line">；OF=CF=1，AX高8位含有效数字</span><br></pre></td></tr></table></figure>
<h2 id="除法指令dividiv">除法指令(DIV/IDIV)</h2>
<ol type="1">
<li><p>除法指令的除数显式给出，隐含使用另一个操作数AX和DX作为被除数</p>
<ul>
<li><p>字节量除法：AX除以r8/m8，8位商存入AL，8位余数存入AH</p></li>
<li><p>字量除法：DX.AX除以r16/m16，16位商存入AX，16位余数存入DX</p></li>
</ul></li>
<li><p><font color = "red">被除数位数至少是除数1倍</font></p></li>
<li><p>被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达</p>
<p>便产生溢出，8086CPU中就产生编号为0的内部中断——除法错中断</p>
<ul>
<li>对DIV指令，除数为0，或者在字除时商超过8位，或者在字除时商超过16位</li>
<li>对IDIV指令，除数为0，或者在字节除时商不在-128～127范围内，或者在字除时商不在-32768～32767范围内</li>
</ul></li>
</ol>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0400h	；ax=400h=1024</span><br><span class="line">mov bl,0b4h	；bl=b4h=180</span><br><span class="line">div bl	；商al＝05h＝5</span><br><span class="line">	；余数ah＝7ch＝124</span><br><span class="line">mov ax,0400h	；ax=400h=1024</span><br><span class="line">mov bl,0b4h	；bl=b4h=－76</span><br><span class="line">idiv bl	；商al＝f3h＝－13</span><br><span class="line">	；余数ah＝24h＝36</span><br></pre></td></tr></table></figure>
<p><font color = "red">对进位标志CF的影响</font></p>
<ul>
<li>会修改CF
<ol type="1">
<li>ADD/ADC</li>
<li>SUB/SBB</li>
</ol></li>
<li>不会修改CF
<ol type="1">
<li>INC</li>
<li>DEC</li>
</ol></li>
<li>不确定
<ol type="1">
<li>MUC/IMUL</li>
<li>DIV/IDIV</li>
</ol></li>
</ul>
<h2 id="符号扩展指令cbwcwd">符号扩展指令(CBW/CWD)</h2>
<p>定义：</p>
<p>符号扩展是指用一个操作数的符号位（即最高位）形成另一个操作数，后一个操作数的各位是全0（正数）或全1（负数）。符号扩展不改变数据大小</p>
<p>种类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CBW		；AL的符号扩展至AH</span><br><span class="line">；如AL的最高有效位是0，则AH＝00</span><br><span class="line">；AL的最高有效位为1，则AH＝FFH。AL不变</span><br><span class="line"></span><br><span class="line">CWD		；AX的符号扩展至DX</span><br><span class="line">；如AX的最高有效位是0，则DX＝00</span><br><span class="line">；AX的最高有效位为1，则DX＝FFFFH。AX不变</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,80h	；al=80h</span><br><span class="line">cbw	；ax=ff80h</span><br><span class="line">add al,255	；al=7fh</span><br><span class="line">cbw	；ax=007fh</span><br></pre></td></tr></table></figure>
<p><font color = "red">典型例题：指令的综合运用</font></p>
<p>【例】：综合运算举例。计算： （V-（X*Y+Z-540））/X
其中X、Y、Z、V均为16位带符号数，已分别装入X、Y、Z、V单元中，要求计算结果把商存入AX，余数存入DX。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/54e90db558c32af218213452a594db0.jpg" /></p>
<h2 id="十进制算术运算指令">十进制算术运算指令</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240329151725488.png" style="zoom:50%;" /></p>
<p>十进制数的运算步骤： 1.对BCD码进行二进制运算
2.用十进制调整指令进行调整</p>
<h3
id="压缩的bcd码调整指令无操作数默认对放在al的数据操作">压缩的BCD码调整指令(无操作数，默认对放在AL的数据操作)</h3>
<p><font color = "yellow">常用来处理数字，所以D：decimal，A：adjust，A表示加法add，S表示减法sub</font></p>
<p><strong>BCD码的运算逻辑还是十进制，只不过是用二进制表示</strong></p>
<h4 id="daa加法">DAA（加法）</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e8acba20b47b74b5d25d0c4a24745b7.jpg" /></p>
<p>解释：为什么第②点是加60H：因为只要当前位表示的数大于等于10都要加6，但是当AL中高四位超过时，直接加6会误解，所以就要加60H，6分配给高4位，0分配给低4位。如果高低一起超过就加66H</p>
<h4 id="das减法">DAS（减法）</h4>
<p>就是将上面加法中减换成加</p>
<blockquote>
<p>小结：就是看每个半字是否有进位或者借位，对于低半字就是看AF和低半字是否大于等于10，对于高半字就是看CF和高半字是否大于等于10</p>
</blockquote>
<h3 id="非压缩的bcd码调整指令">非压缩的BCD码调整指令</h3>
<p><font color = "yellow">常用来处理字符，所以A：表示ASCII码，A表示调整adjust，其他就是加（ADD）减（sub）乘（mul）除（div）</font></p>
<p><font color = "red">压缩的BCD码就是通常的8421码，非压缩的BCD码是用8个二进制位表示一个十进制位</font></p>
<h4 id="aaa加法">AAA(加法)</h4>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e049db2b9e893a62481683220cde5b6.jpg" style="zoom:50%;" /></p>
<blockquote>
<p>注：AAA调整的时候一定还要根据AF判断是否调整的原因如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/fe64c6b2a1e3fa5372babecc04f35c9.jpg" style="zoom:50%;" /></p>
</blockquote>
<h4 id="aas减法">AAS(减法)</h4>
<p>就是将上图加1改成减1，加6改成减6</p>
<blockquote>
<p><font color = "red">小结：无论是压缩还是非压缩的BCD码的加减调整就是看低位有没有向高位进位和借位</font></p>
</blockquote>
<h4 id="aam乘法">AAM(乘法)</h4>
<p>将<strong>二进制乘法的结果调整成十进制非压缩的形式</strong>，<font color = "red">所以跟在乘法操作后面</font></p>
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c03ade250a8aee923bb78f4b37da18e.jpg" style="zoom:50%;" /></p>
<p><a
href="https://www.bilibili.com/video/BV1wm421n7as/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h4 id="aad除法">AAD(除法)</h4>
<p>先将<strong>十进制表示的被除数调整成二进制形式</strong>，再做除法，<font color = "red">所以放在除法前面</font></p>
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/18be2878e728fe3e3735fb3320f8686.jpg" style="zoom:50%;" /></p>
<p><a
href="https://www.bilibili.com/video/BV1JA4m1N7t9/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h1 id="位操作类指令">位操作类指令</h1>
<p><font color = "red">位操作指令都是将CF和OF设置为0，因为位操作不会产生进位，不会溢出</font></p>
<h2 id="逻辑与指令and">逻辑与指令AND</h2>
<p>AND指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑或指令or">逻辑或指令OR</h2>
<p>OR指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑异或指令xor">逻辑异或指令XOR</h2>
<p><font color = "red">与0异或不变，与1异或得相反数</font></p>
<p>XOR指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</p>
<h2 id="逻辑非指令not">逻辑非指令NOT</h2>
<p>NOT指令是一个单操作数指令 NOT指令不影响标志位</p>
<h2 id="测试指令test">测试指令TEST</h2>
<ol type="1">
<li>对两个操作数<font color = "red">执行逻辑与运算，结果不回送到目的操作数</font></li>
<li>TEST指令设置CF = OF =
0，根据结果设置SF、ZF和PF状态，而对AF未定义</li>
</ol>
<h1 id="移位指令shift">移位指令（shift）</h1>
<h2 id="逻辑左移shl">逻辑左移(SHL)</h2>
<p><strong>SHL reg/mem,1/CL</strong>
；逻辑左移，最高位进入CF，最低位补0</p>
<h2 id="算术左移sal">算术左移(SAL)</h2>
<p><strong>SAL reg/mem,1/CL</strong>
；算术左移，最高位进入CF，最低位补0</p>
<blockquote>
<p>注：逻辑左移和算术左移没什么区别</p>
</blockquote>
<h2 id="逻辑右移shr">逻辑右移(SHR)</h2>
<p><strong>SHR reg/mem,1/CL</strong>
；逻辑右移，最低位进入CF，<font color = "red">最高位补0</font></p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/53c6c2518a3aac3e6f447378d2d625f.jpg" /></p>
<h2 id="算术右移sar">算术右移(SAR)</h2>
<p><strong>SAR reg/mem,1/CL</strong>
；算术右移，最低位进入CF，<font color = "red">补符号位</font></p>
<p>举例</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5fd885e4eec0d58c9c1383423bb759d.jpg" /></p>
<p><font color = "red">算术</font>左移和算术右移主要用来进行<font color = "red">有符号数</font>的倍增、减半；</p>
<p><font color = "red">逻辑</font>左移和逻辑右移主要用来进行<font color = "red">无符号数</font>的倍增、减半。</p>
<blockquote>
<p>注：移位指令的<font color = "red">第一个操作数是指定的被移位的操作数</font>，可以是寄存器或存储单元
<font color = "red">后一个操作数表示移位位数</font>，该操作数为1，表示移动一位；<font color = "red">当移位位数大于1时，用且只能用CL寄存器值表示</font>，该操作数表达为CL</p>
</blockquote>
<h2 id="循环移位指令rotate">循环移位指令（rotate）</h2>
<p>ROL reg/mem,1/CL ；不带进位循环左移</p>
<p>ROR reg/mem,1/CL ；不带进位循环右移</p>
<p>RCL reg/mem,1/CL ；带进位循环左移</p>
<p>RCR reg/mem,1/CL ；带进位循环右移</p>
<p>带进位和不带进位的区别:</p>
<p>比如<font color = "red">不带进位的左移</font>，是<font color = "red">将最高位移动到CF里</font>；</p>
<p>而<font color = "red">带进位的左移</font>，是将CF和要移动的8位<font color = "red">合起来看做一个整体</font>一起移动</p>
<p><font color = "red">带进位一般用来处理多精度数的移动</font></p>
<p>举例：</p>
<p>题1：高精度移位</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240330150914140.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1vx421Q7Ft/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p>题2：BCD码合并</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bc3e302c70e3c9e2f4481d5e6b7b9d6.jpg" /></p>
<h1 id="控制转移类指令">控制转移类指令</h1>
<h2 id="非条件转移">非条件转移</h2>
<h3 id="段内寻址">段内寻址</h3>
<h4 id="相对寻址">相对寻址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP LABEL</span><br></pre></td></tr></table></figure>
<p>效果就是将当前IP指针加上LABEL表示的位移量</p>
<h4 id="间接寻址">间接寻址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP R16/M16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：R16表示16进制寄存器，M16表示16进制内存</p>
</blockquote>
<p>效果就是将IP修改为R16/M16中内容</p>
<h3 id="段间寻址">段间寻址</h3>
<h4 id="直接寻址">直接寻址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP FAR PTR LABEL</span><br></pre></td></tr></table></figure>
<p>效果是将IP修改为LABEL的偏移地址，CS修改为LABEL的段地址</p>
<h4 id="间接寻址-1">间接寻址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP FAR PTR MEM</span><br></pre></td></tr></table></figure>
<p>效果就是将IP修改为MEM的低2位字节[MEM]，将CS修改为LABEL的高2位字节[MEM+2](所以MEM是四个字节)</p>
<blockquote>
<p>注：段间间接寻址只能用内存，如果是寄存器的话是寄存器中保存的是对应内存中的地址，举例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV WORD PTR [BX], 0</span><br><span class="line">MOV WORD PTR [BX + 2], 1500H</span><br><span class="line">JMP FAR PTR [BX]</span><br><span class="line">; 转移到1500H:0</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="条件转移指令">条件转移指令</h2>
<h3 id="判断单个标志位状态">判断单个标志位状态</h3>
<p>⑴JZ/JE和JNZ/JNE：利用零标志ZF，判断结果是否为零（或相等）</p>
<p>⑵JS和JNS：利用符号标志SF，判断结果是正是负</p>
<p>⑶JO和JNO：利用溢出标志OF，判断结果是否产生溢出</p>
<p>⑷JP/JPE和JNP/JPO：利用奇偶标志PF，判断结果中“1”的个数是偶是奇</p>
<p>⑸JC/JB/JNAE和JNC/JNB/JAE：利用进位标志CF，判断结果是否进位或借位</p>
<p>上面5种每种里面记1个就行</p>
<p>举例：</p>
<p>题1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	test al,80h	；测试最高位</span><br><span class="line">	jz next0	；D7＝0（ZF＝1），转移</span><br><span class="line">	mov ah,0ffh	；D7＝1，顺序执行</span><br><span class="line">	jmp done	；无条件转向</span><br><span class="line">next0:	mov ah,0</span><br><span class="line">done:	...</span><br><span class="line">	test al,80h	；测试最高位</span><br><span class="line">	jnz next1	；D7＝1（ZF＝0），转移</span><br><span class="line">	mov ah,0	；D7＝0，顺序执行</span><br><span class="line">	jmp done	；无条件转向</span><br><span class="line">next1:	mov ah,0ffh</span><br><span class="line">done:	...</span><br></pre></td></tr></table></figure>
<p>题2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">；计算|X－Y|（绝对值）</span><br><span class="line">；X和Y为存放于X单元和Y单元的16位操作数</span><br><span class="line">；结果存入result</span><br><span class="line">	mov ax,X</span><br><span class="line">	sub ax,Y</span><br><span class="line">	jns nonneg</span><br><span class="line">	neg ax	；neg是求补指令</span><br><span class="line">nonneg:	mov result,ax</span><br></pre></td></tr></table></figure>
<h3 id="条件转移指令大全">条件转移指令大全</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ec17839cba049c8cd0fd850358ccadf.jpg" /></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>Acw730机器人跳跃问题</title>
    <url>/posts/1adefb1.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/732/">题目</a></h1>
<p>机器人正在玩一个古老的基于 DOS 的游戏。 <span id="more"></span></p>
<p>游戏中有 N+1座建筑——从 0 到 N 编号，从左到右排列。</p>
<p>编号为 0 的建筑高度为 0 个单位，编号为 i 的建筑高度为 H(i)
个单位。</p>
<p>起初，机器人在编号为 0 的建筑处。</p>
<p>每一步，它跳到下一个（右边）建筑。</p>
<p>假设机器人在第 k 个建筑，且它现在的能量值是 E ，下一步它将跳到第 k+1
个建筑。</p>
<p>如果 H(k+1)&gt;E ，那么机器人就失去 H(k+1)−E 的能量值，否则它将得到
E−H(k+1) 的能量值。</p>
<p>游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。</p>
<p>现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行输入整数 N 。</p>
<p>第二行是 N 个空格分隔的整数，H(1),H(2),…,H(N) 代表建筑物的高度。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(1≤N,H(i)≤10^5\)</span>,</p>
<h2 id="输入样例1">输入样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例1">输出样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输入样例2">输入样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 4 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例2">输出样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输入样例3">输入样例3：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 6 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例3">输出样例3：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>为什么这题可以联想到二分呢？因为如果找打一个E(0)的最小值，那么所有比E(0)大的值就一定满足题意，所有比E(0)小的值就一定不满足</p>
<p>另外，一定不要忽视第0栋楼的</p>
<p>当跳到第i栋楼时，能量与楼层的关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3a633398726baa6bf8a2ecfa262e0af.jpg" /></p>
<p>结合代码分析</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6a705dce19fbf5d71bd13700ded281f.jpg" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXHEIGHT</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] building = <span class="keyword">new</span> <span class="title class_">int</span>[MAXHEIGHT];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] energy = <span class="keyword">new</span> <span class="title class_">int</span>[MAXHEIGHT];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> startEnergy, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		energy[<span class="number">0</span>] = startEnergy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			energy[i] = <span class="number">2</span> * energy[i - <span class="number">1</span>] - building[i];</span><br><span class="line">			<span class="keyword">if</span>(energy[i] &gt; maxHeight) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(energy[i] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			building[i] = scan.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(building[i] &gt; maxHeight) &#123;</span><br><span class="line">				maxHeight = building[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = maxHeight;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(check(mid, n)) end = mid;</span><br><span class="line">			<span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(start);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>中等题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing1221拉格朗日定理</title>
    <url>/posts/d57017e8.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/1223/">题目</a></h1>
<p>四平方和定理，又称为拉格朗日定理：</p>
<span id="more"></span>
<p>每个正整数都可以表示为至多 4个正整数的平方和。</p>
<p>如果把 0 包括进去，就正好可以表示为 4 个数的平方和。</p>
<p>比如：</p>
<p><span class="math inline">\(5=0^2+0^2+1^2+2^2\)</span> <span
class="math inline">\(7=1^2+1^2+1^2+2^2\)</span></p>
<p>对于一个给定的正整数，可能存在多种平方和的表示法。</p>
<p>要求你对 4 个数排序：</p>
<p>0≤a≤b≤c≤d</p>
<p>并对所有的可能表示法按 a,b,c,d , , ,
为联合主键升序排列，最后输出第一个表示法。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入一个正整数 N 。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出4个非负整数，按从小到大排序，中间用空格分开。</p>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(0&lt;N&lt;5∗10^6\)</span></p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>利用空间换时间，首先将<span class="math inline">\(c^2 +
d^2\)</span>的所有结果保存，然后枚举<span class="math inline">\(a^2 +
b^2\)</span>的结果，用二分在之前保存的结果中查找</p>
<p>保存<span class="math inline">\(c^2 +
d^2\)</span>的结果时，由于题目中有对键值排序的要求，所以利用要按<span
class="math inline">\(c^2 + d^2, c, d\)</span>优先级排序</p>
<h2 id="java中接口在排序中的使用">java中接口在排序中的使用</h2>
<h3
id="首先定义实现比较接口的类在这个类中定义构造函数和重写比较函数">首先定义实现比较接口的类，在这个类中定义构造函数和重写比较函数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square_sum</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Square_sum&gt; &#123;</span><br><span class="line">    <span class="type">int</span> sum_square, c, d;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sum_square</span><span class="params">(<span class="type">int</span> sum_square, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sum_square = sum_square;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Square_sum t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.sum_square != t.sum_square) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.sum_square, t.sum_square);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.c != t.c) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.c, t.c);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.d, t.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="然后定义类数组">然后定义类数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Square_sum[] data = <span class="keyword">new</span> <span class="title class_">Square_sum</span>[MAXSIZE];</span><br></pre></td></tr></table></figure>
<h3 id="接着实例化类数组中每一个对象">接着实例化类数组中每一个对象</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data[k++] = <span class="keyword">new</span> <span class="title class_">Square_sum</span>(c * c + d * d, c, d)</span><br></pre></td></tr></table></figure>
<h3
id="利用arrays.sort排序arrays.sort会使用类数组中重写的比较函数作为排序依据">利用Arrays.sort排序，Arrays.sort会使用类数组中重写的比较函数作为排序依据</h3>
<h2 id="java加速读取与打印的方法">java加速读取与打印的方法</h2>
<p>利用BufferdReader和BuffedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine())</span><br><span class="line">writer.write(String.format(<span class="string">&quot;%d %d %d %d\n&quot;</span>), a, b, c, d)</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum_square</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Sum_square&gt; &#123;</span><br><span class="line">    <span class="type">int</span> square_sum, c, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sum_square</span><span class="params">(<span class="type">int</span> square_sum, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.square_sum = square_sum;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.d = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Sum_square t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.square_sum != t.square_sum) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.square_sum, t.square_sum);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.c != t.c) <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.c, t.c);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.d, t.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXNUM</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">5e6</span>;</span><br><span class="line">    <span class="keyword">static</span> Sum_square[] record_sum_square = <span class="keyword">new</span> <span class="title class_">Sum_square</span>[MAXNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">             <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c * c &lt;= n; c++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c; c * c + d * d &lt;= n; d++) &#123;</span><br><span class="line">                    record_sum_square[count++] = <span class="keyword">new</span> <span class="title class_">Sum_square</span>(c * c + d * d, c, d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.sort(record_sum_square, <span class="number">0</span>, count);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a * a &lt;= n; a++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; a * a + b * b &lt;= n; b++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n - (a * a + b * b);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = count - <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (record_sum_square[mid].square_sum &gt;= t) &#123;</span><br><span class="line">                            end = mid;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            start = mid + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (record_sum_square[start].square_sum == t) &#123;</span><br><span class="line">                        writer.write(String.format(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, record_sum_square[start].c, record_sum_square[start].d));</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing789数的范围-二分基础</title>
    <url>/posts/c9bce4fa.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/791/">题目</a></h1>
<p>给定一个按照升序排列的长度为 n的整数数组，以及 q 个查询。</p>
<p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0
开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<span id="more"></span>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含整数 n和 q，表示数组长度和询问个数。</p>
<p>第二行包含 n 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p>
<p>接下来 q 行，每行包含一个整数 k ，表示一个询问元素。</p>
<h2 id="输出格式">输出格式</h2>
<p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤n≤1000001≤ ≤100000 1≤q≤100001≤ ≤10000 1≤k≤100001≤ ≤10000</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>二分模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找左边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="keyword">void</span> <span class="title function_">search_left</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环结束的时候start = end</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) end = mid;	<span class="comment">//关键一:check(mid)怎么决定，一种是data[mid] &gt;= target,详解见下文</span></span><br><span class="line">        <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="这种二分是要在一个范围内找到指定范围的最左端和最右端">这种二分是要在一个范围内，找到指定范围的最左端和最右端</h2>
<h2 id="以找最左端为例">以找最左端为例</h2>
<h3 id="checkmid如何决定">check(mid)如何决定</h3>
<p>mid的目的是将一段区间分割成两端，其中一段（包括mid）均满足check规定的性质，另一端都不满足</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/499015168eb010e1f1caecd12076fdd.jpg" /></p>
<h3 id="总结">总结</h3>
<h4 id="决定check函数">决定check函数</h4>
<ol type="1">
<li>一定包含mid，就是一定要有=</li>
<li>向危险的边缘疯狂试探的思想</li>
</ol>
<h4
id="口诀左边界无加必有加有边界有加必有减">口诀：左边界，无加必有加；有边界有加必有减</h4>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.kerberos.KerberosKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search_left</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(data[mid] &gt;= target) end = mid;</span><br><span class="line">			<span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search_right</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">			mid = (start + end) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(data[mid] &lt;= target) start = mid;</span><br><span class="line">			<span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			data[i] = scan.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftSide</span> <span class="operator">=</span> search_left(target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(data[leftSide] != target) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.print(leftSide + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightSide</span> <span class="operator">=</span> search_right(target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(data[rightSide] != target) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(rightSide);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/792/">题目二</a></h2>
<h3 id="分析-1">分析：</h3>
<p>在while循环里使用stride表示left与right之间的距离，当距离足够小的时候可以近似认为相等</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line">		<span class="type">double</span> <span class="variable">left</span> <span class="operator">=</span> (-<span class="number">1.0</span>) * <span class="number">10000</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">10000.0</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">stride</span> <span class="operator">=</span> <span class="number">1e-8</span>;</span><br><span class="line">		<span class="keyword">while</span>(right - left &gt; stride) &#123;</span><br><span class="line">			<span class="type">double</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(mid * mid * mid &gt;= n) right = mid;</span><br><span class="line">			<span class="keyword">else</span> left = mid + stride;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.format(<span class="string">&quot;%.6f&quot;</span>, right);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目三"><a
href="https://www.acwing.com/problem/content/798/">题目三</a></h2>
<h3 id="分析-2">分析</h3>
<p>二维</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/93445804d4b28971e344e072d6fbff4.jpg" /></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				data[i][j] = scan.nextInt();</span><br><span class="line">				<span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">					prefixSum[i][j] = prefixSum[i - <span class="number">1</span>][m] + data[i][j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					prefixSum[i][j] = prefixSum[i][j - <span class="number">1</span>] + data[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">			<span class="type">int</span> leftX, leftY;</span><br><span class="line">			leftX = scan.nextInt();</span><br><span class="line">			leftY = scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightX</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightY</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> leftX; row &lt;= rightX; row++) &#123;</span><br><span class="line">				totalSum += (prefixSum[row][rightY] - prefixSum[row][leftY - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(totalSum);</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>二分</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和基础</title>
    <url>/posts/6ebcf9d0.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/797/">题目</a></h1>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来再输入 m 个询问，每个询问输入一对 l,r , 。</p>
<p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行包含两个整数 n 和 m 。</p>
<p>第二行包含 n 个整数，表示整数数列。</p>
<p>接下来 m 行，每行包含两个整数 l 和 r ，表示一个询问的区间范围。</p>
<h2 id="输出格式">输出格式</h2>
<p>共 m 行，每行输出一个询问的结果。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤l≤r≤n, 1≤n,m≤100000 −1000≤数列中元素的值≤1000</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p><span class="math inline">\(前缀和s[i] = a[1] + a[2] + …… +
a[i]\)</span></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			data[i] = scan.nextInt();</span><br><span class="line">			prefixSum[i] = prefixSum[i - <span class="number">1</span>] + data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			System.out.println(prefixSum[right] - prefixSum[left - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>前缀和</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing99激光炸弹-前缀和</title>
    <url>/posts/46a3c91c.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/101/">题目</a></h1>
<p>地图上有 N 个目标，用整数 Xi,Yi ,
表示目标在地图上的位置，每个目标都有一个价值 Wi 。</p>
<p><strong>注意</strong>：不同目标可能在同一位置。</p>
<p>现在有一种新型的激光炸弹，可以摧毁一个包含
R×R个位置的正方形内的所有目标。</p>
<p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和
x，y 轴平行。</p>
<p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
<p>## 输入格式</p>
<p>第一行输入正整数 N 和 R
，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。</p>
<p>接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi , ,
，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。</p>
<p>## 输出格式</p>
<p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p>
<p>## 数据范围</p>
<p><span class="math inline">\(0≤R≤10^9\)</span> <span
class="math inline">\(0&lt;N≤100000\)</span> <span
class="math inline">\(0≤Xi,Yi≤50000\)</span> <span
class="math inline">\(0≤Wi≤10000\)</span></p>
<p>## 输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">0 0 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>## 输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>首先讲解下什么是二维前缀和</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/a1be24141cc56e2e06e0925e75b1802.jpg" /></p>
<p>但是本题的特殊之处在于给的目标是在交叉点上，而上面给的是第几个矩阵</p>
<p>解决方法：平移坐标系，原来在坐标轴上的目标就变成了在坐标轴内的目标，进一步就是变成了和原来一样的第几个小正方形</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/fa457b993c3966a8faa0491504cb5a3.jpg" /></p>
<p>所以先将目标的value填充到对应的方格中，然后计算value的前缀和矩阵，最后利用计算出的前缀和矩阵，通过移动覆盖面积的小方形，以其右下角为基准遍历整个矩阵，计算覆盖面积的最大值</p>
<p><strong>前缀和的灵魂就是将本来时间复杂度<span
class="math inline">\(O(n)\)</span>甚至<span
class="math inline">\(O(n^2)\)</span>的循环遍历求和变成<span
class="math inline">\(O(1)\)</span></strong></p>
<p>注意：</p>
<p>1 题目中一个坐标处可能有多个目标</p>
<p>2 如果火力覆盖面积比最大的5000还大，那就可以不用遍历直接得到答案</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.chrono.MinguoChronology;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> <span class="number">5010</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		r = Math.min(r, <span class="number">5001</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">max_x</span> <span class="operator">=</span> r;</span><br><span class="line">		<span class="type">int</span> <span class="variable">max_y</span> <span class="operator">=</span> r;</span><br><span class="line">		<span class="comment">// 填充一小格的价值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			matrix[x + <span class="number">1</span>][y + <span class="number">1</span>] += scan.nextInt();</span><br><span class="line">			max_x = Math.max(x + <span class="number">1</span>, max_x);</span><br><span class="line">			max_y = Math.max(y + <span class="number">1</span>, max_y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算价值的二维前缀和</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max_x; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= max_y; j++) &#123;</span><br><span class="line">				matrix[i][j] += matrix[i - <span class="number">1</span>][j] + matrix[i][j - <span class="number">1</span>] - matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移动火力覆盖的小方形遍历整个矩阵</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &lt;= max_x; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r; j &lt;= max_y; j++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> matrix[i][j] - matrix[i - r][j] - matrix[i][j - r] + matrix[i - r][j - r];</span><br><span class="line">				<span class="keyword">if</span>(value &gt; maxValue) &#123;</span><br><span class="line">					maxValue = value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(maxValue);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>前缀和</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>BFS - 灌溉</title>
    <url>/posts/e305a760.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/551/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116113111905.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">3 4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="多源bfs的思路">多源BFS的思路</h2>
<h2
id="定义一个节点类记录这个节点的x坐标y坐标和这个节点的层数放在这道题里面其实就是第几分钟灌溉好的">定义一个节点类，记录这个节点的x坐标，y坐标和这个节点的“层数”（放在这道题里面其实就是第几分钟灌溉好的）</h2>
<h2
id="定义一个辅助二维数组记录当前节点是否访问过">定义一个辅助二维数组，记录当前节点是否访问过</h2>
<h2
id="每轮循环先访问队列中队首节点如果当前队首节点的层数小于等于时间说明可以继续按上下左右顺序访问当前弹出的节点的临近节点如果临近节点之前没有访问过就压入队列并且设为访问过">每轮循环先访问队列中队首节点，如果当前队首节点的层数小于等于时间，说明可以继续，按上下左右顺序访问当前弹出的节点的临近节点，如果临近节点之前没有访问过，就压入队列并且设为访问过</h2>
<h3 id="java中队列操作">Java中队列操作</h3>
<h4 id="声明">声明</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="加入元素">加入元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.add(Node);</span><br></pre></td></tr></table></figure>
<h4 id="访问队首元素">访问队首元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.peek()</span><br></pre></td></tr></table></figure>
<h4 id="弹出队首元素">弹出队首元素</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.poll()</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> floor;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> floor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">		<span class="built_in">this</span>.floor = floor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[][] graph = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        	<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        	queue.add(newNode);</span><br><span class="line">        	graph[x][y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> t;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        	<span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        	<span class="keyword">if</span>(newNode.floor &lt;= k) &#123;</span><br><span class="line">            	queue.poll();</span><br><span class="line">            	<span class="type">int</span> <span class="variable">centerX</span> <span class="operator">=</span> newNode.x;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">centerY</span> <span class="operator">=</span> newNode.y;</span><br><span class="line">            	<span class="comment">//向上的方向</span></span><br><span class="line">            	<span class="keyword">if</span>(centerX - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; graph[centerX - <span class="number">1</span>][centerY] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX - <span class="number">1</span>][centerY] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX - <span class="number">1</span>, centerY, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向下的方向</span></span><br><span class="line">            	<span class="keyword">if</span>(centerX + <span class="number">1</span> &lt;= n &amp;&amp; graph[centerX + <span class="number">1</span>][centerY] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX + <span class="number">1</span>][centerY] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX + <span class="number">1</span>, centerY, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向左</span></span><br><span class="line">            	<span class="keyword">if</span>(centerY - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; graph[centerX][centerY -<span class="number">1</span> ] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX][centerY - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX, centerY - <span class="number">1</span>, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="comment">//向右</span></span><br><span class="line">            	<span class="keyword">if</span>(centerY + <span class="number">1</span> &lt;= m &amp;&amp; graph[centerX][centerY + <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            		graph[centerX][centerY + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            		queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(centerX, centerY + <span class="number">1</span>, newNode.floor + <span class="number">1</span>));</span><br><span class="line">            		count++;</span><br><span class="line">            	&#125;</span><br><span class="line">        		</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(count);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>递归实现指数型枚举</title>
    <url>/posts/b9f8e3d9.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/94/">题目</a></h1>
<p>从 1∼n 这 个整数中随机选取任意多个，输出所有可能的选择方案。</p>
<span id="more"></span>
<h2 id="输入格式">输入格式</h2>
<p>输入一个整数 n。</p>
<h2 id="输出格式">输出格式</h2>
<p>每行输出一种方案。</p>
<p>同一行内的数必须升序排列，相邻两个数用恰好 11 个空格隔开。</p>
<p>对于没有选任何数的方案，输出空行。</p>
<p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p>
<h2 id="数据范围">数据范围</h2>
<p>1≤n≤15</p>
<h2 id="输入样例">输入样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>利用dfs的思想递归，每一层对应当前的数，分成两个子树，左子树代表选，右子树代表不选</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1.png" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isChoose = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(a &gt; n) &#123;	<span class="comment">//如果当前层超过最后一层，就可以输出全部结果了</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(isChoose[i]) &#123;</span><br><span class="line">					System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果还没有超过最后一层</span></span><br><span class="line">			<span class="comment">// 选当前层</span></span><br><span class="line">			isChoose[a] = <span class="literal">true</span>;</span><br><span class="line">			dfs(a + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 不选当前层</span></span><br><span class="line">			isChoose[a] = <span class="literal">false</span>;</span><br><span class="line">			dfs(a + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		dfs(<span class="number">1</span>);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目一"><a
href="https://www.acwing.com/problem/content/95/">题目一</a></h2>
<p>递归三要素：参数值和返回值，终止条件，递归逻辑</p>
<p>root表示当前的根，count表示当前root对应是第几层</p>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/description/118/">题目二</a></h2>
<h3 id="分析-1">分析</h3>
<p>为什么要把这题放在枚举里面了？</p>
<p>因为这是就是一道用dfs解决的题目</p>
<p>因为一共有16个开关，每个开关有2种选择，所以一共有<span
class="math inline">\(2^{16}\)</span>种选择，所以可以用暴力解决</p>
<p>用dfs树的思路：当前层的开关不调整是左子树，调整是右子树，如果是右子树就要将该开关本身所在的行与列都调整</p>
<p>举个例子</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4512499dcce75216a9c1d978eb6e681.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span> <span class="variable">CLOSED</span> <span class="operator">=</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span> <span class="variable">OPEN</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] data = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[][] tmpIsVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[][] minIsVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">minStride</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tmpStride</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i][j] == OPEN) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[row][col] == CLOSED) &#123;</span><br><span class="line">            data[row][col] = OPEN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[row][col] = CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        reverse(row, col);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) reverse(row, i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) reverse(j, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(validate()) &#123;</span><br><span class="line"><span class="comment">//              printMatrix();</span></span><br><span class="line">                <span class="keyword">if</span>(tmpStride &lt; minStride) &#123;</span><br><span class="line">                    minStride = tmpStride;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        minIsVisited[i] = Arrays.copyOf(tmpIsVisited[i], <span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> count / <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> count % <span class="number">4</span>;</span><br><span class="line"><span class="comment">//      System.out.format(&quot;当前开关是%d %d\n&quot;, row, col);</span></span><br><span class="line"><span class="comment">//      System.out.println(&quot;当前层开关不按&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">        dfs(count + <span class="number">1</span>);</span><br><span class="line">        tmpIsVisited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        change(row, col);</span><br><span class="line"><span class="comment">//      System.out.println(&quot;当前层开关按&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">        tmpStride += <span class="number">1</span>;</span><br><span class="line">        dfs(count + <span class="number">1</span>);</span><br><span class="line">        tmpIsVisited[row][col] = <span class="literal">false</span>;</span><br><span class="line">        change(row, col);</span><br><span class="line">        tmpStride -= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//      System.out.println(&quot;恢复当前层&quot;);</span></span><br><span class="line"><span class="comment">//      printMatrix();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                System.out.print(data[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNextLine() &amp;&amp; row &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                data[row][i] = line.charAt(i); </span><br><span class="line">            &#125;</span><br><span class="line">            row++;              </span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        change(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tmpStride += <span class="number">1</span>;</span><br><span class="line">        tmpIsVisited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(minStride);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(minIsVisited[i][j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.format(<span class="string">&quot;%d %d\n&quot;</span>, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>排列，递归实现排列型枚举</title>
    <url>/posts/19de5275.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/96/">题目</a></h1>
<p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<span id="more"></span>
<h4 id="输入格式">输入格式</h4>
<p>一个整数 n</p>
<h4 id="输出格式">输出格式</h4>
<p>按照从小到大的顺序输出所有方案，每行 1 个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一
一比较，字典序较小的排在前面。</p>
<h4 id="数据范围">数据范围</h4>
<p>1≤n≤9</p>
<h4 id="输入样例">输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="每到一层root含义">每到一层root含义</h2>
<p>和<a
href="">这道题</a>相比，上一题每一层是当前层的数选还是不选从而分叉，本题是选哪一个从而分叉</p>
<h2 id="isvisited">isVisited</h2>
<p>记录当前root是否访问过</p>
<h2 id="data">data</h2>
<p>记录输出序列</p>
<h2 id="count">count</h2>
<p>记录当前root是序列里第几个元素</p>
<h2 id="回溯往往与递归相辅相成">回溯（往往与递归相辅相成）</h2>
<p>每一个root退出递归后，要将isVisited和data，count恢复成原样</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/2.png" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == n) &#123;							<span class="comment">//如果输出序列已满，全部打印输出</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				System.out.print(data[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i != root &amp;&amp; isVisited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">					isVisited[i] = <span class="literal">true</span>;	</span><br><span class="line">					data[count + <span class="number">1</span>] = i;</span><br><span class="line">					dfs(i, count + <span class="number">1</span>);</span><br><span class="line">					isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">					data[count + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			isVisited[i] = <span class="literal">true</span>;	<span class="comment">//标记当前的root为已经访问</span></span><br><span class="line">			data[<span class="number">1</span>] = i;			<span class="comment">//将当前root加入输出序列</span></span><br><span class="line">			dfs(i, <span class="number">1</span>);</span><br><span class="line">			isVisited[i] = <span class="literal">false</span>;	<span class="comment">//回溯，将当前的root重置为0</span></span><br><span class="line">			data[<span class="number">1</span>] = <span class="number">0</span>;			<span class="comment">//将当前root从输出序列弹出</span></span><br><span class="line">		&#125;</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全排列dfs代码模板">全排列dfs代码模板</h2>
<h3
id="作为递归参数传递记录当前层数的count当count等于全排列数字位数后意味着搜索树到底">作为递归参数传递，记录当前层数的count，当count等于全排列数字位数后，意味着搜索树到底</h3>
<h3
id="记录当前这个数是否访问过的isvisited数组">记录当前这个数是否访问过的isVisited数组</h3>
<h3 id="回溯还原">回溯还原</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int n;</span><br><span class="line">static StringBuffer stringNum = new StringBuffer();</span><br><span class="line">static boolean[] isVisited = new boolean[MAX];</span><br><span class="line">static void dfs(int count) &#123;	//count表示当前层</span><br><span class="line">	if(count == n) &#123;</span><br><span class="line">		根据题意的其他操作</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		if(isVisited[i] == false) &#123;</span><br><span class="line">			isVisited[i] = true;</span><br><span class="line">             stringNum.append(i);</span><br><span class="line">             dfs(count + 1);</span><br><span class="line">             isVisited[i] = false;</span><br><span class="line">             stringNum.deleteCharAt(stringNum.length() - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="举一反三">举一反三</h1>
<h2 id="题目二"><a
href="https://www.acwing.com/problem/content/1539/">题目二</a></h2>
<p>这一题关键在如何剪枝：首先将数组排个序，然后每一层的root返回后，一直向下遍历到和当前root不相同的位置位置，因为从排列角度来说，只要前一个遍历过了，后一个如果相同，一定是重复的</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/64845_fc80efef68-7C344E16678378354C1F3D3558D18A05.png" /></p>
<p>另外关于java中如何加速读写</p>
<p>使用StreamTokenizer和PrintWriter加速</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StreamTokenizer tokenizer;</span><br><span class="line"><span class="keyword">static</span> PrintWriter writer;</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out);</span><br><span class="line">   tokenizer = <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(reader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span>&#123;</span><br><span class="line">       tokenizer.nextToken();</span><br><span class="line">       <span class="keyword">return</span> (<span class="type">int</span>) tokenizer.nval;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>使用时就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = nextInt()</span><br></pre></td></tr></table></figure>
<h2 id="题目三"><a
href="https://www.acwing.com/problem/content/1211/">题目三</a></h2>
<h4 id="分析-1">分析：</h4>
<p>通过枚举解决，难点是如何枚举</p>
<p>题目实际上是n = a + b / c</p>
<p>等式两边同乘以c，得到n * c = a * c + b</p>
<p>先通过dfs全排列找到所有排列，在对排列按照位数划分得到a， b，
剩下的位组成c，代入看是否满足公式</p>
<p>举个例子</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0242354a6fd667e83152bd75a6e7321.jpg" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">StringBuffer</span> <span class="variable">stringNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == m + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//System.out.println(stringNum);</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringNum.length(); i++) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">subStringa</span> <span class="operator">=</span> stringNum.substring(<span class="number">0</span>, i);</span><br><span class="line">				<span class="keyword">if</span>(subStringa.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(subStringa);</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; stringNum.length(); j++) &#123;</span><br><span class="line">						<span class="type">String</span> <span class="variable">subStringb</span> <span class="operator">=</span> stringNum.substring(i, j);</span><br><span class="line">						<span class="keyword">if</span>(subStringb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(subStringb);</span><br><span class="line">							<span class="type">String</span> <span class="variable">subStringc</span> <span class="operator">=</span> stringNum.substring(j, stringNum.length());</span><br><span class="line">							<span class="keyword">if</span>(subStringc.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">								<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.parseInt(subStringc);</span><br><span class="line">								<span class="comment">//System.out.format(&quot;a = %d	b = %d	c = %d\n&quot;, a, b, c);</span></span><br><span class="line">								<span class="keyword">if</span>(n * c == a * c + b) &#123;</span><br><span class="line">									totalNum++;</span><br><span class="line">								&#125;								</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;-------------------------&quot;);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isVisited[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">				isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">				stringNum.append(i);</span><br><span class="line">				dfs(count + <span class="number">1</span>);</span><br><span class="line">				isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">				stringNum.deleteCharAt(stringNum.length() - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">			isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">			stringNum.append(i);</span><br><span class="line">			dfs(<span class="number">2</span>);</span><br><span class="line">			isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">			stringNum.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(totalNum);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4
id="补充java中stringbuffer可变字符串的使用">补充：java中StringBuffer可变字符串的使用</h4>
<h5 id="切割子字符串左闭右开">切割子字符串：左闭右开</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> stringNum.subString(start, end);</span><br></pre></td></tr></table></figure>
<h4 id="字符串转数字">字符串转数字</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(subString)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>搜索</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>DP动态规划入门</title>
    <url>/posts/1370e9cf.html</url>
    <content><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="核心思想">核心思想</h2>
<p>为了解决一个“大”问题，将“大”问题分解成两个“小”问题</p>
<p>举个例子：一次可以走一个台阶或者两个台阶，问走到第n个台阶时，一共有多少种走法？要走到第n级台阶，分成两种情况，一种是从n-1级台阶走一步过来，一种是从n-2级台阶走两步过来</p>
<h2 id="状态">状态</h2>
<p>形如dp[i][j] = val的取值，其中i,
j为下标，用于描述、确定状态所需的变量，val为状态值</p>
<h2 id="状态转移">状态转移</h2>
<p>状态与状态之间的转移关系，转移方向决定了迭代或递归方向</p>
<h2
id="常见特征重叠子问题最优子结构">常见特征：重叠子问题，最优子结构</h2>
<h3 id="重叠子问题">重叠子问题：</h3>
<p>斐波那契数为例，用递归计算fib(5)，分解为图示的子问题，其中fib(3)计算了2次，其实只算1次就够了</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/95b4e7867af7488f8ce8837e23c3bfc1.png" /></p>
<h3 id="最优子结构"><strong>最优子结构</strong></h3>
<h2 id="两种编码方法">两种编码方法</h2>
<h3 id="自顶向下与记忆化"><strong>自顶向下与记忆化</strong></h3>
<p>先考虑大问题，再缩小到小问题，递归很直接地体现了这种思路。为避免递归时重复计算子问题，可以在子问题得到解决时，就保存结果，再次需要这个结果时，直接返回保存的结果就行了。这种存储已经解决的子问题的结果的技术称为“记忆化（Memoization）”。
  以斐波那契数为例，记忆化代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> memoize[N];                                  <span class="comment">//保存结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memoize[n] != <span class="number">0</span>) <span class="keyword">return</span> memoize[n]; <span class="comment">//直接返回保存的结果，不再递归</span></span><br><span class="line">    memoize[n]= fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>);       <span class="comment">//递归计算结果，并记忆</span></span><br><span class="line">    <span class="keyword">return</span> memoize[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自下而上与制表递推"><strong>自下而上与制表递推</strong></h3>
<p>先解决子问题，再递推到大问题。通常通过填写表格来完成，编码时用若干for循环语句填表。根据表中的结果，逐步计算出大问题的解决方案。</p>
<p>用制表法计算斐波那契数，维护一个一维表dp[]，记录自下而上的计算结果，更大的数是前面两个数的和。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/bb9b3fee28e94641a908121c07cec9c6.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)  dp[i] = dp[i-<span class="number">1</span>] +dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分析步骤">分析步骤</h1>
<h2 id="确定状态">确定状态</h2>
<p>一般为“到第i个为止，方案数/最小代价/最大价值</p>
<h2 id="确定状态转移方程">确定状态转移方程</h2>
<p>根据状态转移方向决定迭代还是递归</p>
<h2 id="确定最终状态">确定最终状态</h2>
<h1 id="题目一"><a
href="https://www.lanqiao.cn/problems/1536/learning/?page=1&amp;first_category_id=1&amp;problem_id=1536">题目一</a></h1>
<h2 id="题干">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240227160907000.png" /></p>
<h2 id="分析">分析</h2>
<p>状态：dp[i][j]表示第i行，第j列的和的最大值</p>
<p>状态迁移方程：方向从底向上，取当前位置的下一层的左边或右边的最大值与当前位置求和，作为当前位置dp值</p>
<p>最终状态：dp[1][1]</p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 读入三角形里面的数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">				 dp[i][j] = scan.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">				<span class="comment">// 状态转移方程，不过是从下往上</span></span><br><span class="line">				dp[i][j] += Math.max(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目二"><a
href="https://www.lanqiao.cn/problems/3367/learning/?page=1&amp;first_category_id=1&amp;problem_id=3367">题目二</a></h1>
<h2 id="题干-1">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240228085943251.png" /></p>
<h2 id="分析-1">分析</h2>
<p>确定状态：dp[i]表示到第i级台阶有多少种方案</p>
<p>确定状态转移方程：从后往前,dp[i] = dp[i - 1] + dp[i - 2]</p>
<p>确定最终状态：dp[N]</p>
<p>注意，题目中如果告诉你结果比较大，java一般需要开long</p>
<h2 id="代码-1">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10e5</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span>[] broken = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXSIZE];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[MAXSIZE];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">worse</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">			broken[worse] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第0级台阶</span></span><br><span class="line">		broken[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 第一级台阶比较特殊，如果第一级台阶没有坏，则只用一种可能，就是从第0级台阶上来</span></span><br><span class="line">		<span class="keyword">if</span>(broken[<span class="number">1</span>] == <span class="literal">false</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(broken[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">				dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % p;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		for(int i = 1; i &lt;= N; i++) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		System.out.println();</span></span><br><span class="line">		System.out.println(dp[N]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目三"><a
href="https://www.lanqiao.cn/problems/3423/learning/?page=1&amp;first_category_id=1&amp;problem_id=3423">题目三</a></h1>
<h2 id="题干-2">题干</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240304094002984.png" /></p>
<h2 id="分析-2">分析</h2>
<h3 id="确定状态-1">确定状态</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4c5353de2efaf91f73998dca65bb934.jpg" /></p>
<p>dp[i]:最后一个桶放在位置i的方案总数</p>
<h3 id="状态转移方程">状态转移方程</h3>
<p>因为dp[i]表示最后一个桶在位置i所具有的方案总数，而要求最近的相邻两个桶之间要相隔k个桶，所以dp[i]等于从最后一个桶在位置1的方案(dp[1])到最后一个桶在位置i
- k - 1的方案数(dp[i - k - 1])的和，即<span class="math inline">\(dp[j]
= \sum_{i = 1}^{j - k - 1}dp[i]\)</span></p>
<h3 id="最终状态">最终状态</h3>
<p>题目要求的是总方案数，由dp数列定义可知不是dp[N]，所以要对dp数组求前缀和，prefix[N]才是答案</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		dp[<span class="number">0</span>] = prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i - k - <span class="number">1</span> &lt; <span class="number">1</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> dp[i] =  prefix[i - k - <span class="number">1</span>];</span><br><span class="line">			prefix[i] = (prefix[i - <span class="number">1</span>] + dp[i]) % p;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(prefix[n]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="入门一题"><a
href="https://www.lanqiao.cn/problems/3503/learning/">入门一题</a></h1>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划基础-混境之地5</title>
    <url>/posts/56b92135.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/3820/learning/?page=1&amp;first_category_id=1&amp;problem_id=3820">题目</a></h1>
<h1 id="分析">分析</h1>
<p>这题最初的想法用dfs解决，但会超时，分析是因为每次递归计算的值没有利用，所以开一个dp[n][m][k]数组，表示从起点开始，在经过点(x,
y)，并且在使用喷气背包的次数为t的情况下，能否到达终点</p>
<p>另外要注意地图的边界是从1开始，不是从0开始</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXSIZE</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e3</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// dp有三个值：-1表示没有遍历过，0表示从起点,经过点(x, y),在喷气背包使用t次的情况下无法抵达终点，1则相反，表示可以抵达</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE][MAXSIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> sx, sy, fx, fy;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果发现已经抵达终点</span></span><br><span class="line">    	<span class="keyword">if</span>(x == fx &amp;&amp; y == fy) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果发现当前坐标位置已经遍历过，dp思想的核心体现</span></span><br><span class="line">    	<span class="keyword">if</span>(dp[x][y][p] != -<span class="number">1</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> dp[x][y][p];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 上下左右依次遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    		<span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">    		<span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line">    		<span class="comment">// 判断移动后是否还在地图里</span></span><br><span class="line">    		<span class="keyword">if</span>(!isValid(nx, ny)) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="comment">// 如果当前喷气背包没有使用</span></span><br><span class="line">    		<span class="keyword">if</span>(p == <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">// 当前高度比下一个高度高</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span> dfs(nx, ny, <span class="number">0</span>);</span><br><span class="line">    				<span class="comment">// 如果经过当前点可以抵达终点</span></span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					<span class="comment">// 将dp[x][y][p]置为1并且返回1，向上一层传递</span></span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="comment">// 当前高度比下一个高度低但是使用喷气背包后可以抵达</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &lt; map[nx][ny] &amp;&amp; map[x][y] + k &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span>dfs(nx, ny, <span class="number">1</span>);</span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 如果当前喷气背包已经使用</span></span><br><span class="line">    			<span class="keyword">if</span>(map[x][y] &gt;= map[nx][ny]) &#123;</span><br><span class="line">    				<span class="type">int</span> <span class="variable">canReach</span> <span class="operator">=</span> dfs(nx, ny, <span class="number">1</span>);</span><br><span class="line">    				<span class="keyword">if</span>(canReach == <span class="number">1</span>) &#123;</span><br><span class="line">    					dp[x][y][p] = <span class="number">1</span>;</span><br><span class="line">    					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	dp[x][y][p] = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fillArrays</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">    				dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        n = scan.nextInt();</span><br><span class="line">        m = scan.nextInt();</span><br><span class="line">        k = scan.nextInt();</span><br><span class="line">        sx = scan.nextInt();</span><br><span class="line">        sy = scan.nextInt();</span><br><span class="line">        fx = scan.nextInt();</span><br><span class="line">        fy = scan.nextInt();</span><br><span class="line">        fillArrays();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        		map[i][j] = scan.nextInt();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfs(sx, sy, <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥oj-3362-建造房屋</title>
    <url>/posts/a0fa68f9.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/3362/learning/?page=1&amp;first_category_id=1&amp;problem_id=3362">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240305151646680.png" /></p>
<h1 id="分析">分析</h1>
<h2 id="确定dp含义">确定dp含义</h2>
<p>dp[ i ] [ j
]表示第<strong>i</strong>条街在建了<strong>j</strong>栋房子情况下的方案数量</p>
<h2 id="状态转移方程">状态转移方程</h2>
<p><span class="math inline">\(dp[i][j + q] = \sum_{q = i - 1}^{k}dp[i -
1][q]，其中j从1到m\)</span></p>
<h2 id="最终状态">最终状态</h2>
<p>dp[ n ][ k ]</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 为什么max要设置成下面两种形式，真的就是往大了开吗</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXK</span> <span class="operator">=</span> <span class="number">2605</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN][MAXK];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 下面这个初始化不知道有什么作用</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最外层for循环计算的是从第一条街道到第n条街道</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="comment">// 中间这层for循环计算的是第i条街道上修建的房子从1到n的情况</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">				<span class="comment">// 最里面for循环计算的是前i - 1条街道修建的房屋数量</span></span><br><span class="line">				<span class="comment">// 其中最少每条街道一层房屋，有i-1条街道，所以有i-1条房屋</span></span><br><span class="line">				<span class="comment">// 最多就建到预算花光为止</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i - <span class="number">1</span>; q &lt;= k; q++) &#123;</span><br><span class="line">					dp[i][j + q] += dp[i - <span class="number">1</span>][q];</span><br><span class="line">					dp[i][j + q] %= p;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(dp[n][k]);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题">问题</h1>
<h2 id="maxn-maxk的设置">MAXN, MAXK的设置</h2>
<h2 id="三重for循环顺序的设置">三重for循环顺序的设置</h2>
<h2 id="初始化dp0这一行">初始化dp[0]这一行</h2>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>动态规划</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-安全区</title>
    <url>/posts/d779deea.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="http://oj.ecustacm.cn/problem.php?id=1078">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>在一个n<em>n的网格图上有m个探测器，第i个探测器位于(xi,yi)位置，探测半径为ri。
求出n</em>n个点中有多少个是安全的点，即未被探测的点。</p>
<h2 id="输入格式">输入格式</h2>
<p>第一行为两个整数n,m(1&lt;=n&lt;=100,1&lt;=m&lt;=n*n)
接下来m行每行3个整数表示xi,yi,ri（1&lt;=xi,yi,ri&lt;=n）</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一个整数表示答案</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">3 3 1</span><br><span class="line">4 2 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析：</h1>
<h2
id="每得到一个点就遍历所有二维矩阵判断二维矩阵中对应的点与探测点核心距离是否小于探测距离">每得到一个点，就遍历所有二维矩阵，判断二维矩阵中对应的点与探测点核心距离是否小于探测距离</h2>
<h2
id="利用isvisited数组判断是否访问过防止重复计数">利用isVisited数组判断是否访问过，防止重复计数</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.hypot((x1 - x2), (y1 - y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[][] data = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) data[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">xi</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">yi</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">otherX</span> <span class="operator">=</span> <span class="number">1</span>; otherX &lt;= n; otherX++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">otherY</span> <span class="operator">=</span> <span class="number">1</span>; otherY &lt;= n; otherY++) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">dis</span> <span class="operator">=</span> distance(xi, yi, otherX, otherY);</span><br><span class="line">                    <span class="keyword">if</span>(dis &lt;= (<span class="type">double</span>)ri &amp;&amp; data[otherX][otherY] == <span class="literal">true</span>) &#123;</span><br><span class="line">                        data[otherX][otherY] = <span class="literal">false</span>;</span><br><span class="line">                        totalNum--;</span><br><span class="line">                    &#125;  <span class="comment">//if</span></span><br><span class="line">                &#125;   <span class="comment">//for</span></span><br><span class="line">            &#125;   <span class="comment">//for</span></span><br><span class="line">        &#125;   <span class="comment">//for</span></span><br><span class="line">        System.out.println(totalNum);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-统计方形</title>
    <url>/posts/cc5c249e.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="http://oj.ecustacm.cn/problem.php?id=1079">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>有一个n*m方格的棋盘，求其方格包含多少正方形、长方形（此处长方形不包含正方形）</p>
<h2 id="输入格式">输入格式</h2>
<p>输入存在多组测试数据。每组测试数据输入两个整数n,m，数字不超过5000</p>
<h2 id="输出格式">输出格式</h2>
<p>对于每组数据输出一行包含两个整数，分别表示正方形数目和长方形数目</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 10</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="首先计算对于n-m的矩形一共有多少个子矩形">首先计算对于n *
m的矩形，一共有多少个子矩形</h2>
<p><span class="math inline">\(从选择边的角度，可以选边长从1到n，一共1 +
2 + …… + n = \frac{(n + 1)(n)}{2}\)</span></p>
<h2 id="接着计算对于n-m的矩形一共有多少个子正方形">接着计算对于n *
m的矩形，一共有多少个子正方形</h2>
<h3
id="从选择边的角度可以选的边的长度从1到minn-m">从选择边的角度，可以选的边的长度从1到min(n,
m)</h3>
<h3
id="正方形的边长每增加1母矩形的长可以放下对应边长的正方形的个数就减少1宽同理">正方形的边长每增加1，母矩形的长可以放下对应边长的正方形的个数就减少1，宽同理</h3>
<h2
id="最后用总矩形数量减去总正方形数量就得到总长方形数量">最后用总矩形数量减去总正方形数量就得到总长方形数量</h2>
<h1 id="第一次写错误">第一次写错误</h1>
<h2
id="计算总矩形数量和总正方形数量必须要开long才放得下">计算总矩形数量和总正方形数量必须要开long才放得下</h2>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(input.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">long</span> <span class="variable">nSide</span> <span class="operator">=</span> (n + <span class="number">1</span>) * n / <span class="number">2</span>;    <span class="comment">//n方向可以选出的边数，等差求和</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">mSide</span> <span class="operator">=</span> (m + <span class="number">1</span>) * m / <span class="number">2</span>;    <span class="comment">//m方向可以选出的边数，等差求和</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">totalMatrix</span> <span class="operator">=</span> nSide * mSide;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nSqNum</span> <span class="operator">=</span> n;     <span class="comment">//n方向可以放下正方形的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mSqNum</span> <span class="operator">=</span> m;     <span class="comment">//m方向可以放下正方形的数量</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sqNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">sqLength</span> <span class="operator">=</span> <span class="number">1</span>; sqLength &lt;= Math.min(n, m); sqLength++) &#123;   <span class="comment">//子正方形的边长</span></span><br><span class="line">                sqNum += nSqNum * mSqNum;</span><br><span class="line">                nSqNum--;</span><br><span class="line">                mSqNum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">matrixNum</span> <span class="operator">=</span> totalMatrix - sqNum;</span><br><span class="line">            System.out.format(<span class="string">&quot;%d %d\n&quot;</span>, sqNum, matrixNum);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing95-费解的开关</title>
    <url>/posts/329e4ddf.html</url>
    <content><![CDATA[<p><a
href="https://www.acwing.com/problem/content/description/97/">题目</a></p>
<p>你玩过“拉灯”游戏吗？</p>
<p>2525 盏灯排成一个 5×55×5 的方形。</p>
<p>每一个灯都有一个开关，游戏者可以改变它的状态。</p>
<p>每一步，游戏者可以改变某一个灯的状态。</p>
<p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>
<p>我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。</p>
<p>下面这种状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>在改变了最左上角的灯的状态后将变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>再改变它正中间的灯后状态将变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure>
<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66
步以内使所有的灯都变亮。</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行输入正整数 n�，代表数据中共有 n� 个待解决的游戏初始状态。</p>
<p>以下若干行数据分为 n� 组，每组数据有 55 行，每行 55 个字符。</p>
<p>每组数据描述了一个游戏的初始状态。</p>
<p>各组数据间用一个空行分隔。</p>
<h4 id="输出格式">输出格式</h4>
<p>一共输出 n� 行数据，每行有一个小于等于 66
的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>
<p>对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出
−1−1。</p>
<h4 id="数据范围">数据范围</h4>
<p>0&lt;n≤5000&lt;�≤500</p>
<h4 id="输入样例">输入样例：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">00111</span><br><span class="line">01011</span><br><span class="line">10001</span><br><span class="line">11010</span><br><span class="line">11100</span><br><span class="line"></span><br><span class="line">11101</span><br><span class="line">11101</span><br><span class="line">11110</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line"></span><br><span class="line">01111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>本题关键在于如何枚举</p>
<p>每一行灯的情况由上一行决定，上一行的暗灯由下一行的开关点亮，点亮之后就要改变对应的上下左右其他灯</p>
<p>枚举的是第一行开关闭合与否的情况，与灯的亮暗无关，每一个开关有亮和暗两种情况，5个开关就<span
class="math inline">\(2^5
=32\)</span>种情况，当开关的情况定下来后，第一行的灯的亮暗也就确定了，之后几行的灯的亮暗也跟着确定</p>
<p>举例说明</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c1736fb66ab0f65acd8923abc0e9ff9.jpg"
alt="c1736fb66ab0f65acd8923abc0e9ff9" />
<figcaption
aria-hidden="true">c1736fb66ab0f65acd8923abc0e9ff9</figcaption>
</figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="type">char</span>[][] backUp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>][];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMatrix</span><span class="params">(Scanner scan)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			matrix[i] = scan.nextLine().toCharArray();</span><br><span class="line">			backUp[i] = Arrays.copyOf(matrix[i], matrix[i].length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(matrix[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			matrix[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeMatrix</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 上</span></span><br><span class="line">		<span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x - <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 左</span></span><br><span class="line">		<span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>) flip(x, y - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 右</span></span><br><span class="line">		<span class="keyword">if</span>(y + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x, y + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(x + <span class="number">1</span> &lt;= <span class="number">4</span>) flip(x + <span class="number">1</span>, y);</span><br><span class="line">		<span class="comment">// 自个</span></span><br><span class="line">		flip(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="comment">// 一共要有n次读取</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">// 读取每次的初始灯矩阵并保存备份</span></span><br><span class="line">			readMatrix(scan);</span><br><span class="line"><span class="comment">//			System.out.println(&quot;初始化矩阵为：&quot;);</span></span><br><span class="line"><span class="comment">//			for(int j = 0; j &lt; 5; j++) &#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[j]);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">minChange</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">			<span class="comment">// 遍历 32 种可能性</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将第一行的按法调整成对应的5位二进制</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> String.format(<span class="string">&quot;%5s&quot;</span>, Integer.toBinaryString(j)).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">//				System.out.format(&quot;第一行的开关状态为：%s\n&quot;, tmpString);</span></span><br><span class="line">				<span class="comment">// 第一行的按完后的状态</span></span><br><span class="line"><span class="comment">//				System.out.print(&quot;第一行现在状态：&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[0]);</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(tmpString.charAt(k) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">						changeMatrix(<span class="number">0</span>, k);</span><br><span class="line"><span class="comment">//						System.out.format(&quot;按下开关%d, 第一行现在状态 &quot;, k + 1);</span></span><br><span class="line"><span class="comment">//						System.out.println(matrix[0]);</span></span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//				System.out.println(&quot;开关按完后第一行现在的状态：&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(matrix[0]);</span></span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt; <span class="number">5</span>; b++) &#123;</span><br><span class="line">						<span class="comment">// 通过这一行确定下一行的开关，再根据这个开关看灯的亮暗</span></span><br><span class="line">						<span class="keyword">if</span>(matrix[a][b] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">							changeMatrix(a + <span class="number">1</span>, b);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="comment">//					System.out.format(&quot;经过第%d行后的状态\n&quot;, a+1);</span></span><br><span class="line"><span class="comment">//					for(int c = 0; c &lt; 5; c++) &#123;</span></span><br><span class="line"><span class="comment">//						System.out.println(matrix[c]);</span></span><br><span class="line"><span class="comment">//					&#125;</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 遍历第5行，看是不是都是1</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(matrix[<span class="number">4</span>][k] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						flag = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">					minChange = Math.min(count, minChange);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 将备份矩阵拷贝回原矩阵</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; <span class="number">5</span>; a++) &#123;</span><br><span class="line">					matrix[a] = Arrays.copyOf(backUp[a], backUp[a].length);</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//				System.out.println(&quot;backUp数组是：&quot;);</span></span><br><span class="line"><span class="comment">//				for(int a = 0; a &lt; 5; a++) &#123;</span></span><br><span class="line"><span class="comment">//					System.out.println(backUp[a]);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(minChange &lt;= <span class="number">6</span>) System.out.println(minChange);</span><br><span class="line">			<span class="keyword">else</span> System.out.println(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<p><a href="">深拷贝与浅拷贝</a>，一个大坑，当时折腾了半天</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>中等题</category>
      </categories>
  </entry>
  <entry>
    <title>Java中集合框架的运用</title>
    <url>/posts/22145084.html</url>
    <content><![CDATA[<h1 id="arraylist">ArrayList</h1>
<p>##<a
href="https://www.lanqiao.cn/problems/539/learning/">题目一</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116085923605.png" /></p>
<h3 id="创建">创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3
id="判断一个元素在arraylist中是否存在">判断一个元素在ArrayList中是否存在</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.contains(element)</span><br></pre></td></tr></table></figure>
<h3 id="对一个arraylist排序">对一个ArrayList排序</h3>
<h4
id="collections的默认从小到大排序">Collections的默认从小到大排序</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections</span><br><span class="line">Collections.sort(list)</span><br></pre></td></tr></table></figure>
<h4 id="collections的自定义比较器">Collections的自定义比较器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按降序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历排序后的列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>枚举-油漆房子</title>
    <url>/posts/ea1ffadb.html</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240113101111678.png"
alt="image-20240113101111678" />
<figcaption aria-hidden="true">image-20240113101111678</figcaption>
</figure>
<h1 id="分析">分析</h1>
<h2 id="核心思想是枚举">核心思想是枚举</h2>
<h2 id="首先利用set记录每一种颜色">首先利用set记录每一种颜色</h2>
<h2
id="然后依次从set取出一种颜色作为targetcolor">然后依次从set取出一种颜色作为targetColor</h2>
<h3
id="遍历房子如果当前房子的颜色和targetcolor不相同就以当前房子为起点往后长度为k的区间都涂成targetcolor并且需要的天数递增1">遍历房子，如果当前房子的颜色和targetColor不相同，就以当前房子为起点，往后长度为k的区间都涂成targetColor，并且需要的天数递增1</h3>
<h3
id="否则就一直向下遍历直到所有房子遍历完">否则就一直向下遍历直到所有房子遍历完</h3>
<h2 id="java中hashset使用">java中HashSet使用</h2>
<h3 id="创建">创建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//HashSet&lt;对象名&gt; 集合名 = new HashSet&lt;Integer&gt;();</span></span><br></pre></td></tr></table></figure>
<h3 id="放入数据">放入数据</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set.add(data);</span><br></pre></td></tr></table></figure>
<h3
id="遍历只能用增强型for循环和迭代器">遍历：只能用增强型for循环和迭代器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;Integer&gt; iterator = set.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="type">int</span>[] house = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">//存储所有房子的颜色并记录颜色的种类</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">                house[j] = data;</span><br><span class="line">                set.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minCount</span> <span class="operator">=</span> n;</span><br><span class="line">            <span class="comment">//从集合中选取一种颜色</span></span><br><span class="line">            <span class="keyword">for</span>(Iterator&lt;Integer&gt; iterator = set.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">nowColor</span> <span class="operator">=</span> (Integer)iterator.next();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//遍历房子颜色与当前选取的颜色比较</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; n;) &#123;</span><br><span class="line">                    <span class="comment">//如果当前房子颜色与当前选取的颜色不同</span></span><br><span class="line">                    <span class="keyword">if</span>(house[x] != nowColor) &#123;</span><br><span class="line">                        x = x + k;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        x++;</span><br><span class="line">                    &#125;   <span class="comment">//if</span></span><br><span class="line">                &#125;   <span class="comment">//for</span></span><br><span class="line">                <span class="keyword">if</span>(count &lt; minCount) minCount = count;  <span class="comment">//if</span></span><br><span class="line">            &#125;   <span class="comment">//for</span></span><br><span class="line">            System.out.println(minCount);</span><br><span class="line">        &#125;   <span class="comment">//for</span></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>枚举</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>2023javaA组填空题一</title>
    <url>/posts/4528259b.html</url>
    <content><![CDATA[<h1 id="填空题真题欧拉函数与快速幂"><a
href="http://oj.ecustacm.cn/problem.php?id=2093">2023填空题真题欧拉函数与快速幂</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>给定a, b，求<span class="math inline">\(1 ≤ x ＜ a^b\)</span>
中有多少个 x 与<span class="math inline">\(a^b\)</span> 互质。
由于答案可能很大，你只需要输出答案对 998244353 取模的结果。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入一行包含两个整数分别表示 a, b，用一个空格分隔。 对于 30%
的评测用例，ab ≤ 106； 对于 70% 的评测用例，a ≤ 106，b ≤ 109； 对于 100%
的评测用例，1 ≤ a ≤ 109，1 ≤ b ≤ 1018 。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行包含一个整数表示答案。</p>
<h2 id="输入样例">输入样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样例1：</span><br><span class="line">2 5</span><br><span class="line"></span><br><span class="line">样例2：</span><br><span class="line">12 7</span><br></pre></td></tr></table></figure>
<h2 id="输出样例">输出样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">样例1：</span><br><span class="line">16</span><br><span class="line"></span><br><span class="line">样例2：</span><br><span class="line">11943936</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="欧拉函数">欧拉函数</h2>
<h2 id="快速幂">快速幂</h2>
<p>所以要解决上面问题，首先要用快速幂求出临界值，然后用欧拉函数求出所有的质因数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BigInteger</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;998244353&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextBigInteger();</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextBigInteger();</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ab</span> <span class="operator">=</span> quickPower(a, b.subtract(BigInteger.ONE));</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> eulr(a).multiply(ab).mod(MOD);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BigInteger <span class="title function_">quickPower</span><span class="params">(BigInteger base, BigInteger power)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (power.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (power.and(BigInteger.ONE).compareTo(BigInteger.ZERO) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans.multiply(base).mod(MOD);	<span class="comment">//这里提前取余是关键，否则会超时</span></span><br><span class="line">            &#125;</span><br><span class="line">            base = base.multiply(base).mod(MOD);	<span class="comment">//</span></span><br><span class="line">            power = power.shiftRight(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> BigInteger <span class="title function_">eulr</span><span class="params">(BigInteger n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2&quot;</span>); i.multiply(i).compareTo(n) &lt;= <span class="number">0</span>; i = i.add(BigInteger.ONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.mod(i).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                ans = ans.subtract(ans.divide(i));</span><br><span class="line">                <span class="keyword">while</span>(n.mod(i).equals(BigInteger.ZERO)) &#123;</span><br><span class="line">                    n = n.divide(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n.compareTo(BigInteger.ONE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans.subtract(ans.divide(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a.compareTo(b):</p>
<p>如果a &gt; b， 返回1</p>
<p>如果a &lt; b, 返回-1</p>
<p>如果a = b, 返回0</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>填空题</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing875快速幂</title>
    <url>/posts/6bcd24b7.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/91">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122100217638.png" /></p>
<h1 id="分析">分析</h1>
<p>快速幂，虽然java开BigInteger可以防止爆栈，但是会超时</p>
<p>引理</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240122100259455.png" /></p>
<p>因为有上面的引理，所以在每次求快速幂的过程中都可以取余</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		System.out.println(quickPower(a, b, p));</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> BigInteger <span class="title function_">quickPower</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">baseBigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(base));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">powerInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(power));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">pBigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(p));</span><br><span class="line">		<span class="type">BigInteger</span> <span class="variable">ansBigInteger</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">		<span class="keyword">while</span>(powerInteger.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(powerInteger.and(BigInteger.ONE).compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				ansBigInteger = ansBigInteger.multiply(baseBigInteger).mod(pBigInteger);	<span class="comment">//取余1</span></span><br><span class="line">			&#125; </span><br><span class="line">			baseBigInteger = baseBigInteger.multiply(baseBigInteger).mod(pBigInteger);	<span class="comment">//取余2</span></span><br><span class="line">			powerInteger = powerInteger.shiftRight(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ansBigInteger.mod(pBigInteger);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/posts/20c47d09.html</url>
    <content><![CDATA[<h1 id="定义">定义：</h1>
<p><strong>核心思想：利用二进制来加速运算</strong></p>
<p>举例说明</p>
<p>计算 <span class="math inline">\(3^{45}\)</span></p>
<p>首先把指数45转换为二进制：45(10)=101101(2)</p>
<p>接下来我们可以得到下面的等式</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114436346.png" /></p>
<p>因为</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114454727.png" /></p>
<p>所以我们只需要计算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240121114512200.png" /></p>
<h2 id="代码模板">代码模板</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger <span class="title function_">quick_power</span><span class="params">(BigInteger base, BigInteger power)</span> &#123;	<span class="comment">//base表示底数，power表示指数</span></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">    <span class="keyword">while</span>(power.compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(power.and(BigInteger.ONE).compareTo(BigInteger.ZERO) &lt; <span class="number">0</span>) &#123;	</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	底数与1同或来判断底数的二进制的最后一位是1还是0, </span></span><br><span class="line"><span class="comment">            	任意一个十进制数，如果是偶数，二进制末尾表示是0;如果是奇数，二进制末尾表示1</span></span><br><span class="line"><span class="comment">            	所以与1同或，如果结果是1，说明原来数的末尾是1，原来的数是奇数; 如果结果是0，说明原来末尾是0，原来的数是偶数			*/</span></span><br><span class="line">            ans = ans.multiply(base);	<span class="comment">//如果最后一位是1，那么就要把当前结果累乘到ans中</span></span><br><span class="line">        &#125;</span><br><span class="line">        base = base.multiply(base);		<span class="comment">//由幂的递归可知下一位的base是当前的平方</span></span><br><span class="line">        power = power.shiftRight(<span class="number">1</span>);	<span class="comment">//将指数右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://blog.csdn.net/m0_52072919/article/details/116400820">参考文章</a></p>
<h2 id="举一反三">举一反三</h2>
<h3 id="题目一"><a
href="https://pilotztb.github.io/2024/01/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-Acwing875%E5%BF%AB%E9%80%9F%E5%B9%82/">题目一</a></h3>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>洛谷2008SODI仪仗队</title>
    <url>/posts/ccb37efa.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.luogu.com.cn/problem/P2158">题目</a></h1>
<h2 id="题目描述">题目描述</h2>
<p>作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的
<span class="math inline">\(N \times N\)</span>
的方阵，为了保证队伍在行进中整齐划一，C
君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1149.png" /></p>
<p>现在，C 君希望你告诉他队伍整齐时能看到的学生人数。</p>
<h2 id="输入格式">输入格式</h2>
<p>一行，一个正整数 <span class="math inline">\(N\)</span>。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出一行一个数，即 C 君应看到的学生人数。</p>
<h2 id="样例输入">样例输入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="样例输出">样例输出</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="提示">提示</h2>
<p>对于 <span class="math inline">\(100 \%\)</span> 的数据，<span
class="math inline">\(1 \le N \le 40000\)</span>。</p>
<h1 id="分析">分析</h1>
<p>要求的就是从原点看，能看到几个点（原点不考虑，就是如果n =
1，那么就只有1个人，就是观察者本身，那么他看不到其他人）</p>
<p>举个例子，如果n=4</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0b7367d6f906eb4d59b68faf776abcb.jpg" /></p>
<p>可以看出是9个</p>
<p>那么怎么推出一般情况呢</p>
<p>首先发现点关于y = x
对称，所以只用研究一半就行，又因为（1，1）这个点比较特殊，所以将(0,
1)(1, 0)(1, 1)这三个点另外看，从i = 2开始分析</p>
<p>发现从i = 2到 i = n - 1,
要能看到，说明没有遮挡，即x与y互质，所以就是求<span
class="math inline">\(\sum_{i = 2}^{n - 1}\sum_{j = 0}^{j = i}[gcd(i, j)
= 1]\)</span>（求和公式从左往右看），而<span
class="math inline">\(\sum_{j = 0}^{j = i}[gcd(i, j) =
1]\)</span>就是<span
class="math inline">\(\varphi(i)\)</span>，所以最终计算结果就是$ 3 + 2
*_{i = 2}^{n - 1}(i)$</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		<span class="type">int</span> <span class="variable">ansSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">			ansSum += <span class="number">2</span> * eulr(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ansSum += <span class="number">3</span>;</span><br><span class="line">			System.out.println(ansSum);</span><br><span class="line">			scan.close();			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">eulr</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">				ans -= ans / i;</span><br><span class="line">				<span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">					n /= i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			ans -= ans / n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.acwing.com/problem/content/description/203/">类似(或者说一模一样的题目)</a></p>
<p>区别在于两题对于n的定义，上一题n包含观察者本身，这一题则不包含；比如n=1的时候，上一题结果为0，本题则是3</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥oj610-分数</title>
    <url>/posts/7df5f4eb.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/610/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240311101618051.png" /></p>
<h1 id="分析">分析</h1>
<p>首先是等比数列</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/39282fc6987ee321a5936c2ed59552d.jpg" /></p>
<p>然后一个数论知识</p>
<p>较大的数如果比较小的数的两倍大1或者小1，则两者互质。</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.print((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">20</span>) - <span class="number">1</span>);</span><br><span class="line">		System.out.print(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">		System.out.print((<span class="type">int</span>)Math.pow(<span class="number">2</span>, <span class="number">19</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/posts/f60286b9.html</url>
    <content><![CDATA[<h1 id="基本定义">基本定义</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5fbf00fa9b8608561a46bd64ded90d4.png" /></p>
<p>不过一般写程序不用上面的求法，而是用下面的思路与代码</p>
<p>找出n的因子，剔除含有n的因子的数</p>
<h2 id="代码模板">代码模板</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求欧拉函数Φ(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">eulr</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n;	<span class="comment">//假设最初的结果就是有n个数，下面要一个一个从这n个数删</span></span><br><span class="line">    <span class="comment">// ans表示的是n的素因子个数</span></span><br><span class="line">    <span class="comment">// n表示的是素因子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;	<span class="comment">//循环结束条件是i * i &lt;= 2，只用检查小于平方根的就行，否则就重复</span></span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;	<span class="comment">//如果这个数是n的因数，就要从ans中删除掉所有i的小于n的倍数</span></span><br><span class="line">            ans -= ans / i;	<span class="comment">// ans / i表示比n小的i的最大倍数，这个倍数从1到ans/i一共有ans/i个，从ans中减去这么多</span></span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;		<span class="comment">//从ans中删除i的倍数后，也要</span></span><br><span class="line">                n  = n / i;		<span class="comment">//这一个语句是为了保证完全消除我们刚才得到的那个i因子。防止重复减</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;	<span class="comment">//若n大于1，则此时的n也是一个除1以外的因子</span></span><br><span class="line">        ans -= ans / n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;		<span class="comment">//从ans中删除i的倍数后，也要</span></span><br><span class="line">    n  = n / i;		<span class="comment">//这一个语句是为了保证完全消除我们刚才得到的那个i因子。防止重复减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;	<span class="comment">//若n大于1，则此时的n也是一个除1以外的因子</span></span><br><span class="line">       ans -= ans / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8e058d7f5186fac3503e8cb9e1d501d.jpg" /></p>
<h2 id="举一反三">举一反三</h2>
<h3 id="题目一"><a
href="https://lx.lanqiao.cn/problem.page?gpid=T752###">题目一</a></h3>
<h3 id="题目二"><a
href="https://www.luogu.com.cn/problem/P2158">题目二</a></h3>
<p><a
href="https://pilotztb.github.io/2024/01/22/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%B4%9B%E8%B0%B72008SODI%E4%BB%AA%E4%BB%97%E9%98%9F/">题解</a></p>
<h3 id="题目三"><a
href="https://www.acwing.com/problem/content/description/203/">题目三</a></h3>
<p>与上题几乎一样</p>
<h1 id="线性筛法">线性筛法</h1>
<h1 id="参考文章">参考文章</h1>
<p><a
href="https://blog.csdn.net/ydd97/article/details/47805419">参考文章一</a></p>
<p><a
href="https://blog.51cto.com/u_16213636/7620153">参考文章二</a></p>
<p><a
href="https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=SfPFLdFUU2r7JgOwYzjW1MfNZpAvGKgn1QC5rW4ugBC74c2OKvH08wleW3s8HvAl&amp;search_content=%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">更多题库一</a></p>
<p><a
href="https://www.cnblogs.com/windymoon/p/17053198.html">更多题库二</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>数论</category>
        <category>简单题</category>
      </categories>
      <tags>
        <tag>数论小结</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟-四舍五入打印</title>
    <url>/posts/9afd3e68.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/497/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115064739206.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">80</span><br><span class="line">92</span><br><span class="line">56</span><br><span class="line">74</span><br><span class="line">88</span><br><span class="line">99</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99</span><br><span class="line">10</span><br><span class="line">71.29</span><br></pre></td></tr></table></figure>
<h1
id="分析主要就是java中如何四舍五入打印浮点数">分析：主要就是java中如何四舍五入打印浮点数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123.121323232</span>;</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>)	<span class="comment">//四舍五入打印两位小数，并且要保留最后的0，比如0.80要按0.80打印，不能按0.8打印</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>另外一个隐藏的易错点就是java中两个int型计算还是int，要得到java必须把其中之一强转成double或乘个1.0也成double型</p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">highestScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowestScore</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalScore</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">            totalScore += score;</span><br><span class="line">            <span class="keyword">if</span>(score &lt; lowestScore) lowestScore = score;</span><br><span class="line">            <span class="keyword">if</span>(score &gt; highestScore) highestScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(highestScore);</span><br><span class="line">        System.out.println(lowestScore);</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.00&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">averageScore</span> <span class="operator">=</span> (<span class="type">double</span>)totalScore / n; </span><br><span class="line">        <span class="type">String</span> <span class="variable">rounded_num</span> <span class="operator">=</span> df.format(averageScore);</span><br><span class="line">        System.out.println(rounded_num);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>模拟-字符串操作</title>
    <url>/posts/5fa32b49.html</url>
    <content><![CDATA[<h1 id="题目一-字符串中大小写转换"><a
href="https://www.lanqiao.cn/problems/1590/learning/">题目一</a>
字符串中大小写转换</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115100356557.png" /></p>
<p>toUpperCase方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">str = str.toUpperCase(); </span><br></pre></td></tr></table></figure>
<h1 id="题目二字符串转字符数组">题目二：字符串转字符数组</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115100623353.png" /></p>
<p>toCharArray</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray()) &#123; <span class="comment">// 修改这里</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 修改这里</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="题目三字符串和数字之前的转换">题目三：字符串和数字之前的转换</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115102119742.png" /></p>
<h2
id="字符串转数字数字的类类型.parse数字的类类型字符串">字符串转数字：数字的类类型.parse数字的类类型(字符串)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str);</span><br></pre></td></tr></table></figure>
<h2
id="数字转字符串string.valueof数字">数字转字符串：String.valueOf(数字)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br></pre></td></tr></table></figure>
<h2
id="判断一个字符在不在字符串中字符串.indexof字符如果不在返回-1">判断一个字符在不在字符串中：字符串.indexOf(字符)，如果不在返回-1</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.indexOf(<span class="string">&#x27;9&#x27;</span>) </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">2019</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            <span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;2&#x27;</span>) != -<span class="number">1</span>|| </span><br><span class="line">               str.indexOf(<span class="string">&#x27;0&#x27;</span>) != -<span class="number">1</span>|| </span><br><span class="line">               str.indexOf(<span class="string">&#x27;1&#x27;</span>) != -<span class="number">1</span>||</span><br><span class="line">               str.indexOf(<span class="string">&#x27;9&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">            	sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目四-串的处理"><a
href="https://www.lanqiao.cn/problems/287/learning/">题目四</a>
串的处理</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240118103848703.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">you and me what cpp2005program</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You And Me What Cpp_2005_program</span><br></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3
id="将一个字符串分割成多个子字符串构成字符串数组">将一个字符串分割成多个子字符串构成字符串数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strLiStrings = str.split(<span class="string">&quot;\\s+&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>不同单词，其中不同单词之间的空格不止一个</p>
<h3 id="访问字符串指定位置字符">访问字符串指定位置字符</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subString.charAt(i)</span><br></pre></td></tr></table></figure>
<h2 id="可变字符串">可变字符串</h2>
<h3 id="声明">声明</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure>
<h3 id="在后面加入">在后面加入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.append()</span><br></pre></td></tr></table></figure>
<h3 id="在指定位置插入">在指定位置插入</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.insert(i, <span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除指定位置字符串">删除指定位置字符串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringBuffer.delete(<span class="number">0</span>, <span class="number">2</span>);  #左闭右开</span><br></pre></td></tr></table></figure>
<h2 id="字符">字符</h2>
<h3 id="大小写转换">大小写转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(subString.charAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="判断字符是否是数字">判断字符是否是数字</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.isDigit(subString.charAt(i))</span><br></pre></td></tr></table></figure>
<h3 id="判断字符是否是字母">判断字符是否是字母</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.isAlphabetic(subString.charAt(i))</span><br></pre></td></tr></table></figure>
<p>代码一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">        String[] strLiStrings = str.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String subString : strLiStrings) &#123;</span><br><span class="line">        	<span class="comment">//声明一个可变字符串</span></span><br><span class="line">        	<span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        	<span class="comment">//首字母大写</span></span><br><span class="line">        	stringBuffer.append(Character.toUpperCase(subString.charAt(<span class="number">0</span>)));</span><br><span class="line">        	<span class="comment">//消除多余的空格</span></span><br><span class="line">        	<span class="type">char</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="type">char</span> <span class="variable">now</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; subString.length(); i++) &#123;</span><br><span class="line">        		now = subString.charAt(i);</span><br><span class="line">        		<span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span>(pre == <span class="string">&#x27; &#x27;</span> &amp;&amp; now == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        				<span class="keyword">continue</span>;</span><br><span class="line">        			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        				stringBuffer.append(now);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;	<span class="comment">//if</span></span><br><span class="line">        		pre = now;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">//数字和字符之间加入_</span></span><br><span class="line">        	pre = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	now = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuffer.length(); i++) &#123;</span><br><span class="line">        		now = stringBuffer.charAt(i);</span><br><span class="line">        		<span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        			<span class="keyword">if</span>(Character.isDigit(pre) &amp;&amp; Character.isAlphabetic(now) || Character.isAlphabetic(pre) &amp;&amp; Character.isDigit(now)) &#123;</span><br><span class="line">        				stringBuffer.insert(i, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        			&#125; <span class="comment">//if</span></span><br><span class="line">        		&#125;	<span class="comment">//if</span></span><br><span class="line">        		pre = now;</span><br><span class="line">        	&#125;	<span class="comment">//for</span></span><br><span class="line">        	System.out.print(stringBuffer);</span><br><span class="line">        	System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码二：正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        String str[] = s.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            str[i] = str[i].substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + str[i].substring(<span class="number">1</span>);</span><br><span class="line">            str[i] = str[i].replaceAll(<span class="string">&quot;(\\d)([a-zA-Z])&quot;</span>, <span class="string">&quot;$1_$2&quot;</span>);</span><br><span class="line">            str[i] = str[i].replaceAll(<span class="string">&quot;([a-zA-Z])(\\d)&quot;</span>, <span class="string">&quot;$1_$2&quot;</span>);</span><br><span class="line">            System.out.print(str[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目五进制转换"><a
href="https://www.lanqiao.cn/problems/3499/learning/">题目五</a>：进制转换</h1>
<p>题目</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240118114633245.png" /></p>
<h2
id="将十进制数字转换成二进制字符串">将十进制数字转换成二进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(test)</span><br></pre></td></tr></table></figure>
<h2
id="将十进制数字转换成八进制字符串">将十进制数字转换成八进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(test)</span><br></pre></td></tr></table></figure>
<h2
id="将十进制数字转换成十六进制字符串">将十进制数字转换成十六进制字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(test)</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">test</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">126</span>;</span><br><span class="line">		<span class="keyword">while</span>(count &lt;= <span class="number">2022</span>) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//先判断十进制</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">demicalString</span> <span class="operator">=</span> String.valueOf(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; demicalString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(demicalString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断二进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; binaryString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(binaryString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断八进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; octalString.length(); i++) &#123;</span><br><span class="line">				sum += Character.getNumericValue(octalString.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum != <span class="number">0</span>) &#123;</span><br><span class="line">				test++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//判断十六进制</span></span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(test);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hexString.length(); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(Character.isDigit(hexString.charAt(i))) &#123;</span><br><span class="line">					sum += Character.getNumericValue(hexString.charAt(i));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					sum += hexString.charAt(i) - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(test % sum == <span class="number">0</span>) &#123;</span><br><span class="line">				ans = test;</span><br><span class="line">				count++; </span><br><span class="line"><span class="comment">//				System.out.format(&quot;%d %d\n&quot;, ans, count);				</span></span><br><span class="line">			&#125;</span><br><span class="line">			test++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目六-字符串的拼接"><a
href="https://www.lanqiao.cn/problems/523/learning/">题目六</a>
字符串的拼接</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240119064340539.png" /></p>
<p>输入1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure>
<p>输出1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Right</span><br></pre></td></tr></table></figure>
<p>输入2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-0</span><br></pre></td></tr></table></figure>
<p>输出2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-670-82162-4 </span><br></pre></td></tr></table></figure>
<h2 id="判断两个字符串内容是否相等">判断两个字符串内容是否相等</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1.equals(str2)</span><br></pre></td></tr></table></figure>
<h2
id="将字符串数组用指定字符拼接成一个字符串">将字符串数组用指定字符拼接成一个字符串</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot;-&quot;</span>, strList);</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scan.nextLine(); </span><br><span class="line">        String[] strList = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">yanzhen</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        	yanzhen += strList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.format(&quot;yanzhen = %s\n&quot;, yanzhen);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanzhen.length(); i++) &#123;</span><br><span class="line">        	<span class="type">int</span> <span class="variable">nowNum</span> <span class="operator">=</span> yanzhen.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        	<span class="comment">//System.out.format(&quot;nowNum = %d, i + 1 = %d\n&quot;, nowNum, i + 1);</span></span><br><span class="line">        	sum += nowNum * (i + <span class="number">1</span>);</span><br><span class="line">        	<span class="comment">//System.out.format(&quot;sum = %d\n&quot;, sum);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">11</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        	last = String.valueOf(sum % <span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	last = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        &#125;	<span class="comment">//if</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;last = %s\n&quot;, last);</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;strList[strList.length - 1] = %s\n&quot;, strList[strList.length - 1]);</span></span><br><span class="line">        <span class="keyword">if</span>(strList[strList.length - <span class="number">1</span>].equals(last)) &#123;</span><br><span class="line">        	System.out.print(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	strList[strList.length - <span class="number">1</span>] = last;</span><br><span class="line">        	System.out.println(String.join(<span class="string">&quot;-&quot;</span>, strList));</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟-扫雷</title>
    <url>/posts/4e35f674.html</url>
    <content><![CDATA[<h1 id="题目">题目</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240115083638375.png" /></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">0 1 0 0</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 0</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 9 2 1</span><br><span class="line">9 4 9 2</span><br><span class="line">1 3 9 2</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2 id="按上一行同一行下一行分类">按上一行，同一行，下一行分类</h2>
<h2
id="每一行要判断前一列和后一列是否存在">每一行要判断前一列和后一列是否存在</h2>
<h1 id="代码">代码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">// 1:无需package</span><br><span class="line">// 2: 类名必须Main, 不可修改</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        //在此输入您的代码...</span><br><span class="line">        int n = scan.nextInt();</span><br><span class="line">        int m = scan.nextInt();</span><br><span class="line">        int[][] data = new int[n][m];</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                data[i][j] = scan.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] assistance = new int[n][m];</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                if(data[i][j] == 1) &#123;</span><br><span class="line">                    assistance[i][j] = 9;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果上一行存在</span><br><span class="line">                if(i - 1 &gt;= 0) &#123;</span><br><span class="line">                	//正上方如果有雷</span><br><span class="line">                    if(data[i - 1][j] == 1) &#123;</span><br><span class="line">                        assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //如果左上方存在且有雷</span><br><span class="line">                    if(j - 1 &gt;= 0 &amp;&amp; data[i - 1][j - 1] == 1) &#123;</span><br><span class="line">                    	assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //右上方存在且有雷</span><br><span class="line">                    if(j + 1 &lt; m &amp;&amp; data[i - 1][j + 1] == 1) &#123;</span><br><span class="line">                    	assistance[i][j]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                //对于同一行前一列存在且有雷</span><br><span class="line">                if(j - 1 &gt;= 0 &amp;&amp; data[i][j - 1] == 1) &#123;</span><br><span class="line">                	assistance[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                //对于同一行后一列存在</span><br><span class="line">                if(j + 1 &lt; m &amp;&amp; data[i][j + 1] == 1) &#123;</span><br><span class="line">                	assistance[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">                //下一行存在</span><br><span class="line">                if(i + 1 &lt; n) &#123;</span><br><span class="line">                	//正下方有雷</span><br><span class="line">                	if(data[i + 1][j] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                	//左下方存在且有雷</span><br><span class="line">                	if(j - 1 &gt;= 0 &amp;&amp; data[i + 1][j - 1] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                	//右下方存在且有雷</span><br><span class="line">                	if(j + 1 &lt; m &amp;&amp; data[i + 1][j + 1] == 1) &#123;</span><br><span class="line">                		assistance[i][j]++;</span><br><span class="line">                	&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                System.out.print(assistance[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>基础题</category>
      </categories>
  </entry>
  <entry>
    <title>模拟 - 天干地支</title>
    <url>/posts/27c6c117.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/1029/learning/">题目</a></h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20240116080127420.png" /></p>
<span id="more"></span>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gengzi</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<h2
id="思路一从已知的庚子年1900年出发">思路一：从已知的庚子年1900年出发</h2>
<h3
id="首先分成在1900年前的年份和在1900年后的年份计算l和1900的距离left">首先分成在1900年前的年份和在1900年后的年份，计算l和1900的”距离“left</h3>
<h3 id="对于在1900年前的年份">对于在1900年前的年份</h3>
<h4
id="天干就是在差值模10后加在庚的基础上再模10">天干就是在差值模10后加在庚的基础上再模10</h4>
<h4
id="地支就是在差值模12后加在子的基础上再模12">地支就是在差值模12后加在子的基础上再模12</h4>
<h3 id="对于在1900年前的年份-1">对于在1900年前的年份</h3>
<h4
id="天干就是在差值模10后先将庚加10再减前面的计算后再模10和循环队列的计算方式异曲同工之妙">天干就是在差值模10后，先将庚加10，再减前面的计算后，再模10(和循环队列的计算方式异曲同工之妙)</h4>
<h4
id="地址就是在差值模12后先将子加12再减前面的计算后再模12">地址就是在差值模12后，先将子加12，再减前面的计算后，再模12</h4>
<h3 id="代码一">代码一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] tiangan = &#123;<span class="string">&quot;jia&quot;</span>, <span class="string">&quot;yi&quot;</span>, <span class="string">&quot;bing&quot;</span>, <span class="string">&quot;ding&quot;</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;ji&quot;</span>, <span class="string">&quot;geng&quot;</span>, <span class="string">&quot;xin&quot;</span>, <span class="string">&quot;ren&quot;</span>, <span class="string">&quot;gui&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] dizhi = &#123;<span class="string">&quot;zi&quot;</span>, <span class="string">&quot;chou&quot;</span>, <span class="string">&quot;yin&quot;</span>, <span class="string">&quot;mao&quot;</span>, <span class="string">&quot;chen&quot;</span>, <span class="string">&quot;si&quot;</span>, <span class="string">&quot;wu&quot;</span>, <span class="string">&quot;wei&quot;</span>, <span class="string">&quot;shen&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;xu&quot;</span>, <span class="string">&quot;hai&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tianganIndex;</span><br><span class="line">        <span class="type">int</span> dizhiIndex;</span><br><span class="line">        <span class="keyword">if</span>(year &gt;= <span class="number">1900</span>) &#123;</span><br><span class="line">        	left = year - <span class="number">1900</span>;</span><br><span class="line">            tianganIndex = (left % <span class="number">10</span> + <span class="number">6</span>) % <span class="number">10</span>;</span><br><span class="line">            dizhiIndex = left % <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	left = <span class="number">1900</span> - year;</span><br><span class="line">        	tianganIndex = (<span class="number">6</span> - (left % <span class="number">10</span>) + <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">        	dizhiIndex = (<span class="number">0</span> + <span class="number">12</span> - (left % <span class="number">12</span>)) % <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tianganString</span> <span class="operator">=</span> tiangan[tianganIndex];</span><br><span class="line">        <span class="type">String</span> <span class="variable">dizhiString</span> <span class="operator">=</span> dizhi[dizhiIndex];</span><br><span class="line">        <span class="type">String</span> <span class="variable">nongliString</span> <span class="operator">=</span> tianganString + dizhiString;</span><br><span class="line">        System.out.println(nongliString);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路二">思路二</h2>
<h3
id="关键在找到时间原点既然始终是60一循环那么可以将1200年经过计算是庚申年作为时间原点">关键在找到“时间原点”，既然始终是60一循环，那么可以将1200年（经过计算是庚申年）作为时间原点</h3>
<p>原因是1200年是60的倍数，相当于0</p>
<h3
id="将天干数组从庚开始重新排列地支数组从申开始重新排列">将天干数组从庚开始重新排列，地支数组从申开始重新排列</h3>
<h3
id="直接计算一个年份模10的结果到天干数组里查到对应的下标即可地支同理">直接计算一个年份模10的结果到天干数组里查到对应的下标即可，地支同理</h3>
<h3 id="代码二">代码二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">//最简单的还是给这些天干地支重新排序，然后对年取余输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> year=scanner.nextInt();</span><br><span class="line">        String s1[]=&#123;<span class="string">&quot;geng&quot;</span>,<span class="string">&quot;xin&quot;</span>,<span class="string">&quot;ren&quot;</span>,<span class="string">&quot;gui&quot;</span>,<span class="string">&quot;jia&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;bing&quot;</span>,<span class="string">&quot;ding&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;ji&quot;</span>&#125;;</span><br><span class="line">        String s2[]=&#123;<span class="string">&quot;shen&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;xu&quot;</span>,<span class="string">&quot;hai&quot;</span>,<span class="string">&quot;zi&quot;</span>,<span class="string">&quot;chou&quot;</span>,<span class="string">&quot;yin&quot;</span>,<span class="string">&quot;mao&quot;</span>,<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;si&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;wei&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> tiangan=year % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> dizhi=year % <span class="number">12</span>;</span><br><span class="line">        System.out.println(s1[tiangan]+s2[dizhi]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>三分法</title>
    <url>/posts/7481085d.html</url>
    <content><![CDATA[<h1 id="求一元单峰函数的极值">求一元单峰函数的极值</h1>
<p>二分法使用的场景是单调函数，也就是一次函数。</p>
<p>三分法会将区间分成三份，这个我们都已经知道了。分成三份，自然需要两个端点。这两个端点各有一个值，我们分别叫做m1和m2。我们要求的是函数的最小值，所以我们要想极值逼近。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-6628b0cf182ec681577b9fb23799bc35_720w.webp" /></p>
<p>每次通过比较两个值的大小，缩小三分之一的区间。直到最后区间的范围小于我们设定的阈值为止</p>
<p><strong>三分法</strong>是二分法的变种，他最基本的用途是求<strong>单峰函数</strong>的<strong>极值点</strong>。</p>
<p>以求极大值为例，每次对一个区间<code>[l,r]</code>求三等分点<code>lsec</code>和<code>rsec</code>：</p>
<p>如果<code>f(lsec) &lt; f(rsec)</code>
，说明极大值一定在<code>[lsec,r]</code>内取到，因为如果在<code>[0,lsec)</code>内，那<code>rsec</code>一定处于单调下降的区间内，它的函数值不可能大于<code>lsec</code>的函数值。
于是我们令<code>l=lsec</code>并继续。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-9232f79a4646b65ff2c2715538a28b3f_720w.webp" /></p>
<p>如果<code>f(lsec) &gt; f(rsec)</code>，同理，极大值一定在<code>[l,rsec]</code>内取到，令<code>r=rsec</code>并继续。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-dce8a5a80fd17ba9e4e000baf5c31146_720w.webp" /></p>
<p>这样进行下去，直到<code>l</code>和<code>r</code>的差距小于设定的<code>eps</code>为止。如果求的是极小值而非极大值，只需把上面条件判断处的大于、小于互换。</p>
<h1 id="求二元函数的极致">求二元函数的极致</h1>
<p>三分套三分</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/v2-d3e2755075de272bbb0e76856ab6e231_720w.webp" /></p>
<p>​</p>
<p><a href="https://zhuanlan.zhihu.com/p/100617613">参考文章1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/337752413">参考文章2</a></p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
      </categories>
  </entry>
  <entry>
    <title>多少个星期一</title>
    <url>/posts/5f80bd04.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/611/learning/">题目</a></h1>
<!--more--

![](https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240325105631245.png)

# 分析

## java中时间处理

### LocalDate.of(year, month, day)

### toEpochDay()

用于将日期转换为自 1970 年 1 月 1 日起的天数（epoch day），返回一个 long 类型的值

## 如何统计

计算两个时间点之前星期一的数量就是计算出这两个时间点之间的天数后整除7，关键是对<font color = "red">第一天是星期几的判断</font>

利用一个已知是星期一的时间

如果已知时间与第一天的时间间隔是7的倍数，说明第一天是星期一，那么最后要在前面计算的整除结果上加1

如果已知时间与第一天的时间间隔不是7的倍数，说明第一天不是星期一，就不用加

# 题解

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 已知的年月日</span><br><span class="line">        LocalDate dateToday = LocalDate.of(2024, 3, 25);</span><br><span class="line">        LocalDate dateStartDate = LocalDate.of(1901, 1, 1);</span><br><span class="line">        LocalDate dateEndDate = LocalDate.of(2000, 12, 31);</span><br><span class="line">        long dayBetweenTodayAndStart = calculateDaysBetween(dateToday, dateStartDate);</span><br><span class="line">        long dayBetweenStartAndEnd = calculateDaysBetween(dateEndDate, dateStartDate);</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        if(dayBetweenTodayAndStart % 7 == 0) &#123;</span><br><span class="line">        	flag = true;	//flag = true说明当前第一天是星期一</span><br><span class="line">        &#125;</span><br><span class="line">        long mondays = 0;</span><br><span class="line">        if(flag == true) &#123;</span><br><span class="line">        	mondays = dayBetweenStartAndEnd / 7 + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	mondays = dayBetweenStartAndEnd / 7;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mondays);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算两个日期之间相隔的天数</span><br><span class="line">    public static long calculateDaysBetween(LocalDate date1, LocalDate date2) &#123;</span><br><span class="line">        // 获取两个日期对应的毫秒数</span><br><span class="line">        long millis1 = date1.toEpochDay();</span><br><span class="line">        long millis2 = date2.toEpochDay();</span><br><span class="line">        </span><br><span class="line">        // 计算两个日期相隔的天数</span><br><span class="line">        return Math.abs(millis2 - millis1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>填空题</title>
    <url>/posts/758ce69d.html</url>
    <content><![CDATA[<h1 id="知识点考核"><strong>知识点</strong>考核</h1>
<p>10题：不需要算法。在这些题目中，日期、排序比较常见，我们要多练习。</p>
<p>3题：必须用DFS。<strong>DFS是蓝桥杯省赛最常出现的考点，没有之一</strong>。</p>
<h1 id="难度">难度</h1>
<p>极简2题，学过语言就能做。 简单5题，需要经过一定的训练。
中等4题，需要更多训练。 难题2题，训练多了也不一定会。</p>
<h1 id="技巧">技巧</h1>
<p>填空题遇到<strong>字符、大数字、日期</strong>问题，Python是首选，可以直接模拟，不用什么编码技巧</p>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>日期中连续字符串</title>
    <url>/posts/736ca4c7.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/2096/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240327105210715.png" /></p>
<h1 id="分析">分析</h1>
<p>对于2022[ ][ ][ ][ ]来说，要么前三个连续，要么后三个连续</p>
<h1 id="代码">代码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">	static int[] days = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;</span><br><span class="line">	static void fill(int num, int[] data, int start, int end) &#123;</span><br><span class="line">		if(num &gt;= 10) &#123;</span><br><span class="line">			data[start] = num / 10;</span><br><span class="line">			data[end] = num % 10;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			data[start] = 0;</span><br><span class="line">			data[end] = num;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static boolean judge(int[] date) &#123;</span><br><span class="line">		if(date[0] + 1 == date[1] &amp;&amp; date[1] + 1 == date[2] || date[1] + 1 == date[2] &amp;&amp; date[2] + 1 == date[3]) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] date = new int[4];</span><br><span class="line">		int count = 0;</span><br><span class="line">		for(int i = 1; i &lt;= 12; i++) &#123;</span><br><span class="line">			fill(i, date, 0, 1);</span><br><span class="line">			for(int j = 1; j &lt;= days[i]; j++) &#123;</span><br><span class="line">				fill(j, date, 2, 3);</span><br><span class="line">				if(judge(date)) &#123;</span><br><span class="line">					//System.out.println(Arrays.toString(date));</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>模拟</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing1208翻硬币</title>
    <url>/posts/f19f614d.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.acwing.com/problem/content/description/1210/">题目</a></h1>
<p>小明正在玩一个“翻硬币”的游戏。</p>
<p>桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o
表示反面（是小写字母，不是零）。</p>
<p>比如，可能情形是：<code>**oo***oooo</code></p>
<p>如果同时翻转左边的两个硬币，则变为：<code>oooo***oooo</code></p>
<p>现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？</p>
<p>我们约定：把翻动相邻的两个硬币叫做一步操作。</p>
<h2 id="输入格式">输入格式</h2>
<p>两行等长的字符串，分别表示初始状态和要达到的目标状态。</p>
<h2 id="输出格式">输出格式</h2>
<p>一个整数，表示最小操作步数</p>
<h2 id="数据范围">数据范围</h2>
<p>输入字符串的长度均不超过100。 数据保证答案一定有解。</p>
<h2 id="输入样例1">输入样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**********</span><br><span class="line">o****o****</span><br></pre></td></tr></table></figure>
<h2 id="输出样例1">输出样例1：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="输入样例2">输入样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*o**o***o***</span><br><span class="line">*o***o**o***</span><br></pre></td></tr></table></figure>
<h2 id="输出样例2">输出样例2：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1>
<p>贪心：如果当前位置不同，那就要翻转当前位置和当前位置的下一位，而当前位置之前的所有位置已经都是调整到和目标一样了</p>
<h1 id="代码">代码</h1>
<h2 id="暴搜超时了">暴搜(超时了)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> StringBuffer stringInitial;</span><br><span class="line">	<span class="keyword">static</span> String stringTarget;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">StringBuffer</span> <span class="variable">stringOperation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> stringLen;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">LEFT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">minSteps</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringInitial.charAt(count) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			stringInitial.setCharAt(count, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stringInitial.setCharAt(count, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">		reverse(count);</span><br><span class="line">		reverse(count + direction);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringInitial.toString().equals(stringTarget)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(stringInitial);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == stringLen) &#123;</span><br><span class="line">			<span class="keyword">if</span>(valid() &amp;&amp; steps &lt; minSteps) &#123;</span><br><span class="line">				minSteps = steps;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 翻当前层</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) &#123;	<span class="comment">// 只能翻右边</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps += <span class="number">1</span>;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(count == stringLen - <span class="number">1</span>) &#123;	<span class="comment">// 只能翻左边</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">// 两边都可以翻</span></span><br><span class="line">			<span class="comment">// 翻右边</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, RIGHT);</span><br><span class="line">			steps--;</span><br><span class="line">			<span class="comment">// 翻左边</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps++;</span><br><span class="line">			dfs(count + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 复位</span></span><br><span class="line">			change(count, LEFT);</span><br><span class="line">			steps--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不翻当前层</span></span><br><span class="line">		dfs(count + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		stringInitial = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(tmpString);</span><br><span class="line">		stringTarget = scan.nextLine();</span><br><span class="line">		stringLen = stringInitial.length();</span><br><span class="line">		dfs(<span class="number">0</span>);</span><br><span class="line">		System.out.println(minSteps);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心">贪心</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> StringBuffer stringOperation;</span><br><span class="line">	<span class="keyword">static</span> String stringTarget;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(stringOperation.charAt(count) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">			stringOperation.setCharAt(count, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stringOperation.setCharAt(count, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tmpString</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		stringOperation = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(tmpString);</span><br><span class="line">		stringTarget = scan.nextLine();</span><br><span class="line">		<span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringTarget.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(stringOperation.charAt(i) != stringTarget.charAt(i)) &#123;</span><br><span class="line">				change(i);</span><br><span class="line">				change(i + <span class="number">1</span>);</span><br><span class="line">				steps++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(steps);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>贪心</category>
        <category>简单题</category>
      </categories>
  </entry>
  <entry>
    <title>蓝桥oj1461最少砝码</title>
    <url>/posts/ac42800e.html</url>
    <content><![CDATA[<h1 id="题目"><a
href="https://www.lanqiao.cn/problems/1461/learning/">题目</a></h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240327111158568.png" /></p>
<h1 id="分析">分析</h1>
<h2 id="贪心动归">贪心+动归</h2>
<ul>
<li>当有1个砝码</li>
</ul>
<ol type="1">
<li><p>可以称出的最大质量为1</p></li>
<li><p>称不出的最小质量为2</p></li>
</ol>
<ul>
<li>当有2个砝码</li>
</ul>
<ol type="1">
<li><p>要想得到在1个砝码时称不出来的质量2，新的砝码质量可以是1、2、3，但是4不行，因为4-1
= 3 &gt; 2</p></li>
<li><p>由贪心的思想，要想得到最大质量区间，新砝码取3。原因如下图</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/62bf166787fec419ee437adc9c6d308.jpg" /></p>
<ul>
<li><p>当有3个砝码</p>
<ol type="1">
<li>有2个砝码时得不到的最小质量是5</li>
<li>要想得到质量区间最大，新砝码要<font color = "red">在尽可能大的前提下满足减去前2个砝码的和后依然能得到5</font>。所以新砝码的最大质量为5(2个砝码时最小得不到得到质量)
+ 4(2个砝码时能得到的最大质量) = 9</li>
</ol></li>
<li><p>贪心</p>
<ol type="1">
<li><p>dp[ i ]：在有i个砝码时能得到的最大质量</p></li>
<li><p>转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i + 1] = dp[i] + maxFama </span><br><span class="line">maxFama = dp[i] + (dp[i] + 1)</span><br><span class="line">dp[i + 1] = 3 * dp[i] + 1</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h2 id="估计开多大空间">估计开多大空间</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/02a5c2f1fc188bc571c049fe4390d42.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV19m41167NP/?vd_source=a46136aa644c81e751b3b0cc0e17dbe1">讲解视频</a></p>
<h1 id="代码">代码</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">10e6</span>);</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxNum];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">		dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">minBoundry</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span>(minBoundry &lt; target) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">maxFama</span> <span class="operator">=</span> minBoundry + dp[count];</span><br><span class="line">			minBoundry = dp[count] + maxFama + <span class="number">1</span>;</span><br><span class="line">			dp[++count] = minBoundry - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		scan.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>蓝桥杯</category>
        <category>贪心</category>
        <category>困难</category>
      </categories>
  </entry>
  <entry>
    <title>常用命令</title>
    <url>/posts/6fc55794.html</url>
    <content><![CDATA[<h1 id="上传文件到远程服务器">上传文件到远程服务器</h1>
<p>scp -r -P 12243 I:ztb@43.139.180.140:/home/ztb</p>
<p>快速上传</p>
<p>scp -r -P 22 -C I:ztb@10.154.24.17:/home/ztb</p>
<h1 id="指定显卡">指定显卡</h1>
<p>CUDA_VISIBLE_DEVICES=3</p>
<h1
id="发现无法使用包自己写的包无法导入">发现无法使用包，自己写的包无法导入</h1>
<p>在需要使用导入包代码前写</p>
<p>import sys sys.path.append('/home/ztb/experiment')</p>
<p>然后from …… import ……</p>
<p>其中append假第一个……组成被导入包的绝对路径</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>图像操作</title>
    <url>/posts/5d101fd4.html</url>
    <content><![CDATA[<h1 id="numpy数组">numpy数组</h1>
<h2 id="查看形状">查看形状</h2>
<h3 id="numpy">numpy</h3>
<p>print(f"before transpose img_f shape is {img_f.shape}")</p>
<p>一般PIL图像都是HWC，一般张量都是CHW，所以用 image = img.permute(2, 0,
1)来调换通道</p>
<h1 id="pil">PIL</h1>
<h2 id="section"></h2>
<p>print(Image.open(image_path))就可以查看一个图像的基本信息</p>
<p>&lt;PIL.Image.Image image mode=RGB size=320x320 at
0x7FA27DF10910&gt;</p>
<h1 id="张量">张量</h1>
<p>张量要求输入是四维，所以如果只有1张图片，要修改</p>
<p>张量与PIL之间转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图片并转换为张量</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;/home/ztb/alg_mini/computer_design/sbi数据集/faces/1.png&#x27;</span>)</span><br><span class="line">transform = torchvision.transforms.ToTensor()</span><br><span class="line">image_tensor = transform(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加批量维度并调整通道顺序</span></span><br><span class="line">image_tensor = image_tensor.unsqueeze(<span class="number">0</span>)  <span class="comment"># 添加批量维度</span></span><br><span class="line">image_tensor = image_tensor.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)  <span class="comment"># 调整通道顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片输入模型进行推理</span></span><br><span class="line">output = model(image_tensor)</span><br></pre></td></tr></table></figure>
<p>输入模型的张量格式通常是一个四维张量，其形状为
<code>[batch_size, channels, height, width]</code>，其中：</p>
<ul>
<li><code>batch_size</code> 表示每个批次中样本的数量。</li>
<li><code>channels</code>
表示图片的通道数，对于彩色图片通常为3（R、G、B），对于灰度图片通常为1。</li>
<li><code>height</code> 表示图片的高度。</li>
<li><code>width</code> 表示图片的宽度。</li>
</ul>
<p>这种格式通常称为 CHW 格式，因为通道在前，高度在中间，宽度在最后。</p>
<h1 id="图像值的变换">图像值的变换</h1>
<p>为什么一会float / 255，一会有int * 255</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240520234523830.png" /></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/posts/f15db2c6.html</url>
    <content><![CDATA[<p><font color = "red">子序列：可以不连续；子串：必须连续</font></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>实验</category>
      </categories>
  </entry>
  <entry>
    <title>第一章概述</title>
    <url>/posts/7cc56e97.html</url>
    <content><![CDATA[<h1 id="算法复杂性分析">算法复杂性分析</h1>
<span id="more"></span>
<h3 id="算法渐近复杂性"><strong>算法渐近复杂性</strong></h3>
<h5 id="渐近不严格小大">渐近（不严格小/大）</h5>
<h6 id="渐近上界o">渐近上界<span class="math inline">\(O\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/21e10616849eeb6c492d56a6d3b41be.jpg" /></p>
<h6 id="渐进下界omega">渐进下界<span
class="math inline">\(\Omega\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/b700b630ba0004cbee424bdc38592bd.jpg" /></p>
<h5 id="非紧严格小大">非紧（严格小/大)</h5>
<h6 id="非紧上界omicron">非紧上界<span
class="math inline">\(\omicron\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0e1f5a0b6a92e17917927986bacfd24.jpg" /></p>
<h6 id="非紧下界omega">非紧下界<span
class="math inline">\(\omega\)</span></h6>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/08f6221450cb6ba14c2c2df81694a3f.jpg" /></p>
<h5 id="紧渐近界theta">紧渐近界<span
class="math inline">\(\Theta\)</span></h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5871c004daa7406e10db03a220c0f91.jpg" /></p>
<p>注：上面符号与其说表示的是一个函数，不如说表示的是一个函数簇</p>
<p>总结</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/781bac2d8552666d91e544d982e3115.jpg" /></p>
<h3 id="渐近的性质">渐近的性质</h3>
<h4 id="传递性">传递性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ce3b468a13f85ec631264d592dee717.jpg" /></p>
<h4 id="反身性">反身性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ae5577611fdde16022baac1ce83e840.jpg" /></p>
<h4
id="互对称性一个是另一个的上界另一个就是一个的下界">互对称性：一个是另一个的上界，另一个就是一个的下界</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6de93f7cdffe787c012d9e24ac2ff64.jpg" /></p>
<h4 id="对称性">对称性</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/40f632977b0e41fcd25df8ca64f8a56.jpg" /></p>
<h4 id="算术运算">算术运算</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/df382f960d96e54faf0842061571483.jpg" /></p>
<h1 id="np理论">NP理论</h1>
<h2 id="基本定义">基本定义</h2>
<ul>
<li><p>P：可以在多项式时间解决的问题</p></li>
<li><p>NP：目前没有多项式时间解决的算法，但是如果给出一个候选答案，可以在多项式时间里验证这个答案是不是正确的。</p></li>
<li><p>NPC：满足两个性质：</p></li>
</ul>
<ol type="1">
<li><p>可在多项式时间验证候选答案（是NP问题）；</p></li>
<li><p>任何一个NP问题可在多项式时间内规约到该问题。</p></li>
<li><p>重要性质：如果一个NP完全问题能在多项式时间内得到解决，那么NP中的每一个问题都可以在多项式时间内求解，即P=NP。</p></li>
</ol>
<ul>
<li>NP-Hard：任何一个NP问题可在多项式时间内规约到该问题，但无法证明问题本身是NP问题。NP-Hard至少和NP问题一样难。</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615110153411.png" /></p>
<h2 id="典型npc问题">典型NPC问题</h2>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章-动态规划</title>
    <url>/posts/10f9c13d.html</url>
    <content><![CDATA[<h1 id="矩阵连乘问题">矩阵连乘问题</h1>
<span id="more"></span>
<h2 id="问题描述">问题描述</h2>
<p>给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。</p>
<p>详细说明：</p>
<h3 id="完全加括号的矩阵连乘积">完全加括号的矩阵连乘积</h3>
<p>定义</p>
<p>递归定义如下</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404142841417.png" /></p>
<h3 id="计算乘法次数">计算乘法次数</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404143033534.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Jx4y1v7Pg/?spm_id_from=333.999.0.0">视频讲解：矩阵连乘中乘法次数的计算</a></p>
<h2 id="解决方案">解决方案</h2>
<h3 id="穷举">穷举</h3>
<p>时间复杂度分析：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4bb32aa7f3c7a09736383e8366ee372.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1oZ421v7i7/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：穷举法计算矩阵连乘问题序列数时间复杂度分析</a></p>
<h3 id="动态规划">动态规划</h3>
<p>状态转移方程</p>
<p>其中参数的含义：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bb31de1a4e6e0c728fed7ba5f77af60.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404165259820.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404165317052.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1uZ421B7zS/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：动归解决矩阵连乘中转移方程推导与代码分析</a></p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MatrixChain &#123;</span><br><span class="line">    public static void matrixChain(int[] p, int n, int[][] m, int[][] s) &#123;</span><br><span class="line">        // Initialize diagonal elements of m to 0</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            m[i][i] = 0;</span><br><span class="line"></span><br><span class="line">        for (int r = 2; r &lt;= n; r++) &#123;</span><br><span class="line">            for (int i = 1; i &lt;= n - r + 1; i++) &#123;</span><br><span class="line">                int j = i + r - 1;</span><br><span class="line">                m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];</span><br><span class="line">                s[i][j] = i;</span><br><span class="line">                for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                    int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];</span><br><span class="line">                    if (t &lt; m[i][j]) &#123;</span><br><span class="line">                        m[i][j] = t;</span><br><span class="line">                        s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="备忘录">备忘录</h3>
<p>动归的优化，与纯动态规划区别在于，原来的动态规划的递归方向<font color = "red">从底往上</font>，比如上面是先计算出长度为i的矩阵，再利用得到的结果计算长度为i+1的矩阵</p>
<p>备忘录是利用递归<font color = "red">从顶往下</font></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lookupChain</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[i][j]; <span class="comment">// 说明之前已经计算过，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 同1个矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> lookupChain(i, i) + lookupChain(i + <span class="number">1</span>, j) + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">    <span class="comment">// 上面这步类似纯动归的初始化，分割线在i后面</span></span><br><span class="line">    s[i][j] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lookupChain(i, k) + lookupChain(k + <span class="number">1</span>, j) + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">        <span class="comment">// 上面这个就是针对i, j序列找最小的m[i, j]</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; u) &#123;</span><br><span class="line">            u = t;</span><br><span class="line">            s[i][j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子序列">最长公共子序列</h1>
<h2 id="结构">结构</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240404204318582.png" /></p>
<blockquote>
<p>注：公共子序列不一定连续</p>
<p>举例：X：A, B, C, C, D, E</p>
<p>​ Y:A, B, E, F</p>
<p>最长公共子序列：A, B, E</p>
</blockquote>
<h2 id="状态转移方程">状态转移方程</h2>
<p><strong>c[ i ][ j ]</strong>记录序列和的最长公共子序列的长度</p>
<p>其中，
Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i][j]=0。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c2f7a9fa4b9a76331c2b73ef9c22c07.jpg" /></p>
<h2 id="动归计算最长子序列长度">动归计算最长子序列长度</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b[i][j] = 1 //情况一：X尾和Y尾相等</span><br><span class="line">b[i][j] = 2 //情况二：去X尾更长</span><br><span class="line">b[i][j] = 3 //情况三：去Y尾更长</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lcsLength</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">char</span>[] x, <span class="type">char</span>[] y, <span class="type">int</span>[][] c, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize DP tables</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;	<span class="comment">//列代表字符串X</span></span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;	<span class="comment">//行代表字符串Y</span></span><br><span class="line">        c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制变量法，先固定x的结尾，移动y的结尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] == y[j]) &#123;	<span class="comment">// 如果末尾相同</span></span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;	</span><br><span class="line">                b[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[i - <span class="number">1</span>][j] &gt;= c[i][j - <span class="number">1</span>]) &#123;	<span class="comment">//如果末尾不同且去x尾更长</span></span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果末尾相同且去y尾更长</span></span><br><span class="line">                c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面得到的b矩阵构造最长公共子序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lcs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] x, <span class="type">int</span>[][] b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (b[i][j] == <span class="number">1</span>) &#123;	<span class="comment">// 情况一：结尾相等</span></span><br><span class="line">        lcs(i - <span class="number">1</span>, j - <span class="number">1</span>, x, b);</span><br><span class="line">        System.out.print(x[i - <span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i][j] == <span class="number">2</span>) &#123;	<span class="comment">//情况而：结尾是y尾，y不动，去x尾</span></span><br><span class="line">        lcs(i - <span class="number">1</span>, j, x, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">//情况三：结尾是x尾，y不动，去x尾</span></span><br><span class="line">        lcs(i, j - <span class="number">1</span>, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Cr421t7Ur/?spm_id_from=333.999.0.0">视频讲解：最长公共子序列的两种输出</a></p>
<h1 id="最大子段和">最大子段和</h1>
<h2 id="定义">定义</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405052621608.png" /></p>
<p><font color = "red">最大子段和要求是连续的</font></p>
<h2 id="分治算法">分治算法</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0496c608796c48b6712341468cab3d8.jpg" /></p>
<p>时间复杂度分析（类似快排）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405053751915.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4634de1a817caf595e3d8ee97132df3.jpg" /></p>
<h2 id="动归算法">动归算法</h2>
<h3 id="状态转移方程-1">状态转移方程：</h3>
<p>定义数组<strong>b[ j
]</strong>表示含义为<font color = "red">一定要取数组<strong>a[ j
]</strong>的情况下</font>，能得到的最大子列和</p>
<p><strong>b[ j ]=max{ b[ j-1 ]+a[ j ]，a[ j ]}，1≤j≤n</strong></p>
<h3 id="代码">代码</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405060709253.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b += a[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; sum) &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="凸多边形最优三角剖分">凸多边形最优三角剖分</h1>
<h2 id="定义-1">定义</h2>
<ol type="1">
<li>用多边形顶点的<font color = "red">逆时针序列</font>表示凸多边形</li>
<li>若vi与vj是多边形上<font color = "red">不相邻的2个顶点</font>，则线段vivj称为多边形的一条弦。</li>
<li>多边形的三角剖分是将多边形分割成互不相交的三角形的<font color = "red">弦的集合T</font>。</li>
<li>给定凸多边形P，以及定义在由多边形的<font color = "red">边和弦组成的三角形上的权函数w</font>。要求确定该凸多边形的三角剖分，使得即该三角剖分中诸三角形上<font color = "red">权之和最小</font>。</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405061347814.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/14fae356ce0e5d90eea1611eb8145d5.jpg" /></p>
<h2 id="状态转移方程-2">状态转移方程</h2>
<p>• 定义<strong>t[ i ][ j ]</strong><a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>为凸子多边形{vi-1,vi,…,vj}<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>的最优三角剖分所对应的权函数值，为方便起见，设退化的多边形{vi-1,vi}具有权值0。据此定义，要计算的凸(n+1)边形P的最优权值为t[1][n]。</p>
<p>•
t[i][j]的值可以利用最优子结构性质递归地计算。当j-i≥1时，凸子多边形至少有3个顶点。由最优子结构性质，<font color = "red">t[i][j]的值应为t[i][k]的值加上t[k+1][j]的值，再加上三角形vi-1vkvj的权值</font>，其中i≤k≤j-1。由于在计算时还不知道k的确切位置，而k的所有可能位置只有j-i个，因此可以在这j-i个位置中选出使t[i][j]值达到最小的位置。由此，t[i][j]可递归地定义为：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405070956331.png" /></p>
<p>和之前矩阵连乘定义比较：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240405071037433.png" /></p>
<p><font color = "red">凸多边形是矩阵连乘的拓展，拓展结果就是最后w函数可以是各种自定义</font></p>
<h2 id="代码-1">代码</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a02052d33e6631f72bc6947aba020ca.jpg" /></p>
<h1 id="背包">0-1 背包</h1>
<h2 id="定义-2">定义：</h2>
<p>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p>
<p>0-1背包问题是一个特殊的整数规划问题。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4d16b8d8311d7cd652e8117af7b3147.jpg" /></p>
<h2 id="动态转移方程">动态转移方程</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bd839e9436f7cff13fb968d1d867628.jpg" /></p>
<h2 id="代码-2">代码</h2>
<h3 id="原始版本求最大价值">原始版本求最大价值</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/2e4539f504399446b33100d53a2abff.jpg" /></p>
<h3 id="原始版本求产生最大价值的方法">原始版本求产生最大价值的方法</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b93650f105ff8c2a37a6e03c1e0aee9.jpg" /></p>
<h1 id="流水作业调度">流水作业调度</h1>
<h2 id="定义-3">定义</h2>
<p>n个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。
流水作业调度问题要求<font color = "red">确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少</font></p>
<p>直观来看，最佳调度应该是使机器M1没有空闲时间，同时机器M2的空闲时间最少。通常情况下，机器M2上会出现两种情况：一种是机器空闲，另一种是作业积压。</p>
<p>假设所有作业的集合为N={1, 2, ...,
n}。S⊆N是N的作业子集。在<font color = "yellow">一般情况下，当机器M1开始处理S中的作业时，机器M2可能正在处理其他作业，需要等待时间t才能开始处理S中的作业。我们将在这种情况下完成S中作业所需的最短时间记为T(S,
t)。</font><font color = "red">流水作业调度问题的最优解为T(N,
0)。</font>(t = 0表示机器M2积压时间为0)</p>
<h2 id="johnson不等式">Johnson不等式</h2>
<p>如果作业i和j满足min{bi,aj}≥min{bj,ai}，则称作业i和j满足Johnson不等式。</p>
<h2 id="算法">算法</h2>
<p>流水作业调度问题的Johnson算法 (1)令</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240417053251214.png" />
(2)将N1中作业依ai的递增排序(不严格)；将N2中作业依bi的递减排序(不严格)；
(3)N1中作业接N2中作业构成满足Johnson法则的最优调度。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/50afce87f860ee16279ee01d4e31883.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1gm41127Sq/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h1 id="最优二叉搜索树">最优二叉搜索树</h1>
<h2 id="二叉搜索树定义">二叉搜索树定义</h2>
<ol type="1">
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ol>
<p>如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423094143694.png" style="zoom:50%;" /></p>
<h2 id="搜索的期望耗费">搜索的期望耗费</h2>
<h3
id="所有节点包括成功与不成功的概率和是1">所有节点（包括成功与不成功）的概率和是1</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/906b29131c6f62f386c68f2b44fff07.jpg" /></p>
<h3 id="期望耗费">期望耗费</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/cc165ddcce07e99faabd4b728085569.jpg" /></p>
<h4 id="从深度角度根节点深度为0">从深度角度（根节点深度为0）</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423095637747.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/328544f39d8dd9887c3dae0b2efd2ee.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>也可以从比较次数角度，比如根节点比较1次就能确定</p>
<h2 id="构建最优二叉搜索树">构建最优二叉搜索树</h2>
<h3 id="任务描述">任务描述</h3>
<p>给了一堆节点和每个节点被搜索到的概率，要求建立一棵二叉搜索树，这棵树的期望耗费要最小</p>
<h3 id="问题分析">问题分析</h3>
<h4 id="最优子结构">最优子结构</h4>
<p><span class="math inline">\(w_{i,
j}\)</span>表示包括i到j的节点组成的子树的可能性的和，从i到j的节点是实际存在的节点序号，但是还包括他们的子节点</p>
<p><span class="math inline">\(p_{i,
j}\)</span>表示包括i到j的节点组成的子树的平均“路长”</p>
<p><span class="math inline">\(w_{i,
j}p_{i,j}\)</span>的积表示的是包括i到j的节点组成的树的"贡献"</p>
<p>一棵树要想期望耗费最小，就是这棵树的左右子树贡献最小</p>
<p><a href="">视频讲解：一步一步推出算法设计思想</a></p>
<h4 id="状态转移方程-3">状态转移方程</h4>
<h3 id="代码分析">代码分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Void <span class="title function_">OBST</span> <span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b, <span class="type">int</span> n, <span class="type">int</span> **m, <span class="type">int</span> **s, <span class="type">int</span> **w)</span> </span><br><span class="line">&#123;  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123; w[i+<span class="number">1</span>][i]=a[i]; m[i+<span class="number">1</span>][i]=<span class="number">0</span>; &#125; <span class="comment">//初始状态</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> r=<span class="number">0</span>;r&lt;n;r++)              <span class="comment">//r+1为结点个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n-r;i++)   <span class="comment">//考虑xi～xj共r+1个结点的</span></span><br><span class="line">      &#123; <span class="type">int</span> j=i+r;                       <span class="comment">//最优二叉搜索树</span></span><br><span class="line">         w[i][j]=w[i][j-<span class="number">1</span>]+a[j]+b[j];       <span class="comment">//以xi为根节点</span></span><br><span class="line">         m[i][j]=m[i+<span class="number">1</span>][j]; s[i][j]=i;      <span class="comment">//注意m(i,i-1)=0</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k=i+<span class="number">1</span>; k&lt;=j; k++)</span><br><span class="line">           &#123; <span class="type">int</span> t=m[i][k-<span class="number">1</span>]+m[k+<span class="number">1</span>][j];    <span class="comment">//以xk为根节点</span></span><br><span class="line">              <span class="keyword">if</span> (t&lt;m[i][j])      <span class="comment">//t为当前最小值</span></span><br><span class="line">                   &#123; m[i][j]=t; s[i][j]=k; &#125; <span class="comment">//s记录当前子树根节点xk</span></span><br><span class="line">           &#125;</span><br><span class="line">         m[i][j] += w[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面最好要有个矩阵模拟过程</p>
<p><font color = "yellow">问题：数组a是什么？数组b又是什么？</font></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>(1≤i&lt;j≤n)。<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>(这是顶点集，边数就是j - (i - 1) -1 = j -
i条，每天边对应1个矩阵)。<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第七章_随机化算法</title>
    <url>/posts/37655cdf.html</url>
    <content><![CDATA[<h1 id="随机数">随机数</h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615091622842.png" /></p>
<h1 id="随机算法">随机算法</h1>
<h2 id="数值随机">数值随机</h2>
<h3 id="计算π">计算π</h3>
<p>设有一半径为r的圆及其外切四边形，向正方形随机投掷n个点。设落入圆内的点数为k。若所投入的点在正方形上均匀分布，
则所投入的点落入圆内的概率为：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615092234592.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double Darts(int n)</span><br><span class="line">&#123; // 用随机投点法计算值</span><br><span class="line">    static RandomNumber dart;</span><br><span class="line">    int k=0;</span><br><span class="line">    for (int i=1;i &lt;=n;i++) </span><br><span class="line">    &#123;   double x=dart.fRandom();</span><br><span class="line">         double y=dart.fRandom();</span><br><span class="line">         if ((x*x+y*y)&lt;=1) k++;</span><br><span class="line">     &#125;</span><br><span class="line">    return 4 * k / double(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计算定积分">计算定积分</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615092607038.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double Darts(int n) &#123; </span><br><span class="line">    // 用随机投点法计算定积分 </span><br><span class="line">    static RandomNumber dart; </span><br><span class="line">    int k = 0; </span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        double x = dart.fRandom(); </span><br><span class="line">        double y = dart.fRandom(); </span><br><span class="line">        if (y &lt; f(x)) &#123;</span><br><span class="line">            k++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return k / double(n); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：上面两题本质上都是投点，限制点在目标区域，计算目标区域中点在整个区域中个数</p>
</blockquote>
<h2 id="舍伍德sher-wood">舍伍德（Sher wood)</h2>
<h3 id="随机洗牌">随机洗牌</h3>
<h4 id="算法思想">算法思想</h4>
<p>从位置1取到位置n，每个对应位置随机选一个位置，将两个位置的牌对调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">void Shuffle(Type a[], int n) // 随机洗牌算法</span><br><span class="line">&#123;  </span><br><span class="line">    static RandomNumber rnd;</span><br><span class="line">    for (int i=1;i&lt;n;i++) </span><br><span class="line">    &#123;    int j=rnd.Random(n-i)+i; // 产生[i, n-1]随机数</span><br><span class="line">         Swap(a[i-1], a[j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拉斯维加斯las-vegas">拉斯维加斯（Las Vegas)</h2>
<h3 id="标记重复元素">标记重复元素</h3>
<p>设有n个元素保存在一维数组a中，其中有n/2个元素各不相同，而另外n/2个元素有相同值。也就是说，总共有(n/2)+1种不同的元素值。现要求找出其中那个重复元素。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/fcb7e39eb22bc0d47957b4e23ed7f45.jpg" /></p>
<h2 id="蒙特卡洛monte-carlo">蒙特卡洛（Monte Carlo)</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615095120809.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240615095142731.png" /></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章-递归与分治</title>
    <url>/posts/49cf79ef.html</url>
    <content><![CDATA[<h1 id="主定理解析">主定理解析</h1>
<span id="more"></span>
<h2 id="结论">结论</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/v2-a0299344bcf4a294e5c05d0dd65e6009_720w.webp" /></p>
<h2 id="分析">分析</h2>
<p>递归公式通用形式</p>
<p><span class="math inline">\(T(n) = aT(\frac{n}{b}) +
O(n^d)\)</span></p>
<p>最后的时间复杂度和这a, b ,d几个参数有关。</p>
<p>把递归问题每一层的问题数目，计算量都一一列出，可以得到如下公式</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/246a8395cdf4300171bd87f00b5e9ce.jpg" /></p>
<p>最终的总规模是<font color = "red">等比数列</font>，因为初始问题规模n是固定的，d是规定的，将<span
class="math inline">\(O(n^d)\)</span>看作常数，公比是<span
class="math inline">\(\frac{a}{b^d}\)</span></p>
<ul>
<li><p>情况一：公比小于1</p>
<p>时间复杂度由第一项确定</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317142649653.png" /></p></li>
<li><p>情况二：公比大于1</p>
<p>时间复杂度由最后一项确定</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317142728426.png" /></p></li>
</ul>
<p>​ 化简过程：<br />
​<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/835962a26e5043f390ee6143d828324.jpg" /></p>
<ul>
<li><p>公比等于1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240317143800605.png" /></p></li>
</ul>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章_分支限界法</title>
    <url>/posts/de0cfddc.html</url>
    <content><![CDATA[<h1 id="又探0-1背包">又探0-1背包</h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601191017045.png" /></p>
<h2 id="队列式分支限界法">队列式分支限界法</h2>
<p>就是按照普通队列先进先出规则，然后要注意可行性剪枝，升级可以加上限界剪枝</p>
<h2 id="优先队列分支限界法">优先队列分支限界法</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609204533626.png" style="zoom:50%;" /></p>
<p>要选择一个优先的标准，本题标准就是当前背包里价值，优先将背包里价值大的出列并且将其对应的儿子放入队列中</p>
<p>广搜，根据优先级将当前节点出优先队列（一般是是大顶堆或者小顶堆），然后将当前节点的左孩子和右孩子加入优先队列，加入左孩子前要进行可行性剪枝，加入右孩子前进行限界剪枝</p>
<p>优先级：当前price最大的节点</p>
<p>限界函数：如果右节点贪心所得到的可能最大值比bestp小，就剪枝</p>
<blockquote>
<p>注：这里的限界函数与深搜的做对比的，深搜是将右节点贪心所得到的可能最大值，就是深搜的bestp是在遍历到叶子才会产生，而广搜的bestp是可能没有遍历到叶子就得到了</p>
</blockquote>
<h1 id="又探旅行收货商">又探旅行收货商</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601191037653.png" /></p>
<h2 id="队列是分支限界法">队列是分支限界法</h2>
<h2 id="优先队列分支限界法-1">优先队列分支限界法</h2>
<ol type="1">
<li>优先级 = 当前已经走过的路程 + 未来走的最小路程
<ul>
<li>未来走的最小路程的计算方式：对于每个节点，计算从这个节点走出的最短路径，然后到达每个节点之后，要想计算未来走的最短路径，就是将从当前节点与所有还没有到过的节点的从这个节点走出的最短路径求和，所以建立的树的每一层的未来走的最小路程是相等的</li>
</ul></li>
<li>其他注意点与优先队列一样，不懂可以看下面最大团里的视频讲解</li>
</ol>
<h1 id="单源最短路">单源最短路</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601191248623.png" /></p>
<h2 id="算法思想">算法思想</h2>
<p>就是迪杰斯特拉算法</p>
<p>这里的一种新型剪枝：如果优先队列中一个节点已经存在，又把这个节点放入优先队列，如果新放入的比原来的大，那么新放入的就被剪枝</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601194652185.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/2c0269233c3f57f87f0c2326c95eb06.jpg" /></p>
<h1 id="又探装载问题">又探装载问题</h1>
<p><a
href="https://pilotztb.github.io/posts/9457d29e.html">最早出现在第五章</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601201345926.png" /></p>
<h2 id="普通队列">普通队列</h2>
<p>普通队列并且加上了限界剪枝，限界剪枝函数是如果舍弃一个货物，判断当前船上货物加上剩余货物是否大于之前搜索得到的最大，如果小，这条路剪去</p>
<h2 id="优先队列">优先队列</h2>
<h1 id="又探最大团">又探最大团</h1>
<p><a
href="https://pilotztb.github.io/posts/9457d29e.html">最早出现于第五章回溯</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/814cdfa10929a863e636f3b9f5d01a6.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/58c913a490203bacf7c2671b0ab5342.jpg" /></p>
<ol type="1">
<li>优先队列和树是同时画的</li>
<li>每次选择优先级最大的团
<ul>
<li>这里优先级的标准是（当前团里已有的元素） +
（还没有遍历过的元素）</li>
<li>将优先级最大的出队，然后将它的孩子入队，左孩子要经过可行性剪枝才能入队，右孩子要经过限界剪枝才能入队
<ul>
<li>限界剪枝的标准是判断（当前团里已有的元素） +
（还没有遍历过的元素）是否大于等于bestn，如果小就剪掉‘</li>
</ul></li>
<li>如果优先级一样，就需要看优先队列里谁先入的队，先入队的先拓展</li>
</ul></li>
<li>即使已经将最优节点找到了，也要继续往下遍历，直到当前遍历的节点就是叶子节点</li>
</ol>
<p><a
href="https://www.bilibili.com/video/BV1gy41187AP/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：如何实现手工模拟的建树</a></p>
<h1 id="布线问题">布线问题</h1>
<h2 id="题目要求">题目要求</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4d67e1856ec1ff4768cac5edc9c32de.jpg" style="zoom: 67%;" /></p>
<p>求从a到b的最短路线</p>
<h2 id="算法思想-1">算法思想</h2>
<p>利用广搜，记录从起点到当前节点的路径长度，将当前节点加入队列</p>
<p>找到到终点的路径后，利用回溯，从终点往起点深搜，就是每次从当前节点出发搜一圈，如果有个节点路径长度减1就跳到这个节点，将这个节点加入堆栈直到找到起点，然后把堆栈里面所有倒出来就是要找的路径</p>
<h2 id="代码">代码</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/fe99fe07faa755cbfdee92cdc3ba6dd.jpg" style="zoom: 50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9acdf9e52183f1f544619ffe4e6411f.jpg" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609141027281.png" style="zoom:50%;" /></p>
<h1 id="重排九宫问题">重排九宫问题</h1>
<h2 id="题目描述">题目描述</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609201943959.png" /></p>
<h2 id="算法思想-2">算法思想</h2>
<ol type="1">
<li><p>优先级 = h(x)已移数字的次数（当前路径长） +
p(x)错位数字离开目标位置距离之和
+s(x)每个数字与后接数字相对位置标记之和</p>
<p>s(x)= 0：x与后接数字相 对位置不变 1：x在中心位置） 2：其他</p>
<p>举例说明</p>
<p>第一个是目标状态，第二个是比较容易得到目标状态的状态，第三个是比较难得到目标状态的状态</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609202212620.png" /></p>
<p>比较容易得到目标状态的状态的计算</p>
<p>P(1)=P(2)=…=P(6)=P(8)=1,P(7)=0 S(1)=S(2)=…=S(5)=S(8)=0,S(6)=1,S(7)=2
P(x)= 7, S(x)=3 P(x)+S(x)=10</p>
<p>比较难得到目标状态的状态的计算</p>
<p>P(1)=P(4)=P(8)=2, P(2)=P(3)=1,P(5)=P(6)=P(7)=0 S(5)=S(6)=S(8)=0,
S(1)=S(2)=S(3)=S(4)=S(7)=2 P(x)= 9, S(x)=10 P(x)+S(x)=19</p></li>
</ol>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章_回溯法</title>
    <url>/posts/9457d29e.html</url>
    <content><![CDATA[<h1 id="一些基础">一些基础</h1>
<span id="more"></span>
<p>扩展结点:一个正在产生儿子的结点称为扩展结点</p>
<p>活结点:一个自身已生成但其儿子还没有全部生成的节点称做活结点</p>
<p>死结点:一个所有儿子已经产生的结点称做死结点</p>
<p>深度优先的问题状态生成法：如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）</p>
<p>回溯法：为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding
function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法</p>
<h2 id="子集树和排列树">子集树和排列树</h2>
<h3 id="子集树">子集树</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240530223943531.png" /></p>
<p>遍历子集树需<span class="math inline">\(O(2^n)\)</span>计算时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtrack (int t)</span><br><span class="line">&#123;  if (t&gt;n) output(x);</span><br><span class="line">   else</span><br><span class="line">       for (int i=0;i&lt;=1;i++) </span><br><span class="line">        &#123;  x[t]=i;</span><br><span class="line">           if (constraint(t)&amp;&amp;bound(t))</span><br><span class="line">                 backtrack(t+1);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排列树">排列树</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240530224056147.png" /></p>
<p>遍历排列树需要O(n!)计算时间
(就是有n!个叶子节点，n个元素的排列数就是n!)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtrack (int t)</span><br><span class="line">&#123; if (t&gt;n) output(x);</span><br><span class="line">  else</span><br><span class="line">      for (int i=t;i&lt;=n;i++) </span><br><span class="line">        &#123; swap(x[t], x[i]);</span><br><span class="line">          if (constraint(t)&amp;&amp;bound(t)) </span><br><span class="line">                backtrack(t+1);</span><br><span class="line">          swap(x[t], x[i]);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV15x4y1p7dU/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：如何理解排列树</a></p>
<h1 id="装载问题">装载问题</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531104825510.png" /></p>
<h2 id="算法思想">算法思想</h2>
<p>有点类似于贪心，首先需要将第一艘传尽可能装满，然后剩下的箱子放第二艘船</p>
<p>而将第一艘船装满，就是一种<font color = "red">0-1背包问题</font></p>
<p><font color = "yellow">解空间树是子集树</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/510a28d077bcdded97f47d5eba554ea.jpg" /></p>
<p><font color = "yellow">在上面两个剪枝下如果能遍历到叶子节点就是最优解</font></p>
<h1 id="批处理作业调度">批处理作业调度</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531112759105.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1xZ421H7XT/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：作业完成时间如何计算</a></p>
<p>在机器1上是一条线，就是所有作业在机器1上耗时和</p>
<p>但是在机器2上就断断续续的，并且每一次机器2的结束就是一个任务的结束，将所有任务的结束时间相加就是要得到的完成时间</p>
<h2 id="算法思想-1">算法思想</h2>
<p><font color = "red">解空间树是排列树</font></p>
<h2 id="代码分析">代码分析</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240531115418.jpg" /></p>
<h1 id="n皇后">n皇后</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531115451866.png" /></p>
<h1 id="再探0-1背包">再探0-1背包</h1>
<h2 id="算法思想-2">算法思想</h2>
<p>一个子集树，每一层对应一个物品，左子树放这个物品（来），右子树不放这个物品（不来）</p>
<h3 id="限界函数">限界函数</h3>
<ol type="1">
<li>将0-1背包看成背包，就是物品可以拆，利用贪心，先将所有物品按照单位价值排序，然后依次放入背包，剩下不能放下一整个物品的就拆开来放，这样就能得到当前状态节点往下走能获得的最大价值。
<ul>
<li>将这个最大价值与bestp比较判断有没有继续往下走的必要</li>
<li>bestp是在走到叶子节点后才能得出</li>
</ul></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609204901891.png" /></p>
<h1 id="最大团">最大团</h1>
<h2 id="一些定义">一些定义</h2>
<h3 id="完全子图和最大团">完全子图和最大团</h3>
<p>完全子图就是从一个图中抽出一部分顶点，这些顶点两两之间都有边相连</p>
<p>最大团就是一个图中顶点数最多的完全子图</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6c47982e64c0ce8d26fa9deb07c85e6.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="空子图和最大独立集">空子图和最大独立集</h3>
<p>空子图和最大独立集就是上面的相对，节点两两之间没有边相连</p>
<h2 id="算法思想-3">算法思想</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b80b993e0ee216ddfc21b9b12213667.jpg" /></p>
<p>时间复杂度分析如下</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c6fe3fda4f88011184a54f1630fbd94.jpg" /></p>
<h1 id="图的m着色">图的m着色</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531203233764.png" /></p>
<h2 id="算法思想-4">算法思想</h2>
<p>•解向量：(x1, x2, … , xn)表示顶点i所着颜色x[i]</p>
<p>•可行性约束函数：顶点i与已着色的相邻顶点颜色不重复。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531204112692.png" /></p>
<p>时间复杂度分析类似上面的最大团</p>
<h1 id="旅行售货员">旅行售货员</h1>
<p>一个售货员从起点节点绕一圈回来并且走的路程最短</p>
<h2 id="算法思想-5">算法思想</h2>
<p>是一个排列树</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240531205003937.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Dx4y1E7GU/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：手工模拟旅行收货商建树过程</a></p>
<h1 id="符号三角形">符号三角形</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240601094507421.png" /></p>
<h2 id="算法思想-6">算法思想</h2>
<ol type="1">
<li>解向量：用n元组x[1:n]表示符号三角形的第一行</li>
<li>可行性约束函数：当前符号三角形所包含的“+”个数与“-”个数均不超过n*(n+1)/4</li>
<li>无解的判断：n*(n+1)/2为奇数</li>
<li>比较反直觉的是，解空间是子集树不是排列树</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/56385f34e503ce5266efa742544b3bc.jpg" /></p>
<h1 id="概率方法估计回溯产生的节点数">概率方法估计回溯产生的节点数</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240609205717020.png" /></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-贪心</title>
    <url>/posts/f5cda7c8.html</url>
    <content><![CDATA[<h1 id="活动安排">活动安排</h1>
<span id="more"></span>
<h2 id="算法分析">算法分析</h2>
<p>想法很简单：就是先将活动结束时间按从小到大排个序，然后选择最早的的一个活动，这个活动的开始时间晚于当前集合中最后一个活动的结束时间，加入集合后将集合中结束时间重新修改为刚才加入活动的结束时间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240424191240622.png" /></p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedySelector</span>&lt;Type&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greedySelector</span><span class="params">(<span class="type">int</span> n, Type[] s, Type[] f, <span class="type">boolean</span>[] A)</span> &#123;</span><br><span class="line">        A[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((Comparable&lt;Type&gt;) s[i]).compareTo(f[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                A[i] = <span class="literal">true</span>;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GreedySelector&lt;Integer&gt; greedySelector = <span class="keyword">new</span> <span class="title class_">GreedySelector</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        Integer[] s = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Integer[] f = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span>[] A = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        greedySelector.greedySelector(n, s, f, A);</span><br><span class="line">        System.out.print(<span class="string">&quot;A[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">boolean</span> b : A) &#123;</span><br><span class="line">            System.out.print(b ? <span class="string">&quot;true &quot;</span> : <span class="string">&quot;false &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="背包问题">背包问题</h1>
<h2 id="算法分析-1">算法分析</h2>
<p>这里的物品是可以“拆分”的，不像前面0-1背包物品一个一个都是完整的</p>
<p>贪心：将尽可能多高“性价比"货物放入背包，这里的”性价比“计算是<span
class="math inline">\(\frac{货物价格}{货物重量}\)</span></p>
<h2 id="代码-1">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> M, <span class="type">float</span>[] v, <span class="type">float</span>[] w, <span class="type">float</span>[] x)</span> &#123;</span><br><span class="line">        sort(n, v, w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> M;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; c) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            c -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            x[i] = c / w[i]; <span class="comment">// 最后装入部分物品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span>[] v, <span class="type">float</span>[] w)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设已经实现排序算法</span></span><br><span class="line">        <span class="comment">// 这里使用Arrays.sort()进行排序</span></span><br><span class="line">        <span class="type">float</span>[][] items = <span class="keyword">new</span> <span class="title class_">float</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            items[i][<span class="number">0</span>] = v[i];</span><br><span class="line">            items[i][<span class="number">1</span>] = w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(items, (a, b) -&gt; Float.compare(b[<span class="number">0</span>] / b[<span class="number">1</span>], a[<span class="number">0</span>] / a[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v[i] = items[i][<span class="number">0</span>];</span><br><span class="line">            w[i] = items[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Knapsack</span> <span class="variable">knapsack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knapsack</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">float</span>[] v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="type">float</span>[] w = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">float</span>[] x = <span class="keyword">new</span> <span class="title class_">float</span>[n];</span><br><span class="line">        knapsack.knapsack(n, M, v, w, x);</span><br><span class="line">        System.out.print(<span class="string">&quot;x[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> value : x) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = "red">动态规划和贪心的相似与区别</font></p>
<p>动态规划是先解决子问题然后选择一个最好的解决方案，像0-1背包中dp数组</p>
<p>贪心是先选择一个解决方案然后再解决子问题，像活动安排时先找第一个活动一样</p>
<p><a
href="https://www.bilibili.com/video/BV1Xm411y743/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：课堂老师讲解原声大碟</a></p>
<h1 id="最优装载">最优装载</h1>
<h2 id="算法分析-2">算法分析</h2>
<p>目标尽可能多，所以就先装重量小的</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Loading</span>&lt;Type&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loading</span><span class="params">(<span class="type">int</span>[] x, Type[] w, Type c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Integer[] t = <span class="keyword">new</span> <span class="title class_">Integer</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            t[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(w, t, n);  <span class="comment">// 将所有集装箱按重量排序</span></span><br><span class="line">        Arrays.fill(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;</span><br><span class="line">            x[t[i]] = <span class="number">1</span>;</span><br><span class="line">            c = c - w[t[i]];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Type[] w, Integer[] t, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设已经实现排序算法</span></span><br><span class="line">        <span class="comment">// 这里使用Arrays.sort()进行排序</span></span><br><span class="line">        Arrays.sort(t, <span class="number">1</span>, n + <span class="number">1</span>, (a, b) -&gt; compare(w[b], w[a])); <span class="comment">// 根据重量w进行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出排序结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted indexes:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(t[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较方法，假设 Type 类型实现了 Comparable 接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Type a, Type b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Comparable &amp;&amp; b <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Comparable&lt;Type&gt;) a).compareTo(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Type must implement Comparable interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Loading&lt;Integer&gt; loading = <span class="keyword">new</span> <span class="title class_">Loading</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        Integer[] w = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">// 集装箱重量</span></span><br><span class="line">        <span class="type">int</span>[] x = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// 装载情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 船的载重量</span></span><br><span class="line">        loading.loading(x, w, c, n);</span><br><span class="line">        System.out.print(<span class="string">&quot;x[]: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : x) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼编码">哈夫曼编码</h1>
<h2 id="算法思路">算法思路</h2>
<p>维护一个小顶堆，每次从这个小顶堆中弹出最小和次小，相加后再放回，不断重复直到堆中只有1个节点</p>
<h2 id="计算">计算</h2>
<h3 id="平均码长">平均码长</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240530193731704.png" /></p>
<h1 id="单源最短路">单源最短路</h1>
<h2 id="算法思路-1">算法思路</h2>
<p>每次根据dis数组将距离当前节点集合最近的节点加入集合，然后重新修改dis，并且也修改记录前驱节点的数组prev</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/20952fca63043ef6e6755fe6a21f694.jpg" /></p>
<h1 id="最小生成树">最小生成树</h1>
<h2 id="prim算法">Prim算法</h2>
<h3 id="算法原理">算法原理</h3>
<p>和迪杰斯特拉很像，也是维护dis数组，记录距离当前集合距离，每次将距离当前集合最近的节点放入集合</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240530200445.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240530200455.jpg" /></p>
<h2 id="kruskal算法">Kruskal算法</h2>
<h3 id="算法原理-1">算法原理</h3>
<p>每次将权值最小的边加入集合</p>
<h1 id="多机调度">多机调度</h1>
<h2 id="算法思想">算法思想</h2>
<p>优先安排耗时最长的任务</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/416f745b2d57c01c5b126af2b51758d.jpg" /></p>
]]></content>
      <categories>
        <category>算法设计与分析</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/posts/2ba40472.html</url>
    <content><![CDATA[<h1 id="第一章-操作系统概述">第一章 操作系统概述</h1>
<span id="more"></span>
<blockquote>
<p>思考：</p>
<ul>
<li>操作系统的功能有哪些？</li>
<li>操作系统有哪些特征？最基本的特征是什么？</li>
<li>什么是批处理系统？单道批处理系统与多道批处理系统的区别？</li>
<li>什么是硬实时任务和软实时任务？</li>
<li>在交互性、及时性以及可靠性方面，分时系统与实时系统有什么区别？</li>
<li>CPU有哪些运行模式？什么事情会导致用户态转为内核态?</li>
<li>什么是特权指令和非特权指令？有哪些常见的特权指令？</li>
<li>发生中断或异常应该如何处理？</li>
<li>系统调用的过程是怎样的？</li>
</ul>
</blockquote>
<h2 id="操作系统的基本概念">1.1 操作系统的基本概念</h2>
<h3 id="操作系统的概念">1.1.1 操作系统的概念</h3>
<p><strong>操作系统</strong>是指控制和管理整个计算机系统的硬件与软件资源，合理的组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。
操作系统是最基本的系统软件。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230422221717441.png" /></p>
<p><strong>主要作用</strong>：对整个计算机系统的软硬件资源进行管理和控制，提高资源的利用率和系统的吞吐量，并对计算机的工作和资源的分配进行合理的组织和调度，为用户和应用程序提供方便访问的接口。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230422221736931.png" /></p>
<p>操作系统位于用户层和硬件层之间，向上提供服务，向下管理资源。</p>
<p>牢记一句话：操作系统是<font color = "red">管理计算机资源</font>的软件</p>
<p>举例：操作系统关心什么不关心什么</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c9312f0b8ca397a9b27095c412389e5.jpg" /></p>
<p>第2题看图就能看出来。解释源程序为什么不是操作系统管理：操作系统关心文件放在哪，不关心这是什么文件</p>
<h3 id="操作系统的特征">1.1.2 操作系统的特征</h3>
<h4
id="并发操作系统最基本特征">并发(<font color = "red">操作系统最基本特征</font>)</h4>
<ul>
<li>并发是指两个或多个事件在同一时间间隔内发生。</li>
<li>操作系统的并行性是指计算机系统中同时存在多个运行的程序。</li>
<li>并发(交替)：同一时间间隔； 并行(同时)：同一时刻</li>
<li>单核处理器使用并发，多核处理器使用并行。</li>
<li>程序并发性体现在两个方面：
<ul>
<li>用户程序与用户程序之间的并发执行</li>
<li>用户程序与操作系统程序之间的并发执行</li>
</ul></li>
</ul>
<h4
id="共享操作系统最基本特征">共享(<font color = "red">操作系统最基本特征</font>)</h4>
<p>资源共享(资源复用)即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ol type="1">
<li>互斥共享方式
<ul>
<li>在一段时间内只允许一个进程访问该资源。</li>
<li>在一段时间内只允许一个进程访问的资源称为<strong>临界资源</strong>或<strong>独占资源</strong>。</li>
<li>临界资源：栈、变量和表格。</li>
</ul></li>
<li>同时访问方式
<ul>
<li>另一类资源允许在一段时间内由多个进程"同时"访问。</li>
<li>这里的"同时"是宏观说法，在微观上，这些进程是交替进行访问的。</li>
</ul></li>
</ol>
<p>并发和共享是操作系统两个最基本的特征。</p>
<p>两者之间互为存在的条件：</p>
<ul>
<li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题。</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li>
</ul>
<h4 id="虚拟">虚拟</h4>
<p>虚拟是把一个物理上的实体变为若干逻辑上的对应物。用于实现虚拟的技术，称为虚拟技术。</p>
<ul>
<li>利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的
CPU，称为<strong>虚拟处理器</strong>。</li>
<li>采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，把用户感觉到的(但实际不存在的)存储器称为<strong>虚拟存储器</strong>。</li>
<li>采用虚拟设备技术将一台物理 I/O 设备虚拟为多台逻辑上的 I/O
设备，使原来仅允许在一段时间内由一个用户访问的设备变为在一段时间内允许多个用户同时访问的共享设备。</li>
</ul>
<p>操作系统的虚拟技术：</p>
<ol type="1">
<li>时分复用技术：通过减少处理器和 I/O
设备的空闲时间，来提高计算机资源的利用率，如处理器的分时共享；
<ul>
<li>虚拟处理器技术：将一个物理上的处理器虚拟为多台逻辑上的处理器，用户说感觉到的处理器称为虚拟处理器。</li>
<li>虚拟设备技术：通过虚拟设备技术将一台物理上的 I/O
设备虚拟为多台逻辑上的 I/O 设备。</li>
</ul></li>
<li>空分复用技术：利用存储器的空闲空间区域存放和运行其他的多道程序，以此来提高内存的利用率，如虚拟存储器。
<ul>
<li>虚拟磁盘技术：通过虚拟磁盘技术将一台硬盘虚拟为多台虚拟硬盘。</li>
<li>虚拟存储器技术：将内存分成很多个区域，每个区域存放不同进程，提高内存利用率。</li>
</ul></li>
</ol>
<h4 id="异步">异步</h4>
<p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>
<h3 id="操作系统的目标和功能">1.1.3 操作系统的目标和功能</h3>
<p>操作系统应该具有以下几个功能：</p>
<ol type="1">
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
</ol>
<p>同时操作系统可以用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<h4
id="操作系统作为计算机系统资源的管理者">操作系统作为计算机系统资源的管理者</h4>
<ol type="1">
<li><p>处理机管理</p>
<p>处理机的分配和运行都以进程(或线程)为基本单位。</p>
<p>主要功能：<strong>进程控制</strong>、<strong>进程同步</strong>、<strong>进程通信</strong>、<strong>死锁处理</strong>、<strong>处理机调度</strong></p></li>
<li><p>存储器管理</p>
<p>存储器管理是为了给多道程序的运行提供良好环境，方便用户使用及提高内存的利用率。</p>
<p>主要功能：<strong>内存分配与回收</strong>、<strong>地址映射</strong>、<strong>内存保护与共享</strong>、<strong>内存扩充</strong></p></li>
<li><p>文件管理</p>
<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为<strong>文件系统</strong>。</p>
<p>主要功能：<strong>文件存储空间的管理</strong>、<strong>目录管理</strong>、<strong>文件读写管理和保护</strong></p></li>
<li><p>设备管理</p>
<p>设备管理的主要任务是完成用户的 I/O 请求，方便用户使用各种设备。</p>
<p>主要功能：缓冲管理、设备分配、设备处理和虚拟设备</p></li>
</ol>
<h4
id="操作系统作为用户与计算机硬件系统之间的接口">操作系统作为用户与计算机硬件系统之间的接口</h4>
<p>操作系统提供的接口主要分为两类：</p>
<ul>
<li><p>一类是命令接口，用户利用这些操作命令来组织和控制作业的执行。</p></li>
<li><p>另一类是程序接口，编程人员可以用它们来请求操作系统服务。</p></li>
</ul>
<ol type="1">
<li><p>命令接口 两种方式进行作业控制：联机控制方式和脱机控制方式。
按作业控制方式不同，可分为：联机命令接口和脱机命令接口。</p>
<ol type="1">
<li>联机命令接口(交互式命令接口)，适用于分时或实时系统的接口。</li>
<li>脱机命令接口(批处理命令接口)，适用于批处理系统。</li>
</ol></li>
<li><p>程序接口(也叫系统调用)</p>
<ol type="1">
<li><p>程序接口由一组系统调用(也称广义指令)组成。</p></li>
<li><p>是操作系统为应用程序使用内核功能所提供的接口。最常见的是GUI图形窗口</p></li>
<li><p>是操作系统提供给编程人员的接口</p></li>
<li><p>目的是请求系统服务</p></li>
<li><p>只能通过用户程序间接使用</p></li>
</ol>
<p>举例：</p>
<p>题1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5869e055a57aac69774ac19bf12661e.jpg" /></p>
<p>题2 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0edeabcbe2f1b01275328b42fb1ae23.jpg" /></p>
<p>操作系统与用户通信的接口是命令接口和程序接口(系统调用)</p>
<p>A：shell，命令解析器，属于命令接口</p>
<p>B：命令解释器，命令接口</p>
<p>C：广义指令，就是系统调用命令</p>
<p>D：操作系统不提供管理系统缓存的系统调用</p></li>
</ol>
<h4
id="操作系统实现了对计算机资源的扩充">操作系统实现了对计算机资源的扩充</h4>
<p>没有任何软件支持的计算机称为<strong>裸机</strong>。</p>
<p>把覆盖了软件的机器称为<strong>扩充机器或虚拟机</strong>。</p>
<h2 id="操作系统的发展历程">1.2 操作系统的发展历程</h2>
<h3 id="手工操作阶段">1.2.1 手工操作阶段</h3>
<p>此阶段无操作系统，所有的工作都需要人工干预。</p>
<p>两个缺点(人机矛盾)：</p>
<ul>
<li>用户独占全机，所有计算机资源在一段时间内只能被一个用户使用。</li>
<li>CPU 需要等待人工操作，这造成 CPU
和内存资源大部分时间处于空闲状态。</li>
</ul>
<h3 id="批处理操作系统">1.2.2 批处理操作系统</h3>
<h4 id="单道批处理系统">单道批处理系统</h4>
<p>利用脱机输入输出的方式，在监督程序的控制下实现连续工作。</p>
<p>特征：</p>
<ul>
<li>自动性。磁带上的一批作业能自动地逐个运行，无需人工干预。</li>
<li>顺序性。先调入内存的作业先完成。</li>
<li>单道性(封闭性)
。监督程序每次从磁带上只调入一道程序进入内存运行，当程序完成或异常时，才切换后继程序继续运行。</li>
</ul>
<p>优点：解决了人机矛盾和 CPU 与 I/O
设备速度不匹配的问题，提高系统资源的利用率和系统吞吐率。</p>
<p>缺点：每次只能运行一道程序，不能充分利用系统资源。</p>
<h4 id="多道批处理系统">多道批处理系统</h4>
<p>多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU
中交替地运行，这些程序共享系统中的各种软硬件资源。</p>
<p>特点：</p>
<ul>
<li>多道。计算机内存中同时存放多道互相独立的程序。</li>
<li>宏观上并行。同时进入系统的多道程序都处于运行过程中。</li>
<li>微观上串行。内存中的多道程序轮流占有 CPU，交替执行。</li>
</ul>
<p>举例：</p>
<p><font color = "red">多道相对于单道失去了单道的顺序性和封闭性</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/954c6788eddf5997a124a650fd20e97.jpg" /></p>
<p>实现多道程序设计技术需要解决下列问题：</p>
<ul>
<li>如何分配处理器</li>
<li>多道程序的内存分配问题</li>
<li>I/O 设备如何分配</li>
<li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性</li>
</ul>
<p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。</p>
<figure>
<img
src="D:/HuaweiMoveData/Users/piolet/Desktop/2024-Postgraduate-408-main/OperatingSystem/ch1/assets/image-20230422223017021.png"
alt="image-20230422223017021" />
<figcaption aria-hidden="true">image-20230422223017021</figcaption>
</figure>
<p>优点：系统利用率高，多道程序共享计算机资源；系统吞吐量大，CPU
和其他资源保持忙碌状态。</p>
<p>缺点：用户响应的时间较长；没有人机交互功能。</p>
<blockquote>
<p>❗<font color = "red">无论是单道批处理系统还是多道批处理系统，用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互</font>，这对修改和调试程序是极不方便的。</p>
</blockquote>
<p>举例：</p>
<p>题1</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/be16b40173415a560a5e4ed02a8a8c2.jpg" /></p>
<p>A：脱机技术，对应知识点是1.1.3操作系统作为用户与计算机硬件之间的接口中的命令接口里的脱机命令接口。用于解决独占设备的问题。</p>
<p>B：虚拟技术，以多道程序设计技术为前提</p>
<p>C：交换技术，以多道程序设计技术为前提</p>
<p>D：同时在主存中运行多个程序，提高利用率</p>
<p>题2 计算利用率</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8b910ec5175b426a160105ad32df12b.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d29ab25e68b0825e80c0489806004cb.jpg" /></p>
<p><font color = "red">(1)计算一个东西的利用率是将这个东西所画的时间/总时间</font></p>
<p><font color = "red">(2)多批次常画图(甘特图)</font></p>
<p><font color = "red">(3)甘特图中不同形状的线表示不同的任务，相同的任务就是相同形状的线</font></p>
<h3 id="分时操作系统">1.2.3 分时操作系统</h3>
<p>分时技术：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。</p>
<p>关于时间片举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1644b9853259045dc285fb122d718ff.jpg" /></p>
<p>分时操作系统：多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。所以分时操作系统追求的目标是<font color = "red">快速响应用户</font></p>
<blockquote>
<p>多道批处理是实现作业自动控制而无需人工干预的系统，分时系统是实现人机交互的系统。</p>
</blockquote>
<p>分时系统的特征：</p>
<ul>
<li>同时性(多路性)：一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li>
<li>交互性：用户能够方便地与系统进行人机对话。</li>
<li>独立性：系统中多个用户可以彼此独立地进行操作，互不干扰。</li>
<li>及时性：用户请求能在很短时间内获得响应。</li>
</ul>
<h3 id="实时操作系统">1.2.4 实时操作系统</h3>
<p>实时系统：系统能够及时地对外部请求作出相应，并在规定的时间处理该事件，让所有实时任务协调一致的运行。</p>
<p>软实时系统：可以允许或容忍偶尔出现某一事件没在规定时间内完成处理。</p>
<p>硬实时系统：任何时刻都要绝对保证某个事件在规定的时刻得到处理和响应。</p>
<p>实时操作系统具有以下特征：（说白了就是<font color = "red">一要快，二要可靠</font>)</p>
<ul>
<li>多路性：系统周期性地采集多路现场的信息，以及同时控制多个对象和执行机构。</li>
<li>独立性：系统在采集信息和控制对象的时候都是互不影响、彼此独立的。</li>
<li>实时性：系统的实时性是严格根据控制对象所规定的截止时间来确定的。</li>
<li>交互性：用户通过和程序直接交互来控制它的运行。</li>
<li>可靠性：实时系统要求高度可靠，因为任何差错都会产生无法预料的灾难性后果。</li>
</ul>
<p>实时操作系统的进程调度通常采用<font color = "red">抢占式的优先级高者优先</font></p>
<h3 id="其他操作系统">1.2.5 其他操作系统</h3>
<p>网络操作系统：网络环境下管理和控制网络资源的操作系统，其建立在网络中不同计算机的单机操作系统之上，为用户提供了使用网络资源的接口。</p>
<p>分布式操作系统：配置在分布式系统上的操作系统，可以直接对分布式系统中的各种资源进行动态分配。分布式操作系统管理若干计算机，使它们协调配合完成同一个任务。</p>
<h3 id="小结">小结</h3>
<p>允许多个用户以交互的方式使用计算机的操作系统，叫<font color = "red">分时操作系统</font></p>
<p>允许多个用户将若干作业提交给计算机系统几种处理的操作系统，叫<font color = "red">批处理操作系统</font></p>
<p>能及时处理由过程控制反馈的数据的操作系统，叫<font color = "red">实时操作系统</font></p>
<h2 id="操作系统运行环境">1.3 操作系统运行环境</h2>
<h3 id="处理器运行模式">1.3.1 处理器运行模式</h3>
<p>CPU
通常执行两种不同性质的程序：一种是<strong>操作系统内核程序</strong>，一种是<strong>用户自编程序</strong>(即应用程序)。</p>
<p>其中内核程序是应用程序的“管理者”，因此内核程序要执行一些特权命令，而应用程序处于安全考虑不能执行这些指令：</p>
<ul>
<li>特权指令：指不允许用户直接使用的指令。</li>
<li>非特权指令：指允许用户直接使用的指令。</li>
</ul>
<p>用户程序调用系统 API
函数称为<strong>系统调用</strong>，一旦发生了系统调用，将暂停用户程序的运行，转而执行内核代码，访问内核空间，这称为<strong>内核模式</strong>(即内核态)。从用户态到核心态是通过<font color = "red">硬件</font>完成。执行的是<font color = "red">“访管”</font>指令</p>
<p>当在用户空间执行应用程序自己的代码时，称为<strong>用户模式</strong>(即用户态)。</p>
<p>举例</p>
<ul>
<li>题1：核心态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/1177dc2e6949375861d3ac357a5ebe3.jpg" /></p>
<p>1:批处理的缺点是交互性不足</p>
<p>2：输出/输出需要中断，中断就必须在核心态下执行</p>
<p>3：多道程序设计是为了提高利用率</p>
<p>4：记着就行</p>
<ul>
<li>题2：核心态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/49596ecb3397a0e95148c80257f4df4.jpg" /></p>
<p>ACD都可以通过汇编语言实现，即用户态。而置时钟指令可以这么理解，如果用户可以直接调用，那一个用户可以通过修改自己的时间从而一直占用时间片。</p>
<p><font color = "red">注意区分“调用”和“执行”</font>，用户程序可以调用系统调用指令，但系统调用指令一定执行在核心态</p>
<ul>
<li>题3：用户态指令</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/d517ad28b285b211ba4bfbe7f187455.jpg" /></p>
<p>缺页处理和时钟中断都是中断，都在核心态下执行。</p>
<p>进程调度用户更管不着，也在核心态下执行</p>
<p>命令解释属于命令接口，能面对用户</p>
<ul>
<li><font color = "red">题4：用户态指令，注意与上一题区别</font></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/71f3699b7ea98de3d73bb384b8ebb2b.jpg" /></p>
<p>A：系统调用就是操作系统留给用户程序的接口。系统调用发生在用户态，被调用程序在核心态下运行</p>
<p>B：外部中断是用户态到核心态的“门”，发生在用户态，在核心态下完成中断过程</p>
<p>C：进程切换是系统调用发生过程中的事件</p>
<p>D：缺页在用户态产生，然后进入核心态执行缺页中断服务程序/</p>
<ul>
<li>题5：核心态与用户态之间转换</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/dc4c6f5cde3f303d09bf7ea018f139d.jpg" /></p>
<p>A：可能发生除0的异常</p>
<p>B：都告诉你中断了</p>
<p>C：用户态就可以</p>
<p>D：可能会缺页异常</p>
<p>操作系统内核有以下几种功能：</p>
<ul>
<li>资源抽象：屏蔽底层的硬件细节，使应用程序独立于实际使用的物理资源。</li>
<li>资源分配和回收：将抽象资源分配给应用程序，并在适当的时机进行回收。</li>
<li>资源共享：允许进程共享资源，并提供进程同步和互斥机制，以协助多道程序并发执行。</li>
</ul>
<p>操作系统内核还包括四个方面的内容：</p>
<ul>
<li>时钟管理
<ul>
<li>在计算机的各种部件中，时钟是最关键的设备。</li>
<li>时钟的功能：
<ul>
<li>计时：操作系统需要通过时钟管理，向用户提供标准的系统时间。</li>
<li>中断管理：实现进程的切换。</li>
</ul></li>
</ul></li>
<li>中断机制
<ul>
<li>中断机制是操作系统各项操作的基础。</li>
<li>中断机制中，只有一小部分属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</li>
</ul></li>
<li>原语
<ul>
<li>把具有以下特点的程序称为<strong>原语</strong>：
<ul>
<li>处于操作系统的最底层，是最接近硬件的部分。</li>
<li>这些程序的运行具有原子性，其操作只能一气呵成。</li>
<li>这些程序的运行时间都较短，而且调用频繁。</li>
</ul></li>
<li>定义原语的方法：关闭中断，让其所有动作都不可分割地完成后再打开中断。</li>
</ul></li>
<li>系统控制的数据结构及处理
<ul>
<li>系统常见的操作：
<ul>
<li>进程管理。</li>
<li>存储器管理。</li>
<li>设备管理。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="中断和异常的概念">1.3.2 中断和异常的概念</h3>
<p>操作系统内核工作在核心态，而用户程序工作在用户态。</p>
<p><font color = "red">发生中断或异常时，运行用户态的 CPU
会立即进入核心态。</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230316210022128.png" alt="image-20230316210022128" style="zoom:50%;" /></p>
<h4 id="中断外部中断">中断(外部中断)</h4>
<blockquote>
<p>中断是一种由 I/O 外部设备触发的异步事件，它<font color = "red">与 CPU
正在执行的指令无关</font>，中断提供了外设与 CPU
交流的机制，它也是一种重要的输入输出方式。</p>
</blockquote>
<ol type="1">
<li><p>可屏蔽中断</p>
<p>可屏蔽中断是指通过 INTR
线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</p></li>
<li><p>不可屏蔽中断</p>
<p>不可屏蔽中断是指通过 NMI
线发出的中断请求，通常是紧急的硬件故障。</p></li>
</ol>
<h4 id="异常内部异常">异常(内部异常)</h4>
<blockquote>
<p>异常是 CPU 执行当前指令产生的事件，是同步发生的，与 CPU
正在执行的指令密切相关。</p>
</blockquote>
<ol type="1">
<li><p>故障(fault)</p>
<ul>
<li>故障是一种可能恢复的异常事件。</li>
<li>若可以修复，则 CPU 跳转到引起故障的指令继续进行。</li>
<li>若不能修复，则终止当前程序。</li>
</ul></li>
<li><p>陷阱(trap)</p>
<ul>
<li><p>陷阱是一种有意安排的异常事件。</p></li>
<li><p>陷阱指令也称为<strong>访管指令</strong>、<strong>陷入指令</strong>。</p>
<p>举例</p></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9b7e3926ef45b401339cf966cca1456.jpg" /></p>
<p>用户程序运行特权指令会转成操作系统的核心去运行。其中的中断叫访管中断，属于内部中断</p></li>
<li><p>终止(abort)</p>
<ul>
<li>终止是一种无法恢复的异常事件。</li>
</ul></li>
</ol>
<h4
id="中断与异常的处理过程中断处理是操作系统必须提供的功能">中断与异常的处理过程(<font color = "red">中断处理是操作系统必须提供的功能</font>)</h4>
<ol type="1">
<li><p>中断响应过程(<font color = "red">都是由硬件CPU执行</font>)</p>
<ol type="1">
<li><p>关中断</p>
<p>CPU
首先要关中断，禁止在进行中断处理时又去响应新的中断，防止保存的断点、程序状态字、现场信息被破坏。</p></li>
<li><p>保存断点和程序状态字</p>
<p>断点和状态字信息在特殊的寄存器中(PC 和 PSW)，CPU
会将这两个寄存器内容压栈。</p>
<p>其中<font color = "red">PC</font>的内容由<font color = "red">中断隐指令</font>自动保存，<font color = "red">PSW通用寄存器内容</font>由<font color = "red">操作系统</font>保存</p></li>
<li><p>引出中断服务程序</p>
<p>CPU
检测到中断信号后对具体中断源进行识别，以此引出对应的中断服务程序。并将CPU模式修改为内核态</p></li>
</ol></li>
<li><p>中断处理过程(<font color = "red">由软件操作系统完成</font>)</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/767740c0a7e0a2b2d667f428770298d.jpg" alt="767740c0a7e0a2b2d667f428770298d" style="zoom:25%;" /></p>
<ol type="1">
<li>保护现场</li>
<li>执行中断处理程序</li>
<li>恢复现场</li>
</ol>
<p>举例</p>
<ul>
<li>题1：进入中断处理的程序</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ea43341cdce13960f602dca625c1ffb.jpg" /></p>
<p>无论中断程序是用户还是OS程序，进入中断处理的一定是OS程序</p>
<ul>
<li>题2：中断的保存内容</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/66cab669bcc414763c92e7949fac43e.jpg" /></p>
<p>子程序调用只需要保存断点，即该指令的下一条指令的地址</p>
<p>中断处理不仅要保存断点(PC的内容)，还要保存程序状态字寄存器(PSW的内容)</p>
<ul>
<li><p>题3：中断的保存内容</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/a45350a0a4dc169a07783d348554c06.jpg" /></p></li>
<li><p>题4：中断中由操作系统完成的部分</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/c09f3f5bd07e81a0d956602379f5d37.jpg" /></p>
<p>答案：B</p>
<p><img
src="D:\MyDownloads\Software\wechatfile\WeChat%20Files\wxid_6hyhf91zyxtg22\FileStorage\Temp\a45350a0a4dc169a07783d348554c06.jpg" /></p>
<p>答案：D</p></li>
</ul></li>
</ol>
<p>​</p>
<h4 id="小结-1">小结</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">产生原因</th>
<th style="text-align: center;">同步/异步</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">中断</td>
<td style="text-align: center;">I/O 设备的请求信号</td>
<td style="text-align: center;">异步</td>
<td>返回下一条指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">故障</td>
<td style="text-align: center;">可能恢复的异常事件</td>
<td style="text-align: center;">同步</td>
<td>可能返回当前指令</td>
</tr>
<tr class="odd">
<td style="text-align: center;">陷阱</td>
<td style="text-align: center;">有意安排的异常事件</td>
<td style="text-align: center;">同步</td>
<td>返回下一条指令</td>
</tr>
<tr class="even">
<td style="text-align: center;">终止</td>
<td style="text-align: center;">无法恢复的异常事件</td>
<td style="text-align: center;">同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<h3 id="系统调用">1.3.3 系统调用</h3>
<p>陷阱是一种有意安排的内部异常事件，这样安排的目的是实现系统调用。</p>
<p>所谓系统调用，是指用户在程序中调用系统所提供的一些子功能，系统调用可视为特殊的公共子程序。</p>
<p>系统调用的功能：</p>
<ul>
<li>设备管理：完成设备的请求和释放，以及设备启动等功能。</li>
<li>文件管理：完成文件的读、写、创建及删除等功能。</li>
<li>进程控制：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信：完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<p>用户程序可以执行陷入指令来发起系统调用，请求操作系统提供服务。</p>
<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
<p>举例</p>
<ul>
<li>题1</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6f5f6c7857145603cc107a9ccb9f5e3.jpg" /></p>
<p>1：系统调用需要触发trap指令</p>
<p>2：程序设计无法形成屏蔽中断指令</p>
<p>3：系统调用的概念</p>
<p>4：操作系统的作用</p>
<ul>
<li><p>题2</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9fa388ae4d1221e7a5614c76383717a.jpg" /></p></li>
</ul>
<p>​ 1：断句，对</p>
<p>​ 2：对</p>
<p>​ 3：linux会和windows一样吗？错</p>
<p>​ 4：对</p>
<h3 id="程序的链接与装入">1.3.4 程序的链接与装入</h3>
<p>要使一个程序能在多道程序环境下运行，首先要做的事情是创建进程，而创建进程的首要任务是将程序和数据装入内存。</p>
<p>要将一个用户源程序变为一个可在内存中执行的程序，一般有以下几个步骤：</p>
<ol type="1">
<li><p>编译</p>
<p>由编译程序将用户源代码编译成 CPU
可执行的目标代码，产生了若干个目标模块。</p></li>
<li><p>链接</p>
<p>由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块。</p></li>
<li><p>装入</p>
<p>由装入程序将装入模块装入内存。</p></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/39cce9e3e82a7e9df213b7acc0b171d.jpg" alt="39cce9e3e82a7e9df213b7acc0b171d" style="zoom: 25%;" /></p>
<h4 id="程序的装入地址的变换">程序的装入(地址的变换)</h4>
<ul>
<li><p>绝对装入方式</p>
<p>按照物理内存的位置赋予实际的物理地址。</p></li>
<li><p>静态地址重定位(可重定位装入方式)</p>
<p>静态地址重定位是指在程序开始运行前，程序中指令和数据的各个地址均已完成重定位，此时就已经完成了虚拟地址到内存地址的变换，并且以后不再改变。</p></li>
<li><p>动态地址重定位(动态运行时装入方式)</p>
<p>动态地址重定位方式是在程序执行过程中进行地址变换。</p></li>
</ul>
<h4 id="程序的链接">程序的链接</h4>
<p>源程序经过编译后，可得到一组目标模块，再利用链接程序将这组目标模块链接，形成装入模块。</p>
<p>根据链接的时间不同，可把链接分为以下三种:</p>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，不再拆开。</li>
<li>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对某些目标模块进行链接。</li>
</ul>
<h3 id="程序运行时的内存映像与地址空间">1.3.5
程序运行时的内存映像与地址空间</h3>
<p>地址空间：指的是一组非负整数地址的集合。</p>
<p>采用虚拟地址的好处：</p>
<ul>
<li>每个进程的虚拟地址空间是独立的，方便操作系统之上的用户编程，在多道程序并发的情况下，防止其他进程的干扰破坏。</li>
<li>所有进程的虚拟地址空间的大小和结构划分是一致的，这简化了操作系统对存储器的管理。</li>
<li>将主存看做外部存储器的缓存副本，根据实际运行需要进行信息的交换，可以节省主存空间。</li>
</ul>
<p>程序运行时的内存映像指的是进程在内存中存放和组织的方式，进程会被映射到一个统一的虚拟地址空间。</p>
<p><img align="right" src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5f826210f563db759a6b5047c946cc4.jpg" style="zoom:25%;" /></p>
<p><strong>只读代码和数据区</strong>：进程虚拟地址从此区域开始，该区域存放进程的只读代码和只读数据。</p>
<p><strong>可读/写数据区</strong>：该区域存放进程的可读可写数据。</p>
<p><strong>运行时堆</strong>：由进程在运行时动态创建，该区域可以动态增长和收缩。</p>
<p><strong>共享库</strong>：该区域用于存放公共的共享库代码和数据。</p>
<p><strong>用户栈</strong>：该区域用来存放局部变量、返回地址、函数调用参数等信息。</p>
<p><strong>操作系统内核区</strong>：该区域是操作系统内核使用的地址空间，包括内核程序、代码、内核栈等信息，这些信息对用户程序不可见。</p>
<h2 id="操作系统的体系结构">1.4 操作系统的体系结构</h2>
<h3 id="分层结构">1.4.1 分层结构</h3>
<p>特性：内核分多层，每层可单向调用更低一层提供的接口。</p>
<p>优点：</p>
<ul>
<li>便于调试和验证，自底向上逐层调试验证。</li>
<li>易扩充和易维护，各层之间调用接口清晰固定。</li>
</ul>
<p>缺点：</p>
<ul>
<li>仅可调用相邻低层，难以合理定义各层的边界。</li>
<li>效率低，不可跨层调用，系统调用执行时间长。</li>
</ul>
<h3 id="模块化">1.4.2 模块化</h3>
<p>特性：将内核划分为多个模块，各模块之间相互协作。</p>
<ul>
<li>内核 = 主模块 + 可加载内核模块</li>
<li>主模块：只负责核心功能。</li>
<li>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核。</li>
</ul>
<p>优点：</p>
<ul>
<li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发。</li>
<li>支持动态加载新的内核模块，增强OS适应性。</li>
<li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>模块间的接口定义未必合理、实用。</li>
<li>模块间相互依赖，更难调试和验证。</li>
</ul>
<h3 id="宏内核大内核">1.4.3 宏内核(大内核)</h3>
<p>特性：所有的系统功能都放在内核里。</p>
<p>优点：性能高，内核内部各种功能都可以直接相互调用。</p>
<p>缺点：</p>
<ul>
<li>内核庞大功能复杂，难以维护。</li>
<li>大内核中某个功能模块出错，就可能导致整个系统崩溃。</li>
</ul>
<h3 id="微内核">1.4.4 微内核</h3>
<p>特性：</p>
<ul>
<li>只把中断、原语、进程通信等最核心的功能放入内核。</li>
<li>进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。</li>
</ul>
<p>优点：</p>
<ul>
<li>内核小功能少、易于维护，内核可靠性高。</li>
<li>内核外的某个功能模块出错不会导致整个系统崩溃。</li>
<li>添加系统服务时不必修改内核</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能低，需要频繁切换用户态和核心态。</li>
<li>用户态下的各功能模块不可以直接相互调用，只能通过内核的“消息传递”来间接通信。</li>
</ul>
<h3 id="外核">1.4.5 外核</h3>
<p>特性：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>
<p>优点：</p>
<ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源。</li>
<li>减少了虚拟硬件资源的“映射层”，提升效率。</li>
</ul>
<p>缺点：</p>
<ul>
<li>降低了系统的一致性。</li>
<li>使系统变得更复杂。</li>
</ul>
<h2 id="操作系统引导">1.5 操作系统引导</h2>
<p>基本输入输出系统BIOS是一种固化到计算机内主板上的一个只读存储器芯片内的一种固件。</p>
<p>常见操作系统的引导过程：</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230318174400336.png"
alt="image-20230318174400336" />
<figcaption aria-hidden="true">image-20230318174400336</figcaption>
</figure>
<ul>
<li>引导程序位于硬盘中，且只会将硬盘中存储的操作系统内核加入到内存，其他部分仅在需要时才加入</li>
</ul>
<h2 id="虚拟机">1.6 虚拟机</h2>
<p><strong>基本概念</strong>：虚拟机是一台逻辑计算机，是指利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。</p>
<h4 id="两类虚拟机管理程序vmm的对比">两类虚拟机管理程序(VMM)的对比</h4>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>第一类VMM</th>
<th>第二类VMM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>对物理资源的控制权</td>
<td>直接运行在硬件之上，能直接控制和分配物理资源</td>
<td>运行在Host OS之上，依赖于Host OS为其分配物理资源</td>
</tr>
<tr class="even">
<td>资源分配方式</td>
<td>安装Guest
OS时，VMM在原本的硬盘上自行分配存储空间。<br />类似于外核，分配未经抽象的物理硬件。</td>
<td>GuestOS拥有自己的虚拟磁盘，该盘实际上是Host
OS文件系统中的一个大文件。<br />GuestOS分配到的内存是虚拟内存。</td>
</tr>
<tr class="odd">
<td>性能</td>
<td>性能更好</td>
<td>性能更差，需要HostOS作为中介</td>
</tr>
<tr class="even">
<td>可支持的虚拟机数量</td>
<td>更多，不需要和HostOS竞争支援，相同的硬件资源可以支持更多的虚拟机</td>
<td>更少，HostOS本身需要使用物理资源，HostOS上运行的其他进程也需要物理资源</td>
</tr>
<tr class="odd">
<td>虚拟机的可迁移性</td>
<td>更差</td>
<td>更好</td>
</tr>
<tr class="even">
<td>运行模式</td>
<td>运行在最高特权级(Ring0)，可以执行最高特权的指令</td>
<td>部分运行在用户态，部分运行在内核态。</td>
</tr>
</tbody>
</table>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/635b663711bb4472dc56a2531e8c621.jpg" /></p>
<p>3有迷惑性。这顶多叫并发不是并行。多核处理器才能实现并行</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.4_进程管理（经典进程同步问题）</title>
    <url>/posts/bcd9e18a.html</url>
    <content><![CDATA[<h2 id="生产者-消费者问题">生产者-消费者问题</h2>
<span id="more"></span>
<ul>
<li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用；</li>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区；</li>
<li>只有缓冲区<strong>没满</strong>时，生产者才能把产品<strong>放入</strong>缓冲区，否则必须等待；</li>
<li>只有缓冲区<strong>不空</strong>时，消费者才能从中<strong>取出</strong>产品，否则必须等待；</li>
<li>缓冲区是临界资源，各进程必须<strong>互斥地</strong>访问。</li>
</ul>
<h3 id="分析关系">分析关系</h3>
<p><a
href="https://www.youtube.com/watch?v=HTttVIGar5o">视频讲解</a></p>
<ul>
<li>生产者和消费者访问缓冲区是<strong>互斥</strong>的；</li>
<li>生产者和消费者的工作需要<strong>同步</strong>，即生产完成之后才能消费。</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bb6123b218773c901d59f9fda3caf01.png"
alt="生产者-消费者同步关系" />
<figcaption aria-hidden="true">生产者-消费者同步关系</figcaption>
</figure>
<h3 id="设置信号量">设置信号量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1;    //互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty = n;    //同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full = 0;     //同步信号量，表示产品（非空缓冲区）的数量</span><br></pre></td></tr></table></figure>
<h3 id="实际代码">实际代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        生产产品</span><br><span class="line">        P(empty);    //申请新的缓冲区</span><br><span class="line">        P(mutex);    //申请访问临界资源</span><br><span class="line">        存入缓冲区</span><br><span class="line">        V(mutex);    //释放临界资源</span><br><span class="line">        V(full);     //释放一个消费品（非空缓冲区）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(full);     //申请使用消费品</span><br><span class="line">        P(mutex);    //申请访问临界资源</span><br><span class="line">        从缓冲区取出</span><br><span class="line">        V(mutex);    //释放临界资源</span><br><span class="line">        V(empty);    //释放一个空缓冲区</span><br><span class="line">        消费产品</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<strong>互斥</strong>的P操作一定要在实现<strong>同步</strong>的P操作<strong>之后</strong></p>
<p>两个V操作可以交换顺序</p>
<h2 id="多生产者-多消费者问题">多生产者-多消费者问题</h2>
<p><a
href="https://www.youtube.com/watch?v=_qRkPAKAy6E">视频讲解</a></p>
<p>有父亲、母亲、儿子、女儿四人，其中：</p>
<ul>
<li>父亲往盘子中放苹果；</li>
<li>母亲往盘子中放橘子；</li>
<li>女儿从盘子中拿苹果；</li>
<li>儿子从盘子中拿橘子；</li>
<li>只有盘子空时才能放水果；</li>
<li>只有有需要的水果时才能拿水果。</li>
</ul>
<h3 id="分析关系-1">分析关系</h3>
<p><a
href="https://www.youtube.com/watch?v=lt8BUlwQONM">视频讲解：分析关系时图的画法</a></p>
<ul>
<li>互斥
<ul>
<li>对盘子的访问是互斥的</li>
</ul></li>
<li>同步
<ul>
<li>父亲放入苹果后，女儿才能拿苹果</li>
<li>母亲放入橘子后，儿子才能拿橘子</li>
<li>盘子为空时才能放水果</li>
</ul></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/38a6af127c98159ee7dcd6d08b9bc24.jpg" /></p>
<h3 id="设置信号量-1">设置信号量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1;    //互斥信号量，实现盘子的互斥访问</span><br><span class="line">semaphore plate = 1;    //同步信号量，代表盘子的剩余空位</span><br><span class="line">semaphore apple = 0;    //同步信号量，代表苹果数量</span><br><span class="line">semaphore orange = 0;   //同步信号量，代表橘子数量</span><br></pre></td></tr></table></figure>
<h3 id="实际代码-1">实际代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dad()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        准备苹果</span><br><span class="line">        P(plate);        //申请盘子资源</span><br><span class="line">        P(mutex);</span><br><span class="line">        将苹果放入盘子</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(apple);        //释放一个苹果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        准备橘子</span><br><span class="line">        P(plate);        //申请盘子资源</span><br><span class="line">        P(mutex);</span><br><span class="line">        将橘子放入盘子</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(orange);       //释放一个橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(apple);        //申请苹果资源</span><br><span class="line">        P(mutex);</span><br><span class="line">        拿出苹果</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);        //释放盘子资源</span><br><span class="line">        恰苹果        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">son()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(orange);       //申请橘子资源</span><br><span class="line">        P(mutex);</span><br><span class="line">        拿出橘子</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(plate);        //释放盘子资源</span><br><span class="line">        恰橘子        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于本问题缓冲区为1，可以考虑不设置信号量。</p>
<h2 id="吸烟者问题">吸烟者问题</h2>
<p><a
href="https://www.youtube.com/watch?v=pcqGlVVHHlQ">视频讲解：吸烟者问题</a></p>
<p>系统中有一个供应者和三个吸烟者，吸烟者吸烟需要自己卷烟，其中</p>
<ul>
<li>卷烟需要烟草、纸、胶水三种材料</li>
<li>每个吸烟者各有其中的一种材料</li>
<li>供应者每次会提供其中两种材料，并由缺少该材料的吸烟者拿取</li>
<li>吸烟者制作完烟并抽掉后，发出信号，供应者放下一组物品</li>
</ul>
<h3 id="分析关系-2">分析关系</h3>
<p>可以将桌子视为容量为1的缓冲区，并且将两种材料分别视为三种组合：</p>
<ul>
<li>组合一：纸+胶水</li>
<li>组合二：烟草+胶水</li>
<li>组合三：烟草+纸</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d47483c0962507e78e2d10e0846b2ec.png" /></p>
<ul>
<li>互斥
<ul>
<li>对桌子的访问需要互斥进行</li>
</ul></li>
<li>同步
<ul>
<li>桌上有组合一，第一个抽烟者取走物品</li>
<li>桌上有组合二，第二个抽烟者取走物品</li>
<li>桌上有组合三，第三个抽烟者取走物品</li>
<li>发出完成信号后，供应者将下一个组合放到桌上</li>
</ul></li>
</ul>
<h3 id="信号量设置">信号量设置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore offer1 = 0;    //同步信号量，桌上组合一的数量</span><br><span class="line">semaphore offer1 = 0;    //同步信号量，桌上组合二的数量</span><br><span class="line">semaphore offer1 = 0;    //同步信号量，桌上组合三的数量</span><br><span class="line">semaphore finish = 0;    //同步信号量，抽烟是否完成</span><br><span class="line">int i = 0;               //实现轮流提供材料</span><br></pre></td></tr></table></figure>
<h3 id="实际代码-2">实际代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">provider()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if (i==0)&#123;</span><br><span class="line">            将组合一放在桌上</span><br><span class="line">            V(offer1);        //提供材料</span><br><span class="line">        &#125;else if (i==1)&#123;</span><br><span class="line">            将组合二放在桌上</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125;else if (i==2)&#123;</span><br><span class="line">            将组合三放在桌上</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+1) % 3;       //轮流提供素材</span><br><span class="line">        P(finish);           //等待完成信号</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(offer1);           //请求组合一资源</span><br><span class="line">        从桌上拿走组合一</span><br><span class="line">        卷烟，抽烟</span><br><span class="line">        V(finish);           //发出完成信号</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌上拿走组合二</span><br><span class="line">        卷烟，抽烟</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌上拿走组合三</span><br><span class="line">        卷烟，抽烟</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读者-写者问题">读者-写者问题</h2>
<p><a
href="https://www.youtube.com/watch?v=j7zGzu07lmw">视频讲解：读者写者问题</a></p>
<p>有读者和写者两组并发进程，共享一个文件。要求：</p>
<ul>
<li>读者可以同时读取文件；</li>
<li>同一时间只能有一个写者进行写操作；</li>
<li>任一写着完成写操作之前不允许其他进程进行读或写操作；</li>
<li>写者执行写操作前，应让其他读者和写者全部退出。</li>
</ul>
<h3 id="关系分析">关系分析</h3>
<ul>
<li>互斥
<ul>
<li>写进程和写进程之间</li>
<li>写进程和读进程之间</li>
</ul></li>
</ul>
<h3 id="信号量设置-1">信号量设置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore rw = 1;        //互斥信号量，实现读、写对文件的互斥访问</span><br><span class="line">int count = 0;           //同时在读文件的读进程数量</span><br><span class="line">semaphore mutex = 1;     //互斥信号量，实现读进程对count的互斥访问</span><br></pre></td></tr></table></figure>
<p>然而，以上信号量设置有可能导致<strong>饿死</strong>，具体如下代码一所示，因此，增加一个信号量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore w = 1;          //同步信号量，用于实现“写优先”</span><br></pre></td></tr></table></figure>
<h3 id="实际代码-3">实际代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(rw);</span><br><span class="line">        写文件</span><br><span class="line">        V(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            P(rw);        //由第一个读进程负责上锁</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">        读文件</span><br><span class="line">        </span><br><span class="line">        P(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            V(rw);        //由最后一个读进程负责解锁</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码存在饿死现象，即一直有读进程占用，写进程始终无法运行</p>
<p>因此，引入了“写优先”的信号量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);</span><br><span class="line">        写文件</span><br><span class="line">        V(rw);</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        P(w);             //对每一个读和写进程之间做互斥处理</span><br><span class="line">        P(mutex);</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            P(rw);        //由第一个读进程负责上锁</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        </span><br><span class="line">        读文件</span><br><span class="line">        </span><br><span class="line">        P(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            V(rw);        //由最后一个读进程负责解锁</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这种实际上是各个读、写进程之间公平运行，并不是准确的写优先。</p>
<p><font color = "yellow">通过设置count实现读进程之间不互斥</font></p>
<h2 id="哲学家进餐问题">哲学家进餐问题</h2>
<p><a
href="https://www.youtube.com/watch?v=JtxKQxEm4w0">视频讲解：哲学家进餐问题</a></p>
<p>在一个桌子上，有5位哲学家，其中</p>
<ul>
<li>每位哲学家之间摆着一<strong>根</strong>筷子，共计5根</li>
<li>哲学家平时在思考人生，饿了就会尝试拿起左右手的筷子（一根一根的拿）</li>
<li>如果筷子在别人手上，则等待</li>
<li>拿起了两根筷子时，哲学家开始进食</li>
<li>用餐完毕后放下筷子继续思考</li>
</ul>
<h3 id="关系分析-1">关系分析</h3>
<p>设计有三种思路来防止死锁：</p>
<ol type="1">
<li>将拿左右筷子的动作整体设为互斥操作</li>
<li>最多只允许四个人拿筷子</li>
<li>只允许<strong>奇数号</strong>的哲学家拿起<strong>左边</strong>的筷子；<strong>偶数号</strong>的哲学家拿起<strong>右边</strong>的筷子</li>
</ol>
<h3 id="信号量设置-2">信号量设置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;    //代表五根筷子的资源</span><br><span class="line">semaphore mutex = 1;                         //对左右筷子整体资源互斥访问</span><br></pre></td></tr></table></figure>
<h3 id="实际代码-4">实际代码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pi()&#123;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);            //拿左</span><br><span class="line">        P(chopstick[ (i+1) % 5]);   //拿右</span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">        吃饭</span><br><span class="line">        </span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[ (i+1) % 5]);</span><br><span class="line">        </span><br><span class="line">        思考</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了只有当左右手筷子都可用时才拿起筷子</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.1_进程与线程</title>
    <url>/posts/1edbbd5b.html</url>
    <content><![CDATA[<h2 id="进程的概念组成和特征">进程的概念、组成和特征</h2>
<span id="more"></span>
<h3 id="进程的概念">进程的概念</h3>
<p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</p>
<p><a
href="https://www.youtube.com/watch?v=VR9e-IjJRUY">视频讲解：可视化进程</a></p>
<p><a
href="https://www.youtube.com/watch?v=ttXxSJdqEGY">视频讲解：从一个程序执行过程进一步理解进程，包括代码段和数据段</a></p>
<h3 id="进程的组成">进程的组成</h3>
<p>一个进程实体（进程映像）由<strong>PCB</strong>、<strong>程序段</strong>、<strong>数据段</strong>组成。</p>
<p>进程是<strong>动态</strong>的，进程实体是<strong>静态</strong>的。进程实体反映了进程在某一时刻的状态。</p>
<h4 id="pcb">PCB</h4>
<p>数据结构<strong>PCB</strong> ( Process Control
Block)，即<strong>进程控制块</strong>。操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。</p>
<p><strong>PCB是进程唯一的标识！</strong></p>
<p>PCB中存储了包括PID，UID（进程所属用户ID），进程运行情况等相关信息</p>
<p>当进程结束后，系统会回收PCB。</p>
<h4 id="程序段和数据段">程序段和数据段</h4>
<p>程序段：程序所包含的指令</p>
<p>数据段：程序产生的数据（如各种变量）</p>
<h3 id="进程的特征">进程的特征</h3>
<h4 id="动态性">动态性</h4>
<p>进程是程序的一次执行过程，是动态地产生、变化和消亡的。</p>
<p><strong>动态性是进程最基本的特征。</strong></p>
<h4 id="并发性">并发性</h4>
<p>内存中有多个进程实体，各进程可并发执行</p>
<h4 id="独立性">独立性</h4>
<p>进程是能<strong>独立运行</strong>、<strong>独立获得资源</strong>、<strong>独立接受调度</strong>的基本单位。</p>
<h4 id="异步性">异步性</h4>
<p>各进程按各自独立的、不可预知的速度向前推进，
操作系统要提供“<strong>进程同步机制</strong>”来解决异步问题。</p>
<h4 id="结构性">结构性</h4>
<p>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。</p>
<h2 id="进程的状态与转换">进程的状态与转换</h2>
<p><a
href="https://www.youtube.com/watch?v=pTku55MF51A">视频讲解：进程就绪态和阻塞态</a></p>
<p><a
href="https://www.youtube.com/watch?v=rt_eeKrJRnM">视频讲解：进程终止态</a></p>
<p><a
href="https://www.youtube.com/watch?v=vxxXQRGuHIA">视频讲解：进程五种状态转换</a></p>
<h3 id="进程的状态">进程的状态</h3>
<h4 id="创建态">创建态</h4>
<p>进程正在被创建。包括建立空白PCB，由系统为进程分配资源等。</p>
<h4 id="就绪态">就绪态</h4>
<p>进程获得了<strong>除了处理机外的一切资源</strong>。一旦获得了处理机资源就可以立刻开始运行，系统中处于就绪态的进程可以有<strong>很多个</strong>，通常将它们排成一个队列，称为<strong>就绪队列</strong>。</p>
<h4 id="运行态">运行态</h4>
<p>进程正在处理机上运行。单处理机情况下每个时刻最多只有一个进程在运行态。</p>
<h4 id="阻塞态等待态">阻塞态（等待态）</h4>
<p>进程请求等待某个事件发生，在该事件完成前，即使处理机资源空闲，该进程也不能运行。例如请求了系统调用或者是等待某些资源。</p>
<h4 id="中止态">中止态</h4>
<p>进程正在结束。系统先将进程置为结束态，之后再进行资源的释放和回收等工作。</p>
<p>如果是多核CPU，可以存在多个运行态的进程</p>
<p>运行态、阻塞态和就绪态是进程的三种基本状态</p>
<h3 id="进程状态的转换">进程状态的转换</h3>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/image-20230320213843363.png" alt="image-20230320213843363" style="zoom: 67%;" /></p>
<ul>
<li>两个不能
<ul>
<li>不能直接由阻塞态到运行态</li>
<li>不能直接由就绪态到阻塞态</li>
</ul></li>
<li>转变模式
<ul>
<li>运行态到阻塞态一般是<strong>主动的</strong>行为</li>
<li>阻塞态到就绪态是<strong>被动的</strong>行为</li>
</ul></li>
</ul>
<hr style = "border:2px solid yellow">
<ul>
<li>题目1：进程的状态转换</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/ec2246c148c45bd030bd97a1c9f960d.jpg" /></p>
<p>I/O操作完成之前进程在等待结果，状态为阻塞态，完成后进程等待事件就绪，是就绪态</p>
<ul>
<li><p>题目2：进程状态与处理器效率关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/db58a8fdb97644d35090bb664a2c144.jpg" /></p>
<p>进程的就绪数目越多，争夺CPU的进程就越多，但只要就绪队列不为空，CPU就一直保持繁忙，而当CPU不忙效率才下降</p></li>
</ul>
<hr style = "border:2px solid yellow">
<h3 id="进程的组织方式">进程的组织方式</h3>
<p>链式方式：将同一状态的PCB连接到同一个队列中；</p>
<p>索引方式：将同一状态的PCB放在一个索引表当中。</p>
<h2 id="进程控制">进程控制</h2>
<p>进程控制是使用<strong>原语</strong>来实现的。</p>
<p>原语是指执行期间<strong>不允许中断</strong>的程序段，是一个不可分割的基本单位。</p>
<p>通过“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”实现了原语的<strong>原子性</strong>。</p>
<h3 id="进程的创建">进程的创建</h3>
<h4 id="创建原语">创建原语</h4>
<ol type="1">
<li>申请空白PCB</li>
<li>为进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列（<strong>创建态→就绪态</strong>）</li>
</ol>
<h4 id="引起进程创建的事件">引起进程创建的事件</h4>
<ul>
<li>用户登录</li>
<li>作业调度（<em>有新的作业将要运行</em>）</li>
<li>提供服务</li>
<li>应用请求（<em>用户进程主动请求创建子进程</em>）</li>
</ul>
<h3 id="进程的终止">进程的终止</h3>
<h4 id="撤消原语">撤消原语</h4>
<ol type="1">
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立刻剥夺CPU，将CPU分配给其他进程</li>
<li>中止其所有子进程</li>
<li>将该进程所有资源归还给父进程或是操作系统</li>
<li>删除PCB</li>
</ol>
<h4 id="引起进程中止的事件">引起进程中止的事件</h4>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/40012cbcd9efe70c899cdcdef15dbf8.jpg" /></p>
<p>A：对</p>
<p>B：虚拟地址空间不可共享</p>
<p>C：每个进程PCB都不一样</p>
<p>D：对</p>
<hr style = "border:2px solid yellow">
<h3 id="进程的阻塞和唤醒">进程的阻塞和唤醒</h3>
<p>阻塞原语和唤醒原语必须成对使用</p>
<h4 id="阻塞原语">阻塞原语</h4>
<ol type="1">
<li>找到要阻塞进程对应的PCB</li>
<li>保护进程运行现场，将进程设置为<strong>阻塞态</strong>，暂时停止进程运行</li>
<li>将PCB插入对应事件的等待队列</li>
</ol>
<h4 id="引发阻塞的事件">引发阻塞的事件</h4>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待合作的其他进程完成工作</li>
</ul>
<h4 id="唤醒原语">唤醒原语</h4>
<ol type="1">
<li>在事件队列中找到对应的PCB</li>
<li>将PCB从等待队列移除，设置为<strong>就绪态</strong></li>
<li>将PCB插入就绪队列，等待被唤醒</li>
</ol>
<h4 id="引发唤醒的事件">引发唤醒的事件</h4>
<ul>
<li>等待的事件发生</li>
</ul>
<h3 id="进程的切换">进程的切换</h3>
<h4 id="切换原语">切换原语</h4>
<ol type="1">
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB回复进程所需的运行环境</li>
</ol>
<p><em>运行环境</em>：进程运行中的临时变量等<a
href="https://www.youtube.com/watch?v=hQmxQKYQu3w">视频讲解：运行环境</a></p>
<h4 id="引起切换的事件">引起切换的事件</h4>
<ul>
<li>当前进程时间片到</li>
<li>更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程中止</li>
</ul>
<p><font color = "red">原语公共点</font></p>
<ol type="1">
<li>更新PCB中信息</li>
<li>将PCB插入合适队列</li>
<li>分配/回收资源</li>
</ol>
<h2 id="进程通信">进程通信</h2>
<p><a
href="https://www.youtube.com/watch?v=UrYPPbAwVs4">视频讲解：进程通信需要操作系统支持的原因</a></p>
<h3 id="共享存储">共享存储</h3>
<p><a
href="https://www.youtube.com/watch?v=jMkUtIGY_IU">视频讲解：共享存储</a></p>
<ul>
<li>两个进程对共享空间的访问必须是<strong>互斥</strong>的。</li>
<li>操作系统只提供<strong>共享空间</strong>和<strong>同步互斥工具</strong>（如P，V操作）。</li>
</ul>
<p>两种方式：基于数据结构的共享、基于存储区的共享</p>
<h4 id="基于数据结构的共享">基于数据结构的共享</h4>
<ul>
<li>只能共享<strong>固定的</strong>数据结构</li>
<li>速度慢，是一种低级的共享方式</li>
</ul>
<blockquote>
<p>可以理解为低级全局变量</p>
</blockquote>
<h4 id="基于存储区的共享">基于存储区的共享</h4>
<ul>
<li>共享方式和大小由进程自己决定</li>
<li>速度快，是一种高级的共享方式</li>
</ul>
<h3 id="管道通信">管道通信</h3>
<p><a
href="https://www.youtube.com/watch?v=JF9EUQVgAvM">视频讲解：管道通信</a></p>
<p>管道实际上是一个固定大小的缓冲区</p>
<ul>
<li>管道通信只能实现<strong>半双工通信</strong>，想实现双向通信需要两个管道</li>
<li>各个进程对管道的访问也需要是互斥的</li>
<li>管道中没有写满（读空）时，<strong>不能</strong>向管道中再写（读）数据，<font color = "red">会被阻塞</font></li>
<li>从管道中读取数据是<strong>一次性的</strong>，数据一旦被读取就会从管道中抛弃
<ul>
<li>一次只能有一个读进程</li>
<li>但是可以有多个写进程</li>
</ul></li>
</ul>
<h3 id="消息传递">消息传递</h3>
<p><a
href="https://www.youtube.com/watch?v=s2j-GROUdrE">视频讲解：消息传递</a></p>
<p>进程间的数据交换以格式化消息（message）为单位。</p>
<p>通过<strong>发送消息/接收消息</strong>两个<strong>原语</strong>进行数据交换</p>
<p>两种方式：直接通信方式、间接通信方式</p>
<h4 id="直接通信方式">直接通信方式</h4>
<p>发送进程直接将消息发送到接收进程的消息缓冲队列中</p>
<h4 id="间接通信方式">间接通信方式</h4>
<p>发送进程将消息发送到某个中间实体，一般称为_信箱_，接收端从中间实体接收消息</p>
<p><a href="https://www.youtube.com/watch?v=ZFmXecXwBsU">勘误</a></p>
<hr style = "border:2px solid yellow">
<p>举例：两个进程交换数据的方法</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/f1d09b035f046d79b0f831b99fe7e47.jpg" /></p>
<hr style = "border:2px solid yellow">
<h2 id="线程的概念和特点">线程的概念和特点</h2>
<h3 id="线程的概念">线程的概念</h3>
<p>线程是程序执行的最小单元，是进程中的一个实体，是系统独立调度与分派的基本单位。</p>
<p>线程是程序执行的最小单元，是调度的基本单位</p>
<p>进程是资源分配的最小单元</p>
<h3 id="线程的特点">线程的特点</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425143521850.png" /></p>
<ul>
<li><strong>调度</strong>：线程作为独立调度的基本单位，进程内的线程调度不会引起进程切换，开销变小</li>
<li><strong>并发性</strong>：更好
<ul>
<li>进程之间可以并发运行</li>
<li>同一进程内的线程可以并发运行</li>
<li>不同进程间的线程可以并发执行</li>
</ul></li>
<li><strong>占有资源</strong>：线程几乎不占有资源</li>
<li><strong>独立性</strong>
<ul>
<li>进程拥有独立的地址空间和资源</li>
<li>同一进程内的线程共享地址空间和资源</li>
</ul></li>
<li><strong>系统开销</strong>：当进行进程内线程的切换时，开销远小于进程</li>
<li><strong>支持多处理机系统</strong>：可以将多个线程分配给多个处理机运行</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<ul>
<li>题1：线程的特点</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/0b5d2ab9f223f73ad7895a61b2cbf01.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：线程是处理机调度的基本单位，所以可以独立执行程序</p>
<p>B：线程没有自己独立的地址空间，而是共享所属进程的空间</p>
<p>C：进程能创建多个线程</p>
<p>D：由于共享内存空间，同一进程中的线程间通信无需使用系统调用函数</p>
<ul>
<li><p>题2：线程与进程的关系</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/8318aad027c911753bdacbf7849eed8.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul>
<p>​ B,D：进程是资源分配的单位，内核级线程是处理器调度和分派的单位</p>
<p>​
A:假如有一个内核进程，映射到用户级后有多个线程，那么这些线程之间切换不需要内核级切换进程，也就不需要内核支持</p>
<hr style = "border:2px solid yellow">
<h3 id="线程的实现方式">线程的实现方式</h3>
<h4
id="线程库支持的线程用户级线程-user-level-thread-ult">线程库支持的线程（用户级线程
User-Level Thread, ULT)</h4>
<p><a
href="https://www.youtube.com/watch?v=2JgV_Uc6DZg">视频讲解：用户级线程</a></p>
<ul>
<li><p>线程切换由<strong>应用程序</strong>负责，在<strong>用户态</strong>下即可完成</p></li>
<li><p>线程表存储在用户空间，系统内核意识不到线程的存在</p></li>
<li><p><strong>调度</strong></p>
<ul>
<li><p>操作系统为进程分配时间片</p></li>
<li><p>用户的调度程序再讲时间片分给线程</p></li>
</ul></li>
<li><p>优点</p>
<ul>
<li>线程的切换在用户态即可完成，<strong>开销小、效率高</strong></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>当一个线程被阻塞后，其他线程都会被阻塞，<strong>并发度不高</strong></li>
</ul></li>
</ul>
<h4
id="内核支持的线程内核级线程-kernel-level-thread">内核支持的线程（内核级线程
Kernel-Level Thread）</h4>
<p><a
href="https://www.youtube.com/watch?v=Ylu-HTAx64w">视频讲解：内核级线程</a></p>
<ul>
<li><p>内核级线程的管理工作由<strong>操作系统内核</strong>完成</p></li>
<li><p>内核的切换需要在<strong>内核态</strong>下实现</p></li>
<li><p>线程表存储在内核空间，内核态线程是操作系统内核能够看到的</p></li>
<li><p><strong>调度</strong></p>
<ul>
<li>操作系统以线程为调度单位</li>
</ul></li>
<li><p>优点</p>
<ul>
<li>一个线程被阻塞后，其他线程继续运行，<strong>并发性强</strong></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>线程的切换需要内核态，<strong>成本高、开销大</strong></li>
</ul></li>
</ul>
<hr style = "border:2px solid yellow">
<ul>
<li><p>题目1：内核级线程</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/46854313a7e4af4851f1e445e0db765.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：内核级线程切换相当于进程切换，所以系统开销大</p>
<p>B：内核线程不会堵死，用户线程会</p>
<p>C：内核线程之所以叫内核线程就是因为运行在内核，那么对应的进程也在内核</p>
<p>D：同B</p></li>
<li><p>题目2：用户级线程和内核级线程关系</p></li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/bd0bb7af457b98ed22973d46e642137.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>A：没学到</p>
<p>B：用户级线程调度实际上调度对象是进程，所以需要内核参与</p>
<p>C：用户级线程实际上不存在，所以任何操作系统都能运行</p>
<p>D：同B</p>
<hr style = "border:2px solid yellow">
<h3 id="多线程模型">多线程模型</h3>
<p><a
href="https://www.youtube.com/watch?v=lvCgJ_W19c0">视频讲解：多线程模型</a></p>
<h4 id="一对一模式">一对一模式</h4>
<p>一个用户级线程映射一个内核级线程（一个UTL一个TCB）</p>
<ul>
<li><p>并发能力强</p></li>
<li><p>开销大</p></li>
</ul>
<h4 id="多对一模式">多对一模式</h4>
<p>将多个用户级线程映射到一个内核级线程，等同于用户级线程（多个UTL一个TCB）</p>
<ul>
<li><p>效率高</p></li>
<li><p>并发能力弱；多个线程不能并行的运行在多处理机上</p></li>
</ul>
<h4 id="多对多模式">多对多模式</h4>
<p>将n个用户级线程映射到m个内核级线程上（m &lt;= n）</p>
<h3 id="线程的资源共享">线程的资源共享</h3>
<ul>
<li><strong>共享</strong>
<ul>
<li>进程的虚拟地址空间</li>
</ul></li>
<li><strong>独立</strong></li>
<li>栈</li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=GQ08vKVgY2Y">视频讲解：对于用户级线程和内核级线程之间通俗易懂的区分理解</a></p>
<p>用户级线程是代码逻辑的载体</p>
<p>内核级线程是运行机会的载体</p>
<h2 id="线程的控制">线程的控制</h2>
<h3 id="线程的状态转换">线程的状态转换</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e6d1dffd0f032fad3344ef0d3f3f09a.png" /></p>
<h3 id="线程的组织与控制">线程的组织与控制</h3>
<p><a
href="https://www.youtube.com/watch?v=PRgkXeFsueM">视频讲解：线程的组织与控制</a></p>
<p>将TCB组织成线程表进行管理</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/73fa1304e03b0f97ed8423bd341c965.png" /></p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.3_同步与互斥</title>
    <url>/posts/971699ba.html</url>
    <content><![CDATA[<h2 id="进程同步的概念">进程同步的概念</h2>
<span id="more"></span>
<h3 id="临界资源">临界资源</h3>
<p>临界资源指一个时间段内只允许一个进程使用的资源。</p>
<p>例如物理设备、内存缓冲区等都是临界资源。</p>
<p>在每个进程中，访问临界资源的那部分代码被称为<strong>临界区</strong>。对临界资源的访问，可以分为四个阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    entry section;      //进入区</span><br><span class="line">    critical section;   //临界区</span><br><span class="line">    exit section;       //退出区</span><br><span class="line">    remainder section;  //剩余区</span><br><span class="line">&#125; while (true)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>进入区</strong>：检查是否可以进入临界区，若可以进入，则设置<strong>正在访问临界资源的标志</strong>，以阻止其他进程进入临界区；</li>
<li><strong>临界区（临界段）</strong>：进程中访问临界区的一段代码；</li>
<li><strong>退出区</strong>：将正在访问临界资源的标志<strong>解除</strong>；</li>
<li>剩余区：代码中的其他部分。</li>
</ol>
<p>进入区和退出区负责实现<strong>互斥</strong>。</p>
<p><a
href="https://www.youtube.com/watch?v=eUvtNDHsq98">实现互斥的逻辑代码的讲解</a></p>
<h3 id="同步">同步</h3>
<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<h3 id="互斥">互斥</h3>
<p>对<strong>临界资源</strong>的访问，必须<strong>互斥</strong>地进行。</p>
<p><strong>互斥</strong>，亦称<strong>间接制约关系</strong>。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后,
另一个进程才能去访问临界资源。</p>
<h4 id="互斥的原则">互斥的原则</h4>
<ol type="1">
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：为什么需要进程同步</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/52688d13cae644c1b6933db5f00727f.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>选C：</p>
<p>因为进程同步的是管理多个程序运行，而这些进程都是异步的</p>
<p>题2：进程之间的关系</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/4262ad18f0462b3266be5527e1d9164.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>进程B必须在A写入后才能读取，体现互斥（进程之间争夺互斥资源产生的制约）</p>
<p>进程B和A存在数据交换，体现同步（进程之间需要交换信息和，相互等待而产生的制约）</p>
<hr style = "border:2px solid yellow">
<p>题3：临界区和临界资源的判断</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/9a235df8ff1b692ca5d0da913b7ccc1.jpg" /></p>
<p>临界资源是互斥共享，一次只能给一个进程使用</p>
<hr style = "border:2px solid yellow;">
<p>题4：临界资源与互斥</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0d5463069e1401cbaffa89d9cf7a9b0.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1v1421D74W/?spm_id_from=333.1007.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<ol type="1">
<li>共享资源,是共享资源就要互斥，不是就不用</li>
<li>不同进程之间互不影响</li>
</ol>
<hr style = "border:2px solid yellow">
<p>题5：对同步/互斥设计准则的理解</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/27c6a73cf98872fb9c87ae7911af464.jpg" /></p>
<p>解析：</p>
<p>1：体现了忙则等待</p>
<p>2：体现了空闲让进</p>
<p>3：体现了有限等待</p>
<p>4：体现了让权等待</p>
<hr style = "border:2px solid yellow;">
<h2 id="临界区互斥的实现">临界区互斥的实现</h2>
<h3 id="软件实现">软件实现</h3>
<h4 id="单标志法">单标志法</h4>
<p><a
href="https://www.youtube.com/watch?v=jiJ3hQHIXas">视频讲解:单标志法</a></p>
<p>一个进程在访问完临界区后会把使用临界区资源的权限转交给另一个进程，即每个进程进入临界区的权限只能由另一个进程赋予</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int turn=0;         //公用变量，表示当前允许进入临界区的进程号</span><br><span class="line"></span><br><span class="line">// P0进程</span><br><span class="line">while (turn != 0);  //进入区</span><br><span class="line">critical section;   //临界区</span><br><span class="line">turn = 1;           //退出区</span><br><span class="line">remainder section;  //剩余区</span><br><span class="line"></span><br><span class="line">// P1进程</span><br><span class="line">while (turn != 1);  //进入区</span><br><span class="line">critical section;   //临界区</span><br><span class="line">turn = 0;           //退出区</span><br><span class="line">remainder section;  //剩余区</span><br></pre></td></tr></table></figure>
<p>该算法可以实现同一时刻只允许一个进程进入临界区。</p>
<p>但是两个程序必须轮流进入临界区，若1不再进入临界区，则0将无法再次进入临界区，<strong>违背了“空闲让进”原则</strong>。</p>
<h4 id="双标志先检查法">双标志先检查法</h4>
<p><a href="">视频讲解：双标志先检查法</a></p>
<p>设置一个数组，相应元素表示进程访问临界资源的意愿。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool flag[2];       //表示进入临界区意愿</span><br><span class="line">flag[0] = false;</span><br><span class="line">flag[1] = false;</span><br><span class="line"></span><br><span class="line">//P0进程</span><br><span class="line">while (flag[1]);    //若P1希望进入临界区，则P0循环等待</span><br><span class="line">flag[0] = true;     //标记P0希望进入临界区</span><br><span class="line">critical section;   //访问临界区</span><br><span class="line">flag[0] = false;    //标记P0不再希望使用临界区</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">//P1进程</span><br><span class="line">while (flag[0]);    //若P0希望进入临界区，则P1循环等待</span><br><span class="line">flag[1] = true;     //标记P1希望进入临界区</span><br><span class="line">critical section;   //访问临界区</span><br><span class="line">flag[1] = false;    //标记P1不再希望使用临界区</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>此算法不需要轮流进入临界区，可以连续访问临界资源。</p>
<p>在检查对方意愿和切换自己意愿之间有时间差，可能出现同时访问临界区，<strong>违反了“忙则等待”原则</strong>。</p>
<h4 id="双标志后检查法">双标志后检查法</h4>
<p>相比于双标志先检查法，此算法先修改自身意愿，再进行检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool flag[2];       //表示进入临界区意愿</span><br><span class="line">flag[0] = false;</span><br><span class="line">flag[1] = false;</span><br><span class="line"></span><br><span class="line">//P0进程</span><br><span class="line">flag[0] = true;     //标记P0希望进入临界区</span><br><span class="line">while (flag[1]);    //若P1希望进入临界区，则P0循环等待</span><br><span class="line">critical section;   //访问临界区</span><br><span class="line">flag[0] = false;    //标记P0不再希望使用临界区</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">//P1进程</span><br><span class="line">flag[1] = true;     //标记P1希望进入临界区</span><br><span class="line">while (flag[0]);    //若P0希望进入临界区，则P1循环等待</span><br><span class="line">critical section;   //访问临界区</span><br><span class="line">flag[1] = false;    //标记P1不再希望使用临界区</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>这一算法解决了“忙则等待”的问题，但是若两个进程同时标记为true，又会相互等待造成<strong>饥饿</strong>，<strong>违背了“空闲让进”和“有限等待”原则</strong>。</p>
<h4 id="petersons-algorithm">Peterson's Algorithm</h4>
<p><a
href="https://www.youtube.com/watch?v=g1M9w_smOqI">视频讲解：Peterson算法</a></p>
<p>综合了单标志法和双标志后检查法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//P0进程</span><br><span class="line">flag[0] = true;              //标记P0希望进入临界区</span><br><span class="line">turn = 1;                    </span><br><span class="line"></span><br><span class="line">while (flag[1]&amp;&amp;turn==1);    //若P1希望进入临界区，则P0循环等待</span><br><span class="line">critical section;            //访问临界区</span><br><span class="line">flag[0] = false;             //标记P0不再希望使用临界区</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line">//P1进程</span><br><span class="line">flag[1] = true;              //标记P1希望进入临界区</span><br><span class="line">turn = 0;</span><br><span class="line"></span><br><span class="line">while (flag[0]&amp;&amp;turn==0);    //若P0希望进入临界区，则P1循环等待</span><br><span class="line">critical section;            //访问临界区</span><br><span class="line">flag[1] = false;             //标记P1不再希望使用临界区</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>首先设置自身想要访问临界区，并将当前访问权限交给对方。</li>
<li>若此时对方也希望访问临界资源，则自身循环等待。</li>
<li>当自身访问完临界区后，取消访问意愿标记。以便其它进程访问。</li>
</ol>
<ul>
<li>此算法利用flag[
]实现了临界资源的<strong>互斥访问</strong>，并用turn解决了“<strong>饥饿</strong>”现象；</li>
<li>遵循了空闲让进、忙则等待和有限等待原则；</li>
<li>但是<strong>没有遵循让权等待原则</strong>（需要在CPU上不断循环检测）。</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：Peterson算法的考察</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d8d62bc5a9e286b9f02538a34b01ad2.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="硬件实现">硬件实现</h3>
<h4 id="中断屏蔽方法">中断屏蔽方法</h4>
<p>利用开关中断的方式实现</p>
<p><a
href="https://www.youtube.com/watch?v=zFkjrvCcs84">视频讲解：中断屏蔽</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">关中断 //关中断后不允许当前进程被中断</span><br><span class="line">临界区</span><br><span class="line">开中断</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>优点
<ul>
<li>简洁、高效</li>
</ul></li>
<li>缺点
<ul>
<li>不适用于多处理机</li>
<li>只适用于操作系统内核进程（开/关中断指令只能执行在内核态）</li>
</ul></li>
</ul>
<h4 id="testandset指令">TestAndSet指令</h4>
<p>简称TS指令，或TSL（TestAndSetLock）指令。</p>
<p><a
href="https://www.youtube.com/watch?v=Zls8U3wjB7k">视频讲解：TS/TSL指令</a></p>
<p>TSL指令是用<strong>硬件实现的</strong>，执行的过程不允许被中断。以下是其C语言逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool lock;                        //共享变量表示临界资源是否上锁</span><br><span class="line"></span><br><span class="line">bool TestAndSet(bool *lock)&#123;</span><br><span class="line">    bool old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = true;                //无论之前是否上锁，将lock设置为true</span><br><span class="line">    return old;                  //返回之前lock的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (TestAndSet (&amp;lock));      //若可以进入临界区，则进入循环</span><br><span class="line">critical section;</span><br><span class="line">lock = false;                    //为临界资源解锁</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ul>
<li>优点
<ul>
<li>实现简单</li>
<li>适用于多处理机环境</li>
</ul></li>
<li>缺点
<ul>
<li><strong>不满足让权等待原则</strong>，暂时无法进入临界区的资源仍然会占用CPU并循环执行TS指令，导致“<strong>忙等</strong>”。</li>
</ul></li>
</ul>
<h4 id="swap指令">Swap指令</h4>
<p>也称为Exchange指令，或简称XCHG指令。</p>
<p><a
href="https://www.youtube.com/watch?v=VBz67X3Kf6o">视频讲解：SWAP指令</a></p>
<p>Swap指令是用<strong>硬件实现的</strong>，执行的过程不允许被中断。以下是其C语言逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool lock;</span><br><span class="line"></span><br><span class="line">Swap(bool *a, bool *b)&#123;</span><br><span class="line">    bool temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool old = true;                //局部变量，存放之前lock的值</span><br><span class="line">while (old == true)&#123;</span><br><span class="line">    Swap(&amp;old, &amp;lock)</span><br><span class="line">&#125;</span><br><span class="line">critical section;</span><br><span class="line">lock = false;                   //解锁临界资源</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>其原理、优缺点实际上都与TS指令相似。</p>
<h2 id="锁">锁</h2>
<p><a
href="https://www.youtube.com/watch?v=4LFONkINlqc">视频讲解：锁</a></p>
<p>也称为“自旋锁”，解决临界区最简单的方法就是锁。进程在进入临界区时获得锁，在退出临界区时释放锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool avialible; //锁是否可用</span><br><span class="line"></span><br><span class="line">//获得锁</span><br><span class="line">acquire()&#123;</span><br><span class="line">    while(!available)</span><br><span class="line">        ;				//忙等锁</span><br><span class="line">    available = false;	//获得锁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放锁</span><br><span class="line">release()&#123;</span><br><span class="line">    available = true;	//释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire与release必须是原子操作。</p>
<ul>
<li><strong>优点</strong>
<ul>
<li>等待期间不用切换进程上下文，多核处理器中若上锁的时间很短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其它核正常工作，并快速释放临界区</li>
</ul></li>
<li><strong>缺点</strong>
<ul>
<li>需要忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>不适用于单处理机系统，忙等的过程中不可解锁</li>
</ul></li>
</ul>
<h2 id="信号量">信号量</h2>
<p>信号量是一种功能较强的机制，可用于解决互斥与同步的问题。它只能被两个标准原语<strong>wait(S)</strong>和<strong>signal(S)</strong>访问，也被记作“<strong>P操作</strong>”和“<strong>V操作</strong>”。</p>
<p>在荷兰文中，通过叫passeren，释放叫vrijgeven，PV操作因此得名</p>
<p><a
href="https://www.youtube.com/watch?v=TLDpVzahIFo">视频讲解：信号量是什么以及如何修改信号量</a></p>
<h3 id="整形信号量">整形信号量</h3>
<p>用一个<strong>整数型的变量</strong>作为信号量，用来表示<strong>系统中某种资源的数量</strong>。</p>
<p>与普通整型变量相比，信号量只有三种操作：初始化、P操作、V操作</p>
<p><a
href="https://www.youtube.com/watch?v=Fvur7s3rdxI">视频讲解：整形信号量</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int S = 1;                //初始化整型信号量，表示当前系统中可用资源数量</span><br><span class="line"></span><br><span class="line">void wait(int S)&#123;         //wait原语，相当于进入区</span><br><span class="line">    while (S &lt;= 0);       //若资源不够，则一直等待</span><br><span class="line">    S = S-1;              //若资源够，则占用一个资源</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signal(int S)&#123;       //signal原语，相当于退出区</span><br><span class="line">    s = S+1;              //释放资源</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于P操作中资源不够时会一直循环，所以<strong>不满足让权等待，会发生“忙等”</strong>。</p>
<h3 id="记录型信号量">记录型信号量</h3>
<p><a
href="https://www.youtube.com/watch?v=3Y-80vvq97s">视频讲解：记录型信号量</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value;            //剩余资源数</span><br><span class="line">    struct process *L;    //等待队列</span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>在记录型信号量中，除了代表资源数量的value之外，还有一个进程链表L</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void wait (semaphore S)&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    if (S.value &lt; 0)&#123;</span><br><span class="line">        block(S.L);        //若资源数量不足，则使用block原语将进程阻塞，并加入等待队列之中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signal (semaphore S)&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    if (S.value &lt;= 0)&#123;</span><br><span class="line">        wakeup(S.L);       //若释放资源后可还有进程在等待，则唤醒该进程，使其从阻塞态变为就绪态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此机制遵循了让权等待原则，不会发生“忙等”。</p>
<p><font color = "red">记录型信号量是绝对的重点，要求能手搓代码</font></p>
<h3
id="用信号量机制实现进程同步互斥">用信号量机制实现进程同步、互斥</h3>
<h4 id="进程互斥">进程互斥</h4>
<p><a
href="https://www.youtube.com/watch?v=6_fqHC8yG-M">视频讲解：信号量实现进程互斥</a></p>
<p>设置互斥信号量mutex，初值为1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1;        //这里可以直接这么写</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);               //申请进入临界区</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);               //释放资源</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(mutex);</span><br><span class="line">    critical section;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以理解为此信号量表示进入临界区的名额，并且只有一个。</p>
<p>需要为不同的临界资源设置不同的互斥信号量；</p>
<p>P、V操作必须成对出现。</p>
<h4 id="进程同步">进程同步</h4>
<p><a
href="https://www.youtube.com/watch?v=6ATKzrA17mk">视频讲解：信号量实现进程同步</a></p>
<p>进程同步：让各并发进程按照一定顺序进行</p>
<p>设置同步信号量S，初值为0；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore S = 0;</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">    CODE1;</span><br><span class="line">    CODE2;</span><br><span class="line">    V(S);</span><br><span class="line">    CODE3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S);</span><br><span class="line">    CODE4;</span><br><span class="line">    CODE5;</span><br><span class="line">    CODE6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有CODE1、2执行完毕，且进行了V操作之后，进程2中的P操作才不会阻塞，并且能够继续执行下去。</p>
<h3 id="信号量机制实现前驱关系">信号量机制实现前驱关系</h3>
<p>前驱图</p>
<ol type="1">
<li>需要为每一对前驱关系设置一个同步信号量；</li>
<li>在<strong>前操作之后</strong>对相应的同步信号量执行<strong>V操作</strong>；</li>
<li>在<strong>后操作之前</strong>对相应的同步信号量执行<strong>P操作</strong>。</li>
</ol>
<p><font color = "yellow">上面简称为“前V后P”,在实际解题时，每一对前驱关系都是一个进程同步问题</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    S1;</span><br><span class="line">    V(a);</span><br><span class="line">    V(b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(a);</span><br><span class="line">    S2;</span><br><span class="line">    V(c);</span><br><span class="line">    V(d);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(b);</span><br><span class="line">    S3;</span><br><span class="line">    V(g);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P4()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(c);</span><br><span class="line">    S4;</span><br><span class="line">    V(e);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P5()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(d);</span><br><span class="line">    S5;</span><br><span class="line">    V(f);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P6()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(e);</span><br><span class="line">    P(f);</span><br><span class="line">    P(g);</span><br><span class="line">    S6;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：信号量与进程数之间关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ab2cc7968b751cd4e4f29634741e51b.jpg" /></p>
<p>互斥量</p>
<p>互斥量初值一般为1，表示临界区只允许1个进程进入，从而实现互斥</p>
<p>互斥量等于0时，表示临界区已有1个进程进入，临界区外无等待进程</p>
<p>互斥量小于0时，表示临界区中有1个进程，临界区外等待的进程数量等于互斥量的绝对值</p>
<p>资源量</p>
<p>资源量初值可以是任何数，表示可用的资源数</p>
<p>资源量小于0，表示所有进程已用完，等待的进程数就是资源量的绝对值</p>
<hr style = "border: 2px solid yellow;">
<p>题2：信号量与进程联系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f4954fbcadca68b0f7dd56f3afa1e72.jpg" /></p>
<p>解：每次允许2个，所以信号量初始值为2，同时有3个进程，所以可能有1个进程在临界区等待，所以最小值是1。所以答案是A</p>
<hr style = "border: 2px solid yellow;">
<p>题3：信号量与进程之间关系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/40a765c00740c3b6e1f3f07504be624.jpg" /></p>
<p>分析：</p>
<p>唤醒另一个进程，但只是唤醒，说明这个进程要么在临界区，要么在临界区外等待，所以信号量的值小于等于0</p>
<hr style="border: 2px solid yellow;">
<p>题4：不同同步机制的比较</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/微信图片_20240331160825.jpg" />
解析</p>
<details>
<summary>
A：Peterson方法
</summary>
<pre><code>while(1) &#123;
    turn = j;    // 表示谦让给对方
    flag[i] = true;    // 表示自己希望进入
    while(turn == j && flag[j] == true)    // 对方也希望进入并且自己还把机会谦让给对方了
    // 临界区
    flag[i] = false;
    // 剩余区
&#125;</code></pre>
Peterson方法可以实现<br> 空闲让进<br> 忙则等待<br> 有限等待<br>
但不能实现让权等待，因为是while循环就算无法获取临界资源也会占用CPU
</details>
<details>
<summary>
B:swap指令
</summary>
<pre><code>void swap(boolean *a, boolean *b) &#123;
        boolean tmp = *a;
        *a = *b;
        *b = tmp;
&#125;</code></pre>
对于每个临界资源，<code>Swap</code>指令为其设置一个全局布尔变量<code>lock</code>，其初值为<code>FALSE</code>。<br>
在每个进程中还会设置一个局部布尔变量<code>key</code>，其初值为<code>TRUE</code>。<br>
有进程在临界区时，重复交换和检查过程，直到临界区里的进程退出<br>
<pre><code>do &#123;
    key = true;
    do &#123;
        swap(&lock, &key);
    &#125;while(key == true);
    // 临界区
    lock = false;
    // 剩余区
&#125;while(true);</code></pre>
swap可以实现空闲让进<br>
但是swap不能实现让权等待，因为swap其实是硬件实现，所以会一鼓作气执行完，这就意味着不会中断，那么就不能实现让权等待
</details>
<details>
<summary>
C: 信号量方法
</summary>
<pre><code>typedef struct &#123;
    int value;  //表示资源的数量
    struct process *L;  //一个链表，用来链接所有等待当前资源的进程
&#125;semaphore;
void wait(semaphore S) &#123;
    S.value--;  //表示申请一个资源
    if(S.value < 0)&#123; //如果进程已经使用完了
        将这个进程加到当前信号量S相应的阻塞队列中
        block(S.L); //自我阻塞，放弃处理机，并且加入对应资源的阻塞队列中
    &#125;   
&#125;
void signal(semaphore S) &#123;
    S.value++;  //表示对应资源可以申请的数量增加1
    if(S.value <= 0) &#123;  // 如果当前资源依然在被需求，仍有等待该进程的资源被阻塞
        将S.L中第一个被阻塞的进程移除
        wakeup(S.L) //唤醒S.L中第一个被阻塞的进程。与上面移除对应，从阻塞态转变为就绪态
    &#125;
&#125;</code></pre>
信号量是同时满足了同步/阻塞的四种要求
</details>
<details>
<summary>
D: TSL指令
</summary>
<pre><code>boolean TSL(boolean *lock)&#123;
    boolean old = *lock;
    *lock = true;
    return old;
&#125;
do &#123;
    while(TSL(&lock));  //判断当前临界资源是否可以使用
    临界区
    lock = false;
    剩余区
&#125;(true)</code></pre>
TSL也可以满足闲则让进，但和B的swap一样,TSL也是由机器代码实现，所以一口气执行完，所以不会中途退出，也就不能满足让权等待
</details>
<hr style = "border:2px solid yellow">
<p>题5 信号量的使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/742d6f24bec32f2ab468dfd8bb3048f.jpg" /></p>
<hr style = "border:2px solid yellow">
<h2 id="管程">管程</h2>
<h3 id="管程的定义和基本特征">管程的定义和基本特征</h3>
<h4 id="什么是管程">什么是管程：</h4>
<p>管程是一种特殊的软件模块，由这些部分组成:：</p>
<ol type="1">
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部于管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字。</li>
</ol>
<p>这里“过程”其实就是函数</p>
<h4 id="管程的特征">管程的特征：</h4>
<ol type="1">
<li>局部于管程的数据只能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li>每次<strong>仅允许一个进程</strong>在管程内执行某个内部过程；</li>
<li>每次只<strong>开放一个过程</strong>（由编译器实现）；</li>
<li>可以在管程中设置条件变量和<strong>等待/唤醒操作</strong>以解决<strong>同步</strong>问题。</li>
</ol>
<p><font color = "yellow">类似于Java中的实体类封装，只能用类提供的方法来修改内部变量</font></p>
<h3
id="例用管程实现生产者消费者问题">例：用管程实现生产者消费者问题</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer&#123;</span><br><span class="line">    condition full, empty;</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    void insert(Item item)&#123;</span><br><span class="line">        if (count == N)&#123;</span><br><span class="line">            wait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        insert_item (item);</span><br><span class="line">        </span><br><span class="line">        if (count == 1)&#123;</span><br><span class="line">            signal(empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void remove()&#123;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            wait (empty);</span><br><span class="line">        &#125;;</span><br><span class="line">        count--;</span><br><span class="line">        </span><br><span class="line">        if (count == N-1)&#123;</span><br><span class="line">            signal(full);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return remove_item();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer()&#123;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        Item itme = 生产产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        Item itme = ProducerConsumer.remove();</span><br><span class="line">        消费产品</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附java中实现管程">附：Java中实现管程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class monitor&#123;</span><br><span class="line">    private Item buffer[] = new Item[N];</span><br><span class="line">    private int count = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void insert(Item item)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过synchronized关键字即可实现类似的功能</p>
<h3 id="条件变量">条件变量</h3>
<p>条件变量用于<strong>进程同步</strong></p>
<p>如下图中定义了a、b、c三个条件变量</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b6a96fe50423fdde236a2db77fda1ac.png" /></p>
<ul>
<li>可以简单理解为资源的<strong>等待队列</strong>，一个条件变量代表一种阻塞的原因</li>
<li>条件变量的调用使用signal/wait</li>
<li>条件变量无法实现互斥，实际使用一般与锁配合使用</li>
</ul>
<p><strong>与信号量的区别</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">信号量</th>
<th style="text-align: center;">条件变量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">是否有值</td>
<td style="text-align: center;">有，表示资源数， 也有等待队列</td>
<td style="text-align: center;">无，仅仅是一个等待队列</td>
</tr>
<tr class="even">
<td style="text-align: center;">操作</td>
<td style="text-align: center;">P、V</td>
<td style="text-align: center;">wait、signal</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">V操作会累计值</td>
<td style="text-align: center;">signal可能会有无效操作</td>
</tr>
</tbody>
</table>
<hr style = "border:2px solid yellow">
<p>题1：管程的定义与特点考察</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/693515d869526eefdd1662014da3c60.jpg" /></p>
<p>解析：</p>
<p>A：管程既能实现互斥也能实现同步</p>
<hr style = "border:2px solid yellow">
<p>题2：管程组成</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f46ac2ec4358b3a0d85e60f9e826369.jpg" /></p>
<p><font color = "red">管程只对自己负责</font></p>
<p>题3：管程中wait和信号量中V操作区别与联系</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f271da63da1219c133a381104d17dc8.jpg" /></p>
<p>解析</p>
<p>信号量机制中的V操作一定会改变信号量S的值：S = S + 1</p>
<p>管程中signal操作是针对某个条件变量，若不存在因该条件而阻塞的进程，则signal不会产生任何影响</p>
<hr style = "border:2px solid yellow;">
<p>题4：条件变量中各个操作的使用 <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f836844501930974768b9a92cdf47c7.jpg" /></p>
<p>解析：</p>
<p>若进程A执行x.wait()操作，则进程A会被阻塞，并挂到条件变量x的阻塞队列上。如果进程B执行x.signal()，会唤醒x对应阻塞队列的队首进程，进程B不受影响</p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.2处理机调度</title>
    <url>/posts/20ce47b7.html</url>
    <content><![CDATA[<h2 id="调度的概念层次">调度的概念、层次</h2>
<span id="more"></span>
<h3 id="调度的概念">调度的概念</h3>
<p>在处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<p><strong>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</strong></p>
<h3 id="调度的层次">调度的层次</h3>
<p><a
href="https://www.youtube.com/watch?v=pTGz9jJv560">视频讲解：三种调度层次</a></p>
<h4 id="作业调度高级调度">作业调度（高级调度）</h4>
<p>按照一定原则从外村上处于后备队列的作业中选择一个（或多个），给它分配内存等必要资源，并<strong>建立相应的进程（建立PCB）</strong>，以使它获得<strong>竞争处理机资源的权利</strong>。</p>
<p>作业调度是外存和内存之间的调度。每个作业只调入一次、调出一次。作业调度时建立相应的PCB；作业调出时撤销相应的PCB。</p>
<h4 id="内存调度中级调度">内存调度（中级调度）</h4>
<p>可以将暂时不能运行的进程调入外存等待。这些进程会进入“<strong>挂起状态</strong>”，其PCB仍然<strong>常驻在内存</strong>，被放入到挂起队列中。其目的是<strong>提高内存利用率和系统吞吐量</strong>。</p>
<p><strong>通过中级调度来决定将哪个处于挂起状态的进程重新调入内存中</strong>。</p>
<h4 id="进程调度低级调度">进程调度（低级调度）</h4>
<p>按照某种方法和策略从就绪队列中选择一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>。其<strong>频率很高</strong>，一般几十毫秒一次。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">调度发生在</th>
<th style="text-align: center;">进程状态变化</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">高级调度</td>
<td style="text-align: center;">外存→内存（面向作业）</td>
<td style="text-align: center;">无→创建态→就绪态</td>
</tr>
<tr class="even">
<td style="text-align: center;">中级调度</td>
<td style="text-align: center;">外存→内存（面向进程）</td>
<td style="text-align: center;">挂起态→就绪态（阻塞挂起→阻塞态）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">低级调度</td>
<td style="text-align: center;">内存→CPU</td>
<td style="text-align: center;">就绪态→挂起态</td>
</tr>
</tbody>
</table>
<h2 id="调度的时机切换与过程">调度的时机、切换与过程</h2>
<h3 id="调度器调度程序">调度器/调度程序</h3>
<p>就绪态与运行态之间的相互切换由调度程序引起并决定。</p>
<ul>
<li><p>让谁运行：调度程序</p></li>
<li><p>运行多久：时间片大小</p></li>
</ul>
<h3 id="进程调度的时机">进程调度的时机</h3>
<p><a
href="https://www.youtube.com/watch?v=LV5eOKoPZAg">视频讲解：进程调度的时机</a></p>
<h4 id="需要进行进程调度的情况">需要进行进程调度的情况</h4>
<ul>
<li><p>当前进程<strong>主动</strong>放弃处理机资源</p>
<ul>
<li><p>进程正常中止</p></li>
<li><p>进程出现异常终止</p></li>
<li><p>进程主动请求阻塞</p></li>
</ul></li>
<li><p>当前进程<strong>被动</strong>放弃处理机资源</p>
<ul>
<li><p>分配的时间片用完</p></li>
<li><p>有更紧急的事件要处理（如I/O中断）</p></li>
<li><p>有更高优先级的进程进入就绪队列</p></li>
</ul></li>
</ul>
<h4 id="不能进行进程调度与切换的情况">不能进行进程调度与切换的情况</h4>
<ul>
<li><p>在处理中断的过程中</p></li>
<li><p>进程处于<strong>操作系统内核程序临界区</strong>中(<a
href="https://www.youtube.com/watch?v=sYQWdEkMfLI">视频讲解：</a>)</p></li>
<li><p>在进行原子操作的过程中（<strong>原语</strong>）。</p></li>
</ul>
<p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源，各进程需要<strong>互斥地</strong>访问临界资源。</p>
<p><strong>临界区</strong>：访问临界资源的那段代码。</p>
<p><strong>内核程序临界区</strong>：一般是用于访问<strong>内核数据结构</strong>的，例如进程的就绪队列。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<h4 id="非剥夺调度方式非抢占方式">非剥夺调度方式（非抢占方式）</h4>
<p>只允许进程主动放弃处理机资源。即便有更高优先级的任务到达，也要等待当前进程主动终止或进入阻塞态。</p>
<ul>
<li><p>实现简单，系统开销小</p></li>
<li><p>无法及时处理紧急任务</p></li>
</ul>
<h4 id="剥夺调度方式抢占方式">剥夺调度方式（抢占方式）</h4>
<p>当有更重要的任务需要使用处理机时，立即暂停当前正在执行的进程，将处理机资源给更紧迫的任务。</p>
<ul>
<li><p>可以优先处理更紧急的任务</p></li>
<li><p>可以让各进程按照时间片轮流执行</p></li>
<li><p>适用于分时操作系统、实时操作系统</p></li>
</ul>
<h3 id="进程的切换与过程">进程的切换与过程</h3>
<h4 id="狭义的进程调度与进程切换">狭义的进程调度与进程切换</h4>
<p><strong>狭义的进程调度</strong>：从就绪队列中<strong>选中一个要运行的进程</strong>。这个进程可以是刚刚被暂停执行的进程，也可以是<strong>另一个进程</strong>，后者就需要<strong>进程切换</strong>。</p>
<p><strong>进程切换</strong>：一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p><strong>广义的进程调度</strong>包含了选择进程和进程切换两个步骤。</p>
<h4 id="进程切换中实现了什么">进程切换中实现了什么</h4>
<ul>
<li><p>对原来进程的各种数据进行保存</p></li>
<li><p>对新的进程进行各种数据的恢复</p></li>
</ul>
<p><strong>进程的切换是有代价的</strong>，过于频繁的进行进程的调度、切换会使得操作系统的效率降低。</p>
<h3 id="闲逛进程">闲逛进程</h3>
<p>用于占位</p>
<ul>
<li><p>优先级最低</p></li>
<li><p>是0地址指令，在指令周期末尾检查中断</p></li>
</ul>
<h2 id="进程调度的基本准则">进程调度的基本准则</h2>
<h3 id="cpu利用率">CPU利用率</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425164409300.png" /></p>
<p>设备利用率同理</p>
<h3 id="系统吞吐量">系统吞吐量</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165100390.png" /></p>
<h3 id="周转时间">周转时间</h3>
<p>周转时间，是指从<strong>作业提交给系统开始</strong>，到<strong>作业完成</strong>这段时间的时间间隔。包括作业等待、在就绪队列中排队、在处理机上运行、进行输入/输出操作所所花费时间的总和。</p>
<p><a
href="https://www.youtube.com/watch?v=ieKNXj3rNvY">视频讲解：理解带权周转时间</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165120693.png" /></p>
<ul>
<li><p>带权周转时间必然≥1</p></li>
<li><p>带权周转时间越小越好</p></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240425165344124.png" /></p>
<h3 id="等待时间">等待时间</h3>
<p>等待时间，指的是进程/作业<strong>处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>
<p>作业等待I/O设备的时间进程也在被服务，不计入等待时间。</p>
<p>还要加上作业在外存后备队列中等待被调度的时间。</p>
<h3 id="响应时间">响应时间</h3>
<p>响应时间，指从用户<strong>提交请求</strong>到<strong>首次响应</strong>所用的时间。</p>
<hr style = "border:2px solid yellow">
<p>举例：计算平均周转时间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d9f720a0b78ee940bbcef234991fcb6.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6fc3041edc7f61329731803a114b288.jpg" /></p>
<p><a
href="https://www.bilibili.com/video/BV1Kz421f7SF/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="典型的调度算法">典型的调度算法</h2>
<p><strong>饥饿</strong>：某个进程/作业长期得不到服务</p>
<h3
id="先来先服务调度算法fcfsfirst-come-first-serve">先来先服务调度算法（FCFS，First
Come First Serve)</h3>
<h4 id="算法思想">算法思想</h4>
<p>主要从“公平”的角度考虑</p>
<h4 id="作业规则">作业规则</h4>
<p>按照作业/进程到达的先后顺序进行服务，即<strong>等待时间</strong>越久的进程/作业越优先得到服务</p>
<h4 id="用于作业进程调度">用于作业/进程调度</h4>
<p>用于作业调度时，考虑的是哪个作业<strong>先到达后备队列</strong>；</p>
<p>用于进程调度时，考虑的是哪个进程<strong>先到达就绪队列</strong></p>
<h4 id="是否可抢占">是否可抢占</h4>
<p>非抢占式算法</p>
<h4 id="优缺点">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>公平</p></li>
<li><p>算法实现简单</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>排在长作业后的短作业需要等待很长的时间，<strong>带权周转时间</strong>很大</li>
</ul></li>
</ul>
<p>即：<strong><em>FCFS对长作业有利，对短作业不利</em></strong></p>
<p><a href="">视频讲解：缺点的感性理解，带权时间大</a></p>
<h4 id="是否会导致饥饿">是否会导致饥饿</h4>
<p>不会</p>
<h3
id="短作业优先调度算法sjfshortest-job-first">短作业优先调度算法（SJF，Shortest
Job First)</h3>
<h4 id="算法思想-1">算法思想</h4>
<p>追求最少的<strong>平均等待时间</strong>，最少的<strong>平均周转时间</strong>、最少的<strong>平均带权周转时间</strong></p>
<h4 id="算法规则">算法规则</h4>
<p>最短的作业/进程优先得到服务</p>
<h4 id="用于作业进程调度-1">用于作业/进程调度</h4>
<p>既可用于作业调度，也可用于进程调度。用于进程调度时称为<strong>短进程优先（SPF,
Shortest Process First）算法</strong></p>
<h4 id="是否可抢占-1">是否可抢占</h4>
<p>SJF和SPF是非抢占式的算法，同时也有抢占式的<strong>最短剩余时间优先</strong>调度算法（SRTN，Shortest
Reamaining Time First Next）</p>
<p>调度的点：</p>
<ol type="1">
<li>就绪队列改变需要进行调度</li>
<li>进程完成时</li>
</ol>
<h4 id="优缺点-1">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li>“最短的”平均等待时间、平均周转时间</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>不公平</p></li>
<li><p>对短作业有利，对长作业不利</p></li>
<li><p>可能产生饥饿现象</p></li>
<li><p>作业/进程的运行时间是由用户提供的，不一定能做到真正的短作业优先</p></li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-1">是否会导致饥饿</h4>
<p>会</p>
<ol type="1">
<li><p>题目中未特别说明，短作业/进程优先算法默认是<strong>非抢占式</strong>的</p></li>
<li><p>SJF调度算法的平均等待时间、平均周转时间最少 ❌</p></li>
<li><p>在所有进程<strong>同时到达</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少
✔</p></li>
<li><p><strong>抢占式的</strong>短作业/进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少
✔</p></li>
<li><p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法(如FCFS)，SJF依然可以获得<strong>较少</strong>的平均等待时间、平均周转时间</p></li>
<li><p>如果选择题中遇到
“SJF算法的平均等待时间、平均周转时间<strong>最</strong>少”
的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p></li>
</ol>
<h3 id="高响应比优先">高响应比优先</h3>
<h4 id="算法思想-2">算法思想</h4>
<p>要综合考虑作业/进程的等待时间和要求服务的时间</p>
<h4 id="算法规则-1">算法规则</h4>
<p>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务</p>
<p><img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\image-20240428084035733.png" /></p>
<h4 id="是否可抢占-2">是否可抢占</h4>
<p>非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
<h4 id="优缺点-2">优缺点</h4>
<ul>
<li><p>综合考虑了等待时间和运行时间（要求服务时间）</p>
<ul>
<li><p>等待时间相同时，要求服务时间短的优先</p></li>
<li><p>要求服务时间相同时，等待时间长的优先</p></li>
</ul></li>
<li><p>对于长作业而言，等待时间越长响应比越高，避免了饥饿问题</p></li>
</ul>
<h4 id="是否会导致饥饿-2">是否会导致饥饿</h4>
<p>不会</p>
<h3
id="时间片轮转调度算法rrround-robin">时间片轮转调度算法（RR，Round-Robin）</h3>
<h4 id="算法思想-3">算法思想</h4>
<p>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。</p>
<h4 id="算法规则-2">算法规则</h4>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>。若进程未在一个时间片内执行完，
则剥夺处理机，将进程放到就绪队列队尾重新排队。如果一个进程在一个时间片内执行完且时间片还有剩余，则从就绪队列中选择下一个进程上处理机</p>
<h4 id="用于作业进程调度-2">用于作业/进程调度</h4>
<p>用于<strong>进程调度</strong>（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p>
<h4 id="是否可抢占-3">是否可抢占</h4>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用
权，因此时间片轮转调度算法<strong>属于抢占式的算法</strong>。由时钟装置发出时钟中断来通知CPU时间片已到。</p>
<h4 id="优缺点-3">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>公平</p></li>
<li><p>响应快</p></li>
<li><p>适用于分时操作系统</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>高频率的进程调度会有一定的开销</p></li>
<li><p>不能区分任务的紧急程度</p></li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-3">是否会导致饥饿</h4>
<p>不会</p>
<p>时间片太大：每个进程在一个时间片内完成，退化成先来先服务调度算法，增大进程响应时间</p>
<p>时间片太小：频繁的进程切换会造成较大的系统开销，导致实际用于进程执行的时间减少</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<ol type="1">
<li><p>进程的周转时间 = 进程的完成时间 - 进程的抵达时间</p></li>
<li><p>非抢占的短进程优先的优先级：抵达时间&gt;进程耗时,</p>
<p>首先先抵达的进程先执行，如果有两个进程同时得到了获得处理器的机会，耗时短的进程先执行</p></li>
<li><p>抢占的短进程优先级：进程耗时&gt;抵达时间</p>
<p>不论抵达时间，只要这个进程时间短就先执行</p></li>
</ol>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/dbfd083e610ddbb34929309ca567d60.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/5c4a3c08db4b55f3c2de414783211ef.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr style = "border:2px solid yellow">
<h3 id="优先级调度算法">优先级调度算法</h3>
<h4 id="算法思想-4">算法思想</h4>
<p>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据<strong>任务的紧急程度</strong>来决定处理顺序。</p>
<h4 id="算法规则-3">算法规则</h4>
<p>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。</p>
<h4 id="用于作业进程调度-3">用于作业/进程调度</h4>
<p>既可用于作业调度，也可用于进程调度，还可用于I/O调度中。</p>
<h4 id="是否可抢占-4">是否可抢占</h4>
<ul>
<li><p>非剥夺式优先级调度算法：在进程主动放弃处理机时进行调度（非抢占的）</p></li>
<li><p>剥夺式优先级调度算法：还需要在就绪队列变化时，检查是否会发生抢占（抢占的）</p></li>
</ul>
<h4 id="优缺点-4">优缺点</h4>
<ul>
<li><p>优点</p>
<ul>
<li><p>用优先级区分紧急程度、重要程度</p></li>
<li><p>适用于实时操作系统</p></li>
<li><p>可以灵活的调整各种作业、进程的偏好程度</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>若不断地有高优先级进程到来，可能会导致饥饿</li>
</ul></li>
</ul>
<h4 id="是否会导致饥饿-4">是否会导致饥饿</h4>
<p>会</p>
<p>静态优先级：进程创建时确定优先级，一直不变</p>
<p>动态优先级：创建进程时有一个初始值，之后视情况动态的调整优先级</p>
<ul>
<li><p>系统进程优先级高于用户进程</p></li>
<li><p>前台进程优先级高于后台进程</p></li>
<li><p>操作系统更偏好I/O型进程，原因如下图</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240428090653912.png" /></p></li>
</ul>
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<h4 id="算法规则-4">算法规则：</h4>
<ul>
<li><p>将进程划分为多个队列，例如系统进程、交互式进程、批处理进程......</p></li>
<li><p>进程创建成功后插入到某个队列中</p></li>
<li><p><strong>队列之间</strong></p>
<ul>
<li><p>固定优先级：高优先级队列空时低优先级才能被调度</p></li>
<li><p>时间片划分：各自分配不同百分比的时间片</p></li>
</ul></li>
<li><p><strong>队列内部</strong>：不同的队列可以采取不同的调度策略</p></li>
</ul>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<p><a
href="https://www.youtube.com/watch?v=huqBqzyx7Zw">视频讲解演示</a></p>
<h4 id="算法思想-5">算法思想</h4>
<p>对其他调度算法的折中权衡</p>
<h4 id="算法规则-5">算法规则</h4>
<ol type="1">
<li><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p></li>
<li><p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</p></li>
<li><p>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p></li>
</ol>
<h4 id="用于作业进程调度-4">用于作业/进程调度</h4>
<p>用于进程调度</p>
<h4 id="是否可抢占-5">是否可抢占</h4>
<p><strong>抢占式的算法</strong>。在k级队列的进程运行过程中，若更上级的队列
(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
<h4 id="优缺点-5">优缺点</h4>
<ul>
<li><p>对各类型进程相对公平（FCFS的优点）；</p></li>
<li><p>每个新到达的进程都可以很快就得到响应（RR的优点）；</p></li>
<li><p>短进程只用较少的时间就可完成非（SPF的优点）；</p></li>
<li><p>不必实现估计进程的运行时间（避免用户作假）；</p></li>
<li><p>可以灵活的调整对各类进程的偏好程度</p></li>
</ul>
<h4 id="是否会导致饥饿-5">是否会导致饥饿</h4>
<p>会</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：计算进程周转时间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/6d4604f3006df742125a89fcbcf881e.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/3ef6bb6f71e0d115a852c155ffb9209.jpg" /></p>
<p>题2：不同调度算法对比：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c315caa8b32cecf15360fe0bfa7bcfc.jpg" /></p>
<p>分析：</p>
<p>CPU繁忙型：类似与长作业，需要占用CPU较长时间，而很少I/O</p>
<p>I/O繁忙型：频繁访问I/O端口，频繁放弃CPU，所以占用CPU时间不长，而一旦放弃就必须重新排队等待调度</p>
<p>时间片轮转调度：无论对于长作业还是短作业分配的时间片都一样，所以几乎没区别</p>
<p>先来先服务：适合CPU繁忙型，不适合I/O繁忙型</p>
<p>短作业优先：适合I/O繁忙型</p>
<p>优先级调度：根据优先级，而优先级与时间无必然关系</p>
<hr style = "border:2px solid yellow">
<h2 id="上下文及其切换机制">上下文及其切换机制</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/096f38e373acdd0ab80a61bc1ca78ac.png" /></p>
<p><strong>红色部分</strong>是进程/线程切换时需要保存/恢复的上下文</p>
<h3 id="进程的上下文切换">进程的上下文切换</h3>
<p>进程切换导致的地址空间代价巨大：</p>
<ul>
<li><p>保存/恢复页表寄存器</p></li>
<li><p>TLB全部失效</p></li>
<li><p>Cache全部失效，有可能需要Cache写回</p></li>
<li><p>新进程运行初期可能缺页率高，需要I/O操作</p></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.5_死锁</title>
    <url>/posts/7677daa1.html</url>
    <content><![CDATA[<h1 id="死锁的概念">死锁的概念</h1>
<span id="more"></span>
<h2 id="死锁的定义"><strong>死锁的定义</strong></h2>
<p>在并发环境下，各进程因竞争资源而造成的一种相互等待对方手里的资源，导致这些进程均阻塞。若没有外力干涉，这些进程都无法继续前进。</p>
<p><strong>死锁：</strong>
互相等待对方手里的资源，导致各进程都阻塞，无法前进的现象</p>
<p><strong>相关概念：</strong></p>
<ul>
<li><strong>饥饿：</strong>
由于长期得不到资源，某进程一直得不到处理机的现象</li>
<li><strong>死循环：</strong>
某进程执行过程中一直跳不出某个循环的现象</li>
</ul>
<h2 id="死锁产生的必要条件"><strong>死锁产生的必要条件</strong></h2>
<p>死锁的产生，以下四个条件缺一不可：</p>
<ul>
<li><strong>互斥条件：</strong>
只有对互斥资源的争抢才可能导致死锁；</li>
<li><strong>不剥夺条件：</strong>
进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放；</li>
<li><strong>请求和保持条件：</strong>
进程已经占用了至少一个资源，同时又提出了新的资源请求，而所请求的资源被其他进程所占用，此时请求被阻塞，但是该进程仍然保持已有的资源不放；</li>
<li><strong>循环等待条件：</strong>
存在一种进程循环等待资源的现象，循环中的每一个进程已获得的资源同时被下一个进程所需求。</li>
</ul>
<p>发生死锁时一定有循环等待，但发生循环等待时未必会死锁。</p>
<p>如果系统中还有其他同类型资源，则不会发生死锁；如果系统中每种资源只有一个，则将会发生死锁。</p>
<p><strong>死锁的处理策略：</strong> - 死锁预防 - 避免死锁 -
死锁的检测及解除</p>
<h1 id="死锁预防">死锁预防</h1>
<h2 id="破坏互斥条件"><strong>破坏互斥条件</strong></h2>
<p>把只能互斥访问的资源变为共享资源。例如使用SPOOLing技术使得设备可以逻辑上共享。但是一般不常用。</p>
<h2 id="破坏不剥夺条件"><strong>破坏不剥夺条件</strong></h2>
<ul>
<li>当某个进程请求新的资源而得不到时，立刻释放其已有资源，以待后面再次申请；</li>
<li>为进程设置不同的优先级，当某个进程需要的资源被其他进程占用时，可以由操作系统协作将想要的资源强行剥夺。</li>
</ul>
<p><em>缺点：</em> - 实现起来较为复杂；</p>
<ul>
<li><p>这种方式会造成前一阶段工作的失效，因此仅适用于易保存和恢复的资源，例如CPU；</p></li>
<li><p>反复申请和释放资源会造成较大的系统开销；</p></li>
<li><p>若采用方案一，可能导致饥饿（某个进程一直被迫放弃已有的资源）。</p></li>
</ul>
<h2 id="破坏请求和保持条件">破坏请求和保持条件</h2>
<p>采用静态分配方法，在运行前一次性申请所需的全部资源，在未获得全部资源前进程不投入运行。一旦投入运行，这些资源一直归此进程所有。</p>
<p><em>缺点：</em> -
对于使用时间很短的资源会造成资源浪费，资源利用率低； -
有可能导致某些进程饥饿。</p>
<h2 id="破坏循环等待条件"><strong>破坏循环等待条件</strong></h2>
<p>采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p><em>缺点：</em></p>
<ul>
<li>不方便增加新的系统资源，有可能需要全部重新分配序号；</li>
<li>进程实际使用资源的顺序可能与序号不一致，会造成资源浪费；</li>
<li>必须依次申请资源，编程麻烦。</li>
</ul>
<h1 id="死锁避免">死锁避免</h1>
<h2
id="安全序列不安全状态死锁的联系"><strong>安全序列、不安全状态、死锁的联系</strong></h2>
<p><a
href="https://www.youtube.com/watch?v=CKtntRRpu9Y">视频讲解：安全序列</a></p>
<ul>
<li><strong>安全序列：</strong>
如果系统按照这种序列分配资源，则每个进程都能顺利完成。</li>
<li><strong>安全状态：</strong>
<font color = "yellow">只要能找出一个安全序列</font>，系统就是安全状态。安全序列可能有多个。</li>
<li><strong>不安全状态：</strong>
如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。</li>
</ul>
<h2 id="银行家算法"><strong>银行家算法</strong></h2>
<p><a
href="https://www.youtube.com/watch?v=iWXaWNREMsU">视频讲解：判断安全性序列</a></p>
<p><font color = "red">比较available数组和need矩阵，看available数组满足need矩阵哪几行，将allocation矩阵中的对应行加入available数组</font></p>
<p><a
href="https://www.youtube.com/watch?v=V4F_u03kB-Y">视频讲解：代码手工模拟银行家算法</a></p>
<p>在系统中有<span class="math inline">\(n\)</span>个进程和<span
class="math inline">\(m\)</span>种资源的情况下，可以使用银行家算法来管理资源的分配。以下是银行家算法的步骤：</p>
<ol type="1">
<li><p><strong>数据表示：</strong></p>
<ul>
<li><p>对于每个进程 <span
class="math inline">\(P_i\)</span>，声明其对各个资源的最大需求数，使用一个
<span class="math inline">\(n \times m\)</span>
的矩阵表示，称为最大需求矩阵 <span
class="math inline">\(Max\)</span>。其中，<span
class="math inline">\(Max[i, j]=K\)</span> 表示进程 <span
class="math inline">\(P_i\)</span> 最多需要 <span
class="math inline">\(K\)</span> 个资源 <span
class="math inline">\(R_j\)</span>。</p></li>
<li><p>使用另一个 <span class="math inline">\(n \times m\)</span>
的矩阵表示系统对所有进程的资源分配情况，称为分配矩阵 <span
class="math inline">\(Allocation\)</span>。</p></li>
<li><p>计算每个进程尚需的资源量，即 <span
class="math inline">\(Need\)</span> 矩阵，由 <span
class="math inline">\(Max - Allocation\)</span>
得到，表示各进程还需要多少资源。</p></li>
<li><p>用一个长度为 <span class="math inline">\(m\)</span> 的一维数组
<span class="math inline">\(Available\)</span>
表示当前系统中还有多少可用资源。</p></li>
</ul></li>
<li><p><strong>请求资源处理：</strong></p>
<ul>
<li><p>若 <span class="math inline">\(Request_i[j] &lt;
Need[i,j]\)</span>，转到步骤3，否则表示请求的资源超出了最大需求，出错。</p></li>
<li><p>若 <span class="math inline">\(Request_i[j] &lt;
Available[j]\)</span>，转到步骤4，否则表示尚无可用资源，<span
class="math inline">\(P_i\)</span> 需等待。</p></li>
</ul></li>
<li><p><strong>资源分配：</strong></p>
<ul>
<li>系统尝试将资源分配给 <span
class="math inline">\(P_i\)</span>，并修改相应数据：
<ul>
<li><span class="math inline">\(Available = Available -
Request_i\)</span></li>
<li><span class="math inline">\(Allocation[i,j] = Allocation[i,j] +
Request_i[j]\)</span></li>
<li><span class="math inline">\(Need[i,j] = Need[i,j] -
Request_i[j]\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>安全性检查：</strong></p>
<ul>
<li><p>进行安全性检查，判断此次分配后系统是否处于安全状态：</p>
<ol type="1">
<li><p>若能找到一个安全序列，则表示系统是安全的，允许分配资源给 <span
class="math inline">\(P_i\)</span>。</p></li>
<li><p>若找不到安全序列，系统处于不安全状态，拒绝分配资源给 <span
class="math inline">\(P_i\)</span>，使其等待。</p></li>
</ol></li>
</ul></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>给定系统资源状态如下：</p>
<ul>
<li>Available = (3, 3, 2)</li>
</ul>
<p>各进程的最大需求和已分配资源如下：</p>
<table>
<thead>
<tr class="header">
<th>进程</th>
<th>最大需求</th>
<th>已分配</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P0</td>
<td>(7, 5, 3)</td>
<td>(0, 1, 0)</td>
</tr>
<tr class="even">
<td>P1</td>
<td>(3, 2, 2)</td>
<td>(2, 0, 0)</td>
</tr>
<tr class="odd">
<td>P2</td>
<td>(9, 0, 2)</td>
<td>(3, 0, 2)</td>
</tr>
<tr class="even">
<td>P3</td>
<td>(2, 2, 2)</td>
<td>(2, 1, 1)</td>
</tr>
<tr class="odd">
<td>P4</td>
<td>(4, 3, 3)</td>
<td>(0, 0, 2)</td>
</tr>
</tbody>
</table>
<p>计算得到：</p>
<p><span class="math display">\[
\begin{align*}
Max &amp;= \begin{bmatrix} 7 &amp; 5 &amp; 3 \\ 3 &amp; 2 &amp; 2 \\ 9
&amp; 0 &amp; 2 \\ 2 &amp; 2 &amp; 2 \\ 4 &amp; 3 &amp; 3 \end{bmatrix}
\\
Allocation &amp;= \begin{bmatrix} 0 &amp; 1 &amp; 0 \\ 2 &amp; 0 &amp; 0
\\ 3 &amp; 0 &amp; 2 \\ 2 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 2
\end{bmatrix} \\
Need &amp;= Max - Allocation = \begin{bmatrix} 7 &amp; 4 &amp; 3 \\ 1
&amp; 2 &amp; 2 \\ 6 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 4 &amp; 3
&amp; 1 \end{bmatrix}
\end{align*}
\]</span></p>
<p>接下来，逐行比较 <span class="math inline">\(Available\)</span> 和
<span class="math inline">\(Need\)</span>，选择 <span
class="math inline">\(Need\)</span> 中比 <span
class="math inline">\(Available\)</span>
小的一行，释放该进程的资源，并更新 <span
class="math inline">\(Available\)</span> 和 <span
class="math inline">\(Need\)</span>。</p>
<p>例如，释放 <span class="math inline">\(P1\)</span>
的资源，则得到：</p>
<p><span class="math display">\[
\begin{align*}
Need_1 &amp;= \begin{bmatrix} 7 &amp; 6 &amp; 0 \\ 4 &amp; 0 &amp; 1 \\
3 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 4 &amp; 3 &amp; 1
\end{bmatrix} \\
Available_1 &amp;= Available + Need_1[1] = (5, 3, 2) + (3, 2, 2) = (8,
5, 4)
\end{align*}
\]</span></p>
<p>按照这个逻辑继续进行，直到所有进程都被释放或者无法找到满足条件的进程。</p>
<p>然后，再次比较 <span class="math inline">\(Available\)</span> 和
<span class="math inline">\(Need\)</span>，如果 <span
class="math inline">\(Need\)</span> 中有一行比 <span
class="math inline">\(Available\)</span>
小，则该行对应的进程不可满足，系统不安全，否则系统是安全的。</p>
<hr style = "border:2px solid yellow">
<h1 id="死锁的检测和解除">死锁的检测和解除</h1>
<p><a
href="https://www.youtube.com/watch?v=4RmefB15I8E">视频讲解：动态过程理解资源分配图实现死锁检测</a></p>
<h2 id="资源分配图"><strong>资源分配图：</strong></h2>
<ul>
<li><p><strong>结构：</strong></p>
<ul>
<li>进程节点：对应一个进程</li>
<li>资源节点：对应一类资源（可能有多个）</li>
</ul></li>
<li><p><strong>边：</strong></p>
<ul>
<li>进程节点 --&gt; 资源节点：进程对资源的申请（每条边代表一个）</li>
<li>资源节点 --&gt;
进程节点：已经为进程分配了资源（每条边代表一个）</li>
</ul></li>
<li><p><strong>环路：</strong></p>
<ul>
<li>若出现环路，意味着满足了循环等待条件，可能存在死锁。</li>
<li>若不存在环路，破坏了循环等待条件，必定不存在死锁。</li>
</ul></li>
</ul>
<h2 id="死锁定理"><strong>死锁定理：</strong></h2>
<p>在资源分配图中，找到既不阻塞也不是孤点的进程 <span
class="math inline">\(P_i\)</span>，消去他所有的请求边和分配边；再找到下一个可以消去所有请求和分配的进程；若能消去图中的所有边，则称该图是可完全简化的。</p>
<p>这些步骤合理地解释了死锁检测和解除的过程。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5f648bda9a66a57c791fec1f01a1533.png" /></p>
<p><strong>死锁定理：</strong></p>
<p>系统会发生死锁的条件是<strong>当且仅当系统状态的资源分配图是不可完全简化的</strong>。</p>
<p>死锁定理<strong>不需要</strong>全部的进程运行所需资源信息。</p>
<h2 id="死锁的解除">死锁的解除</h2>
<p><strong>在化简资源分配图后，还有边连接的进程就是死锁进程</strong>。对于死锁的进程，需要解除死锁。</p>
<ol type="1">
<li><strong>资源剥夺法</strong>：挂起某些死锁进程（暂存到外存上），抢占其资源并分配给其他死锁的进程。需要注意防止被挂起进程产生饥饿；</li>
<li><strong>撤销进程法（终止进程法）</strong>：强制撤销部分甚至全部死锁进程并释放其资源。优点是实现简单，缺点是会导致进程之前的努力全部木大；</li>
<li><strong>进程回退法</strong>：让一个或多个进程回退到可以避免死锁的地步。需要系统记录进程的历史信息并设置还原点。</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.2_虚拟内存</title>
    <url>/posts/b9d479be.html</url>
    <content><![CDATA[<h2 id="虚拟内存的概念">虚拟内存的概念</h2>
<span id="more"></span>
<h3 id="传统存储管理方式的特征">传统存储管理方式的特征</h3>
<ol type="1">
<li><strong>一次性</strong>：作业必须一次性全部装入内存才能开始运行
<ul>
<li>作业很大时，内存无法完全装入，导致作业无法运行</li>
<li>大量作业运行时，内存无法容纳所有作业，导致多道程序并发性下降</li>
</ul></li>
<li><strong>驻留性</strong>：作业一旦进入内存，就会一直驻留在内存中，直到作业运行结束
<ul>
<li>会导致暂时无用的大量数据驻留在内存中，导致内存的浪费</li>
</ul></li>
</ol>
<h3 id="局部性原理">局部性原理</h3>
<p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(
因为程序中存在大量的循环)</p>
<p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p>
<h3 id="虚拟存储器的定义和特征">虚拟存储器的定义和特征</h3>
<p>基于<strong>局部性原理</strong>，</p>
<ul>
<li>在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，
就可以让程序开始执行。</li>
<li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负贵将所需信息从外存调入内存，然后继续执行程序。</li>
<li>若内存空间不够，由操作系统负贵将内存中暂时用不到的信息换出到外存。</li>
</ul>
<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>。</p>
<h4 id="虚拟内存的主要特征">虚拟内存的主要特征</h4>
<ul>
<li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li>
<li><strong>对换性</strong>：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>
<li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li>
</ul>
<h3 id="虚拟内存技术的实现">虚拟内存技术的实现</h3>
<p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<strong>离散分配的内存管理方式</strong>基础上。</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<h2 id="请求分页管理方式">请求分页管理方式</h2>
<p><strong>请求调页功能</strong>：将不在内存中的页面从外存调入内存</p>
<p><strong>页面置换功能</strong>：将暂时用不到的页面调出到外存</p>
<h3 id="页表结构">页表结构</h3>
<p><a
href="https://www.youtube.com/watch?v=76TOpLVoUSE">视频讲解：请求分页中页表结构</a></p>
<p>请求分页式的页表内容包括：</p>
<ul>
<li>页号（隐含）</li>
<li>内存块号</li>
<li><strong>状态位</strong>：该页面是否已经调入内存</li>
<li><strong>访问字段</strong>：该页面在一段时间内的被访问次数，用于页面置换参考</li>
<li><strong>修改位</strong>：页面调入内存后是否被修改过</li>
<li><strong>外存地址</strong>：页面在外存中的存储位置</li>
</ul>
<h3 id="缺页中断机构">缺页中断机构</h3>
<p><a
href="https://www.youtube.com/watch?v=yo3GXOep6VY">视频讲解：缺页中断</a></p>
<p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个<strong>缺页中断</strong>，然后由操作系统的<strong>缺页中断处理程序</strong>处理中断。</p>
<p>此时<strong>缺页的进程阻塞</strong>，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p>
<ol type="1">
<li>如果内存中<strong>有空闲块</strong>，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</li>
<li>如果内存中<strong>没有空闲块</strong>，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li>
</ol>
<p>缺页中断属于内中断，属于故障中断（可以被故障处理程序修复）</p>
<h3 id="地址变换机构">地址变换机构</h3>
<p><a
href="https://www.youtube.com/watch?v=POkQILooQDI">视频讲解：地址变换</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/538ffe766624fae73dbdb27721b4a2e.png" style="zoom: 33%;" /></p>
<ol type="1">
<li>只有<strong>写指令</strong>才需要修改<strong>修改位</strong>。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li>
<li>需要用某种页面置换算法来决定一个换出页面</li>
<li>换入/换出页面都需要启动慢速的I/0操作，如果换入/
换出太频繁，会有很大的开销。</li>
<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>
</ol>
<h2 id="页面置换算法">页面置换算法</h2>
<h3 id="最佳置换算法optoptimal">最佳置换算法（OPT，Optimal）</h3>
<p><a
href="https://www.youtube.com/watch?v=HQGlrb0jo-M">视频讲解：最佳置换</a></p>
<p>每次选择淘汰的页面将是<strong>以后永不使用</strong>，或者<strong>在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。</p>
<p>最佳置换算法可以保证最低的缺页率，但实际运行中无法预知接下来访问页面的顺序，因此<strong>最佳置换算法时无法实现的</strong>。</p>
<h3 id="先进先出置换算法fifo">先进先出置换算法（FIFO）</h3>
<p><a
href="https://www.youtube.com/watch?v=YT9oYI_PwVY">视频讲解：先进先出</a></p>
<p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>。</p>
<p><strong>实现方法</strong>：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。
队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p><strong>Belady异常</strong>：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p><strong>只有FIFO算法会产生belady异常</strong>，且FIFO算法虽然实现简单，但是<strong>算法性能差</strong>。</p>
<h3 id="最近最久未使用置换算法lru">最近最久未使用置换算法（LRU）</h3>
<p><a
href="https://www.youtube.com/watch?v=BdsGIDaq4dw">视频讲解：最近最久未使用</a></p>
<p>每次淘汰的页面是<strong>最近最久未使用的页面</strong>。</p>
<p><strong>实现方法</strong>：赋予每个页面对应的页表项中，用访问字段记录该页面<strong>自上次被访问以来所经历的时间t</strong>。
当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p>实现需要硬件支持，<strong>性能较好，但开销较大</strong>。</p>
<h3 id="时钟置换算法clock">时钟置换算法（CLOCK）</h3>
<p><a
href="https://www.youtube.com/watch?v=atnUe6aqdxY">视频讲解：时钟置换算法</a></p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU,
Not Recently Used）。</p>
<p>简单的CLOCK算法实现方法：</p>
<ul>
<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成
一个循环队列</li>
<li>当某页被访问时，其访问位置为1</li>
<li>当需要淘汰一个页面时，只需检查页的访问位
<ul>
<li>如果是0，就选择该页换出</li>
<li>如果是1，则将它置为0，暂不换出，继续检查下一个页面</li>
</ul></li>
<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描
<ul>
<li>第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择-一个淘汰页面最多会经过两轮扫描</li>
</ul></li>
</ul>
<h4 id="改进型的时钟算法">改进型的时钟算法</h4>
<p>在原基础上，只有被淘汰的页面被修改过时，才需要写回外存。在其他条件都相同时，应<strong>优先淘汰没有修改过的页面</strong>，避免I/O操作。这就是改进型的时钟置换算法的思想。</p>
<p><strong>实现方法</strong>：设置一个修改位，用于表示页面被修改过。0表示未被修改，1表示已修改。为方便讨论，用（访问位，修改位）的形式表示各页面状态。</p>
<ul>
<li>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</li>
<li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</li>
<li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</li>
<li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</li>
</ul>
<h2 id="页面分配策略">页面分配策略</h2>
<h3 id="驻留集大小">驻留集大小</h3>
<p><strong>驻留集</strong>：指请求分页存储管理中给进程分配的物理块的集合。</p>
<p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p>
<ul>
<li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</li>
<li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低</li>
</ul>
<p>分配策略的分类：</p>
<ul>
<li>驻留集数量
<ul>
<li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间<strong>驻留集数量不再改变</strong>。</li>
<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。</li>
</ul></li>
<li>置换策略
<ul>
<li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换</li>
<li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li>
</ul></li>
</ul>
<p>由于采用全局置换必定会导致某个进程的驻留集数量发生变化，故实际上只有三种策略：</p>
<h4 id="固定分配局部置换">固定分配局部置换</h4>
<p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。</p>
<p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p>
<p><strong>缺点</strong>：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。</p>
<h4 id="可变分配全局置换">可变分配全局置换</h4>
<p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。</p>
<p>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。</p>
<p>操作系统会将一些重要的页面锁定，不允许其被换出内存</p>
<p>采用这种策略时，只要某进程发生缺页，
都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个<strong>被选中的进程拥有的物理块会减少，缺页率会增加</strong>。</p>
<h4 id="可变分配局部置换">可变分配局部置换</h4>
<p>刚开始会为每个进程分配一定数量的物理块。</p>
<p>当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。</p>
<ul>
<li>如果进程在运行中<strong>频繁地缺页</strong>，系统会为该进程<strong>多分配</strong>几个物理块，直至该进程缺页率趋势适当程度；</li>
<li>反之，如果进程在运行中<strong>缺页率特别低</strong>，则可适当<strong>减少</strong>分配给该进程的物理块。</li>
</ul>
<p><font color = "red">可变分配全局置换是一定会给分配，可变分配局部置换是需要看频率</font></p>
<h3 id="调入页面的时机">调入页面的时机</h3>
<h4 id="预调页策略">预调页策略</h4>
<ul>
<li>根据局部性原理
<ul>
<li>一次调入若干个相邻的页面可能比一次调入一个页面更高效</li>
<li>但<strong>如果提前调入的页面中大多数都没被访问过，则又是低效的</strong></li>
</ul></li>
<li>因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右</li>
<li>故这种策略<strong>主要用于进程的首次调入</strong>，
由程序员指出应该先调入哪些部分</li>
</ul>
<h4 id="请求调页策略">请求调页策略</h4>
<ul>
<li>进程在运行期间发现缺页时才将所缺页面调入内存。</li>
<li>由这种策略调入的页面一定会被访问到，不存在低效</li>
<li>但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大</li>
<li>这种策略主要在进程运行中使用</li>
</ul>
<h3 id="从何处调入页面">从何处调入页面</h3>
<ol type="1">
<li><p>系统拥有足够的对换区空间</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505111006676.png" /></p>
<ul>
<li>页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。</li>
<li>在进程运行前，需将进程相关的数据从文件区复制到对换区</li>
</ul></li>
<li><p>系统缺少足够的对换区空间</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505110923776.png" style="zoom:50%;" /></p>
<ul>
<li>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</li>
<li>对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</li>
</ul></li>
<li><p>UNIX方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505111105978.png" style="zoom:50%;" /></p>
<ul>
<li>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。</li>
<li>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li>
</ul></li>
</ol>
<h2 id="抖动">抖动</h2>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为<strong>抖动</strong>（颠簸）。</p>
<p>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（<strong>分配给进程的物理块不够</strong>）。</p>
<h2 id="工作集">工作集</h2>
<p>与驻留集不同，工作集指的是在某段时间间隔里，进程<strong>实际访问页面</strong>的集合。</p>
<p>这段时间被称为<strong>窗口尺寸</strong>。一般来说，窗口尺寸会设计的比工作集大很多，根据所得的工作集大小，合理的分配驻留集的大小。</p>
<p>工作集的大小若小于驻留集，则会发生<strong>抖动</strong>现象。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章习题</title>
    <url>/posts/50cd5fe4.html</url>
    <content><![CDATA[<h1 id="进程概念">进程概念</h1>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>4.1_文件系统基础</title>
    <url>/posts/c8d0992d.html</url>
    <content><![CDATA[<h2 id="文件的概念">文件的概念</h2>
<span id="more"></span>
<h3 id="文件的定义">文件的定义</h3>
<p>一组有意义的信息的集合</p>
<h3 id="文件的属性">文件的属性</h3>
<p><strong>文件名</strong>：由创建文件的用户决定，同一目录下不允许存在相同的文件名</p>
<p><strong>标识符</strong>：系统内各文件的唯一标签，对于用户而言不可见</p>
<p><strong>类型</strong>：文件的类型</p>
<p><strong>位置</strong>：文件存放的路径（对用户而言）、在外存中的地址信息（对操作系统而言）</p>
<p><strong>保护信息</strong>：对文件进行访问控制用的信息</p>
<p><strong>创建时间</strong>、<strong>修改时间</strong>等。</p>
<h3 id="操作系统提供的相关功能">操作系统提供的相关功能</h3>
<ul>
<li>创建文件（create系统调用）</li>
<li>删除文件（delete系统调用）</li>
<li>读文件（read系统调用）</li>
<li>写文件（write系统调用）</li>
<li>打开文件（open系统调用）</li>
<li>关闭文件（close系统调用）</li>
</ul>
<p><strong>打开文件表</strong>：存储文件的读写信息</p>
<p>每一位用户有一个自己的打开文件表</p>
<table style="width:100%;">
<colgroup>
<col style="width: 4%" />
<col style="width: 6%" />
<col style="width: 44%" />
<col style="width: 12%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">编号</th>
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">读写指针</th>
<th style="text-align: center;">访问权限</th>
<th style="text-align: center;">系统表索引号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">读/写进程对该 文件的读/写操作
进行到的位置</td>
<td style="text-align: center;">只读/读写/..</td>
<td style="text-align: center;">文件在系统的打开 文件表中的编号</td>
</tr>
</tbody>
</table>
<p>此外，整个系统拥有一张系统打开文件表</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">编号</th>
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">……</th>
<th style="text-align: center;">外存地址</th>
<th style="text-align: center;">打开计数器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">当前有多少进程 打开了此文件</td>
</tr>
</tbody>
</table>
<p>每个文件在系统打开表中仅有一个表项</p>
<p>每个文件在用户打开表中的表项不一定相同</p>
<h2 id="文件的逻辑结构">文件的逻辑结构</h2>
<p><strong>逻辑结构</strong>：在<strong>用户</strong>看来，文件内部的数据应该是如何组织起来的</p>
<p><strong>物理结构</strong>：在<strong>操作系统</strong>看来，文件
的数据是如何存放在外存中的</p>
<h3 id="无结构文件">无结构文件</h3>
<p>文件内部的数据就是一系列二进制流或字符流组成。又称<strong>流式文件</strong>，如：Windows操作系统中的.txt文件、mp3文件等。</p>
<h3 id="有结构文件">有结构文件</h3>
<p>由一组相似的记录组成，又称<strong>记录式文件</strong>。每条记录又若干个数据项组成。如：数据库表文件，CSV文件等。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>（作为识别不同记录的ID）。</p>
<p>根据每条记录的长度是否相等，可以分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</p>
<p>有结构文件的<strong>逻辑结构</strong>可以分为以下三种：</p>
<h4 id="顺序文件">顺序文件</h4>
<p><a
href="https://www.youtube.com/watch?v=YzS-P6HUg3c">视频讲解：顺序文件</a></p>
<p>文件中的记录一个接一个地<strong>顺序排列（逻辑上）</strong>，记录可以是定长的或可变长的。</p>
<p>顺序文件可以有以下存储方式：</p>
<ul>
<li>链式存储：（逻辑上相邻、物理上不相邻）无论是定长/可变长记录，都<strong>只能依次查找</strong>，无法实现随机存取</li>
<li>顺序存储：（逻辑上相邻、物理上也相邻）
<ul>
<li>可变长记录：无法实现随机存储</li>
<li>定长记录：可以实现随机存储。记录长度为L，则第i个记录的相对位置就是 i
* L
<ul>
<li>若采用串结构；（记录之间的顺序与关键字无关，一般按照记录时间排序）无法快速找到对应关键字的记录</li>
<li>若采用顺序结构：（记录之间按照关键字排列）可以迅速查找到相应关键字对应的记录</li>
</ul></li>
</ul></li>
</ul>
<p>考试中一般提到顺序文件默认为<strong>顺序存储的顺序文件</strong></p>
<p><strong>顺序文件实现增删改查较为困难</strong></p>
<h4 id="索引文件">索引文件</h4>
<p><a
href="https://www.youtube.com/watch?v=e6VB1f5l8lQ">视频讲解：索引文件</a></p>
<p>索引表本身是定长记录的顺序文件。因此可以快速找到第i个记录对应的索引项。</p>
<p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p>
<p>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此<strong>主要用于对信息处理的及时性要求比较高的场合</strong>。</p>
<p>同时，可以对不同的数据项建立多个索引表，方便查找。</p>
<p>缺点：当记录数量增大时，索引表的大小也会变大，甚至可能出现索引表比文件本身还大的情况</p>
<p>索引文件是<strong>顺序存储</strong>的，可以使用<strong>折半查找</strong>。</p>
<h4 id="索引顺序文件">索引顺序文件</h4>
<p><a
href="https://www.youtube.com/watch?v=QANMBF37ryE">视频讲解：索引顺序文件</a></p>
<p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<strong>一组记录</strong>对应<strong>一个索引表项</strong>。</p>
<p>即，将文件分为若干组顺序文件，查找时先通过索引表找到所在的顺序文件，再通过顺序检索找到相应的记录。</p>
<p>若有n个记录，则索引顺序文件<strong>最好的分组</strong>为：</p>
<ul>
<li>分成<span class="math inline">\(\sqrt{n}\)</span>组</li>
<li>每组<span class="math inline">\(\sqrt{n}\)</span>条记录</li>
</ul>
<p>索引顺序文件的索引表<strong>不是顺序存储</strong>的，只能使用<strong>顺序查找</strong>。</p>
<h3
id="小结文件物理结构和逻辑结构区别">小结：文件物理结构和逻辑·结构区别</h3>
<p><a
href="https://www.youtube.com/watch?v=37Zt6cKN34Q">视频讲解：文件逻辑结构和物理结构区别</a></p>
<p><font color = "yellow">总结：逻辑结构是用户设置的，物理结构是操作系统设置的</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523091235470.png" /></p>
<p>每个字符1B。在用户看来，整个文件占用一片连续的逻辑地址空间，用fseek找到<font color = "red">逻辑上</font>第十六个字符</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523091530715.png" /></p>
<p>在操作系统角度，就是一堆二进制数据，<font color = "red">随便拆</font>，<font color = "yellow">将（逻辑块号，块内偏移量）转换为（物理块号，块内偏移量）</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523094000179.png" /></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523091605867.png"
alt="连续分配" />
<figcaption aria-hidden="true">连续分配</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523091626894.png"
alt="链接分配" />
<figcaption aria-hidden="true">链接分配</figcaption>
</figure>
<h4 id="创建顺序文件">创建顺序文件</h4>
<h5 id="逻辑上">逻辑上</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523095155829.png" /></p>
<h5 id="物理上">物理上</h5>
<h6 id="连续分配">连续分配</h6>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523095213837.png"
alt="连续分配" />
<figcaption aria-hidden="true">连续分配</figcaption>
</figure>
<h6 id="链接分配">链接分配</h6>
<figure>
<img
src="C:\Users\piolet\AppData\Roaming\Typora\typora-user-images\image-20240523095258592.png"
alt="链接分配" />
<figcaption aria-hidden="true">链接分配</figcaption>
</figure>
<h6 id="索引分配">索引分配</h6>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523095315002.png"
alt="索引分配" />
<figcaption aria-hidden="true">索引分配</figcaption>
</figure>
<h4
id="顺序文件采用顺序存储链式存储用户设计">顺序文件采用顺序存储/链式存储（用户设计）</h4>
<p>顺序文件：各个记录可以顺序存储或链式存储</p>
<h5 id="顺序存储">顺序存储</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523095502397.png"
alt="顺序存储" />
<figcaption aria-hidden="true">顺序存储</figcaption>
</figure>
<h5 id="链式存储">链式存储</h5>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523095659616.png"
alt="链式存储" />
<figcaption aria-hidden="true">链式存储</figcaption>
</figure>
<h4
id="链式存储的顺序文件采用连续分配">链式存储的顺序文件采用连续分配</h4>
<p>其中链式存储是用户逻辑上设置的存储方式，连续分配则是操作系统的物理存储形式</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523100022522.png"
alt="连续分配" />
<figcaption aria-hidden="true">连续分配</figcaption>
</figure>
<h4
id="链式存储的顺序文件采用链接分配">链式存储的顺序文件采用链接分配</h4>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523100055826.png"
alt="链接分配" />
<figcaption aria-hidden="true">链接分配</figcaption>
</figure>
<h4 id="逻辑结构索引文件">逻辑结构：索引文件</h4>
<p>用户自己建立的，映射：关键字à记录存放的逻辑地址</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523100351840.png" /></p>
<h4 id="索引文件采用索引分配">索引文件采用索引分配</h4>
<p>操作系统建立的，映射：逻辑块号à物理块号</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240523100417607.png"
alt="image-20240523100417607" />
<figcaption aria-hidden="true">image-20240523100417607</figcaption>
</figure>
<h2 id="目录结构">目录结构</h2>
<h3 id="文件控制块">文件控制块</h3>
<p>文件控制块（FCB）：<strong>FCB的有序集合称为文件目录</strong>，一个FCB就是一个文件目录项</p>
<p>FCB中包含了文件的：</p>
<ul>
<li>基本信息（文件名、物理地址、逻辑结构、物理结构等）</li>
<li>存取控制信息（是否可读/可写、禁止访问的用户名单等）</li>
<li>使用信息（如文件的建立时间、修改时间等）。</li>
</ul>
<h3 id="目录结构-1">目录结构</h3>
<p>用户需要对目录进行的操作：</p>
<ul>
<li><strong>搜索</strong>：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li>
<li><strong>创建文件</strong>：创建一个新文件时，需要在其所属的目录中增加一个目录项</li>
<li><strong>删除文件</strong>：当删除一个文件时，需要在目录中删除相应的目录项</li>
<li><strong>显示目录</strong>：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li>
</ul>
<p>目录有以下几种结构：</p>
<h4 id="单级目录结构">单级目录结构</h4>
<p><a
href="https://www.youtube.com/watch?v=1LdVuzbKA0c">视频讲解：单级目录</a></p>
<p>整个系统中只建立一张目录表，每个文件占一个目录项。</p>
<ul>
<li>优点
<ul>
<li>实现了按名存取</li>
</ul></li>
<li>缺点
<ul>
<li>不允许文件重名</li>
<li>不适用于多用户操作系统</li>
</ul></li>
</ul>
<h4 id="两级目录结构">两级目录结构</h4>
<p><a
href="https://www.youtube.com/watch?v=-wB7ACafZ1g">视频讲解：两级目录</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240514104454277.png" /></p>
<p>早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master
File Directory）和用户文件目录（UFD，User Flie Directory）。</p>
<p>主目录记录用户名和其用户文件目录存储的位置，用户目录记录用户文件的FCB信息。</p>
<ul>
<li>优点
<ul>
<li>允许不同用户的文件重名</li>
<li>对多用户文件的访问限制</li>
</ul></li>
<li>缺点
<ul>
<li>缺乏灵活性，用户不能对文件进行分类</li>
</ul></li>
</ul>
<h4 id="多级目录结构">多级目录结构</h4>
<p><a
href="https://www.youtube.com/watch?v=7XlI8X_52aE">视频讲解：多级目录</a></p>
<p>又称树形目录结构。用户要访问某个文件时要用<strong>文件路径名</strong>标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从根目录出发的路径称为<strong>绝对路径</strong>。</p>
<p>当目录层数较多时，每次都从根目录查找是很费时的，因此一般会设置<strong>当前目录</strong>。</p>
<p>当用户已经打开了某个目录，即这张目录表已调入内存，那么可以把它设置为当前目录。当用户想要访问某个文件时，可以使用从当前目录出发的<strong>相对路径</strong>。</p>
<ul>
<li>优点
<ul>
<li>便于对文件进行分类</li>
<li>层次结构清晰</li>
</ul></li>
<li>缺点
<ul>
<li>不便于实现文件的共享</li>
</ul></li>
</ul>
<h4 id="无环图目录结构">无环图目录结构</h4>
<p><a
href="https://www.youtube.com/watch?v=DrRiUAvXAp0">视频讲解：无环图目录结构</a></p>
<p>在树形目录结构的基础上，增加些指向同一节点的有向边，使整个目录成为一个<strong>有向无环图</strong>。可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p>
<p>可以更方便地实现多个用户间的文件共享。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/08c7d7eed6c64ed338759e1052c7555.png" /></p>
<p>需要为每个共享结点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除节点的请求时，只是删除该用户的FCB、并使共享计数器减1，<strong>并不会直接删除共享结点</strong>。当共享计数器的值为0时，才会删除该结点。</p>
<h3 id="索引节点">索引节点</h3>
<p><a
href="https://www.youtube.com/watch?v=fPGiBXd2iuI">视频讲解：索引节点</a></p>
<p>由于在查找文件时只需要使用到文件名这一信息，因此可以将其他的文件信息放进<strong>索引节点</strong>中。这样目录中只需要存储<strong>文件名和指向索引节点的指针</strong>即可。</p>
<p>存放在外存中的索引结点称为<strong>磁盘索引结点</strong>，当索引结点放入内存后称为<strong>内存索引结点</strong>。
相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p>
<h3 id="目录的实现">目录的实现</h3>
<ul>
<li><strong>线性表</strong>
<ul>
<li>查找方式：顺序查找</li>
<li>优点：实现简单</li>
<li>缺点：查找比较费时</li>
</ul></li>
<li><strong>哈希表</strong>
<ul>
<li>查找方式：散列查找</li>
<li>优点：查找迅速</li>
<li>缺点：需要一些措施来避免冲突</li>
</ul></li>
</ul>
<p>实际使用中顺序查找比较多</p>
<p>查找得到的是文件的<strong>逻辑地址</strong></p>
<h2 id="文件共享">文件共享</h2>
<h3
id="基于索引节点的共享方式硬链接">基于索引节点的共享方式（硬链接）</h3>
<p>在索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。</p>
<p>当某个用户删除自己的该文件时，只是删除该用户目录项中指向索引节点的条目，并将索引节点中count减一。</p>
<h3 id="基于符号链的共享方式软链接">基于符号链的共享方式（软链接）</h3>
<p>系统创建一个LINK类型的文件，记录了它所指向的文件的路径，当操作系统访问时，通过该路径按级查找目录，得到该文件。</p>
<p>软链接直接复制计数变量，删除文件不影响符号链接。</p>
<p>软连接的方式由于需要逐级访问目录，因此会比硬链接要慢。</p>
<h2 id="文件保护">文件保护</h2>
<h3 id="口令保护">口令保护</h3>
<p>为文件设置一个<strong>口令</strong>，用户请求访问该文件时必须提供口令。</p>
<p>口令一般存放在<strong>文件对应的FCB或索引结点中</strong>。用户访问文件前需要先输
入口令，操作系统会将用户提供 的口令与FCB中存储的口令进行对比，
如果正确，则允许该用户访问文件。</p>
<ul>
<li>优点
<ul>
<li>保存口令的开销不多</li>
<li>验证口令的开销也很小</li>
</ul></li>
<li>缺点
<ul>
<li>口令存放在系统内部，不够安全</li>
</ul></li>
</ul>
<h3 id="加密保护">加密保护</h3>
<p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密。</p>
<p>例如，使用异或运算，密码为01001，则对于文件的原始二进制位每5个一组依次与密码进行异或运算，得到密文，解码时，同样将密文依次异或运算，得到明文。</p>
<ul>
<li>优点
<ul>
<li>保密性强</li>
</ul></li>
<li>缺点
<ul>
<li>加密/解密需要一定的时间</li>
</ul></li>
</ul>
<h3 id="访问控制">访问控制</h3>
<p>在每个文件的FCB（或索引结点）中增加一个<strong>访问控制列表（Access-Control
List，ACL）</strong>，该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p><strong>精简的访问列表</strong>：以<strong>组</strong>为单位，标记各用户组可以对文件执行哪些操作。解决了当系统用户过多时访问控制表过大的问题。</p>
<ul>
<li>优点
<ul>
<li>实现灵活，可以实现复杂的文件保护方式</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.1_内存管理概念</title>
    <url>/posts/24954513.html</url>
    <content><![CDATA[<h2 id="内存相关概念">内存相关概念</h2>
<span id="more"></span>
<p><a
href="https://www.youtube.com/watch?v=Y0Hn4APRxS4">视频讲解：内存基本概念</a></p>
<p>程序执行前需要先放到内存中才能被CPU处理。内存是为了缓和CPU与外存之间的速度矛盾。</p>
<p>内存地址从0开始，每一个地址对应一个<strong>存储单元</strong>（用于存放数据的最小单元）。</p>
<ul>
<li>若计算机按字节编址，则每个存储单元大小为一字节（1B），即8个二进制位；</li>
<li>若计算机按字编址，且字长为16位，则存储单元大小为一个字长，即16个二进制位。</li>
</ul>
<blockquote>
<ul>
<li><strong>千字节 (KB)</strong>: <span
class="math inline">\(2^{10}\)</span> 字节 = 1 KB</li>
<li><strong>兆字节 (MB)</strong>: <span
class="math inline">\(2^{20}\)</span> 字节 = 1 MB</li>
<li><strong>吉字节 (GB)</strong>: <span
class="math inline">\(2^{30}\)</span> 字节 = 1 GB</li>
</ul>
</blockquote>
<p><font color = "red">按字节编址的含义是一个地址对应的空间大小是一个字节</font></p>
<h2 id="内存管理的基本原理和要求">内存管理的基本原理和要求</h2>
<p><a
href="https://www.youtube.com/watch?v=m-9_x4F0Km8">视频讲解：指令的工作原理</a></p>
<h3 id="逻辑地址与物理地址">逻辑地址与物理地址</h3>
<p><strong>逻辑地址</strong>：相对于进程的起始地址而言的地址</p>
<p><strong>物理地址</strong>：实际在内存中的地址</p>
<p>在程序中，一般使用的是逻辑地址。</p>
<h3 id="程序的装入和链接">程序的装入和链接</h3>
<p><a
href="https://www.youtube.com/watch?v=hRTNHX8K4HY">视频讲解：从写程序到运行</a></p>
<p>创建进程时，通常需要将程序和数据装入内存，这一过程通常包含以下几个步骤：</p>
<ul>
<li><p><strong>编译</strong>：将高级语言翻译为机器语言，形成一组<strong>目标模块</strong></p></li>
<li><p><strong>链接</strong>：<strong>形成逻辑地址</strong>，将编译后的的目标模块与所需的静态库一起，形成一个完整的<strong>装入模块</strong></p>
<ul>
<li><strong>静态链接</strong>：在程序执行前将各目标模块及其所需库函数组成一个完整的装入模块</li>
<li><strong>装入时动态链接</strong>：在各目标模块装入时，一边装入一边链接</li>
<li><strong>运行时动态链接</strong>：在程序执行到相应目标模块时，才进行链接
<ul>
<li>便于修改和更新</li>
<li>便于实现对目标模块的共享</li>
</ul></li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=ZuAvWvUCQLs">视频讲解：链接</a></p></li>
<li><p><strong>装入</strong>：将装入模块装入内存运行（<strong>逻辑地址→物理地址</strong>）</p>
<ul>
<li><strong>绝对装入</strong>：若已经知道程序将在内存的哪个位置运行，则编译时就将逻辑地址转换为物理地址
<ul>
<li>灵活性很差，只适用于单道程序环境</li>
</ul></li>
<li><strong>静态重定位（可重定位装入）</strong>：对所有的逻辑单元进行重定位，将其转化为物理地址
<ul>
<li>必须要一次全部装入内存（一次分配所需的全部内存）</li>
<li>逻辑地址必须是<strong>连续的</strong></li>
<li>程序运行期间不能再次移动</li>
</ul></li>
<li><strong>动态重定位（动态运行时装入）</strong>：设置一个<strong>重定位寄存器</strong>，里面存放程序的起始地址。程序<strong>执行</strong>时，会将逻辑地址与重定位寄存器中的值相加得到物理地址
<ul>
<li>允许程序在内存中移动</li>
<li>可以分配到不连续的区域中</li>
<li>可以动态的分配内存</li>
</ul></li>
</ul></li>
</ul>
<p>​ <a
href="https://www.youtube.com/watch?v=KvIaBHajOcA">视频讲解：程序的装入方式</a></p>
<h3 id="内存管理的功能">内存管理的功能</h3>
<p><a
href="https://www.youtube.com/watch?v=i8h6TeURMk8">视频讲解：内存管理</a></p>
<ul>
<li><strong>内存空间的分配与回收</strong>：主存储器空间的分配与管理</li>
<li><strong>地址转换</strong>：逻辑地址到物理地址</li>
<li><strong>内存空间的扩展</strong>：虚拟化</li>
<li><strong>存储保护</strong>：保护各个作业只能访问自己的内存空间</li>
</ul>
<h3 id="内存保护">内存保护</h3>
<ul>
<li>设置<strong>上、下限寄存器</strong>，进行越界检测</li>
<li>通过<strong>重定位寄存器</strong>和<strong>界地址寄存器</strong>，进行越界检测。其中重定位寄存器存放<strong>起始物理地址</strong>，界地址寄存器存放<strong>最大逻辑地址</strong>。</li>
</ul>
<h3 id="内存共享">内存共享</h3>
<ul>
<li><strong>可重入代码</strong>：允许多个进程同时访问，但不允许修改</li>
<li>为每个进程配备局部数据区，将可能改变的部分复制进去，修改进程自己的私有数据</li>
</ul>
<h2 id="覆盖与交换">覆盖与交换</h2>
<h3 id="覆盖技术">覆盖技术</h3>
<p>将用户空间分为一个<strong>固定区</strong>和若干<strong>覆盖区</strong>。</p>
<p>常用的部分放入固定区，不常用的段在需要时放入覆盖区，当需要使用时将相应的段从外存调入覆盖区。</p>
<ul>
<li>内存中能够更新的地方只有覆盖区的部分</li>
<li>对用户不透明</li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=BK51PfeCVxI">视频讲解：覆盖技术</a></p>
<h3 id="交换技术">交换技术</h3>
<p>当内存空间紧张时，将内存中的某些进程暂时<strong>换出</strong>到外存，并将外存中某些已经具备运行条件的进程<strong>换入</strong>内存。</p>
<p>PCB是常驻内存的</p>
<p>中级调度（内存调度）就是决定将哪个处于挂起状态的进程重新换入内存。</p>
<ul>
<li>在具有交换功能的操作系统中，磁盘空间通常分为<strong>文件区</strong>和<strong>对换区</strong>
<ul>
<li>文件区存储文件，追求磁盘空间的利用率，对磁盘空间的管理采用离散分配方式</li>
<li>对换区占用空间很小，追求换入换出速度，对磁盘空间的管理采用连续分配方式</li>
</ul></li>
<li>交换通常发生在有较多进程在运行且内存吃紧的时刻</li>
<li>当系统负荷降低时停止交换</li>
<li>一般会优先换出<strong>阻塞进程</strong>以及<strong>底优先级的进程</strong>，同时为了防止出现饥饿现象，有时还要考选进程在内存的驻留时间</li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=HuYf4BIZ9JY">视频讲解：交换技术</a></p>
<h2 id="连续分配管理方式">连续分配管理方式</h2>
<p>连续分配：系统为用户进程分配的必须是一个<strong>连续的内存空间</strong></p>
<h3 id="单一连续分配">单一连续分配</h3>
<p><a
href="https://www.youtube.com/watch?v=HuYf4BIZ9JY">视频讲解：单一连续分配</a></p>
<p>在单一连续分配方式中，内存被分为系统区和用户区。</p>
<ul>
<li>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；</li>
<li>用户区用于存放用户进程相关数据。</li>
</ul>
<p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>
<ul>
<li>优点：
<ul>
<li>实现简单；</li>
<li>无外部碎片；</li>
<li>可以<strong>采用覆盖技术</strong>扩充内存；</li>
<li>不一定需要采取内存保护（eg: 早期的PC操作系统MS-DOS）</li>
</ul></li>
<li>缺点：
<ul>
<li>只能用于单用户、单任务的操作系统中；</li>
<li>有<strong>内部碎片</strong>；</li>
<li>存储器利用率极低。</li>
</ul></li>
</ul>
<p>内部碎片：系统分配给进程的内存空间中，没有被利用到的区域</p>
<p>外部碎片：内存中的某些空闲分区太小而难以利用</p>
<h3 id="固定分区分配">固定分区分配</h3>
<p><a
href="https://www.youtube.com/watch?v=kQX7MUQpbBM">视频讲解：固定分区分配</a></p>
<p>将整个用户空间划分为若千个<strong>固定大小</strong>的分区，在每个分区中只装入一道作业。</p>
<ul>
<li>分区大小相等：
<ul>
<li>缺乏灵活性</li>
<li>适合用于用一台计算机控制多个相同对象的场合</li>
</ul></li>
<li>分区大小不等：
<ul>
<li>增加了灵活性，可以满足不同大小的进程需求；</li>
<li>根据常在系统中运行的作业大小情况进行划分
（比如：划分多个小分区、适量中等分区+少量大分区）</li>
</ul></li>
</ul>
<p>操作系统需要建立一个数据结构——<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，内容包括对应分区的大小、起始地址、状态(是否已分配)。</p>
<ul>
<li>优点：
<ul>
<li>实现简单；</li>
<li>无外部碎片</li>
</ul></li>
<li>缺点：
<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不<strong>采用覆盖技术</strong>来解决，但这又会降低性能；</li>
<li>会产生内部碎片，内存利用率低。</li>
</ul></li>
</ul>
<h3 id="动态分区分配可变分区分配">动态分区分配（可变分区分配）</h3>
<p><a
href="https://www.youtube.com/watch?v=4QpWyIjvDA0">视频讲解：动态分区分配</a></p>
<p>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此<strong>系统分区的大小和数目是可变的</strong>。</p>
<ol type="1">
<li><p>使用什么数据结构存储内存的使用情况</p>
<ul>
<li><p><strong>空闲分区表</strong>：每一个空闲分区对应一个表项，其内容包括空闲分区的起始地址、大小、分区号、状态等信息</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504201937048.png" /></p></li>
<li><p><strong>空闲分区链</strong>：每一个空闲分区的起始部分和末尾部分分别设置前向指针和后向指针，指向前（后）一个空闲分区，同时在起始部分存储分区大小等信息</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504202030559.png" /></p></li>
</ul></li>
<li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p>
<ul>
<li>使用<strong>动态分区分配算法</strong></li>
</ul></li>
<li><p>如何进行空间的分配与删除</p>
<ul>
<li>使用<strong>空闲分区表</strong>
<ul>
<li><strong>分配</strong>：修改或直接删除相应的空闲分区</li>
<li><strong>回收</strong>：修改或直接新增空闲分区，若存在合并，则删除掉其中一个</li>
</ul></li>
</ul></li>
<li><p>优缺点</p>
<ul>
<li>优点
<ul>
<li>系统分区的大小和数目是可变的</li>
<li>不会产生内部碎片</li>
</ul></li>
<li>缺点
<ul>
<li>可能产生外部碎片</li>
</ul></li>
</ul></li>
</ol>
<p>可以采用“拼凑”（紧凑）技术来解决外部碎片，即操作系统不断地移动各个分区，使之相邻，拼出更大的空闲分区。</p>
<p>紧凑技术需要<strong>重定位寄存器</strong>的支持</p>
<h3 id="动态分区分配算法">动态分区分配算法</h3>
<p>在存在多个可用的空闲分区时，通过动态分区分配算法来决定使用哪个空闲分区</p>
<h4 id="首次适应算法first-fit">首次适应算法（First Fit）</h4>
<p>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。相应的，空闲分区以<strong>地址递增</strong>的方式进行排列。</p>
<h4 id="最佳适应算法best-fit">最佳适应算法（Best Fit）</h4>
<p>尽可能优先使用小的空闲分区，找到第一个能满足大小的空闲分区。相应的，空闲分区按照<strong>容量递增</strong>的方式进行排列。</p>
<p>可能会产生很多<strong>外部碎片</strong>。</p>
<h4 id="最坏适应worst-fit">最坏适应（Worst Fit）</h4>
<p>也称为最大适应算法。优先使用大分区，找到第一个能满足大小的空闲分区。相应的，空闲分区按照<strong>容量递减</strong>的方式进行排列。</p>
<p>大的空闲分区不断变小，可能导致后到来的大进程无内存可用。</p>
<h4 id="邻近适应next-fit">邻近适应（Next Fit）</h4>
<p><a
href="https://www.youtube.com/watch?v=AGczrx-e_pc">视频讲解：领近适应算法</a></p>
<p>相当于对首次适应算法的改良，每一次从<strong>上次查找结束的地方</strong>开始继续查找，找到第一个能满足大小的空闲分区。相应的空闲分区在按照<strong>地址递增</strong>存储的同时，可以使用<strong>循环链表</strong>等类似数据结构。</p>
<ul>
<li>首次适应算法相比于临近适应算法开销较大（每次都要从头开始检索）</li>
<li>首次适应每次都从头开始检索，会优先利用低地址部分的小分区，能够给大进程留下更多的大空闲分区</li>
</ul>
<p>四种算法中，首次适应一般效果是最好的</p>
<h2 id="非连续分配管理方式">非连续分配管理方式</h2>
<h3 id="基本分页存储方式">基本分页存储方式</h3>
<h4 id="数据结构页表">数据结构——页表</h4>
<!--more-->
<p><a
href="https://www.youtube.com/watch?v=UgoWRdQ3dbI">视频讲解：页框和页面的定义</a></p>
<p>将内存空间分为一个个大小相等的分区，每个分区就是一个<strong>页框</strong>（页帧、内存块、物理块、物理页面）。每个页框有一个编号，即<strong>页框号</strong>（页帧号、内存块号、物理块号、物理页号），页框号从0开始。<font color = "yellow">页框是内存被划分</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504210153989.png" style="zoom:50%;" /></p>
<p>将进程的逻辑地址空间也分为<strong>与页框大小相等</strong>的一个个
部分，
每个部分称为一个<strong>页</strong>或<strong>页面</strong>。每个页面也有一个编号，即<strong>页号</strong>，页号也是从0开始。<font color = "yellow">页和页面是进程逻辑划分</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504210811958.png" style="zoom:50%;" /></p>
<ul>
<li>操作系统以页框为单位为各个进程分配内存空间；</li>
<li>进程的页面与内存的页框有一一对应的关系；</li>
<li>各个页面不必连续存放，可以放到不相邻的各个页框中。</li>
</ul>
<p><font color = "yellow">理解记忆：因为进程最终要放到内存中，所以内存的划分叫页框，页框是用来放东西的，进程的划分叫页面，是被放的东西</font></p>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p>
<ul>
<li>一个进程对应一张页表</li>
<li>页表通常存在PCB中，使用专门的<strong>页表基址寄存器</strong>存放</li>
<li>进程的每个<strong>页面</strong>对应一个<strong>页表项</strong></li>
<li>每个页表项由<strong>页号</strong>和<strong>块号</strong>组成</li>
<li>页表记录进程页面和实际存放的<strong>页框</strong>之间的映射关系</li>
</ul>
<p><font color = "yellow">一个进程对应一张页表</font></p>
<p><font color = "yellow">进程的每一个页面对应一个页表项，页表项中保存的是这个页面在内存中对应的页表框的编号，保存页表时不用保存页号，因为就是一个数组</font></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504233222085.png"
alt="页表数据结构" />
<figcaption aria-hidden="true">页表数据结构</figcaption>
</figure>
<p>页表项大小的计算</p>
<p>Eg：假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节?</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504231113089.png" /></p>
<blockquote>
<p>页表项大小的计算</p>
<p>假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节？</p>
<p>内存块大小=页面大小=4KB= <span class="math inline">\(2^{12}\)</span>
B</p>
<p>4GB的内存总共会被分为 <span
class="math inline">\(\frac{2^{32}}{2^{12}} = 2^{20}\)</span>
个内存块。</p>
<p>内存块号的范围应该是 <span class="math inline">\(0 \sim 2^{20} -
1\)</span>。</p>
<p>内存块号至少要用20bit来表示。</p>
<p>至少要用3字节来表示块号(3 * 8 = 24bit)。</p>
</blockquote>
<p>每一个页表项中，块号占上述空间，页号不占存储空间（页表项是连续存放的，只要知道起始地址，即可推算出某个块的地址）</p>
<p><a
href="https://www.youtube.com/watch?v=ACxbNpanJA0">视频讲解：页表数据结构和计算每个页表项占的字节数量</a></p>
<h4 id="逻辑地址的转换">逻辑地址的转换</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240612040405292.png" /></p>
<p><a
href="https://www.youtube.com/watch?v=VZI1nxZPxAs">视频讲解：分页系统的地址变换</a></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240504233808485.png"
alt="如何查找进程中逻辑地址在内存中对应的物理地址" />
<figcaption
aria-hidden="true">如何查找进程中逻辑地址在内存中对应的物理地址</figcaption>
</figure>
<p><font color = "yellow">1. 确定逻辑地址在页面中页号</font></p>
<p>通用方法是除以页面大小后取除法的整数部分</p>
<p>但是如果把页面大小设置为2的整数幂，比如说是<span
class="math inline">\(2^k\)</span>，相当于二进制右移k位，那么留下的就是页号</p>
<p><font color = "yellow">2.
查找这个页面在内存块中开始的物理地址</font></p>
<p>通用方式是以此为下标在页表中查找对应下标单元中存储的对应内存块的编号，用这个编号乘内存块大小即可以得到这个页面在内存块中开始的物理地址</p>
<p>如果页面大小是2的整数幂，比如<span
class="math inline">\(2^k\)</span>，因为将页面映射到内存中，内存中的页框大小和页面大小相同，所以只用将起始地址后k位直接替换为偏移地址即可</p>
<p><font color = "yellow">3.
用第二步得到的开始的物理地址加逻辑地址的偏移地址即可以得到真正的物理地址</font></p>
<p>通用方法是除以页面大小后取除法的小数部分</p>
<p>但是如果把页面大小设置为2的整数幂，比如说是<span
class="math inline">\(2^k\)</span>，相当于二进制右移k位，那么移走的k位就是页内偏移量</p>
<p>虽然进程的各个页是离散存放的，但是页面的内部是连续的。</p>
<blockquote>
<p>如果有 <strong>K 位</strong> 表示
<strong>页内偏移量</strong>，则说明该系统中一个页面的大小是 <span
class="math inline">\(2^{K}\)</span> 个内存单元。</p>
<p>如果有 <strong>M 位</strong> 表示
<strong>页号</strong>，则说明在该系统中，一个进程最多允许有 <span
class="math inline">\(2^{M}\)</span> 个页面。</p>
</blockquote>
<h4 id="基本地址变换机构">基本地址变换机构</h4>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放页表在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。
进程未执行时，页表的始址和页表长度放在<strong>进程控制块(PCB)</strong>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>根据逻辑地址访问内存单元的流程：</p>
<ol type="1">
<li>根据逻辑地址计算出页号、页内偏移量</li>
<li>判断页号是否越界（页号应当<strong>小于</strong>页表长度）</li>
<li>查询页表，找到页号对应的页表项，确定页面的内存块号</li>
<li>用内存块号和页内偏移量得到物理地址</li>
<li>根据物理地址访问内存单元</li>
</ol>
<p><strong>页表长度</strong>：这个页表中总共有几个页表项，即总共有几个页；</p>
<p><strong>页表项长度</strong>：每个页表项占多大的存储空间；</p>
<p><strong>页面大小</strong>：一个页面占多大的存储空间</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>例：若页面大小 <span class="math inline">\(L\)</span>
为1K字节，页号2对应的内存块号 <span
class="math inline">\(b=8\)</span>，将逻辑地址 <span
class="math inline">\(A=2500\)</span> 转换为物理地址 <span
class="math inline">\(E\)</span></p>
<p>（这里页面大小1K也可以描述为“按照字节编址，页内偏移量占10位）</p>
<p>计算页号、页内偏移量：</p>
<p>页号：<span class="math inline">\(P = \frac{A}{L} = \frac{2500}{1024}
= 2\)</span></p>
<p>页内偏移量：<span class="math inline">\(W = A \% L = 2500 \% 1024 =
452\)</span></p>
<p>由题可知，页号2没有越界，且内存块号为8</p>
<p>求物理地址：</p>
<p>物理地址：<span class="math inline">\(E = b \times L + W = 8 \times
1024 + 452 = 8644\)</span></p>
<hr style = "border:2px solid yellow">
<p><strong>页式管理中地址是一维的。</strong>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。只需要给出逻辑地址，计算机就可以得出页号、页内偏移量。</p>
<p><a
href="https://www.youtube.com/watch?v=Hpmd4nOHtf4">视频讲解：页表项大小的设置</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505051610519.png" /></p>
<p>如果不是页表项<span
class="math inline">\(2^k\)</span>，就会有内部碎片</p>
<h4 id="具有快表的地址变换机构">具有快表的地址变换机构</h4>
<p><a
href="https://www.youtube.com/watch?v=oJ7BlPfVkdM">视频讲解：流程图演示快表</a></p>
<p><strong>快表</strong>，又称<strong>联想寄存器</strong>（TLB，Translation
Lookaside
Buffer），是一种<strong>访问速度比内存快很多</strong>的<strong>高速缓存</strong>（TLB不是内存），用来存放<strong>最近访问的页表项的副本</strong>，可以加速地址变换的速度。</p>
<p>与此对应，内存中的<strong>页表</strong>常称为<strong>慢表</strong>。</p>
<ul>
<li>每一次切换进程时处理机会清空快表</li>
<li>在检查完页号是否越界后会尝试访问快表中的副本，若命中，则直接得到内存块号</li>
<li>否则，正常查询，并在找到页表项之后将其存入快表</li>
<li><strong>快表少了一次内存访问</strong></li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：引入快表后耗时计算</p>
<p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1μs，访问一次内存耗时100μs。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少？</p>
<p><span class="math inline">\((1+100) \times 0.9 + (1+100+100) \times
0.1 = 111 \mu s\)</span></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b2fd4a7c4d9f199edd113ef4e075bba.jpg" /></p>
<p><a
href="https://www.youtube.com/watch?v=D-yHXsnUIhg">视频讲解：引入快表的耗时计算</a></p>
<hr style = "border:2px solid yellow">
<p><strong>注意题目中是否支持快慢表一起查询</strong></p>
<p><a
href="https://www.youtube.com/watch?v=8cwrdqSbIsg">视频讲解：局部性原理</a></p>
<h4 id="两级页表">两级页表</h4>
<p>单级页表的问题：</p>
<p><a
href="https://www.youtube.com/watch?v=6Y3jZytvOtU">视频讲解：单级页表存在的问题</a></p>
<ol type="1">
<li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</li>
<li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面（局部性原理）</li>
</ol>
<p>通过将页表进行分组，例如使得每一组恰好装入一个内存块，并对这些分组后的页表再建立一个页表用于查询。分别称为一级页表（页目录表）、二级页表、三级页表等。</p>
<p><a
href="https://www.youtube.com/watch?v=P_cmB0ymSkE">视频讲解：多级页表解决单级页表连续分配问题</a></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><a href="">视频讲解</a></p>
<p>例：某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则要采用（
）级页表，页内偏移量为（ ）位?</p>
<p>分析数据：</p>
<p>页面大小 = 4KB = <span class="math inline">\(2^{12}\)</span> B</p>
<p>页表项大小 = 4B = <span class="math inline">\(2^2\)</span> B</p>
<p>求页号、页内偏移量：</p>
<p>页内偏移量 = 12</p>
<p>页号位数 = 40 - 12 = 28</p>
<p>每一页内可存放的表项：页面大小 / 页表项大小 = <span
class="math inline">\(2^{10}\)</span></p>
<p>剩余的28位可以分为8+10+10，即三级页表</p>
<hr style = "border:2px solid yellow">
<p>当快表不存在时，页表级数越多、访存次数越大。<font color = "red">如果有n级页表，需要访存n
+ 1次</font></p>
<h3 id="基本分段存储管理">基本分段存储管理</h3>
<p><a href="">视频讲解：分段的基本操作</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505071650394.png" /></p>
<p><strong>进程的地址空间</strong>：按照程序自身的逻辑关系划分为若干个段，每个段都有-一个段名，每段从0开始编址</p>
<p><strong>内存分配规则</strong>：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但各段之间可以<strong>不相邻</strong>。</p>
<p>分段系统的逻辑地址结构由<strong>段号</strong>（段名）和<strong>段内地址</strong>（段内偏移量）所组成，其中：</p>
<ul>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>段内地址位数决定了每个段的最大长度是多少</li>
</ul>
<h4 id="段表">段表</h4>
<p><a
href="https://www.youtube.com/watch?v=LY_i0c2xI7A">视频讲解：段表</a></p>
<p>作用与页表类似，结构包括段号、段长、基址，<strong>每个段表项的长度是相同的</strong></p>
<blockquote>
<p>注：每个段的大小不同，但是作为用于查询的段表项大小相同</p>
</blockquote>
<ul>
<li>段号：由于段表项长度相同，可以是隐含的</li>
<li>段长：该段的长度</li>
<li>基址：该段在内存中的起始地址</li>
</ul>
<h4 id="地址变换">地址变换</h4>
<p><a
href="https://www.youtube.com/watch?v=OsBatPp58o4">视频讲解：分段存储地址转换</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505072829203.png" /></p>
<ol type="1">
<li><p>根据逻辑地址得到段号、段内地址</p></li>
<li><p>判断段号是否越界（段号应当小于段表长度M）</p></li>
<li><p>查询段表，得到对应的段表项（段表项地址 = 段表始址 + 段号 *
段表项长度）</p></li>
<li><p>判断段内地址是否超过段长</p>
<blockquote>
<p>注：这是分段存储与分页存储最大区别，因为分页的话每个页面大小相同，所以根据已知逻辑地址和页面大小直接可以计算得到页内偏移地址，并且这个偏移地址不会存在溢出问题，而段内存储的段内地址是另外给出，所以必须要判断是否溢出</p>
</blockquote></li>
<li><p>计算得到物理地址（物理地址 = 段基址 + 段内地址）</p></li>
<li><p>访问目标内存单元</p></li>
</ol>
<h4 id="分段和分页管理的区别">分段和分页管理的区别</h4>
<ul>
<li>分页管理
<ul>
<li>页是信息的物理单位</li>
<li>分页的主要目的是为了实现离散分配，提高内存利用率，<strong>不会产生外部碎片，只有少量的内部碎片</strong></li>
<li>分页仅仅是系统管理上的需要，完全是系统行为，对用户是<strong>不可见的</strong></li>
<li>分页的用户进程地址空间是<strong>一维的</strong>，程序员只需给出一个记忆符即可表示一个地址</li>
<li><font color = "yellow">分页不需要给出页面长度，也就不需要检查页面是否越界</font></li>
</ul></li>
<li>分段管理
<ul>
<li>段是信息的逻辑单位</li>
<li>分段的主要目的是更好地满足用户需求，<strong>会产生外部碎片</strong></li>
<li>一个段通常包含着一组属于一个逻辑模块的信息</li>
<li>分段对用户是<strong>可见的</strong>，用户编程时需要显式地给出段名</li>
<li>分段的用户进程地址空间是<strong>二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li>
<li>分段更容易实现信息的共享和保护</li>
<li><font color = "yellow">分段由于每个段长不同，所以需要记录段长，也需要检测段中是否越界</font></li>
</ul></li>
</ul>
<h3 id="段页式管理方式">段页式管理方式</h3>
<ul>
<li>将进程按逻辑模块分段</li>
<li>再将各段分页（如每个页面4KB）</li>
<li>再将内存空间分为大小相同的内存块</li>
<li>运行进程前将各页面分别装入各内存块中</li>
</ul>
<p>段页式管理方式的逻辑地址由段号、页号和页内偏移量组成，其中</p>
<ul>
<li>段号的位数决定了每个进程最多可以分几段</li>
<li>页号的位数决定了每个段最多有多少页</li>
<li>页内偏移量决定了页面的大小和内存块的大小</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505091212442.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505092216946.png" /></p>
<p><font color = "yellow">段页式管理结构是二维的，需要显示给出段号和这个段首地址</font></p>
<h4 id="数据结构">数据结构</h4>
<p><strong>段表</strong>：段表项包括段号（隐含）、页表长度、页表存放块号（页表起始地址）</p>
<p><strong>页表</strong>：页表项包含页号（隐含）、页面存放的内存块号</p>
<p><a
href="https://www.youtube.com/watch?v=O03Q-B6Z61I">视频讲解：段页式管理</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240505090606052.png" /></p>
<h4 id="地址转化过程">地址转化过程</h4>
<ol type="1">
<li>根据<strong>逻辑地址</strong>得到<strong>段号S</strong>、<strong>页号P</strong>和<strong>页内偏移量W</strong></li>
<li>判断段号是否越界（段号S应当小于段表长度M）</li>
<li>查询段表，找到相应的段表项（段表项地址 = 段表始址F + 段号S *
段表项长度）</li>
<li>检查页号是否越界（页号应当小于页表长度）</li>
<li>根据<strong>页表存放块号</strong>和<strong>页号</strong>找到对应的<strong>页表项</strong></li>
<li>根据<strong>内存块号</strong>和<strong>页内偏移量</strong>得到<strong>物理地址</strong></li>
</ol>
<p>总计三次访问内存</p>
<p>同样可以引入快表，并以段号和页号作为查询关键字，若快表命中，则可以直接得到物理地址，仅需一次访存。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>4.2_文件的系统实现</title>
    <url>/posts/53f2afb5.html</url>
    <content><![CDATA[<h2 id="文件系统结构">文件系统结构</h2>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ac3fef52b3118a3474cf268ead365ef.png" /></p>
<h2 id="文件系统布局">文件系统布局</h2>
<h3 id="文件在磁盘中的结构">文件在磁盘中的结构</h3>
<h4 id="文件系统的建立">文件系统的建立</h4>
<ol type="1">
<li>空白磁盘</li>
<li><strong>物理格式化</strong>
<ul>
<li>划分扇区</li>
<li>检测坏扇区</li>
<li>用备用扇区替换坏扇区</li>
</ul></li>
<li><strong>逻辑格式化</strong>
<ul>
<li>磁盘分区</li>
<li>建立主引导记录</li>
<li>建立系统盘中的引导块、超级块、根目录等等</li>
</ul></li>
</ol>
<h4 id="文件系统中的特殊块">文件系统中的特殊块</h4>
<ul>
<li><strong>主引导记录</strong>：位于0号扇区，用于找到引导块</li>
<li><strong>引导块</strong>：位于系统盘中，启动系统</li>
<li><strong>超级块</strong>：用于快速找到所有的空闲分区，系统启动时载入内存</li>
<li><strong>空闲空间管理</strong>：位示图等</li>
<li><strong>i节点区</strong>：索引节点，存放每个文件的索引节点</li>
<li><strong>根目录</strong></li>
</ul>
<h3 id="文件在内存中的结构">文件在内存中的结构</h3>
<ul>
<li>目录的缓存</li>
<li>系统打开文件表</li>
<li>进程打开文件表</li>
</ul>
<p>设要访问某路径上的文件，实际步骤如下：</p>
<ol type="1">
<li>通过open指令根据路径逐级读入目录</li>
<li>将目录M读入<strong>缓存</strong>，开始寻找目标FCB</li>
<li>找到FCB，复制进入<strong>系统打开文件表</strong>，打开计数设1</li>
<li>在<strong>进程打开文件表</strong>中新建条目，指向相应的系统打开文件表</li>
</ol>
<h2 id="虚拟文件系统vfs">虚拟文件系统（VFS）</h2>
<h3 id="虚拟文件系统的特点">虚拟文件系统的特点</h3>
<ul>
<li>对用户提供统一的接口</li>
<li>要求下层文件系统实现某些特定的函数功能（read、write…）</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/1097136763ff8baaef4c88547c223c0.png" /></p>
<ul>
<li>在内存中创建vnode来存储来自不同文件系统的目录项信息
<ul>
<li>每打开一个文件，就创建一个vnode</li>
<li>vnode中函数功能指针指向实现函数功能的位置</li>
</ul></li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/40379f0b7e75d377d49c10775c94b35.png" /></p>
<h3 id="vfs所定义的对象类型">VFS所定义的对象类型</h3>
<ul>
<li>超级块对象</li>
<li>索引节点对象</li>
<li>目录对象</li>
<li>文件对象</li>
</ul>
<h3 id="文件系统挂载">文件系统挂载</h3>
<ol type="1">
<li>在VFS中注册新挂载的文件系统，在<strong>挂载表</strong>中添加文件系统的相关信息</li>
<li>向VFS提供函数地址列表</li>
<li>将新的问价系统加到<strong>挂载点</strong></li>
</ol>
<h2 id="文件的物理结构">文件的物理结构</h2>
<p><a
href="https://www.youtube.com/watch?v=begoHAhzzzw">视频讲解：磁盘块与文件块</a></p>
<p><strong>磁盘块</strong>：类似于<strong>内存分页</strong>，磁盘中的存储单元也会被分为一个个<strong>块/磁盘块/物理块</strong>。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同</strong>。</p>
<p><strong>文件块</strong>：在外存管理中为了方便对文件数据的管理，与内存管理相似的，<strong>文件的逻辑地址空间</strong>也被分为了一个一个的文件块。</p>
<p>文件的逻辑地址也可以表示为（<em>逻辑块号，块内地址</em>）的形式。</p>
<h3 id="连续分配">连续分配</h3>
<p><a
href="https://www.youtube.com/watch?v=jMQQ3GyQQR0">视频讲解：连续分配</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240613202701991.png" /></p>
<p>连续分配方式要求每个文件在磁盘上占有<strong>一组连续的块</strong>。<font color = "red">即逻辑相邻的也要物理相邻</font></p>
<p>在文件目录中记录存放的<strong>起始块号</strong>和<strong>长度</strong>
。因此只需要找到相应的FCB，即可找到对应的文件。</p>
<p>物理块号=起始块号+逻辑块号(用户给出)</p>
<ul>
<li>优点
<ul>
<li>支持顺序访问(<font color = "yellow">就是要想访问中间一个块，必须从第一个块开始访问</font>)</li>
<li>支持直接（随机）访问(<font color = "yellow">就是要想访问中间一个块，可以通过比如下标直接访问，不要从头开始访问</font>)</li>
<li>在顺序读/写时速度最快（磁道挨着，磁头移动距离最短）</li>
</ul></li>
<li>缺点
<ul>
<li>不方便文件的拓展</li>
<li>存储空间利用率低，会产生磁盘碎片</li>
</ul></li>
</ul>
<h3 id="链接分配">链接分配</h3>
<p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。</p>
<p><strong>记录成组分解技术</strong>：存储时不可以跨越“块”存储记录</p>
<h4 id="隐式链接">隐式链接</h4>
<p><a
href="https://www.youtube.com/watch?v=3B3zvnqH9yI">视频讲解：隐式链接</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240613213113291.png" /></p>
<p>目录中记录了文件存放的<strong>起始块号</strong>和<strong>结束块号</strong>。除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的。同时，在文件目录中包含了第一块和最后一块的指针。</p>
<p>要访问某个磁盘块，需要顺序的访问它前面的所有磁盘块来指向它。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>方便文件拓展</p></li>
<li><p>不会产生碎片</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>只支持顺序存储，不支持随机存储</p></li>
<li><p>指向下一个磁盘块的指针会占用少量空间</p></li>
</ul></li>
</ul>
<h4 id="显式链接">显式链接</h4>
<p><a
href="https://www.youtube.com/watch?v=WpQfRebGC2s">视频讲解：显式链接</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240613213353511.png" /></p>
<p>把用于链接文件各物理块的指针<strong>显式地</strong>存放在一张表中。即文<strong>件分配表</strong>（FAT，File
Allocation Table）。</p>
<p><strong>FAT中存放了物理块号和这个物理块指向的下一个物理块号</strong>。一个磁盘仅设一张FAT，开机时读入并在之后常驻内存。其各个表项在物理上连续存储（即实际硬盘中的依次各物理块），表长相同，因此物理块号是隐含的。</p>
<p>给出逻辑地址，如何找到对应的物理地址：</p>
<p>首先从FCB中找到第0项，然后根据FAT依次往下找</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>方便文件拓展</p></li>
<li><p>不会产生碎片</p></li>
<li><p>支持随机存储</p></li>
<li><p>地址转换不需要访问磁盘（FAT存储在内存中，查询不需要进行IO操作）</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>FAT需要占用一定的空间</li>
</ul></li>
</ul>
<p>题目中没有说则默认为隐式链接</p>
<h3 id="索引分配">索引分配</h3>
<p><a
href="https://www.youtube.com/watch?v=Xq_cNRUVOAU">视频讲解：索引分配</a></p>
<p><a
href="https://www.youtube.com/watch?v=epIOk25c3yc">视频讲解：索引分配基础介绍</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240613214232316.png" /></p>
<p>索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（类似于内存管理中的页表，建立逻辑页面到物理页之间的映射关系)。</p>
<p>索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p>
<p>访问时，先通过FCB找到文件的索引块地址，再根据逻辑地址查找索引块得到实际磁盘块。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>支持随机存储</p></li>
<li><p>易于拓展</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>索引表占用一定的空间</p></li>
<li><p>访问数据块前需要先读入索引块</p></li>
<li><p>可能需要多次磁盘读取操作</p></li>
</ul></li>
</ul>
<p>当文件很大，索引表一个物理块装不下时，有三种处理方案：</p>
<h4 id="链接方案">链接方案</h4>
<p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。FCB中只需要存放第一个索引块的地址即可。</p>
<p>要查找一个块，需要将前面的所有索引表都查找一遍，效率低下。</p>
<h4 id="多层索引">多层索引</h4>
<p><a
href="https://www.youtube.com/watch?v=I0uX0qogqok">视频讲解：多层索引</a></p>
<p>建立多层索引，使第一层索引块指向第二层的索引块。还可根据
文件大小的要求再建立第三层、第四层索引块。</p>
<p>例：假设磁盘块大小为1KB，一个索引表项占4B，则一个
磁盘块只能存放256个索引项。</p>
<p>若某文件采用两层索引，则该文件的最大长度可以到</p>
<p>256×256×1KB=65536KB=64MB256×256×1KB=65536KB=64MB</p>
<p><strong>以两层为例</strong>，访问地址时，先访问FCB找到顶级索引表，根据逻辑地址计算出二级索引表的块号，访问二级索引表，并查询得到物理块号，<strong>共计三次IO访问</strong>。</p>
<ul>
<li><p>缺点</p>
<ul>
<li>即使是小文件，也需要经过K+1次读磁盘（K为索引层数）</li>
</ul></li>
</ul>
<h4 id="混合索引">混合索引</h4>
<p><a
href="https://www.youtube.com/watch?v=WK0OxCl7log">视频讲解：混合索引</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240613214618070.png" /></p>
<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表），还包含两级间接索引（指向两层索引表）
。</p>
<p>解决了小文件读磁盘次数过多的问题。</p>
<p>做题时注意条件中顶级索引块是否已经调入内存。</p>
<h2 id="文件的存储空间管理">文件的存储空间管理</h2>
<h3 id="存储空间的划分与初始化">存储空间的划分与初始化</h3>
<ul>
<li><p>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）</p></li>
<li><p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p>
<ul>
<li><p>目录区：存放FCB、用于磁盘空间管理的相关信息</p></li>
<li><p>文件区：存放文件数据</p></li>
</ul></li>
</ul>
<h3 id="存储空间的管理">存储空间的管理</h3>
<p>文件存储设备的管理实质上就是对空闲块的组织和管理</p>
<h4 id="空闲表法">空闲表法</h4>
<p><strong>如何分配磁盘块</strong>：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p>
<p><strong>如何回收磁盘块</strong>：与内存管理中的动态分区分配很类似，考虑是否合并空闲分区的问题即可。</p>
<h4 id="空闲链表法">空闲链表法</h4>
<p>系统存储链头、链尾指针。</p>
<ul>
<li><p><strong>空闲盘块链</strong>：以<strong>盘块为单位</strong>组成空闲链，每一个盘块中保存指向下一个盘块的指针</p>
<ul>
<li><p>如何分配：若某文件申请K个盘块，则从链头开始依次摘
下K个盘块分配，并修改空闲链的链头指针。</p></li>
<li><p>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p></li>
<li><p>适用于离散的物理结构、分配时可能需要<strong>多次重复</strong>的操作</p></li>
</ul></li>
<li><p><strong>空闲盘区链</strong>：<strong>以盘区（连续的空闲盘块）为单位</strong>组成空闲链，第一个盘块中保存盘区长度、下一个盘区的指针</p></li>
<li><p>如何分配：</p>
<ul>
<li><p>若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，
按照算法规则找到一个大小符合要求的空闲盘区， 分配给文件</p></li>
<li><p>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，
注意分配后可能要修改相应的链指针、盘区大小等数据</p></li>
</ul></li>
<li><p>如何回收：</p>
<ul>
<li><p>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中</p></li>
<li><p>若回收区没有和任何空闲区相邻，将回收区作为单独的盘区挂到链尾</p></li>
</ul></li>
<li><p>离散分配、连续分配均适用，且分配多个盘块时效率更高</p></li>
</ul>
<h4 id="位示图法">位示图法</h4>
<p>每个二进制位对应一个盘块，如0代表盘块空闲，1代表盘块已分配。</p>
<p>位示图一般用连续的字来表示，如一
个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ceaf808ca2ee916c1d641271a719f02.png" /></p>
<p>设字长为n，盘块号为b，字号为i，位号为j，则有：</p>
<p>b=n×i+j i=b/n; j=b%n</p>
<p><strong>如何分配</strong>：</p>
<ul>
<li><p>若文件需要K个块</p>
<ol type="1">
<li><p>顺序扫描位示图，找到K个相邻或不相邻的0</p></li>
<li><p>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</p></li>
<li><p>将相应位设置为1</p></li>
</ol></li>
</ul>
<p><strong>如何回收</strong>：</p>
<ol type="1">
<li><p>根据回收的盘块号计算出对应的字号、位号</p></li>
<li><p>将相应位置的二进制位设为0</p></li>
</ol>
<h4 id="成组链接法">成组链接法</h4>
<p>文件卷的目录区中专门用一个磁盘块作为<strong>超级块</strong>，当系统启动时需要<strong>将超级块读入内存</strong>。并且要保证内存与外存中的超级块数据一致。将空闲块进行分组，如100个一组。</p>
<p>在超级块中，记录了下一个分组的空闲盘块的盘块数和这一组盘块的盘块号。</p>
<p>在每一组的第一个盘块中记录下一组空闲盘块的开始的盘块号。若是最后一组，则记为某个特殊值如-1。</p>
<p>盘块的分组有数量限制，且最后一组的数量上限会少一块（用于标记特殊值）。</p>
<p><strong>如何分配</strong>：</p>
<ol type="1">
<li><p>检查下一个分组中空闲块是否足够</p></li>
<li><p>分配空闲块，并修改空闲块数</p></li>
<li><p>若需要将整租空闲块都分配出去，需要先将第一块的内容复制到超级块中。</p></li>
</ol>
<p><strong>如何回收</strong>：</p>
<ul>
<li><p>若第一个分组没有满，则将该空闲块插入第一组中，修改相应信息；</p></li>
<li><p>若分组已满，需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，<strong>让新回收的块成为第一个分组</strong>。</p></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章_汇编语言程序格式_1</title>
    <url>/posts/c5c98601.html</url>
    <content><![CDATA[<h1 id="完整段定义的伪操作">完整段定义的伪操作</h1>
<span id="more"></span>
<p>8086/8088在管理内存时，需要按照逻辑段进行划分，不同的逻辑段可以用来存放不同目的的数据。在程序中使用四个段寄存器CS,DS,ES和SS来访问它们。</p>
<h2 id="段定义伪指令">段定义伪指令</h2>
<p>一般格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">段名   SEGMENT   [定位类型] [组合类型] [‘类别名&#x27;]</span><br><span class="line">             …...</span><br><span class="line">             ... ...         本段语句序列</span><br><span class="line">             … ...</span><br><span class="line">段名    END</span><br></pre></td></tr></table></figure>
<h3 id="定位类型">定位类型</h3>
<p>定位类型用于决定段的起始边界，即<font color = "red">第一个可存放数据的位置（不是段基址）</font></p>
<h4 id="page">PAGE</h4>
<p>表示该段从一个页面的边界开始</p>
<p>由于<font color = "red">一个页面为256个字节，并且页面编号从0开始</font>，因此，PAGE定位类型的段起始地址的最后8位二进制数一定为0，即以00H结尾的地址。</p>
<h4 id="para">PARA</h4>
<p>表示该段从一个小节的边界开始</p>
<p><font color = "red">如果用户未选定位类型，则缺省为PARA。</font></p>
<h4 id="word">WORD</h4>
<p>表示该段从一个偶数字节地址开始，即段起始单元地址的最后一位二进制数一定是0。</p>
<h4 id="byte">BYTE</h4>
<p>表示该段起始单元地址可以是任一地址值。</p>
<blockquote>
<p>注意：定位类型为PAGE和PARA时，段起始地址与段基址相同。定位类型为WORD和BYTE时，段起始地址与段基址可能不同。</p>
</blockquote>
<h3 id="组合类型">组合类型</h3>
<p>用来指定段与段之间的连接关系和定位</p>
<h4 id="none">NONE</h4>
<p>若未指定组合类型，表示本段与其它段无连接关系。在装入内存时，本段有自己的物理段，因此有自己的段基址。</p>
<h4 id="public">PUBLIC</h4>
<p>在满足定位类型的前提下，将不同模块的同名段邻接在一起，形成一个新的逻辑段，共用一个段基址。段内的所有偏移量调整为相对于新逻辑段段基址的偏移量</p>
<h4 id="common">COMMON</h4>
<p>产生一个覆盖段。在多个模块连接时，把该段与其它也用COMMON说明的同名段置成相同的段基址，这样就达到了共享同一存储区。共享存储区的长度由同名段中最大的段确定。</p>
<h4 id="stack">STACK</h4>
<p>把所有同名段连接成一个连续段，且系统自动对SS段寄存器初始化为该连续段的段基址。并初始化堆栈指针SP。</p>
<p><font color = "red">
用户程序中应至少有一个段用STACK说明，否则需要用户程序自己初始化SS和SP。</font></p>
<h4 id="at表达式">AT表达式</h4>
<p>表示本段可定位在表达式所指示的小节边界上。表达式的值也就是段基值。</p>
<h4 id="memory">MEMORY</h4>
<p>表示本段在存储器中应定位在所有其它段这之后的最高地址上。如果有多个用MEMORY说明的段，则只处理第一个用MEMORY说明的段。其余的被视为COMMON</p>
<h3 id="类别名">类别名</h3>
<p>类别名为某一个段或几个相同类型段设定的类型名称。系统在进行连接处理时，把<font color = "red">类别名相同的段存放在相邻的存储区</font>，但段的划分与使用仍按原来的设定。</p>
<blockquote>
<p>在定义一个段时，段名是必须有的项，而定位类型、组合类型和类别名三个参数是可选项。各个参数之间用空格分隔。<font color = "red">各参数之间的顺序不能改变。</font></p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STACK1   SEGMENT PARA STACK &#x27;STACK0&#x27;</span><br><span class="line">         .....</span><br><span class="line">STACK1   ENDS</span><br><span class="line"></span><br><span class="line">DATA1    SEGMENT PARA &#x27;DATA&#x27;</span><br><span class="line">         ......</span><br><span class="line">DATA1    ENDS</span><br><span class="line"></span><br><span class="line">STACK2   SEGMENT PARA &#x27;STACK0&#x27;</span><br><span class="line">         ......</span><br><span class="line">STACK2   ENDS</span><br><span class="line"></span><br><span class="line">CODE     SEGMENT PARA MEMORY</span><br><span class="line">         ASSUME CS:CODE, DS:DATA1, SS:STACK1</span><br><span class="line">MAIN:</span><br><span class="line">         ......</span><br><span class="line">         ......</span><br><span class="line">CODE     ENDS</span><br><span class="line"></span><br><span class="line">         END MAIN</span><br><span class="line"></span><br><span class="line">DATA2    SEGMENT BYTE &#x27;DATA&#x27;</span><br><span class="line">         ......</span><br><span class="line">DATA2    ENDS</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1HE421u7pw/?spm_id_from=333.1007.top_right_bar_window_history.content.click">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="段寻址伪指令">段寻址伪指令</h2>
<p>段寻址伪指令ASSUME的作用是告诉汇编程序,在处理源程序时，<font color = "yellow">定义的段与哪个寄存器关联</font>。并不设置各个段寄存器的具体内容，段寄存器的值是在程序运行时设定的。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240410064410369.png" /></p>
<p><font color = "yellow">问题：这个怎么在emu8086中看？</font></p>
<blockquote>
<p>注：可以使用关键字NOTHING将前面的设置删除。</p>
<p>ASSUME ES:NOTHING ;删除前面对ES与某个定义段的关联 ASSUME NOTHING
;删除全部4个段寄存器的设置</p>
</blockquote>
<h2 id="段寄存器的装入">段寄存器的装入</h2>
<h3 id="ds和es的装入">DS和ES的装入</h3>
<p><font color = "red">没有声明就无法装入</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d6c268d1985627b4718651b066ef308.jpg" /></p>
<blockquote>
<pre><code>为了改正上述程序中的错误，可以在变量DBYTE2前加一个段前缀说明即可。即：
MOV  ES:DBYTE2[2],  AL</code></pre>
</blockquote>
<p><a
href="https://www.bilibili.com/video/BV1Pt421N7L1/?spm_id_from=333.1007.top_right_bar_window_dynamic.content.click&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><font color = "red">初步小结：貌似既需要用ASSMUE指定段分配到哪个段寄存器里面，也要将段的首地址分配到段寄存器里面？</font></p>
<h3 id="ss的装入">SS的装入</h3>
<p><a href="">视频讲解</a></p>
<h4 id="法一">法一：</h4>
<p><font color = "yellow">1. 组合类型使用STACK参数</font></p>
<p><font color = "yellow">2. ASSUME语句与SS关联</font></p>
<p><font color = "yellow">3.
栈顶指针SP初始化为最大值（根据声明的堆栈段大小决定)</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240418232229883.png" /></p>
<hr style = "border:2px solid yellow">
<h4 id="法二">法二</h4>
<p>类似前面数据段装入，需要额外定义一个变量top</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240418234105426.png" /></p>
<p>堆栈操作都是按字操作</p>
<h2
id="当前位置计数器与定位伪指令orgorigin">当前位置计数器$与定位伪指令ORG(Origin)</h2>
<h3 id="当前位置计数器">当前位置计数器$</h3>
<p><font color = "yellow">$表示当前指针地址</font></p>
<h3 id="定位伪指令org">定位伪指令ORG</h3>
<h4 id="格式">格式</h4>
<p>ORG 数值表达式</p>
<h4 id="作用">作用</h4>
<p>将数值表达式的值赋给当前位置计数器。<font color = "yellow">ORG相当于移动当前位置指针</font>。<font color = "red">赋给它的值必须是正值</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA1    SEGMENT</span><br><span class="line">    ORG 30H</span><br><span class="line">    DB1 DB 12H,34H   ; DB1在DATA1段内的偏移量为30H</span><br><span class="line">    ORG $+20H        ; 保留20H个字节单元，其后再存放&#x27;ABCD....</span><br><span class="line">    STRING DB ‘ABCDEFGHI’</span><br><span class="line">    COUT EQU $-STRING ; 计算STRING的长度</span><br><span class="line">    DB2 DW $          ; 取$的偏移量，类似变量的用法</span><br><span class="line">    ; DB3 DB $         ; 此语句错误!</span><br><span class="line">DATA1 ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE</span><br><span class="line">    ORG 10H</span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    ; ...</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1Mt42177ns/?spm_id_from=333.999.0.0">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="从程序返回操作系统的方法">从程序返回操作系统的方法</h2>
<h3 id="使用dos系统功能调用实现返回">使用DOS系统功能调用实现返回</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，4CH</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>
<h2 id="程序基本结构">程序基本结构</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例3-11】求字存储单元中两个数之差，结果存入下一个相邻的字单元中。</span><br><span class="line">NAME  EXAMPLE</span><br><span class="line">DATA   SEGMENT</span><br><span class="line">BUF    DW 3483H,4596H</span><br><span class="line">RES    DW  ? 	</span><br><span class="line">DATA   ENDS</span><br><span class="line">STACK  SEGMENT STACK ‘STACK’</span><br><span class="line">       STA  DW 100 DUP(?)</span><br><span class="line">STACK  ENDS</span><br><span class="line">CODE   SEGMENT</span><br><span class="line">       ASSUME CS:CODE.DS:DATA</span><br><span class="line"> START:MOV AX,DATA              </span><br><span class="line">       MOV DS,AX </span><br><span class="line">       MOV AX,BUF</span><br><span class="line">       SUB AX,BUF+2</span><br><span class="line">       MOV RES,AX </span><br><span class="line">       MOV AH,4CH</span><br><span class="line">      INT  21H                                 </span><br><span class="line">CODE  ENDS</span><br><span class="line">END   START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1GD421n7p8/?spm_id_from=333.999.0.0">视频讲解</a></p>
<p><font color = "yellow">一个段的名字就是一个段的标号，就是这个段的首地址。是个常亮</font></p>
<p><font color = "yellow">取变量，变量名字出现在指令中，表示取变量中内容</font></p>
<h1 id="dos-功能子程序调用">DOS 功能子程序调用</h1>
<h2 id="带显示的键盘输入1号功能">带显示的键盘输入（1号功能）</h2>
<p><a
href="https://www.bilibili.com/video/BV1EF4m1A7j9/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<p><font color = "red">将字符的ASCII码送入AL寄存器，并在屏幕上显示该字符</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，01H</span><br><span class="line">INT     21H  </span><br></pre></td></tr></table></figure>
<h2 id="不带显示的键盘输入8号功能">不带显示的键盘输入（8号功能）</h2>
<p>除了不显示字符其他和1号功能一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AH，8</span><br><span class="line">INT    21H</span><br></pre></td></tr></table></figure>
<h2 id="字符显示2号功能">字符显示（2号功能）</h2>
<p>打印单个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DL, &#x27;A&#x27;</span><br><span class="line">MOV AH, 02H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>
<p>打印单个字符还好，什么叫数字转ASCII码值？还有2位数需要转字符串循环输出</p>
<p>数字转ASCII码方法：数字+‘0’即可</p>
<h2 id="字符串输入0ah号功能">字符串输入（0AH号功能）</h2>
<p>缓冲区第一个字节是可输入的最大字符数+1</p>
<p>第二个字节是系统在调用该功能时，自动填入的本次调用时实际输入的字符个数，<font color = "yellow">实际应用时初始化时常设置为0</font></p>
<p>从第三个字节开始存放输入字符的ASCII码，当用户输入回车键时，结束输入，并<font color = "red">将回车键的ASCII码（0DH）作为最后一个字符送入缓冲区。但它不计入实际输入字符个数</font></p>
<p>参考代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    CHAR_BUF DB 31H, DB 0, DB 31H DUP(&#x27;$&#x27;)</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:        </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    ; 显示字符串</span><br><span class="line">    MOV DX, OFFSET CHAR_BUF</span><br><span class="line">    MOV AH, 0AH</span><br><span class="line">    INT 21H</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H                   </span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.bilibili.com/video/BV1rt421w7Dv/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h2 id="字符串显示9号功能">字符串显示（9号功能）</h2>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    CHAR_BUF DB &#x27;This is a test&#x27;, 0AH, 0DH, &#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:        </span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    MOV DX, OFFSET CHAR_BUF</span><br><span class="line">    MOV AH, 9H</span><br><span class="line">    INT 21H</span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH         ; 功能号：退出程序</span><br><span class="line">    INT 21H             ; 调用 DOS 中断 21H</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure></p>
<p>解释：</p>
<ul>
<li>0AH表示换行，将光标移到下一行开头。</li>
<li>0DH表示回车，将光标移到当前行开头。</li>
</ul>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章_汇编语言程序格式_2</title>
    <url>/posts/5c9b3e6f.html</url>
    <content><![CDATA[<h1 id="汇编语言程序的开发">汇编语言程序的开发</h1>
<span id="more"></span>
<h2 id="语句类型">语句类型</h2>
<p>指令语句：完成一定操作功能，能够翻译成机器代码</p>
<p>指示语句：提供有关信息，并不能翻译成机器代码</p>
<h3 id="定义数据段部分">定义数据段部分</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">DATA ENDS</span><br></pre></td></tr></table></figure>
<h3 id="定义代码段">定义代码段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CODE SEGMENT</span><br><span class="line">	ASSUME CS:CODE, DS:DATA</span><br><span class="line">CODE ENDS</span><br></pre></td></tr></table></figure>
<h3 id="定义源程序">定义源程序</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START:</span><br><span class="line">    MOV AX,DATA</span><br><span class="line">    MOV DS,AX </span><br><span class="line">    INT 21H </span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p>完整代码组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT      ; 段定义开始（DATA段）</span><br><span class="line">    BUF1 DB 34H   ; 第1个加数</span><br><span class="line">    BUF2 DB 2AH   ; 第2个加数</span><br><span class="line">    SUM  DB 1     ; 准备用来存放和数的单元</span><br><span class="line">DATA ENDS         ; 段定义结束（DATA段）</span><br><span class="line"></span><br><span class="line">CODE SEGMENT      ; 段定义开始（CODE段）</span><br><span class="line">    ASSUME CS:CODE, DS:DATA  ; 规定DATA、CODE分别为数据段和代码段</span><br><span class="line">START:    </span><br><span class="line">    MOV AX,DATA</span><br><span class="line">    MOV DS,AX       ; 将数据段的起始地址显式加载到DS寄存器中</span><br><span class="line">    MOV AL,BUF1     ; 取第1个加数</span><br><span class="line">    ADD AL,BUF2     ; 和第2个加数相加</span><br><span class="line">    MOV SUM,AL      ; 存放结果</span><br><span class="line">    MOV AH,4CH      ; 设置DOS功能号</span><br><span class="line">    INT 21H         ; 返回DOS状态</span><br><span class="line">CODE ENDS         ; 段定义结束（CODE段）</span><br><span class="line"></span><br><span class="line">END START         ; 整个源程序结束</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释： MOV AX,DATA MOV DS,AX 为什么不能直接 MOV DS, DATA</p>
<p>因为在汇编语言中，<code>DATA</code>
只是一个符号，代表着数据段的起始地址，而不是一个立即数。段寄存器（如
<code>DS</code>）只能接受立即数作为其操作数，而不是一个符号。</p>
</blockquote>
<h1 id="参数变量和标号">参数、变量和标号</h1>
<h2 id="符号定义语句伪指令">符号定义语句伪指令</h2>
<h3 id="等值语句">等值语句</h3>
<p>语句格式：符号名 EQU 表达式</p>
<p><font color = "red">上面的替换是前替后</font></p>
<p>功能：用符号名来表示EQU右边的表达式。后面的程序中一旦出现该符号名，汇编程序将把它替换成该表达式。</p>
<hr style = "border:2px solid yellow;">
<p>1.常数或数值表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COUNT  EQU  5</span><br><span class="line">NUM    EQU  COUNT+5</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow;">
<p>2.地址表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR1  EQU  DS：[BP+14]</span><br></pre></td></tr></table></figure>
<p><font color = "red">上面说叫在DS数据段中以BP作基址寻址的一个存储单元。这句话是什么意思</font></p>
<hr style = "border:2px solid yellow;">
<p>3.变量、寄存器名或指令助记符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREG  EQU  CX；在后面的程序使用CREG就是使用CX</span><br><span class="line">CBD   EQU  DAA；DAA为十进制调整指令。  </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow;">
<p><font color = "red">敲重点：在同一源程序中，同一符号不能用EQU定义多次。！！！</font></p>
<h3 id="等号语句">等号语句</h3>
<p>格式：符号名=表达式</p>
<p><font color = "red">敲重点</font></p>
<ol type="1">
<li>等号语句与等值语句具有相同的作用。但等号语句可以对一个符号进行<font color = "yellow">多次定义</font>。</li>
<li>等值语句与等号语句都不会为符号分配存储单元。因此所定义的符号<font color = "yellow">没有段、偏移量和类型等属性</font>。</li>
</ol>
<h3 id="解除定义伪指令purge">解除定义伪指令PURGE</h3>
<p>功能：解除指定符号的定义</p>
<hr style = "border:2px solid yellow">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y1 EQU 7</span><br><span class="line">PURGE Y1</span><br><span class="line">Y1 EQU 128 </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="数据定义伪指令">数据定义伪指令</h2>
<h3 id="常数">常数</h3>
<ol type="1">
<li><p>十进制缺省</p></li>
<li><p>实数</p>
<p>整数部分 • 小数部分E ±指数部分</p>
<p>举例：<font color = "red">2.134 E +10这个到底怎么读？</font></p></li>
<li><p>字符串常数</p>
<ol type="1">
<li><p>单引号或者双引号都可以</p></li>
<li><p>以各个字符的ASCII码值存储在内存。</p></li>
</ol></li>
</ol>
<h3 id="变量">变量</h3>
<h4 id="变量的定义与预置">变量的定义与预置</h4>
<ol type="1">
<li>命名</li>
<li>预制存储单元(伪指令
DB、DW、DD、DQ和DT等)，<font color = "yellow">含义是一次分配出多少存储单元</font></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240403205729101.png" /></p>
<hr style = "border:2px solid yellow">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VAR_DATA SEGMENT</span><br><span class="line">    DATA1 DB 12H    ; 定义 DATA1，包含一个字节的数据 12H</span><br><span class="line">    DATA2 DB 20H,30H    ; 定义 DATA2，包含两个字节的数据 20H 和 30H</span><br><span class="line">    DATA3 DW 5678H    ; 定义 DATA3，包含一个字的数据 5678H</span><br><span class="line">VAR_DATA ENDS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 1.
<font color = "yellow">汇编中声明的变量名也是有地址的（类比C语言中指针的指针）</font></p>
<ol start="2" type="1">
<li>DATA2可以理解成1个数组，这个数组中有2个字节，分别是20H和30H</li>
</ol>
</blockquote>
<hr style = "border:2px solid yellow">
<h4 id="变量的属性">变量的属性</h4>
<h5 id="段属性">段属性</h5>
<p>它表示变量存放在哪一个逻辑段中。</p>
<p>例如上面例子中的变量DATA1、DATA2和DATA3三个变量都存放在VAR-DATA逻辑段中。</p>
<h5 id="偏移量属性offset">偏移量属性（OFFSET)</h5>
<p>它表示变量所在位置与段起始点之间的字节数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c23e5f70c94e2ef26fa21f012b57b36.jpg" /></p>
<p>如上述例子中，变量DATA1的偏移量为0，DATA2为1，DATA3为3。</p>
<h5 id="类型属性">类型属性</h5>
<p>​
它表示变量占用存储单元的字节数。其中DB伪指令定义的变量为字节，DW定义的变量为字，DD定义的为双字（4字节），DQ定义的为4字，DT定义的为5字。</p>
<h4 id="变量赋值表达式">变量赋值表达式</h4>
<h5 id="数值表达式">数值表达式</h5>
<p>例如：DATA1 DB 32，30H
DATA1的内容为32（20H），DATA1+1单元内容为30H.</p>
<h5 id="表达式">？表达式</h5>
<p>不带引号的问号“？”表示可以预置任意内容。</p>
<p>例如：DA-BYTE DB ？，？，？
表示让汇编程序分配三个字节存储单元。这些存储单元的内容的值为任意值。</p>
<p><font color = "yellow">但是在emu8086中无法使用，所以直接写作DA-BYTE
DB 3</font></p>
<h5 id="字符串表达式">字符串表达式</h5>
<h6 id="db">DB</h6>
<p>对于DB伪指令，<font color = "red">字符串为用引号括起来的不超过255个字符</font>。给<font color = "red">每一个字符分配一个字节单元</font>。字符串按<font color = "red">从左到右映射为从低到高存放</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING1 DB ‘ABCDEF’</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160235825.png" /></p>
<hr style = "border:2px solid yellow">
<h6 id="dw">DW</h6>
<p>DW伪指令可以给两个字符组成的字符串分配两个字节存储单元。</p>
<p>两个字符的存放顺序是前一个字符放在高地址，后一字符放低地址单元。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING2 DW ‘AB’, ‘CD’, ’EF’</p>
<p><font color = "yellow">为什么41H比42H高?</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160632184.png" /></p>
<hr style = "border:2px solid yellow">
<h6 id="dd">DD</h6>
<p>给两个字符组成的字符串分配4个字节单元。（就是会强制多分配）</p>
<p>两个字符存放在较低地址的两个字节单元中。存放顺序与DW伪指令相同，而较高的两个字节单元都存放0。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>STRING3 DD ‘AB’, ‘CD’</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406160957395.png" /></p>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：DW和DD伪指令<font color = "red">不能用两个以上</font>字符构成的字符串赋初值，否则将出错。</p>
</blockquote>
<h5 id="dup表达式">DUP表达式</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240406161058532.png" /></p>
<p>表达式1是重复的次数，表达式2是重复的内容。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_A  DB   10H  DUP(?)	; 分配16个字节单元(10H = 16D)</span><br><span class="line">DATA_B  DB   20H  DUP(&#x27;AB&#x27;)	; 分配20H*2=40H个 字节，其内容为重复字符串‘AB’</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：DUP的嵌套使用</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e31ed9ea0bf3d693348d30b48bf55fd.jpg" /></p>
</blockquote>
<h4 id="变量的使用">变量的使用</h4>
<h5 id="在指令语句中引用">在指令语句中引用</h5>
<h6 id="直接引用变量名">直接引用变量名</h6>
<p>在指令语句中<font color = "red">直接引用变量名</font>就是对其<font color = "red">存储单元的内容</font>进行存取</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DA1 DB 0FEH    ; 将 0FEH 存储在 DA1 中</span><br><span class="line">DA2 DW 52ACH    ; 将 52ACH 存储在 DA2 中</span><br><span class="line">...</span><br><span class="line">MOV AL, DA1    ; 将 DA1 中的数据 (0FEH) 传送到 AL 中, 而不是DA1的地址，这一点很重要</span><br><span class="line">MOV BX, DA2    ; 将 DA2 中的数据 (52ACH) 传送到 BX 中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h6 id="变量名出现在编制寻址">变量名出现在编制寻址</h6>
<p><font color = "red">变量名作为地址</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">DA3  DB  10H  DUP(?)</span><br><span class="line">DA4  DW  10H  DUP（1）</span><br><span class="line">MOV  DA3[SI]，AL		; 将AL的内容送入从DA3 开始再偏移(SI)的存储单元中</span><br><span class="line">ADD  DX，DA4[BX][DI]	; 将从DA4开始再偏移(BX)+(DI)的字存储单元的内容与DX的内容相加，结果送回DX中。</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>总结：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/20c432cdfa1474bf62d93726ec4d20b.jpg" /></p>
<h5 id="在伪指令语句中引用">在伪指令语句中引用</h5>
<p>之前声明的变量名赋给新变量名，新变量得到的是原变量的偏移地址（新变量大小是1个字）或偏移地址+段地址（新变量大小是2个字）</p>
<hr style = "border:2px solid yellow">
<p>举例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     设上述语句所在段的段基值为0915H，NUM的偏移量为0004H</span><br><span class="line">NUM DB 75H    ; 将 75H 存储在 NUM 中</span><br><span class="line">ARRAY DW 20H DUP(0)    ; 定义一个大小为 20 的字数组，每个单元里有4个存储单元。并全部初始化为 0</span><br><span class="line">ADR1 DW NUM    ; 将 NUM 的偏移地址存储在 ADR1 中</span><br><span class="line">ADR2 DD NUM    ; 将 NUM 的偏移地址和段地址存储在 ADR2 中</span><br><span class="line">ADR3 DW ARRAY[2]    ; 将 ARRAY 的第 2 个元素的偏移地址存储在 ADR3 中</span><br></pre></td></tr></table></figure></p>
<p>详细解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARRAY DW 20H DUP(0) </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8650cfe09bfbdf274d894e08bfeebd7.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR1 DW NUM</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240406191100.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR2 DD NUM   </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6bd40a9707c89b23590adf30d332ed8.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR3 DW ARRAY[2]    </span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/984d428c1d26418fce2c518d930b656.jpg" /></p>
<p><font color = "red">注意ARRAY[ 1 ]和ARRAY + 1的区别</font></p>
<p><font color = "yellow">居然不是从0开始数？</font></p>
<hr style = "border:2px solid yellow">
<h2 id="标号">标号</h2>
<p>定义：标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地，即作转移指令的操作数。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8ef02dbc46243bd657be08fc6f42a5e.jpg" /></p>
<p>属性</p>
<p>（1）段属性（SEG）</p>
<p>表示该标号所代表的地址在哪个逻辑段中，即段基值。</p>
<p>（2）偏移量属性（OFFSET）</p>
<p>它表示该标号所代表的地址在段内与段起点间的字节数，即地址的偏移量。</p>
<p><font color = "yellow">（3）距离属性（也叫类型属性）</font></p>
<p>它表示该标号可以被段内还是段间的指令调用。</p>
<ol type="1">
<li><p>NEAR（近）：该标号<font color = "yellow">只能作段内转移</font>，也就是说只能是与该标号所指指令同在一个逻辑段的转移指令和调用指令才能使用它。<font color = "yellow">缺省的情况下都默认是NEAR</font>
如 SUB1：MOV AX，30H (也可以显式声明：标号名 LABEL NEAR)</p></li>
<li><p>FAR（远）：该标号可以被非本段的转移和调用指令使用。需要显式指明。格式为：
标号名 LABEL FAR</p></li>
</ol>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB1_FAR    LABEL    FAR</span><br><span class="line">SUB1:  MOV  AX,30H</span><br></pre></td></tr></table></figure>
<p>SUB1_FAR与SUB1两个标号具有相同的段属性和偏移量属性，即相同的逻辑地址。被转移指令或调用指令访问时，是指同一个入口地址，但SUB1-FAR可以被其它段的指令调用。</p>
<hr style = "border:2px solid yellow">
<h1 id="表达式与运算符">表达式与运算符</h1>
<h2 id="算术运算符">算术运算符</h2>
<ol type="1">
<li><p>运算符“+”和“-”也可作单目运算符，表示数的正负。</p></li>
<li><p>使用“+”、“-”、“＊”、和“/”运算符时，参加运算的数和运算结果都是整数。</p></li>
<li><p>“/”运算为取商的整数部分，而“MOD”运算取除法运算的余数。</p></li>
<li><p>"SHR"和"SHL"为逻辑移位运算符</p>
<blockquote>
<p>注意：移位运算符与移位指令区别在于， <font color = "red">
移位运算符的操作对象是某一具体的数（常数），而移位指令是对一个寄存器或存储单元</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>移位运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NUM=11011011B</span><br><span class="line">…</span><br><span class="line">MOV   AX, NUM SHL 1</span><br><span class="line">MOV   BX, NUM SHR 2</span><br><span class="line">ADD   DX, NUM SHR 6</span><br></pre></td></tr></table></figure>
<p>移位指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHL AX 1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
</blockquote></li>
<li><p>下标运算符“[ ]”具有相加的作用</p>
<p>作用：将表达式1与表达式2的值相加后形成一个存储器操作数的地址。</p>
<p><font color = "yellow">下面这两个语句等效</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV   AX, DA_WORD[20H]</span><br><span class="line">MOV   AX, DA_WORD+20H</span><br></pre></td></tr></table></figure>
<p><font color = "red">敲重点,
MOV中什么时候是取地址里所保存变量的值，什么时候是取地址</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409063256494.png" /></p>
<p><font color = "yellow">总结：寄存器之间如果是[]连接就是取地址里的值，如果是+连接就是取地址</font></p></li>
</ol>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>逻辑运算符有NOT、AND、OR和XOR等四个，它们执行的都是按位逻辑运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AX, NOT 0F0H   =&gt; MOV  AX, 0FF0FH</span><br><span class="line">MOV  AL, NOT 0F0H   =&gt; MOV  AL, 0FH</span><br><span class="line">MOV  BL, 55H AND 0F0H =&gt; MOV  BL, 50H</span><br><span class="line">MOV  BH, 55H OR 0F0H  =&gt; MOV  BH, 0F5H</span><br><span class="line">MOV  CL, 55H XOR 0F0H =&gt; MOV  CL, 0A5H</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符">关系运算符</h2>
<p>关系运算符包括：EQ（等于）、NE（不等于）、LT（小于）、
LE（小于等于）、GT（大于）、 GE（大于等于）</p>
<ol type="1">
<li>关系运算符用于比较两个表达式的大小。关系运算符比较的两个表达式<font color = "yellow">必须同为常数或同一逻辑段中的变量</font></li>
<li>如果是<font color = "yellow">常量</font>的比较，则按<font color = "yellow">无符号数</font>进行比较；如果是<font color = "yellow">变量</font>的比较，则比较它们的<font color = "yellow">偏移量</font>的大小。</li>
<li>关系运算符得到结果<font color = "yellow">如果是true，将所有位改为1</font>，相反全部改为0</li>
</ol>
<h2 id="数值返回运算符">数值返回运算符</h2>
<h3 id="seg运算符">SEG运算符</h3>
<p>取变量或标号所在段的段基值。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409064348465.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="offset运算符">OFFSET运算符</h3>
<p>该运算符的作用是取变量或标号在段内的偏移量。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409065001320.png" /></p>
<hr style = "border:2px solid yellow">
<h3 id="type运算符">TYPE运算符</h3>
<p>该运算符的作用为取变量或标号的类型属性，并用数字形式来表示。<font color = "yellow">对变量来说就是取它的字节长度。</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409225139483.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V1    DB    &#x27;ABCDE&#x27;</span><br><span class="line">V2    DW   1234H, 5678H</span><br><span class="line">V3    DD    V2   ; 存放V2的段基值和偏移量</span><br><span class="line">       ……</span><br><span class="line">       MOV   AL, TYPE V1</span><br><span class="line">       MOV   CL, TYPE V2</span><br><span class="line">       MOV   CH, TYPE V3</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV  AL，01H</span><br><span class="line">MOV  CL，02H</span><br><span class="line">MOV  CH，04H</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="length运算符">LENGTH运算符</h3>
<p>该运算符<font color = "red">只能加在变量的前面，且只能管最外层</font>。比如如果变量是用重复数据操作符DUP说明的，则返回外层DUP给定的值。如果没有用DUP说明，则返回值总是1。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1  DB   10H DUP(0)</span><br><span class="line">K2  DB   10H, 20H, 30H, 40H</span><br><span class="line">K3  DW   20H DUP(0, 1, 2 DUP(0))</span><br><span class="line">K4  DB   &#x27;ABCDEFGH&#x27;</span><br><span class="line">……..</span><br><span class="line">MOV   AL, LENGTH K1; (AL)=10H</span><br><span class="line">MOV   BL, LENGTH K2; (BL)=1</span><br><span class="line">MOV   CX, LENGTH K3; (CX)=20H</span><br><span class="line">MOV   DX, LENGTH K4; (DX)=1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="size运算符">SIZE运算符</h3>
<p>该运算符<font color = "red">只能作用于变量</font>，SIZE取值<font color = "yellow">等于LENGTH和TYPE两个运算符返回值的乘积</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1  DB   10H DUP(0)</span><br><span class="line">K2  DB   10H, 20H, 30H, 40H</span><br><span class="line">K3  DW   20H DUP(0, 1, 2 DUP(0))</span><br><span class="line">K4  DB   &#x27;ABCDEFGH&#x27;</span><br><span class="line">……..</span><br><span class="line">MOV   AL, SIZE K1 ; (AL)=10H</span><br><span class="line">MOV   BL, SIZE K2 ; (BL)=1</span><br><span class="line">MOV   CL, SIZE K3 ; (CL)=20H*2=40H</span><br><span class="line">MOV   DL, SIZE K4 ; (DL)=1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="属性修改运算符">属性修改运算符</h2>
<h3 id="ptr运算符">PTR运算符</h3>
<p><font color = "red">临时修改，类似于C语言强转</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DA_BYTE    DB   20H DUP(0)</span><br><span class="line">DA_WORD    DW   30H DUP(0)</span><br><span class="line">      ……</span><br><span class="line">MOV   AX, WORD PTR DA_BYTE[10]</span><br><span class="line">ADD   BYTE PTR DA_WORD[20], BL	; DA_WORD本来大小是一个字大小，强转成1个字节大小</span><br><span class="line">INC   BYTE PTR [BX]</span><br><span class="line">SUB   WORD PTR [SI], 100</span><br><span class="line">JMP   FAR PTR SUB1 ; 指明SUB1不是本段中的地址</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="highlow运算符">HIGH/LOW运算符</h3>
<p><font color = "red">将一个数据分离出高字节和低字节。</font></p>
<p>如果表达式为一个常量，则将其分离成高8位和低8位；如果表达式是一个地址（段基值或偏移量）时，则分离出它的高字节和低字节。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">CONST EQU 0ABCDH</span><br><span class="line">DA1 DB 10H DUP(0)</span><br><span class="line">DA2 DW 20H DUP(0)</span><br><span class="line">DATA ENDS</span><br><span class="line">      …….</span><br><span class="line">MOV AH, HIGH CONST</span><br><span class="line">MOV AL, LOW CONST</span><br><span class="line">MOV BH, HIGH (OFFSET DA1)</span><br><span class="line">MOV BL, LOW (OFFSET DA2)</span><br><span class="line">MOV CH, HIGH (SEG DA1)</span><br><span class="line">MOV CL, LOW (SEG DA2)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH, 0ABH</span><br><span class="line">MOV AL, 0CDH</span><br><span class="line">MOV BH, 00H</span><br><span class="line">MOV BL, 10H</span><br><span class="line">MOV CH, 09H</span><br><span class="line">MOV CL, 26H</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：<font color = "red">HIGH/LOW运算符不能用来分离一个变量、寄存器或存储器单元的高字节与低字节。</font></p>
</blockquote>
<h3 id="this运算符">THIS运算符</h3>
<p>THIS运算符一般与等值运算符EQU连用，用来定义一个变量或标号的类型属性。所定义的变量或标号的段基值和偏移量与紧跟其后的变量或标号相同。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_BYTE  EQU THIS BYTE</span><br><span class="line">DATA_WORD  DW 10 DUP(0)</span><br><span class="line">          ……</span><br><span class="line">          MOV AX, DATA_WORD</span><br><span class="line">          MOV BL, DATA_BYTE</span><br><span class="line">          …...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = "yellow">问题：什么意思？</font></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章_基本汇编语言程序设计_1</title>
    <url>/posts/a122e292.html</url>
    <content><![CDATA[<h1 id="顺序程序设计">顺序程序设计</h1>
<span id="more"></span>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>利用学号查学生的数学成绩表</p>
<p>算法分析：首先在数据段中建立一个成绩表TABLE，在表中各学生的成绩按照学号从小到大的顺序存放。要查的学号存放在变量NUM中，查表的结果放在变量MATH中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TITLE   TABLE LOOKUP</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT</span><br><span class="line">    TABLE DB 81,78,90,64,85,76,93,82,57,80</span><br><span class="line">          DB 73,62,87,77,74,86,95,91,82,71</span><br><span class="line">    NUM   DB 8</span><br><span class="line">    MATH  DB ?</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">    DW 20H DUP(0)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">COSEG   SEGMENT</span><br><span class="line">    ASSUME CS:COSEG, DS:DATA, SS:STACK1</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    MOV BX, OFFSET TABLE    ; BX指向表首址</span><br><span class="line">    XOR AH, AH</span><br><span class="line">    MOV AL, NUM             ; 找第8个学生，但是下标是7</span><br><span class="line">    DEC AL</span><br><span class="line">    ADD BX, AX              ; BX加上学号指向要查的成绩</span><br><span class="line">    MOV AL, [BX]            ; 查到成绩送AL</span><br><span class="line">    MOV MATH, AL            ; 存结果</span><br><span class="line">    MOV AH, 4CH             ; 返回DOS</span><br><span class="line">    INT 21H</span><br><span class="line">COSEG   ENDS</span><br><span class="line"></span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><a href="">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h1 id="分支程序设计">分支程序设计</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240426074513737.png" /></p>
<h2 id="转移指令">转移指令</h2>
<p>格式: JMP 目标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:</span><br><span class="line">JMP TARGET</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line">TARGET:</span><br><span class="line">    ...........</span><br><span class="line">    :</span><br></pre></td></tr></table></figure>
<h2
id="用比较测试指令条件转移指令实现分支">用比较/测试指令+条件转移指令实现分支</h2>
<h1 id="数据转移">数据转移</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5869d150e4b1d6b7278131bad30568a.jpg" /></p>
<p><font color = "yellow">当源块首地址&lt;目的块首地址时，从数据块末地址开始传送。反之，则从首地址开始传送</font></p>
<blockquote>
<p>注：跳转指令一览</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0f213110d0a8998ace099b3eaa42dfc.jpg" /></p>
</blockquote>
<h1 id="用跳转表形成多路分支">用跳转表形成多路分支</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b66a135c3b375e38fb8623ec430e39e.jpg" /></p>
<h1 id="loopzloope">LOOPZ/LOOPE</h1>
<p>要用到LOOPE/LOOPZ：在ZF为1且CX不等于0时（条件成立或结果为零）继续循环。如果当前字符是空格，且字符串没有遍历完(CX初始化为字符串长度)，就继续向下遍历</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/505e44bc6322f1a4386841da91deb62.jpg" /></p>
<h1 id="loopnzloopne">LOOPNZ/LOOPNE</h1>
<p>编写程序，计算两个字节数组ARY1和ARY2对应元素之和，一直计算到两数之和为0或数组结束为止。并将和存入数组SUM中，将该数组的长度存放在NUM单元中</p>
<p>要用到LOOPNZ/LOOPNE，如果当前数组没有遍历完或者当前对应位置两数之和不是0</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240602152342420.png" /></p>
<h1 id="jcxz">JCXZ</h1>
<p>防止一开始做循环，CX里面的值就是0，那么0-1=0FFFFH先入死循环</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序结构为：</span><br><span class="line">                ..........</span><br><span class="line">                MOV  CX,COUNT</span><br><span class="line">                JCXZ   NEXT</span><br><span class="line">LOP:      ..........</span><br><span class="line">               LOOP   LOP</span><br><span class="line">NEXT:  ..............</span><br></pre></td></tr></table></figure></p>
<h1 id="选用cx计数控制循环">选用CX计数控制循环</h1>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dadff5123e6be524025bf9658148bb2.png" style="zoom:50%;" /></p>
<p>关键代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240602161534512.png" style="zoom:50%;" /></p>
<h1 id="条件控制循环">条件控制循环</h1>
<p>题干：</p>
<p>将字单元VARW 中含1的个数统计出来，存入CONT单元中</p>
<p>思想：</p>
<p>本例中通过将字单元各位逐位移入最高位来判断。为了减少循环次数，循环中加上了判断各位是否全为0，这样可使低位为全0时的循环次数减少。</p>
<h1 id="多重循环">多重循环</h1>
<p>题干：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240602162139732.png" style="zoom:50%;" /></p>
<p>设计</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240602162219309.png" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章_BIOS和DOS中断调用</title>
    <url>/posts/7a7853ba.html</url>
    <content><![CDATA[<h1 id="bios">BIOS</h1>
<span id="more"></span>
<h2 id="键盘输入功能调用int-16h">键盘输入功能调用(INT 16H)</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616104811672.png" /></p>
<p>举例：从键盘读入0～9中任一数，根据不同数显示不同的字符串。要求用BIOS中断来接收键盘输入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	STACK SEGMENT PARA STACK                         ；堆栈段定义</span><br><span class="line">	DB	256	DUP（？）</span><br><span class="line">	STACK	ENDS</span><br><span class="line">	</span><br><span class="line">	DATA SEGMENT	PARA PUBLIC&#x27;DATA&#x27;	   ；数据段定义</span><br><span class="line">	THIRTY	DB	30	                  ；设每字符串长30</span><br><span class="line">      PARM	DB	128	DUP（0）</span><br><span class="line">	MSG0	DB	&#x27;I LIKE IBM PC…&#x27;</span><br><span class="line">	MSG1	DB	&#x27;8080   PROGRAMMING   IS   RUN…&#x27;</span><br><span class="line">	MSG2	DB	&#x27;TIME TO BUY MANY DISKETTES…&#x27;</span><br><span class="line">	MSG3	DB	&#x27;THIS PROGRAM WORKS…&#x27;</span><br><span class="line">&#x27;	MSG4	DB	&#x27;TURN OFF THAT PRINTER！…&#x27;</span><br><span class="line">	MSG5	DB	&#x27;I HAVE MANY…&#x27;</span><br><span class="line">	MSG6	DB	&#x27;THE PSP CAN BE USEFUL…&#x27;</span><br><span class="line">	MSG7	DB	&#x27;BASIC WAS EASIER THEN THIS…&#x27;</span><br><span class="line">	MSG8	DB	&#x27;DOS IS INDISPESABLE…‘</span><br><span class="line">     MSG9	DB	&#x27;LAST MESSAGE OF THE DAY..&#x27;</span><br><span class="line">	ERRMSG	DB	&#x27;ERROR！ INVALID PARAMETER！&#x27;</span><br><span class="line">	DATA	ENDS</span><br><span class="line">	</span><br><span class="line">	CODE SEGMENT	PARA	PUBLIC  &#x27;CODE        ；代码段</span><br><span class="line">	START PROC FAR</span><br><span class="line">		ASSUME	CS: CODE, DS:DATA</span><br><span class="line">		PUSH	DS                  ；采用段前缀方式返回DOS</span><br><span class="line">		MOV	AX，0</span><br><span class="line">		PUSH	AX</span><br><span class="line">		MOV	AX，DATA</span><br><span class="line">         MOV ES，AX</span><br><span class="line">		ASSUME ES：DATA</span><br><span class="line">		MOV	DX，AX</span><br><span class="line">		ASSUME DS:DATA</span><br><span class="line">		MOV	AH，0		；功能号为0</span><br><span class="line">		INT	16H		；键盘输入，字符在AL中</span><br><span class="line">		SUB	AL，&#x27;0&#x27;	；减去字符‘0’的ASCII码</span><br><span class="line">		JC	ERROR	；键入字符编码小于30H转</span><br><span class="line">            CMP	AL，9		；是9吗</span><br><span class="line">		JA	ERROR           ；大于9转，否则顺序执行</span><br><span class="line">		MOV	BX，OFFSET MSG0	      ；MSG0位移送BX</span><br><span class="line">		MUL	THIRTY	；(AL)×30</span><br><span class="line">		ADD	BX，AX        ；计算输入信息在信息表中的位移</span><br><span class="line">		CALL	DISPLAY	；转子显示信息</span><br><span class="line">		RET			；返回</span><br><span class="line"></span><br><span class="line">   ERROR：</span><br><span class="line">           MOV BX， OFFSET ERRMSG ；出错显示信息位移送BX                                                   </span><br><span class="line">		CALL	DISPLAY          ；转子显示信息</span><br><span class="line">		RET	                            ；返回</span><br><span class="line">	DISPLAY	PROC	NEAR</span><br><span class="line">		MOV	CX，30	；显示字符个数</span><br><span class="line">	        DISP1：	</span><br><span class="line">            MOV	AL，［BX］</span><br><span class="line">		CALL	DISPCHAR	；转显示字符子程序</span><br><span class="line">		INC	BX</span><br><span class="line"></span><br><span class="line">            LOOP	DISP1</span><br><span class="line">		MOV	DL，0DH		；显示回车符</span><br><span class="line">		CALL	DISPCHAR</span><br><span class="line">		MOV	DL，0AH		；显示换行符</span><br><span class="line">		CALL	DISPCHAR</span><br><span class="line">		RET</span><br><span class="line">	DISPLAY	ENDP</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"> DISPCHAR RPOC	NEAR	    ；显示AL中字符号程序</span><br><span class="line">            PUSH	BX</span><br><span class="line">		MOV	BX，0</span><br><span class="line">		MOV	AH，14            ；14号功能调用为BIOS输出字符</span><br><span class="line">		INT	10H</span><br><span class="line">		POP	BX</span><br><span class="line">		RET</span><br><span class="line">	DISPCHAR	ENDP</span><br><span class="line">	CODE	ENDS</span><br><span class="line">		END	START</span><br></pre></td></tr></table></figure>
<h2 id="bios显示功能调用int-10h">BIOS显示功能调用(INT 10H)</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616065552927.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616065542151.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616065611892.png" /></p>
<h3 id="光标的设置">光标的设置</h3>
<h4 id="int-10h的1号功能是设置光标的大小和状态">INT
10H的1号功能是设置光标的大小和状态</h4>
<ol type="1">
<li><p>光标起始行值放在CH的低4位，结束行值放在CL的低4位。</p></li>
<li><p>CH的D4位为光标禁止位，用来表示光标的状态。当该位为1时，光标不显示。</p></li>
<li><p>单色显示器的光标大小的范围从0~13。光标的默认方式是宽度为2列的闪烁的下划线。</p></li>
</ol>
<h3 id="int-10h的2号功能是设置光标位置">INT
10H的2号功能是设置光标位置</h3>
<ol type="1">
<li><p>光标位置的行号设在DH寄存器中，列号设在DL中。</p></li>
<li><p>在25×80的显示方式中，坐标设在（0，0）是屏幕的左上角，（24，79）是屏幕的右下角。</p></li>
<li><p>BH中必须包含被输出的页号，对单色显示器来说，页号总是0。</p></li>
</ol>
<p><font color = "red">所以设置光标一半就是设置行（DH)，列(DL)，页(BH)</font></p>
<p>举例：置光标开始行为5，，并把它设置到第5行第6列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设置光标的大小</span><br><span class="line">MOV	CH，5	；开始行为5</span><br><span class="line">MOV	CL，7		；结束行为7</span><br><span class="line">MOV	AH，1	；设置光标大小</span><br><span class="line">INT 	10H		；调用BIOS</span><br><span class="line">; 设置光标的位置</span><br><span class="line">MOV	DH，4		；第5行</span><br><span class="line">MOV	DL，5		；第6列</span><br><span class="line">MOV	BH，0		；0页</span><br><span class="line">MOV	AH，2	；设置光标位置</span><br><span class="line">INT 	10H		；调用BIOS</span><br></pre></td></tr></table></figure>
<h4 id="读光标位置int-10h的3号功能">读光标位置，INT 10H的3号功能</h4>
<ol type="1">
<li><p>页号必须在BH中指定。</p></li>
<li><p>此功能把光标位置的行号回送给DH，列号回送给DL。光标大小的参数填入CH和CL中，也就是说，在CH和CL中回送的是用功能1设置的光标参数。</p></li>
</ol>
<p>举例 读0页的当前光标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	AH，3</span><br><span class="line">MOV	BH，0</span><br><span class="line">INT	10H</span><br></pre></td></tr></table></figure>
<h3 id="选择显示页int-10h的5号功能">选择显示页，INT 10H的5号功能</h3>
<p>INT 10H的功能5可由程序确定显存中的显示区域。</p>
<p>ROM
BIOS将CGA的显存分为4页，每页25×80个字符，或分为8页，每页25×40个字符。每一页的起始地址在</p>
<p>1
KB的边界。这4页的起始地址分别为B800:0000、B800:1000、B800:2000和B800:3000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	AL，VPAGE		；AL=显示页数</span><br><span class="line">MOV	AH，5			；AH=功能号</span><br><span class="line">INT	10H</span><br></pre></td></tr></table></figure>
<h3 id="卷屏int-10h的6号和7号功能">卷屏，INT 10H的6号和7号功能</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616100738761.png" /></p>
<h4 id="清屏">清屏</h4>
<p>举例1：清除整个屏幕，设置AH为6，AL为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLEAR	PROC</span><br><span class="line">	   PUSH	AX</span><br><span class="line">	   PUSH	BX</span><br><span class="line">	   PUSH	CX</span><br><span class="line">	   PUSH	DX</span><br><span class="line">        </span><br><span class="line">        MOV	AH，6	；屏幕上卷功能号</span><br><span class="line">        MOV	AL，0		；AL=0时，为清屏</span><br><span class="line">	    MOV	CH，0	；CH：屏幕左上角坐标的行号</span><br><span class="line">	    MOV	CL，0		；CL：屏幕左上角坐标的列号</span><br><span class="line">	    MOV	DH，24	；DH：屏幕右下角坐标的行号</span><br><span class="line">	    MOV	DL，79	；DL：屏幕右下角坐标的列号</span><br><span class="line">	    MOV	BH，7		   ；上卷行属性正常（即黑底白字）</span><br><span class="line">        INT	10H</span><br><span class="line">        </span><br><span class="line">			POP		DX</span><br><span class="line">			POP		CX</span><br><span class="line">			POP		BX</span><br><span class="line">			POP		AX</span><br><span class="line">			RET</span><br><span class="line">	CLEAR	ENDP</span><br></pre></td></tr></table></figure>
<p>举例2：将一半的屏幕从黑底白字改为白底黑子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    STR DB &#x27;Hello world&#x27;, &#x27;$&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    </span><br><span class="line">    ; 设置屏幕显示属性和区域</span><br><span class="line">    MOV AH, 07h    ; 功能号为07h，选择屏幕下卷功能</span><br><span class="line">    MOV AL, 0      ; AL = 0，表示向下滚动0行</span><br><span class="line"></span><br><span class="line">    MOV BH, 70h    ; 设置显示属性，BH = 70h（白色文本，黑色背景）</span><br><span class="line">    MOV CH, 0      ; 设置左上角行值，CH = 0</span><br><span class="line">    MOV CL, 0      ; 设置左上角列值，CL = 0</span><br><span class="line">    MOV DH, 24     ; 设置右下角行值，DH = 24</span><br><span class="line">    MOV DL, 39     ; 设置右下角列值，DL = 39</span><br><span class="line">    INT 10h        ; 调用BIOS中断，功能号由AH寄存器指定，这里为07h</span><br><span class="line"></span><br><span class="line">    ; 打印字符串</span><br><span class="line">    MOV SI, OFFSET STR  ; SI 指向字符串 STR</span><br><span class="line">    MOV AH, 0Eh         ; BIOS功能号：显示字符，AL为字符，BH为页号（颜色）</span><br><span class="line">    MOV BL, 07h         ; 文本颜色，白色文本，黑色背景</span><br><span class="line">    PRINT_LOOP:</span><br><span class="line">        LODSB            ; 加载SI指向的字节到AL，同时SI递增</span><br><span class="line">        CMP AL, &#x27;$&#x27;      ; 判断是否字符串结束标志</span><br><span class="line">        JE PRINT_DONE    ; 如果是结束标志，退出循环</span><br><span class="line">        INT 10h          ; 调用BIOS中断显示字符</span><br><span class="line">        JMP PRINT_LOOP   ; 继续循环打印下一个字符</span><br><span class="line"></span><br><span class="line">    PRINT_DONE:</span><br><span class="line">    </span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line"></span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果如下所示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616083056535.png" /></p>
<p>举例3：在屏幕中心的小窗口显示字符</p>
<p>举例4：编写一个完整的程序(例5-11)在PC机上运行。此程序在屏幕的中间建立一个20列宽和9行高的窗口，</p>
<p>然后把键盘输入的内容在这个窗口上显示出来。键入的字符将被显示在窗口的最下面一行，每当输入20个字</p>
<p>符，该行就向上卷动，9行字符输入完后，顶端行的内容消失。</p>
<h3 id="字符的显示9号和10号功能">字符的显示：9号和10号功能</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616101019128.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616101027227.png" /></p>
<p>使用INT
10H的9、10两功能，这两个功能的共同点是：都能在光标处显示一个字符，且显示后，光标不动</p>
<p>这就是说，当显示下一个字符前，一定要用2号功能将光标移至下一个字符位置。这两种功能的区别在于用9</p>
<p>号功能显示的字符的属性是用户规定的，用10号功能显示的字符的属性是该位置上已有的属性(以前规定的)。</p>
<h4 id="单色字符显示">单色字符显示</h4>
<p>举例：从屏幕(40，15)位置开始，用反显示法连续显示5个闪烁的“*”</p>
<p>解释：什么叫反显：正常终端背景是黑色，字体是白色，现在调整终端背景白色，字体是黑色。设置如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616102229352.png" style="zoom:50%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    ; 无需数据段定义</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">    ASSUME CS:CODE, DS:DATA</span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line"></span><br><span class="line">    ; 设置光标位置到 (15, 40)</span><br><span class="line">    MOV AH, 02H          ; AH = 02H，设置光标位置</span><br><span class="line">    MOV BH, 0            ; 单色显示器，显示页永远为0</span><br><span class="line">    MOV DH, 15           ; 行号</span><br><span class="line">    MOV DL, 40           ; 列号</span><br><span class="line">    INT 10H              ; 将光标设置在 (15, 40) 处</span><br><span class="line"></span><br><span class="line">    ; 显示反显和闪烁的 &#x27;*&#x27; 字符</span><br><span class="line">    MOV AH, 09H          ; 显示字符及属性功能</span><br><span class="line">    MOV AL, &#x27;*&#x27;          ; 欲显示 &#x27;*&#x27;</span><br><span class="line">    MOV BL, 11110000B         ; 属性 1111 0000 (反显和闪烁)</span><br><span class="line">    MOV CX, 5            ; 重复显示字符的个数</span><br><span class="line">    INT 10H</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616102828628.png" style="zoom: 33%;" /></p>
<h4 id="彩色字符显示">彩色字符显示</h4>
<p>修改BL为 MOV BL, 0DAH 即可</p>
<h4 id="彩色文本方式下外框颜色的设置">彩色文本方式下外框颜色的设置</h4>
<h1 id="dos">DOS</h1>
<h2 id="磁盘管理">磁盘管理</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616110346406.png" /></p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章_输入输出和中断程序设计</title>
    <url>/posts/3939ae20.html</url>
    <content><![CDATA[<h1 id="io指令">I/O指令</h1>
<span id="more"></span>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="存储器寻址">存储器寻址</h3>
<ul>
<li>定义：</li>
</ul>
<p>外设端口作为存储器中的一个地址</p>
<ul>
<li>优点：</li>
</ul>
<ol type="1">
<li>指令多</li>
<li>不需要专门的输入输出指令</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<p>占用了内存空间</p>
<h3 id="端口寻址">端口寻址</h3>
<ul>
<li>定义：</li>
</ul>
<p>通过专门的I/O端口</p>
<ul>
<li>优点：</li>
</ul>
<p>不会占用内存空间，因为，I/O设备通过专用的端口地址进行访问。这些端口地址与内存地址空间是分开的，因此不会占用内存地址空间。</p>
<h2 id="输入输出指令">输入输出指令</h2>
<p><font color = "red">只能使用AL或AX寄存器</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616133422337.png" style="zoom:50%;" /></p>
<h2 id="间接输入输出指令">间接输入输出指令</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616133445960.png" style="zoom:50%;" /></p>
<p><font color = "yellow">AL是8位，DX是16位，那么是不是觉得很奇怪为什么DX能送入AL？其实DX里面是一个地址，是将DX这个地址里指向的内容放入AL或者AX中</font></p>
<blockquote>
<p>注：由于DX位外设端口地址，范围从0000H~0FFFFH，允许有65536个端口地址</p>
</blockquote>
<p>举例1：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240620204136804.png" /></p>
<p>举例2：测试某状态寄存器（端口地址为27H）的第2位是否为1，若为1，则转移到ERROR进行处理。其指令序列为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IN AL, 27H</span><br><span class="line">TEST AL, 00000100B</span><br><span class="line">JNZ ERROR</span><br></pre></td></tr></table></figure>
<p>举例3：将某接口的命令寄存器（端口地址为126H）的第7位控制成组数据传送</p>
<p><font color = "red">因为一个字节能表示的无符号数范围是从0~255，126H
&gt;
255，所以无法直接使用立即数，而是要将126H先放到DX寄存器里</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX, 126H</span><br><span class="line">IN AL, DX</span><br><span class="line">OR AL, 80H</span><br><span class="line">OUT DX, AL</span><br></pre></td></tr></table></figure>
<p>举例4：利用程序查询方式进行串口通信的程序</p>
<p>计算机串行数据端口地址为3F8H，状态寄存器地址是3FDH。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;输入子程序</span><br><span class="line">TELI PROC FAR		;查询读入数据</span><br><span class="line">PUSH	DX</span><br><span class="line">MOV	DX, 03FDH</span><br><span class="line">TEL1:</span><br><span class="line">    IN	AL, DX         ;读入端口状态</span><br><span class="line">    TEST AL, 01		;测试</span><br><span class="line">    JZ	TEL1			;未准备好，循环查询</span><br><span class="line">    MOV	DX, 03F8H		;准备好，读入数据</span><br><span class="line">    IN 	AL, DX</span><br><span class="line">    POP	DX</span><br><span class="line">    RET</span><br><span class="line">TELI ENDP</span><br><span class="line"></span><br><span class="line">TELO PROC FAR         ;输出子程序</span><br><span class="line">PUSH DX</span><br><span class="line">PUSH AX</span><br><span class="line">MOV DX, 03FDH </span><br><span class="line">TELO1:</span><br><span class="line">    IN	AL, DX               ;读入端口状态</span><br><span class="line">    TEST AL, 20H 	 ;测试</span><br><span class="line">    JZ TELO1	               ;第5位为1，发送寄存器空,继续等待</span><br><span class="line">    MOV DX, 03F8H     ;发送寄存器不空，输出数据</span><br><span class="line">    OUT	DX, AL	</span><br><span class="line">    POP	AX</span><br><span class="line">    POP	DX</span><br><span class="line">    RET</span><br><span class="line">TELO ENDP</span><br></pre></td></tr></table></figure>
<h1 id="中断传送">中断传送</h1>
<h2 id="中断分类">中断分类</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616133855191.png" /></p>
<h2 id="中断向量表">中断向量表</h2>
<p>四个单元组成一个向量</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616151743048.png" /></p>
<p>中断向量表地址分配</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616151908473.png" /></p>
<h2 id="中断响应过程">中断响应过程</h2>
<ol type="1">
<li><p>取中断类型号N；</p></li>
<li><p>标志寄存器(PSW)内容压栈；</p></li>
<li><p>当前代码段寄存器(CS)内容压栈；</p></li>
<li><p>当前指令指针(IP)内容压栈；</p></li>
<li><p>禁止外部中断和单步中断(置IF=0，TF=0)；</p></li>
<li><p><font color = "red">从中断向量表中取4×n的字内容送IP，取4×n＋2的字内容送CS；</font></p></li>
<li><p>转中断处理程序。</p></li>
</ol>
<blockquote>
<p>注：中断过程与子程序调用的区别：
除了保护返回地址CS:IP之外，还保存标志寄存器PSW的内容。</p>
<p>在中断发生时CPU自动清除了IF和TF</p>
<p>中断处理程序返回时使用IRET指令</p>
</blockquote>
<h2 id="中断优先级">中断优先级</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240616152145453.png" /></p>
<h1 id="中断处理程序">中断处理程序</h1>
<h2 id="设置中断向量">设置中断向量</h2>
<p><font color = "red">共同点：设置中断向量的时候规定格式是DS:DX</font></p>
<h3 id="手搓">手搓</h3>
<ol type="1">
<li>先根据中断号计算在中断向量表中的偏移地址（如果已知要将当前中断子程序作为第N号中断，那么它在中断向量表中的位置是4
* N，设置BX = 4 * N）</li>
<li>关中断</li>
<li>分别设置段地址和偏移地址</li>
<li>开中断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	AX，0</span><br><span class="line">MOV	DS，AX</span><br><span class="line">MOV	BX，N*4	     ;设置N号中断向量</span><br><span class="line">CLI			     ;关中断</span><br><span class="line">MOV	WORD PTR[BX]，OFFSET INTHAND  ;置偏移</span><br><span class="line">MOV	WORD PTR[BX+2]，SEG INTHAND      ;置段值</span><br><span class="line">STI	            	   ;开中断</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：INTHAND表示被调用的中断处理程序</p>
</blockquote>
<h3 id="dos功能调用25号功能">DOS功能调用25号功能</h3>
<p><strong>入口参数：</strong></p>
<ul>
<li>AL ：中断号</li>
<li>DS：中断子程序段地址</li>
<li>DX：中断子程序偏移地址</li>
</ul>
<p><strong>调用过程</strong></p>
<ol type="1">
<li>将中断子程序的段地址通过AX赋给DS</li>
<li>将中断子程序的偏移地址副歌DX</li>
<li>调用25H号功能，设置AH=25H</li>
<li>将这个中断子程序对应的中断号写入AL</li>
<li>调用21H中断实现将中断向量写入中断向量表</li>
</ol>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INTHAND：</span><br><span class="line">MOV AX，SEG  INTHAND	 ；中断处理程序的段地址</span><br><span class="line">MOV DS，AX</span><br><span class="line">MOV DX，OFFSET  INTHAND  ；中断处理程序的偏移地址</span><br><span class="line">MOV AH，25H</span><br><span class="line">MOV AL，N</span><br><span class="line">INT  21H</span><br></pre></td></tr></table></figure>
<h2 id="获取中断向量">获取中断向量</h2>
<p><font color = "red">获取中断向量的时候固定格式是ES:BX</font></p>
<h3 id="手搓-1">手搓</h3>
<ol type="1">
<li>根据中断号计算在中断向量表中的偏移地址</li>
<li>将ES:[中断向量表中的偏移地址]作为偏移地址，将ES:[中断向量表中的偏移地址作为偏移地址+2]作为段地址</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例5-5-3】利用直接读取法读取n号中断向量，并保存在双字变量OLDVECTOR中：</span><br><span class="line">      ……</span><br><span class="line">     XOR AX,AX</span><br><span class="line">     MOV ES,AX</span><br><span class="line">     MOV AX,ES:[n*4]               ；取偏移地址</span><br><span class="line">     MOV WORD PTR OLDVECTOR,AX     ；保存</span><br><span class="line">     MOV AX,ES:[n*4+2]             ；取段地址</span><br><span class="line">     MOV WORD PTR OLDVECTOR+2,AX   ；保存</span><br><span class="line">      ……</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="dos功能调用35号功能">DOS功能调用35号功能</h3>
<p><strong>入口参数</strong>： 中断号</p>
<p><strong>出口参数</strong></p>
<ul>
<li>ES：中断子程序的段地址</li>
<li>BX：中断子程序的偏移地址</li>
</ul>
<p><strong>调用过程</strong></p>
<ol type="1">
<li>调用35H号功能</li>
<li>将AL设置为中断号n</li>
<li>调用21H号中断</li>
<li>从BX中取出中断子程序的偏移地址，从ES中取出中断子程序的段地址</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例5-5-4】使用DOS功能调用取得n号中断的中断向量</span><br><span class="line">     ……</span><br><span class="line">     MOV AH,35H</span><br><span class="line">     MOV AL,n		  ；中断类型号为n</span><br><span class="line">     INT 21H              ；中断向量在ES：BX中</span><br><span class="line">     MOV WORD PTR OLDVECTOR,BX</span><br><span class="line">     MOV WORD PTR OLDVECTOR+2,ES</span><br><span class="line">     </span><br><span class="line">     ……</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第七章外设</title>
    <url>/posts/bc3a85.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章_高级汇编程序设计</title>
    <url>/posts/50d063bc.html</url>
    <content><![CDATA[<h1 id="宏汇编">宏汇编</h1>
<span id="more"></span>
<h2 id="宏定义">宏定义</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏名	macro [形参表]</span><br><span class="line">	宏定义体</span><br><span class="line">	endm</span><br></pre></td></tr></table></figure>
<h2 id="宏调用">宏调用</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏名	[实参表]</span><br></pre></td></tr></table></figure>
<h2 id="宏展开">宏展开</h2>
<p>宏展开——在汇编时，用宏定义体的代码序列替代宏指令的过程。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">；宏定义</span><br><span class="line">shlext	macro shloprand,shlnum</span><br><span class="line">	push cx</span><br><span class="line">	mov cl,shlnum	</span><br><span class="line">	shl shloprand,cl</span><br><span class="line">	pop cx</span><br><span class="line">	endm</span><br><span class="line">；宏指令</span><br><span class="line">	shlext ax,6</span><br><span class="line">；宏展开</span><br><span class="line"> 1	push cx</span><br><span class="line"> 1	mov cl,06</span><br><span class="line"> 1	shl ax,cl</span><br><span class="line"> 1	pop cx</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="宏操作符">宏操作符</h2>
<h3 id="连接操作符">连接操作符&amp;</h3>
<h4 id="含义">含义</h4>
<p>宏展开时，对应形参的实参就与它前后的符号连接在一起</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例1】连接符&amp;的使用:</span><br><span class="line">SHIFT_VAR MARCO R_M,DIRECT,COUNT</span><br><span class="line">          MOV CL,COUNT</span><br><span class="line">          S&amp;DIRECT R_M,CL</span><br><span class="line">          ENDM</span><br><span class="line">SHIFT_VAR AX,HL,2的宏展开为：</span><br><span class="line">+    MOV CL,2</span><br><span class="line">+    SHL AX,CL </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="表达式操作符">表达式操作符%</h3>
<h4 id="含义-1">含义</h4>
<p>告诉宏汇编程序获取表达式的值，而不是获取表达式文本本身</p>
<blockquote>
<p>注意：这个操作符一般是出现在宏调用中，不允许出现在形参的前面。</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">；宏定义</span><br><span class="line">SHIF0 MACRO CNT</span><br><span class="line">      MOV CL,CNT</span><br><span class="line">      ENDM</span><br><span class="line">SHIF1 MACRO REG,DIRECT,NUM</span><br><span class="line">      COUNT=NUM</span><br><span class="line">      SHIF0 %COUNT</span><br><span class="line">      S&amp;DIRECT REG,CL</span><br><span class="line">      ENDM          </span><br><span class="line">；宏调用</span><br><span class="line">  SHIF1 AX,HL,2</span><br><span class="line">  SHIF1 BL,AR,3</span><br><span class="line">；宏展开</span><br><span class="line">  SHIF1 AX,HL,2</span><br><span class="line">  +   MOV CL,2</span><br><span class="line">  +   SHL AX,CL</span><br><span class="line">  SHIF1 BL,AR,3</span><br><span class="line">  +    MOV CL,3</span><br><span class="line">  +    SAR BL,CL</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="文本操作符">文本操作符&lt;&gt;</h3>
<h4 id="含义-2">含义</h4>
<p>把一个完整的实参括起来，作为一个单一的实参</p>
<blockquote>
<p>注意:文本操作符还可以用来处理某些特殊字符：如“；”和“&amp;”。</p>
<p>例：&lt;；&gt;就表示一个分号“；”的实参，而不是注释符。</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例3</span><br><span class="line">; 宏定义</span><br><span class="line">EXCHANGE MACRO ADR1,ADR2,AL</span><br><span class="line">MOV AL,ADR1</span><br><span class="line">XCHG AL,ADR2</span><br><span class="line">MOV ADR2,AL</span><br><span class="line">ENDM</span><br><span class="line">; 宏调用</span><br><span class="line">EXCHANGE &lt;BYTE PTR DA_WORD1&gt;,&lt;BYTE PTR DA_WORD2&gt;,AL</span><br><span class="line">;宏展开时，替换的三条指令是：</span><br><span class="line">MOV AL,BYTE PTR DA_WORD1</span><br><span class="line">XCHG AL,BYTE PTR DA_WORD2</span><br><span class="line">MOV BYTE PTR WORD1,AL </span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h3 id="字符操作符">字符操作符！</h3>
<h4 id="含义-3">含义</h4>
<p>相当于C语言中转义字符</p>
<h3 id="宏注解符">宏注解符；；</h3>
<h4 id="含义-4">含义</h4>
<p>说明后面文字是注解，仅出现在宏定义中</p>
<h3 id="local伪指令重要">LOCAL伪指令（重要）</h3>
<h4 id="含义-5">含义</h4>
<p>在宏定义中使用变量名和标号，为了避免在宏展开时产生多个相同的变量名或标号。</p>
<p>宏展开时，LOCAL伪指令指定的变量、标号自动生成格式为“？?ⅩⅩⅩⅩ”的符号，其中后四位顺序使用0000～FFFF的十六进制数字。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【例5】用连续相加的办法实现无符号数乘法运算，编制宏定义MULTIP</span><br><span class="line">MULTIP  MACRO MULT1,MULT2,MULT3</span><br><span class="line">        LOCAL LOP,EXIT0</span><br><span class="line">        MOV DX,MULT1   ；乘数1</span><br><span class="line">        MOV CX,MULT2   ；乘数2</span><br><span class="line">        XOR BX,BX</span><br><span class="line">        XOR AX,AX</span><br><span class="line">        JCXZ EXIT0</span><br><span class="line">    LOP:ADD BX,DX</span><br><span class="line">        ADC AX,0</span><br><span class="line">        LOOP LOP</span><br><span class="line">  EXIT0:MOV MULT3,BX</span><br><span class="line">        MOV MULT3+2,AX</span><br><span class="line">        ENDM</span><br><span class="line">设某数据段有如下定义的变量：</span><br><span class="line">          DA1 DW 1234H,5678H</span><br><span class="line">          DA2 DW 120H,210H</span><br><span class="line">          DA3 DW 4 DUP(?)</span><br><span class="line">在代码段中：如有两次宏调用，则两次的宏展开如下：                                    </span><br><span class="line">  		┇</span><br><span class="line">          MULTIP DA1,DA2,DA3</span><br><span class="line">	+       MOV DX,DA1</span><br><span class="line">	+       MOV CX,DA2</span><br><span class="line">	+       XOR BX,BX	</span><br><span class="line">	+       XOR AX,AX</span><br><span class="line">	+       JCXZ ?? 0001</span><br><span class="line">          +??0000:ADD BX,DX</span><br><span class="line">	+       ADC AX,0</span><br><span class="line">	+       LOOP ??0000</span><br><span class="line">          +??0001:MOV DA3,BX</span><br><span class="line">	+       MOV DA3+2,AX</span><br><span class="line">		 ┇</span><br><span class="line">			┇</span><br><span class="line">          MULTIP DA1+2,DA2+2,DA3+4</span><br><span class="line"></span><br><span class="line">	+       MOV DX,DA1+2</span><br><span class="line">	+       MOV CX,DA2+2</span><br><span class="line">	+       XOR BX,BX</span><br><span class="line">	+       XOR AX,AX</span><br><span class="line">	+       JCXA ??0003</span><br><span class="line">          +??0002:ADD BX,DX</span><br><span class="line">                  ADC AX,0</span><br><span class="line">       	        LOOP ??0002</span><br><span class="line">          +??0003:MOV DA3+4,BX</span><br><span class="line">	+       MOV DA3+6,AX</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h1 id="重复汇编">重复汇编</h1>
<h2 id="定义">定义</h2>
<ol type="1">
<li><p>重复汇编常用在宏定义体中，也可以在一般汇编语句中使用</p></li>
<li><p>重复汇编伪指令有三个：</p>
<p>REPEAT——按参数值重复</p>
<p>FOR——按参数个数重复</p>
<p>FORC——按参数的字符个数重复</p></li>
<li><p>最后，用ENDM结束</p></li>
</ol>
<h2 id="按参数值重复">按参数值重复</h2>
<h3 id="定义-1">定义</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPEAT  重复次数</span><br><span class="line">   重复体</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 宏定义</span><br><span class="line">char = &#x27;A&#x27;</span><br><span class="line">REPEAT 26</span><br><span class="line">  db char</span><br><span class="line">  char = char +1</span><br><span class="line">ENDM</span><br><span class="line">; 宏展开</span><br><span class="line"> 1	db char	;等效于db &#x27;A&#x27;</span><br><span class="line"> 1	char = char +1</span><br><span class="line"> 1	db char	;等效于db &#x27;B&#x27;</span><br><span class="line"> 1	char = char +1</span><br><span class="line">	...</span><br><span class="line"> 1	db char	;等效于db &#x27;Z&#x27;</span><br><span class="line"> 1	char = char +1</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="按参数个数重复">按参数个数重复</h2>
<h3 id="定义-2">定义</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOR  形参,〈实参表〉</span><br><span class="line">   重复体</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 宏定义</span><br><span class="line">FOR regad, &lt;ax,bx,cx,dx&gt;</span><br><span class="line">  push  regad</span><br><span class="line">ENDM</span><br><span class="line">; 宏展开</span><br><span class="line"> 1	push  ax</span><br><span class="line"> 1	push  bx</span><br><span class="line"> 1	push  cx</span><br><span class="line"> 1	push  dx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h2 id="按参数字符个数重复">按参数字符个数重复</h2>
<h3 id="定义-3">定义</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FORC  形参, 字符串</span><br><span class="line">   重复体</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 宏定义</span><br><span class="line">FORC regad,dcba</span><br><span class="line">    pop  &amp;regad&amp;x</span><br><span class="line">ENDM</span><br><span class="line">; 宏展开</span><br><span class="line"> 1	pop  dx</span><br><span class="line"> 1	pop  cx</span><br><span class="line"> 1	pop  bx</span><br><span class="line"> 1	pop  ax</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<h1 id="条件汇编">条件汇编</h1>
<h2 id="定义-4">定义</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFxx 表达式	;满足，汇编分支语句体1</span><br><span class="line">	分支语句体1</span><br><span class="line">ELSE	;不满足，汇编分支语句体2</span><br><span class="line">	分支语句体2    </span><br><span class="line">ENDIF	;条件汇编结束</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdata	macro	num</span><br><span class="line">	IF num lt 100	;;如果num &lt; 100，则汇编如下语句</span><br><span class="line">		db num dup (?)</span><br><span class="line">	ELSE	;;否则，汇编如下语句</span><br><span class="line">		db 100 dup (?)</span><br><span class="line">	ENDIF</span><br><span class="line">endm</span><br><span class="line">	pdata 12	  ;宏调用①</span><br><span class="line">	pdata 102	  ;宏调用②	</span><br></pre></td></tr></table></figure>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>1.1计算机系统层次结构</title>
    <url>/posts/15a679ce.html</url>
    <content><![CDATA[<h1 id="计算机系统层次结构">计算机系统层次结构</h1>
<span id="more"></span>
<h2 id="计算机硬件的组成">计算机硬件的组成</h2>
<h3 id="冯诺依曼计算机">冯·诺依曼计算机</h3>
<p>将指令以代码的形式存入主存储器中，之后按照顺序依次执行，直到程序执行结束。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image.png"
alt="冯诺依曼计算机" />
<figcaption aria-hidden="true">冯诺依曼计算机</figcaption>
</figure>
<p>冯诺依曼计算机</p>
<h4 id="特点">特点：</h4>
<ol type="1">
<li>计算机硬件系统由<strong>运算器</strong>、<strong>存储器</strong>、<strong>控制器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>5大部件组成；</li>
<li>指令和数据以同等地位存于存储器内，并可<strong>按地址寻访</strong>；</li>
<li>指令和数据均用二进制代码表示；</li>
<li>指令由<strong>操作码</strong>和<strong>地址码</strong>组成
<ul>
<li>操作码用来表示操作的性质；</li>
<li>地址码用来表示操作数在存储器中的位置；</li>
</ul></li>
<li>指令在存储器内按顺序存放。通常指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序；</li>
<li>早期的冯诺依曼机<strong>以运算器为中心</strong>，输入/输出设备通过运算器与存储器传送数据。</li>
</ol>
<hr style = "border:2px solid yellow">
<p>冯诺伊曼机基本工作方式是<font color = "red">控制流驱动</font>
<font color = "red">按地址访问并顺序执行指令</font>是冯诺依曼机工作方式的基本特点</p>
<p><font color = "red">如何区分指令和数据：</font></p>
<ul>
<li><font color = "yellow">通过不同的时间段来区分指令和数据</font>，即在取指令阶段（或取指微程序）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。</li>
<li><font color = "yellow">通过地址来源区分</font>，由<span
class="math inline">\(PC\)</span>提供存储单元地址的取出的是指令，由指令地址码部分取出（提供存储单元地址或在指令中给出立即数）的是操作数。</li>
</ul>
<hr style = "border:2px solid yellow">
<h3 id="现代计算机的组织结构">现代计算机的组织结构</h3>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(1).png"
alt="以存储器为核心" />
<figcaption aria-hidden="true">以存储器为核心</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(2).png"
alt="计算机的功能部件" />
<figcaption aria-hidden="true">计算机的功能部件</figcaption>
</figure>
<h3 id="计算机的功能部件">计算机的功能部件</h3>
<h4 id="存储器">存储器</h4>
<p>存储器<font color = "yellow">包括主存储器（主存、内存储器）和辅助存储器（辅存、外存储器）</font>。</p>
<p><font color = "yellow">主存的组成如图所示：</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(3).png" /></p>
<ul>
<li><strong>存储体</strong>：存放二进制信息；</li>
<li><strong>地址寄存器（MAR，Memory Adders
Register）</strong>：存放访存地址，经过地址译码后找到相应的存储单元；
<font color = "red">MAR的位数表示地址码的长度</font></li>
<li><strong>数据寄存器（MDR，Memory Data
Register）</strong>：暂存要从存储器中读或写的信息。
MDR的位数表示每个存储单元的位数，<font color = "red">也叫存储字长</font></li>
</ul>
<p><font color = "yellow">主存的作用</font>:程序运行时的主要位置，包括所需的数据</p>
<p><font color = "red">敲重点：MAR和MDR之间关系的理解</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f20c126f0cfa928b3fe8e269131e8ad.jpg" /></p>
<p>主存储器是由若干<strong>存储单元</strong>构成的，每个存储单元包含若干<strong>存储元件</strong>，每一个存储元件可以存储一位二进制代码0或1。因此每一个存储单元可以存储一串二进制码。这串二进制码称为<strong>存储字</strong>，它的位数称为<strong>存储字长</strong>，实际上就是存储单元中存储元件的个数。</p>
<p>例如，一个存储单元中有8个存储元件，则其存储字长为8位（bit），也可以称为1字节（B，Byte）。</p>
<p><font color = "red">MAR有n位(有n位地址) = 有 <span
class="math inline">\(2^n\)</span> 个存储单元 。</font></p>
<blockquote>
<p>MAR和MDR虽然是存储器一部分，但现在也存在于CPU</p>
</blockquote>
<hr style = "border:2px solid yellow">
<p>举例</p>
<p>题1：寄存器和高速缓冲寄存器Cache都集成在CPU上，<font color = "red">离CPU越近速度越快</font>，所以存取速度上<font color = "yellow">寄存器&gt;Cache&gt;内存。</font></p>
<hr style = "border:2px solid yellow">
<p>题2：计算机位数相关的计算</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3a43b967fb511d8b24df8bffb92d5a3.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/befbcc95fbbba16d5e58b2bcc9492bf.jpg" /></p>
<hr style = "border:2px solid yellow">
<h4 id="运算器">运算器</h4>
<p>用于处理计算机的算术运算和逻辑运算。运算器包括：</p>
<ul>
<li><strong>算术逻辑单元</strong>（ALU）（<em>核心</em>）</li>
<li>累加器（ACC）</li>
<li>乘商寄存器（MQ）</li>
<li>操作计数器（X）</li>
<li>变址寄存器（IX）</li>
<li>基址寄存器（BR）</li>
<li>程序状态寄存器（PSW）</li>
</ul>
<h4 id="控制器">控制器</h4>
<p>控制计算机各部件运行。包括：</p>
<ul>
<li><strong>控制单元</strong>（CU）</li>
<li><strong>指令寄存器（IR）</strong>：存放当前执行指令的地址</li>
<li><strong>程序计数器（PC）</strong>：自动加1以得到下一条指令的地址</li>
</ul>
<h2 id="计算机的工作过程">1.2.2 计算机的工作过程</h2>
<p>简单版本：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(4).png" /></p>
<p>先定义下面会用到的变量含义：</p>
<p>M：主存中某存储单元 OP(IR)：取操作码 Ad(IR)：取地址码</p>
<h3 id="取指令">取指令</h3>
<ol type="1">
<li>PC --&gt;
MAR：将指令的地址从PC（程序计数器）传至<strong>地址寄存器</strong></li>
<li>M(MAR) --&gt;
MDR：根据地址从存储体（或地址寄存器）中取到指令，并传至<strong>数据寄存器</strong></li>
<li>(MDR) --&gt; IR：将得到的指令传给<strong>指令寄存器</strong></li>
</ol>
<h3 id="分析指令">分析指令</h3>
<ol type="1">
<li>OP(IR) --&gt;
CU：CU（控制单元）分析IR（指令寄存器）中的指令，并做出操作</li>
</ol>
<h3 id="执行指令">执行指令</h3>
<ol type="1">
<li>Ad(IR) --&gt;
MAR：IR(指令寄存器)将地址码给<strong>地址寄存器</strong></li>
<li>M(MAR) --&gt;
MDR：地址寄存器找到数据，存至<strong>数据寄存器</strong></li>
<li>(MDR) --&gt; ACC：数据寄存器将数据传至<strong>累加器</strong></li>
</ol>
<p><font color = "red">CPU通过指令周期的不同阶段来区分指令和数据</font></p>
<p>详细版本：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@master/e9e73f2d230eba9698155818f817b31.jpg" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：CPU结构</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4136cbd3f8fce2909214cefef7a9613.jpg" /></p>
<p>解析：地址译码器是主存里面的</p>
<hr style = "border:2px solid yellow">
<h2 id="计算机的层次结构">1.2.3 计算机的层次结构</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(5).png" /></p>
<ul>
<li>M4：用编译程序<strong>翻译</strong>成机器语言程序</li>
<li>M3：用汇编程序<strong>汇编</strong>成机器语言程序</li>
<li>M2：用机器语言<strong>解释</strong>操作系统</li>
<li>M1：用微指令<strong>解释</strong>机器指令</li>
<li>M0：由硬件<strong>直接执行</strong>微指令</li>
<li><strong>翻译程序</strong>：源程序→机器语言
<ul>
<li><strong>编译</strong>（C++、Java）
<ul>
<li>高级语言→机器语言</li>
<li>通篇翻译</li>
<li>仅需执行一次</li>
</ul></li>
<li><strong>解释</strong>（python、JS）
<ul>
<li>高级语言→机器语言</li>
<li>翻译一句执行一句</li>
<li>每次执行都需要翻译</li>
</ul></li>
<li><strong>汇编</strong>
<ul>
<li>汇编语言→机器语言</li>
</ul></li>
</ul></li>
<li>硬件和软件之间互相依存，协同发展</li>
<li>两者间没有严格的界限</li>
</ul>
<hr style = "border:2px solid yellow">
<p>举例：上下层关系</p>
<p><font color = "red">1.
上层实现对下层功能的拓展，下层是上层的基础。</font></p>
<p><font color = "red">2.
上下层可以分割，仅有下层没有上层也可以</font></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>1.2计算机的性能指标</title>
    <url>/posts/68a1692.html</url>
    <content><![CDATA[<h2 id="主要性能指标">主要性能指标</h2>
<span id="more"></span>
<h3 id="主存容量">主存容量</h3>
<p>总容量=存储单元个数∗存储字长(bit)<a href="#fn1" class="footnote-ref"
id="fnref1"
role="doc-noteref"><sup>1</sup></a>=存储单元个数∗存储字长/8(byte, B)<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<ul>
<li>MAR的位数：反应存储单元的个数，即 <span
class="math inline">\(2^n\)</span> 个存储单元（n为位数）；</li>
<li>MDR的位数：等于<strong>存储字长</strong>。</li>
</ul>
<p>例：主存容量为64K*32位，即MAR位数为16位，MDR位数为32位。</p>
<blockquote>
<p><span class="math inline">\(2^{10}\)</span>:K</p>
<p><span class="math inline">\(2^{20}\)</span>:M</p>
<p><span class="math inline">\(2^{30}\)</span>:G</p>
<p><span class="math inline">\(2^{40}\)</span>:T</p>
</blockquote>
<h3 id="机器字长">机器字长</h3>
<p>计算机进行<strong>一次整数运算</strong>所能处理的二进制数据的位数。</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p>题1：微机的位数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4436fc5684497295cd8d0cb939c22ac.jpg" /></p>
<hr style = "border:2px solid yellow;">
<p>题2：机器字长与字节的关系：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f700e1c37ecc9f0bc4087189a84c812.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="cpu时钟周期和主频">CPU时钟周期和主频</h3>
<p><strong>CPU时钟周期</strong>：<font color = "red">CPU中最小的时间单位，每个动作至少需要一个时钟周期。</font></p>
<p><strong>主频（CPU时钟频率）</strong>：机器内部主时钟的频率，主频越高，计算机运行速度越快。</p>
<p><span class="math inline">\(CPU时钟周期 = \frac{1}{主频}\)</span></p>
<h3 id="cpi">CPI</h3>
<p><strong>CPI（Clock cycle Per
Instruction）</strong>：执行一条指令所需的时钟周期数。</p>
<p>指令执行的时间 = CPI ∗ CPU时钟周期</p>
<hr style = "border:2px solid yellow">
<p>举例：影响CPI的因素</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/d9d27a51c62f5f8b58019a3c56bac6f.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="cpu执行时间">CPU执行时间</h3>
<p>CPU执行时间，即整个程序的执行时间。</p>
<p><span class="math inline">\(CPU执行时间 = (平均CPI * 指令条数) *
CPU时钟周期 = \frac{CPU时钟周期数}{主频}\)</span></p>
<h3 id="mipsmflopsgflops和tflops">MIPS、MFLOPS、GFLOPS和TFLOPS</h3>
<p><strong>MIPS (Million Instructions Per
Second)</strong>：每秒执行多少百万条指令。</p>
<p><span class="math inline">\(MIPS = \frac{指令条数}{执行时间 * 10^6} =
\frac{主频}{CPI}\)</span></p>
<p><strong>MFLOPS ( Mega Floating point Operations Per
Second)</strong>：每秒执行多少百万次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240409095304737.png" /></p>
<p><strong>GFLOPS ( Giga Floating point Operations Per
Second)</strong>：每秒执行多 少十亿次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408095051254.png" /></p>
<p><strong>TFLOPS (Tera Floating -point Operations Per
Second)</strong>：每秒执行多少 万亿次浮点运算。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240408095057575.png" /></p>
<h2 id="其他相关术语">其他相关术语</h2>
<h3 id="吞吐量和响应时间">吞吐量和响应时间</h3>
<p><strong>吞吐量</strong>：系统在单位时间内处理请求的容量，<font color = "red">常用作评价计算机系统性能的综合参数之一</font></p>
<p><strong>响应时间</strong>：从用户发出请求到系统响应请求并得到结果的时间，包括CPU运行时间和等待时间。</p>
<h3 id="数据通路带宽">数据通路带宽</h3>
<p>数据总线一次能并行传输数据的位数。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>单位是位<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>单位是字节,1字节=8位<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>5.1_CPU的基本功能和结构</title>
    <url>/posts/eeed506a.html</url>
    <content><![CDATA[<h1 id="cpu的基本组成">CPU的基本组成</h1>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606201552117.png" /></p>
<h2 id="寄存器组">寄存器组</h2>
<p>寄存器：CPU在处理信息的过程中，用来暂时存放各种信息。</p>
<h3 id="通用寄存器组">通用寄存器组</h3>
<p>用户可通过编程访问的寄存器，在指令系统中为它们分配了相应的编号。指令中以寄存器号来指示。</p>
<h3 id="暂存器">暂存器</h3>
<p>暂存器对编程者来说是透明的，即在程序中不会出现。</p>
<p>作用：暂时存放CPU处理过程中的临时信息，避免破坏通用寄存器的内容。</p>
<p>例如，实现从内存的单元A传送数据到另一个单元B。从单元A读出的数据先送到CPU中的一个暂存器，然后再从暂存器送入单元B。</p>
<h3 id="指令寄存器ir">指令寄存器IR</h3>
<p>作用：用来存放当前正在执行的指令。控制器根据其内容（操作码以及地址信息）产生所需要的各种微命令。</p>
<h3 id="程序计数器pc">程序计数器PC</h3>
<p>作用：指示指令在存储器中的存放位置。</p>
<p>程序顺序执行时，每当从主存中取出一条指令后，PC内容就自动增量计数，指向下一条指令。</p>
<p>程序发生转移时，将转移地址送入PC，使其指向转移目的地的指令地址。</p>
<h3 id="程序状态字寄存器psw">程序状态字寄存器PSW</h3>
<p>作用：记录现行程序的运行状态和指示程序的工作方式。</p>
<h4 id="特征位">特征位</h4>
<p>进位位C、溢出位V、零值位Z、符号位S、奇偶位P等。</p>
<h4 id="方式控制位">方式控制位</h4>
<p>跟踪位T、中断允许位I、程序优先级字段、工作方式字段等。</p>
<h3 id="地址寄存器mar">地址寄存器MAR</h3>
<p>作用：用来保存当前CPU所访问的数据cache存储器中单元的地址。</p>
<h3 id="数据缓冲寄存器mdr">数据缓冲寄存器MDR</h3>
<p>存放CPU与主存之间交换的数据。</p>
<p>由CPU写入主存的数据先送入MDR，主存地址译码找到指定单元后，再将数据从MDR送入到该单元。</p>
<p>从主存中读出的数据，先送入MDR，然后再送到指定的CPU内部某寄存器。</p>
<p>MAR和MDR是连接CPU与主存的桥梁，这两个寄存器不能编程访问，即对用户透明。</p>
<h1 id="控制器">控制器</h1>
<p>由程序计数器(PC)、指令寄存器(IR)、指令译码器、时序产生器和操作控制器组成，它是发布命令的“决策机</p>
<p>构”，即完成协调和指挥整个计算机系统的操作。</p>
<p>控制器的主要功能有：</p>
<p>1、从内存中取出一条指令，并指出下一条指令在内存中的位置。</p>
<p>2、对指令进行译码或测试，并产生相应的控制信号。</p>
<p>3、输出相应的控制信号，指挥并控制CPU，内存和I/O之间的数据流动的方向。</p>
<h1 id="运算器">运算器</h1>
<p>由算术逻辑单位（ALU）、累加寄存器（AC）、数据缓冲寄存器(DR)和状态条件寄存器(PSW)组成，它是数</p>
<p>据加工处理部件。
运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。</p>
<p>运算器的主要功能：</p>
<p>1、执行所有的算术运算。</p>
<p>2、执行所有的逻辑运算，并进行逻辑测试。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>5.2_指令执行过程</title>
    <url>/posts/b07fc105.html</url>
    <content><![CDATA[<h2 id="指令周期">指令周期</h2>
<span id="more"></span>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606203103631.png" /></p>
<p>指令周期：CPU从主存中取出并执行一条指令的全部时间。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/82318d6200a829db53b4696517d38bb.png" /></p>
<p>一个<strong>指令周期</strong>由若干<strong>机器周期</strong>表示，机器周期也叫<strong>CPU周期</strong>。</p>
<p>一个<strong>机器周期</strong>包含若干<strong>时钟周期（节拍）</strong>，<font color = "red">时钟周期是CPU操作的最基本单位。</font></p>
<ul>
<li>每个指令周期内机器周期可以不相等</li>
<li>每个机器周期内节拍数也可以不相等</li>
</ul>
<p>完整的指令周期如下图所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/daf0acddc67712ae6a66090d425de80.png" /></p>
<p>运行时，通过<strong>触发器</strong>来判断当前处于指令周期内的哪一个阶段。</p>
<h2 id="指令周期的数据流">指令周期的数据流</h2>
<h3 id="寻址周期">寻址周期</h3>
<p>根据PC的内容从主存中取出指令并存入IR</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e7f5413e7482afcbbc48c51156a0411.png" /></p>
<ol type="1">
<li>将当前指令地址送到<strong>存储地址寄存器</strong>
<ol type="1">
<li>(PC)→MAR(PC)→MAR</li>
</ol></li>
<li>CU发出控制信号，由控制总线传到主存，标明是<strong>读信号</strong>
<ol type="1">
<li>1→R1→R</li>
</ol></li>
<li>将MAR指向的主存中的内容经<strong>数据总线</strong>传至MDR
<ol type="1">
<li>M(MAR)→MDRM(MAR)→MDR</li>
</ol></li>
<li>将MDR中的数据送入<strong>指令寄存器IR</strong>
<ol type="1">
<li>(MDR)→IR(MDR)→IR</li>
</ol></li>
<li>CU发出控制信号，形成下一条指令的地址
<ol type="1">
<li>(PC)+1→PC(PC)+1→PC</li>
</ol></li>
</ol>
<h3 id="间址周期">间址周期</h3>
<p>取操作数的有效地址</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/276576497acff1b4b71270020417281.png" /></p>
<ol type="1">
<li>将指令的地址码送入MAR
<ol type="1">
<li>Ad(IR)→MARAd(IR)→MAR</li>
</ol></li>
<li>CU发出控制信号，表示读操作
<ol type="1">
<li>1→R1→R</li>
</ol></li>
<li>将MAR所指主存中的内容传入MDR
<ol type="1">
<li>M(MAR)→MDRM(MAR)→MDR</li>
</ol></li>
<li>将得到的有效地址送入IR
<ol type="1">
<li>(MDR)→Ad(IR)(MDR)→Ad(IR)</li>
</ol></li>
</ol>
<h3 id="执行周期">执行周期</h3>
<p>取操作数，根据IR中的操作码进行相关运算</p>
<p>执行周期的数据流向视不同指令而定，没有统一的数据流向。</p>
<h3 id="中断周期">中断周期</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0ee27676498b3b60be12ba4d1b31073.png" /></p>
<p>中断执行前需要保存当前程序的<strong>断点</strong>。</p>
<p>断点一般采用堆栈保存，SP为栈顶指针，进栈的操作顺序为先修改指针，再存入数据。</p>
<ol type="1">
<li>CU控制SP减一，并将修改后的栈顶地址存入MAR
<ol type="1">
<li>(SP)-1→SP(SP)-1→SP</li>
<li>(SP)→MAR(SP)→MAR</li>
</ol></li>
<li>CU发出控制信号，表明当前为写操作
<ol type="1">
<li>1→W1→W</li>
</ol></li>
<li>将断点内容（PC内容）存入MDR
<ol type="1">
<li>(PC)→MDR(PC)→MDR</li>
</ol></li>
<li>CU将中断程序的入口地址存入PC
<ol type="1">
<li>向量地址→PC向量地址→PC</li>
</ol></li>
</ol>
<h2 id="指令执行方案">指令执行方案</h2>
<h3 id="单指令周期">单指令周期</h3>
<p>对所有指令都选<strong>用相同的执行时间来完成</strong>。
指令之间<strong>串行执行</strong>，指令周期取决于执行时间最长的指令的执行时间。</p>
<p>会降低整个系统的运行速度。</p>
<h3 id="多指令周期">多指令周期</h3>
<p>对不同类型的指令<strong>选用不同的执行步骤来完成</strong>。
指令之间<strong>串行执行</strong>，可选用不同个数的时钟周期来完成不同指令的执行过程。</p>
<p>需要更复杂的硬件设计。</p>
<h3 id="流水线方案">流水线方案</h3>
<p>在每一个时钟周期启动一条指令，尽量让多条指令<strong>同时运行</strong>，但各自处在<strong>不同的执行步骤</strong>中。
指令之间<strong>并行执行</strong>。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>5.3_数据通路的功能和基本结构</title>
    <url>/posts/3e2d984d.html</url>
    <content><![CDATA[<p><strong>数据通路</strong>：数据在功能部件之间传送的路径</p>
<p>数据通路包括数据流经的组件，如ALU、寄存器等</p>
<p><strong>内部总线</strong>：同一部件，如CP，内部各寄存器和运算部件之间的总线</p>
<p><strong>系统总线</strong>：计算机系统各部件，如CP、内存、通道和I/O接口之间的总线</p>
<span id="more"></span>
<h1 id="cpu内部单总线方式">CPU内部单总线方式</h1>
<p>系统结构图如下所示</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/22e18ec75fabe00e936f3af281bbc03.png" /></p>
<p>1、寄存器之间的数据传送</p>
<p>设将PC的内容传送至MAR</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606203805458.png" /></p>
<p>2、主存和CPU之间的数据传输</p>
<p>设CPU从主存读取指令</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606203816629.png" /></p>
<p>3、执行算数或逻辑运算</p>
<p>由于ALU两个输入端必须同时有效，而总线只能传输一路数据，因此先将一个输入数据存入暂存寄存器Y</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606203841110.png" /></p>
<h1 id="专用数据通路方式">专用数据通路方式</h1>
<p>相较于单总线方式，将数据通路的流通方向单独安排线路。</p>
<p>优点是效率高，缺点是硬件量较大。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>5.5_指令流水线</title>
    <url>/posts/815eda5e.html</url>
    <content><![CDATA[<h1 id="流水线的概念">流水线的概念</h1>
<span id="more"></span>
<p>1、指令流水的定义</p>
<p>将指令执行过程划分为<strong>不同的阶段</strong>，占用<strong>不同的资源</strong>，使得多条指令<strong>同时执行</strong>。</p>
<p>（1）顺序执行方式</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-c9bf99ccd7c918e7c184c9879904665ad1a54a95%2F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=6a14914aba45f54cb3ae17811ef7b418f003b24a091809621409f94317823ace"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>顺序执行方式</p>
<p>时间：�=3��<em>T</em>=3*n**t*</p>
<p>传统冯诺依曼结构，又称<strong>串行执行方式</strong>。</p>
<ul>
<li><p>优点</p>
<ul>
<li>控制简单，硬件代价小</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>执行指令的速度较慢，</p></li>
<li><p>各功能部件的利用率很低</p></li>
</ul></li>
</ul>
<p>（2）一次重叠执行方式</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-02f9a944f44aa22bfe9642f375ef518652fe12d7%2F%E4%B8%80%E6%AC%A1%E9%87%8D%E5%8F%A0%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=e145395fb134a7f273f752ebb4aaa34b98809027d614fb838b51d77a1d9b6e3e"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>一次重叠执行方式</p>
<p>时间：�=3�+(�−1)×2�=(1+2�)�<em>T</em>=3<em>t</em>+(<em>n</em>−1)×2<em>t</em>=(1+2<em>n</em>)<em>t</em></p>
<ul>
<li><p>优点</p>
<ul>
<li><p>程序的执行时间缩短了1/3</p></li>
<li><p>各功能部件的利用率明显提高。</p></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li><p>需要付出硬件上较大开销的代价</p></li>
<li><p>控制过程比顺序执行复杂</p></li>
</ul></li>
</ul>
<p>（3）二次重叠执行方式</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-f437956ea671991ee3ce6237fefc601b6210742c%2F%E4%BA%8C%E6%AC%A1%E9%87%8D%E5%8F%A0%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=cd441dde7c62629bd1ee528abbb1c83fc4fd59a2bebb03340d7b88c0a18064c0"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>二次重叠执行方式</p>
<p>时间：�=3�+(�−1)�=(2+�)�<em>T</em>=3<em>t</em>+(<em>n</em>−1)<em>t</em>=(2+<em>n</em>)<em>t</em></p>
<p>时间更短</p>
<p>实际使用中也可以分成更多段，如4段甚至5段</p>
<p>2、流水线的表示方法</p>
<p>（1）指令执行过程图</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-f1cd95d3389b2849b3c53c535db07372bfb06ec3%2F%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=1630a29a930d484a97a91f158217bad27418f6c695a7ab2c0c7ef839a94ba7ad"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>指令执行过程图</p>
<p>主要用于分析指令执行过程以及影响流水线的因素</p>
<p>（2）时空图</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-31a1b4584a5f8cda4b94986fe862440f01da53c0%2F%E6%97%B6%E7%A9%BA%E5%9B%BE.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=9a606cae950ea210e1fa6bf654f197caa4f492e99e71c9d0e00174bca2162ed2"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>时空图</p>
<p>主要用于分析流水线的性能</p>
<p>5.5.2 流水线的性能指标</p>
<p>1、吞吐率</p>
<p>吞吐率是指在单位时间内流水线所<strong>完成的任务数量</strong>，或是输出结果的数量</p>
<ul>
<li><p>吞吐率：TP=���TP=<em>T<strong>k</strong>n</em></p>
<ul>
<li><p>�<em>n</em>：任务数量</p></li>
<li><p>��*T**k*：完成n个任务的总时间</p></li>
</ul></li>
<li><p>理想状态下的流水线时空图</p></li>
</ul>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-a64b88fd6c1a45ab315cbbd2dc784b29d9a558db%2F%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%9E%E5%90%90%E7%8E%87.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=3cb55bc4142f179b59a7dd9fd5d2c2a0a4410762be30b9582178fc48c3c23612"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>流水线的吞吐率</p>
<ul>
<li><p>一条指令的执行分为k个阶段</p></li>
<li><p>每个阶段耗时Δ�Δ<em>t</em></p></li>
</ul>
<p>��=[�+(�−1)]Δ�TP=��+�−1Δ�TP���=lim⁡�→∞TP=1Δ�<em>T<strong>k<em>=[<em>k</em>+(<em>n</em>−1)]Δ</em>t<em>TP=</em>k<em>+</em>n<em>−1</em>n<em>Δ</em>t<em>TP</em>ma</strong>x</em>=<em>n</em>→∞limTP=Δ<em>t</em>1</p>
<p>2、加速比</p>
<p><strong>不使用</strong>流水线所用的时间与<strong>使用</strong>流水线所用的时间之比。</p>
<p>S���=lim⁡�→∞S=�S*ma**x<em>=</em>n<em>→∞limS=</em>k*</p>
<p>3、效率</p>
<p>流水线的<strong>设备利用率</strong>称为流水线的效率。</p>
<p>流水线效率=任务占用了的时空区域总的时空区域 E���=lim⁡�→∞E=1
流水线效率=总的时空区域任务占用了的时空区域E*ma**x<em>=</em>n*→∞limE=1</p>
<p>5.5.3 影响流水线的因素</p>
<p>1、结构相关（资源冲突）</p>
<p><strong>结构相关</strong>：由于多条指令在同一时刻<strong>争用同一资源</strong>（主存、寄存器等）而形成的冲突</p>
<p>解决方案</p>
<ul>
<li><p>后一相关指令暂停一周期</p></li>
<li><p><strong>资源重复配置</strong>：数据存储器+指令存储器分开存储</p></li>
</ul>
<p>2、数据相关（数据冲突）</p>
<p>在一个程序中，存在必须<strong>等待</strong>前一条指令执行完才能执行后一条指令的情况，则这两条指令即为<strong>数据相关</strong>。</p>
<p>解决方案</p>
<ul>
<li><p>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行</p>
<ul>
<li><p>硬件阻塞（stall）</p></li>
<li><p>软件插入<strong>空操作NOP</strong></p></li>
</ul></li>
<li><p><strong>数据旁路</strong>技术：通过数据旁路直接将ALU的运算结果接回为下一条操作的输入</p></li>
<li><p><strong>编译优化</strong>：通过编译器调整指令顺序来解决数据相关</p></li>
</ul>
<p>3、控制相关（控制冲突）</p>
<p>当流水线遇到<strong>转移指令</strong>和其他<strong>改变PC值</strong>的指令而造成断流时，会引起控制相关</p>
<p>解决方案</p>
<ul>
<li><p>转移指令分支预测</p>
<ul>
<li><p>简单预测</p></li>
<li><p>动态预测</p></li>
</ul></li>
<li><p>预取转移成功和不成功两个控制流方向上的目标指令</p></li>
<li><p>加快和提前形成条件码</p></li>
<li><p>提高转移方向的猜准率</p></li>
<li><p>在分支指令插入空操作</p></li>
</ul>
<p>5.5.4 流水线的分类</p>
<p>1、根据流水线使用的级别</p>
<ul>
<li><p><strong>部件功能级流水线</strong>：将复杂的<strong>算术逻辑运算</strong>组成流水线工作方式</p></li>
<li><p><strong>处理机级流水线</strong>：把一条<strong>指令</strong>解释过程分成多个子过程</p></li>
<li><p><strong>处理机间级流水线</strong>：协调不同处理机间的不同任务</p></li>
</ul>
<p>2、根据流水线可以完成的功能</p>
<ul>
<li><p><strong>单功能流水线</strong>：只能实现一种固定的专门功能</p></li>
<li><p><strong>多功能流水线</strong>：通过各段间的不同连接方式可以同时或不同时地实现多种功能</p></li>
</ul>
<p>3、根据同一时间内各段之间的连接方式</p>
<ul>
<li><p><strong>静态流水线</strong>：在同一时间内，流水线的各段只能按同一种功能的连接方式工作</p></li>
<li><p><strong>动态流水线</strong>：在同一时间内，当某些段正在实现某种运算时，另一些段可以进行另一种运算</p></li>
</ul>
<p>4、根据各个功能段之间是否有反馈信号</p>
<ul>
<li><p><strong>线性流水线</strong>：从输入到输出，每个功能段<strong>只允许经过一次</strong>，
不存在反馈回路</p></li>
<li><p><strong>非线性流水线</strong>：存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算</p></li>
</ul>
<p>5.5.5 流水线的多发技术</p>
<p>1、超标量技术</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-787f3515c5b536ebeb67ecc6ba8b34122012704a%2F%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=814c6a5ce9d9662cad1ad4045405626f4fe42500679245d0c58fcb04ff84719b"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>超标量技术</p>
<p>每个时钟周期内可<strong>并发多条独立指令</strong>，通过编译优化技术，把可并行执行的指令搭配起来。属于<strong>空分复用技术</strong>。</p>
<ul>
<li><p>要配置多个功能部件</p></li>
<li><p>不能调整指令的执行顺序</p></li>
<li><p>如上图中，称为处理机的<strong>度为3</strong></p>
<ul>
<li>传统指令流水线度为1</li>
</ul></li>
</ul>
<p>2、超流水技术</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-0ce4a9926f577b961ee5c5c81a1e2ce9df71b71b%2F%E8%B6%85%E6%B5%81%E6%B0%B4%E6%8A%80%E6%9C%AF.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=5812153aa738c84bf35f2de9cbdd6f8333e4efa6358fa4cbe33f35fb850054ae"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>超流水技术</p>
<p>在一个时钟周期内<strong>再分段</strong>，一个功能部件使用多次。属于<strong>时分复用技术</strong>。</p>
<ul>
<li><p>流水线速度为原来的多倍</p></li>
<li><p>不能调整指令的执行顺序</p></li>
<li><p>靠编译程序解决优化问题</p></li>
</ul>
<p>3、超长指令字</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-de900f6cdaff4cabea057286dd5503f98c37a3d2%2F%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=cf15f93833f63bd181b0153d1ded3f2ddf7de066831339324878c45040e1b354"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>超长指令字</p>
<p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条</p>
<ul>
<li>具有多个操作码字段的超长指令字（可达几百位）</li>
</ul>
<p>5.5.6 5段式指令流水线</p>
<figure>
<img
src="https://aye10032.gitbook.io/~gitbook/image?url=https%3A%2F%2F263180029-files.gitbook.io%2F~%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%2F-MgTVRt7hyq7APa35yqR%2Fuploads%2Fgit-blob-cf1c5b1314ad22dfa7c9008c720f128da29c743c%2F5%E6%AE%B5%E5%BC%8F%E6%B5%81%E6%B0%B4%E7%BA%BF.png%3Falt%3Dmedia&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=4733d023f226654eae4935f10df6187e32584fbf7e60ea7444e64678cf82e238"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>5段式流水线</p>
<ul>
<li><p><strong>取指IF</strong>（instruction
fetch）：将指令从Cache中取出，放入寄存器</p></li>
<li><p><strong>指令译码ID</strong>（instruction decode）</p>
<ul>
<li><p>指令译码</p></li>
<li><p>将操作数从通用寄存器中取出，放入锁存器</p></li>
</ul></li>
<li><p><strong>执行EX</strong>（execute）</p></li>
<li><p><strong>访存M</strong>（memory）</p></li>
<li><p><strong>写回WB</strong>（write
back）：将运算结果写回主存/寄存器</p></li>
</ul>
<p>指令和数据分开存储在两个Cache中，可以使得取指与访存同时执行</p>
<p>Cache未命中会造成流水线断流</p>
<p>RISC中只有LOAD和STORE指令才能访问主存</p>
<p>令每个阶段时间耗时一样，取最长耗时为准</p>
<p><strong>缓冲寄存器（锁存器）</strong>：位于流水线每一段之后，其作用是<strong>保存本流水段的执行结果</strong>，提供给下一流水段使用</p>
<p>1、运算类指令</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add Rs,Rd</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IF：根据PC从指令Cache取指令到IF段锁存</p></li>
<li><p>ID：取出操作数到ID段锁存</p></li>
<li><p>EX：运算，将结果存入EX段锁存</p></li>
<li><p>M：空段</p></li>
<li><p>WB：将运算结果写回指定寄存器</p></li>
</ul>
<p>2、LOAD指令</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD Rd,114(Rs)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IF：根据PC从指令Cache取指令到IF段锁存</p></li>
<li><p>ID</p>
<ul>
<li><p>将<strong>基址寄存器</strong>的值存到段锁存器中</p></li>
<li><p>将<strong>偏移量</strong>的值（立即数）存到Imm中</p></li>
</ul></li>
<li><p>EX：运算，得到有效地址，将结果存入EX段锁存</p></li>
<li><p>M：根据有效地址从Cache中取数，放入M段锁存器中</p></li>
<li><p>WB：将取出的数写回指定寄存器</p></li>
</ul>
<p>3、STORE指令</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STORE Rs,114(Rd)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IF：根据PC从指令Cache取指令到IF段锁存</p></li>
<li><p>ID</p>
<ul>
<li><p>将<strong>基址寄存器</strong>的值存到ID段锁存器中</p></li>
<li><p>将<strong>偏移量</strong>的值（立即数）存到Imm中</p></li>
<li><p>将要存的数放到ID段锁存器中</p></li>
</ul></li>
<li><p>EX：</p>
<ul>
<li><p>运算，得到有效地址，将结果存入EX段锁存</p></li>
<li><p>将要存的数从ID段锁存器转移到EX段锁存</p></li>
</ul></li>
<li><p>M：将数据写入Cache</p></li>
<li><p>WB：空段</p></li>
</ul>
<p>4、转移类指令</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beq Rs,Rt,114 //若(Rs)==(Rt),则(PC)+指令字长+(偏移量X指令字长)→PC</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IF：根据PC从指令Cache取指令到IF段锁存</p></li>
<li><p>ID</p>
<ul>
<li><p>将要进行比较的两个数存到段锁存器中</p></li>
<li><p>将<strong>偏移量</strong>的值（立即数）存到Imm中</p></li>
</ul></li>
<li><p>EX：运算，比较两个数</p></li>
<li><p>M：将目标PC的值写回PC</p></li>
<li><p>WB：空段</p></li>
</ul>
<p>5、无条件转移指令</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp 114</span><br></pre></td></tr></table></figure>
<ul>
<li><p>IF：根据PC从指令Cache取指令到IF段锁存</p></li>
<li><p>ID：将<strong>偏移量</strong>的值（立即数）存到Imm中</p></li>
<li><p>EX：将目标PC的值写回PC</p></li>
<li><p>M：空段</p></li>
<li><p>WB：空段</p></li>
</ul>
<p>修改PC的硬件实际上是与5段式流水线的硬件独立的</p>
<p>需要尽早的完成对PC的修改</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>5.4_控制器的工作原理和功能</title>
    <url>/posts/93874b86.html</url>
    <content><![CDATA[<h2 id="硬布线控制器">硬布线控制器</h2>
<span id="more"></span>
<h3 id="硬布线控制器单元图">硬布线控制器单元图</h3>
<p>根据<strong>指令操作码</strong>、<strong>当前的机器周期</strong>、<strong>节拍信号</strong>、<strong>机器状态条件</strong>即可确定当前节拍下应发出什么<strong>微命令</strong>。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/af0b4152bc4a16926eb0dbeb3004ca8.png" /></p>
<p>硬布线控制器</p>
<ul>
<li>通过判断取值周期、节拍数和具体指令操作码，写出逻辑表达式</li>
<li>将逻辑表达式以电路实现</li>
</ul>
<h3 id="硬布线控制器的设计">硬布线控制器的设计</h3>
<p>分析每个阶段的微操作序列</p>
<ul>
<li>会用到哪些指令</li>
<li>在什么阶段用到</li>
<li>在什么条件下用到</li>
</ul>
<p>选择CPU控制方式</p>
<ul>
<li>定长周期 &amp; 不定长周期</li>
<li>每个机器周期几个节拍</li>
</ul>
<p>安排微操作时序</p>
<ul>
<li>哪些微操作在前，那些在后</li>
<li>每个节拍内安排多少指令</li>
</ul>
<p>电路设计</p>
<ol type="1">
<li>列出操作时间表</li>
<li>写出微操作命令的最简表达式</li>
<li>画出逻辑图</li>
</ol>
<h3 id="排微操作时序的原则">排微操作时序的原则</h3>
<ul>
<li>微操作的<strong>先后顺序</strong>不得随意更改
<ul>
<li>先分析指令的依赖顺序</li>
</ul></li>
<li>被控对象<strong>不同</strong>的微操作尽量安排在<strong>一个节拍内</strong>完成</li>
<li><strong>占用时间较短</strong>的微操作尽量安排在一个节拍内完成，并允许有先后顺序
<ul>
<li>同样在CPU内部的寄存器之间的数据流可以安排在一个周期内</li>
<li>主存和内部寄存器之间的数据操作不能在一个节拍内</li>
</ul></li>
</ul>
<h3 id="硬布线控制器的特点">硬布线控制器的特点</h3>
<ul>
<li>一般用于RISC （精简指令集系统）</li>
<li>扩充指令较困难</li>
<li>执行速度很快，微操作控制信号由组合逻辑电路即时产生</li>
</ul>
<h2 id="微程序控制器">微程序控制器</h2>
<h3 id="微程序控制器的设计思路">微程序控制器的设计思路</h3>
<ol type="1">
<li>若干微命令编制成一条微指令，控制实现一步操作；</li>
<li>若干微指令组成一段微程序，解释执行一条机器指令；</li>
<li>采用<strong>存储程序</strong>思想，出厂前将所有指令的<strong>微程序</strong>存入<strong>控制器存储器</strong>中</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ee1c8ebf262900782bb4a2edead53dc.png" /></p>
<h3 id="微程序控制器的基本结构">微程序控制器的基本结构</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606205231119.png" /></p>
<h4 id="微指令执行原理">微指令执行原理</h4>
<ul>
<li><strong>控制存储器CM</strong>：存放微程序，由<strong>ROM</strong>构成
<ul>
<li>容量为：微指令数量×微指令字长微指令数量×微指令字长</li>
</ul></li>
<li><strong>CMAR（μPC）</strong>：微地址寄存器，相当于PC和MAR的作用</li>
<li><strong>地址译码</strong>：处理微地址，转化为CM控制信号</li>
<li><strong>CMDR（μIR）</strong>：存储从CM中取出的微指令，位数与微指令字长相等</li>
<li><strong>微地址形成部件</strong>：通过IR中指定的操作码确定该指令对应的微指令序列的首微地址</li>
<li><strong>顺序逻辑</strong>：控制微指令的执行顺序
<ul>
<li>可以通过机器指令的寻址特征判断寻址方式，决定是否要跳过间址周期</li>
</ul></li>
<li>一个微程序理论上包括寻址周期微程序、间址周期微程序、执行周期微程序和中断周期微程序四个微程序段</li>
<li>取值周期、间址周期和中断周期的微程序通常是共用的</li>
<li>若有n条指令，则最少有n+1条微程序段（可能会没有间址周期和中断周期）</li>
</ul>
<h4 id="微指令工作过程">微指令工作过程</h4>
<h5 id="取机器指令">取机器指令</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606205507992.png" /></p>
<h5 id="转微程序入口">转微程序入口</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606205538794.png" /></p>
<h5 id="执行首条微指令">执行首条微指令</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606205605374.png" /></p>
<h5 id="取后续微指令">取后续微指令</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606205629600.png" /></p>
<h5 id="继续执行直到返回">继续执行直到返回</h5>
<h3 id="微指令的格式">微指令的格式</h3>
<h4 id="水平型微指令">水平型微指令</h4>
<p>一条微指令能定义<strong>多个</strong>可并行的微命令。</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b34e52d20c16970b18a40a637fb2609.png"
alt="水平型微指令" />
<figcaption aria-hidden="true">水平型微指令</figcaption>
</figure>
<ul>
<li>优点
<ul>
<li>微程序短</li>
<li>执行速度快</li>
</ul></li>
<li>缺点
<ul>
<li>微指令长</li>
<li>编写麻烦</li>
</ul></li>
</ul>
<h4 id="垂直型微指令">垂直型微指令</h4>
<p>一条微指令只能定义<strong>一个</strong>微命令，由微操作码字段规定具体功能</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f9b6459eb4226fe00fcf865af45e39b.png"
alt="垂直型微指令" />
<figcaption aria-hidden="true">垂直型微指令</figcaption>
</figure>
<ul>
<li>优点
<ul>
<li>微指令短</li>
<li>简单规整，便于编写</li>
</ul></li>
<li>缺点
<ul>
<li>微程序长</li>
<li>执行速度慢，工作效率低</li>
</ul></li>
</ul>
<h4 id="混合型微指令">混合型微指令</h4>
<p>在垂直型的基础上增加一些不太复杂的并行操作。</p>
<ul>
<li>微指令较短，仍便于编写</li>
<li>微程序也不长，执行速度加快</li>
</ul>
<h3 id="微指令的编码方式">微指令的编码方式</h3>
<p>讨论水平型微指令中操作控制部分如何编码表示微指令</p>
<h4 id="直接编码">直接编码</h4>
<ul>
<li>在微指令的操作控制字段中，每一位代表一个微操作命令。</li>
<li>某位为“1”表示该控制信号有效</li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bf55aedf0c8d83f7cae6b7dfa1709db.png"
alt="直接编码" />
<figcaption aria-hidden="true">直接编码</figcaption>
</figure>
<ul>
<li>优点
<ul>
<li>简单直观</li>
<li>执行速度快</li>
<li>操作并行性好</li>
</ul></li>
<li>缺点
<ul>
<li>微指令字长过长，导致CM容量需求极大S</li>
</ul></li>
</ul>
<h4 id="字段直接编码方式">字段直接编码方式</h4>
<ul>
<li>将微指令的控制字段分成若干“段” ，每段经译码后发出控制信号</li>
<li>分段原则
<ul>
<li><strong>互斥性微命令</strong>分在<strong>同一段内</strong>，<strong>相容性微命令</strong>分在<strong>不同段内</strong></li>
<li>每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间</li>
<li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令
<ul>
<li>当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作</li>
</ul></li>
</ul></li>
</ul>
<p><strong>互斥性微命令</strong>：不允许并行完成的微命令</p>
<p><strong>相容性微命令</strong>：允许并行完成的微命令</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/ff3a2b37767154a466596b46d8159c8.png"
alt="字段直接编码方式" />
<figcaption aria-hidden="true">字段直接编码方式</figcaption>
</figure>
<hr style = "border:2px solid yellow">
<p>例：某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法。共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有多少位?</p>
<ul>
<li>第一个互斥类：7+1=8≤237+1=8≤23</li>
<li>第二个互斥类：3+1=4≤223+1=4≤22</li>
<li>第三个互斥类：12+1=13≤2412+1=13≤24</li>
<li>第四个互斥类：5+1=6≤235+1=6≤23</li>
<li>第五个互斥类：6+1=7≤236+1=7≤23</li>
<li>总字段数：3+2+4+3+3=15 位</li>
</ul>
<hr style = "border:2px solid yellow">
<p>优点 - 可以缩短指令字长</p>
<p>缺点 - 要通过译码电路后再发出微命令，因此比直接编码方式慢</p>
<h4 id="字段间接编码">字段间接编码</h4>
<p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠子段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。</p>
<ul>
<li>进一步缩短指令字长</li>
<li>执行更慢</li>
</ul>
<h3 id="微指令的地址形成方式">微指令的地址形成方式</h3>
<ul>
<li>通过微指令的<strong>下地址字段</strong>指出</li>
<li>依据机器指令的<strong>操作码</strong>形成
<ul>
<li>机器指令放入IR</li>
<li>微地址形成部件通过机器指令的操作码部分形成微指令的地址</li>
</ul></li>
<li><strong>增量计数器法</strong>：（CMAR）+1 → CMAR，类似PC</li>
<li>分支转移
<ul>
<li>转移方式：指明判别条件</li>
<li>转移地址：指明转移成功后的去向</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/9f030e9854caac6ba7761a96df85b1f.png"
alt="分支转移" />
<figcaption aria-hidden="true">分支转移</figcaption>
</figure>
<ul>
<li>通过测试网络</li>
<li>由硬件产生微程序入口地址
<ul>
<li>取值周期的第一条微指令的地址由硬件自动给出</li>
</ul></li>
</ul>
<h3 id="微程序控制单元的设计">微程序控制单元的设计</h3>
<h4 id="设计步骤">设计步骤</h4>
<ol type="1">
<li><p>分析每个阶段的微操作序列</p></li>
<li><p>写出对应机器指令的微操作命令及节拍安排</p>
<ul>
<li>写出每个周期所需要的微操作（与硬布线相同）</li>
<li>添加微程序控制器特有的微操作
<ul>
<li>取值周期
<ul>
<li>每条微指令执行结束之后：Ad(CMDR)→CMAR，指明下地址</li>
<li>最后一条执行结束后：OP(IR)→微地址形成部件→CMAR，确定执行周期的微程序首地址</li>
</ul></li>
<li>执行周期
<ul>
<li>指明下地址：Ad(CMDR)→CMAR</li>
</ul></li>
</ul></li>
</ul>
<p>确定微指令格式</p>
<ul>
<li>根据操作码的编码方式确定<strong>操作控制字段</strong>的位数</li>
<li>根据CM中的微指令总数确定<strong>顺序控制字段</strong>的位数</li>
<li>根据操作控制字段和顺序控制字段的长度确定微指令字长</li>
</ul></li>
<li><p>编写微指令码点</p></li>
</ol>
<h4 id="微程序设计分类">微程序设计分类</h4>
<ul>
<li><strong>静态</strong>微程序设计：
<ul>
<li>微程序无需改变</li>
<li>采用ROM</li>
</ul></li>
<li><strong>动态</strong>威程序设计
<ul>
<li>通过改变微指令和微程序改变机器指令</li>
<li>有利于仿真</li>
<li>采用EPROM</li>
</ul></li>
</ul>
<p><strong>毫微程序设计</strong>：用毫微程序解释微程序（更进一步）</p>
<h3 id="微程序控制器的特点">微程序控制器的特点</h3>
<ul>
<li>执行速度慢</li>
<li>较规整，易于扩充修改</li>
<li>适用于CISC（复杂指令集系统）</li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第八章输入输出系统</title>
    <url>/posts/ed8e6d6e.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.1_存储器概述</title>
    <url>/posts/7e50f3e7.html</url>
    <content><![CDATA[<h2 id="存储器的分类">存储器的分类</h2>
<span id="more"></span>
<h3 id="按在计算机中的作用分类">按在计算机中的作用分类</h3>
<ul>
<li>主存储器</li>
<li>辅助存储器</li>
<li>高速缓冲存储器（Cache）</li>
</ul>
<h3 id="按照存储介质分">按照存储介质分</h3>
<ul>
<li>磁表面存储器</li>
<li>磁芯存储器</li>
<li>光存储器</li>
<li>半导体存储器</li>
</ul>
<h3 id="按存取方式分类">按存取方式分类</h3>
<ul>
<li>随机存储器（RAM）</li>
<li>只读存储器（ROM）：断电不丢失信息</li>
<li>串行访问存储器：需要先<strong>物理</strong>寻址
<ul>
<li>顺序存取存储器：磁带</li>
<li>直接存取存储器：磁盘</li>
</ul></li>
</ul>
<h3 id="信息的可保存性">信息的可保存性</h3>
<ul>
<li>断电后存储信息是否消失
<ul>
<li>易失性：RAM</li>
<li>非易失性</li>
</ul></li>
<li>读出时是否破坏信息
<ul>
<li>破坏性读出：DRAM</li>
<li>非破坏性读出</li>
</ul></li>
</ul>
<h2 id="存储器的性能指标">存储器的性能指标</h2>
<ul>
<li>存储容量
<ul>
<li>存储容量 = 存储字数 X 字长（1M X 8位）</li>
</ul></li>
<li>单位成本
<ul>
<li>每位价格=总成本总容量每位价格=总容量总成本</li>
</ul></li>
<li>存储速度
<ul>
<li>存取时间</li>
<li>存取周期</li>
<li>主存带宽</li>
</ul></li>
</ul>
<h2 id="多级存储结构">多级存储结构</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dec59015fe3572a8f2d5c45e51bd427.png" /></p>
<ul>
<li>Cache到主存：解决CPU与主存之间<strong>速度</strong>的矛盾</li>
<li>主存和辅存：解决主存<strong>容量</strong>的问题</li>
</ul>
<p>从CPU→cache→主存→磁盘→磁带、光盘</p>
<ul>
<li>速度越来越慢</li>
<li>容量越来越大</li>
<li>价格越来越低</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430062117520.png" /></p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.2_半导体随机存储器</title>
    <url>/posts/ed914090.html</url>
    <content><![CDATA[<p>#基本的半导体原件及原理</p>
<span id="more"></span>
<p><a
href="https://www.youtube.com/watch?v=grkXoxG_Wqs">视频讲解:基本的半导体原件及原理</a></p>
<h2 id="存储元">存储元</h2>
<p>利用MOS管实现“高通低阻”</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430070558021.png" /></p>
<h2 id="存储体结构组成">存储体结构组成</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430070637587.png" /></p>
<blockquote>
<p>注：1个字节8个bit，一个存储字多少个bit看具体设计</p>
</blockquote>
<h2 id="存储芯片的基本原理">存储芯片的基本原理</h2>
<p><a
href="https://www.youtube.com/watch?v=8GfnWZktHdk">视频讲解：存储芯片的基本原理</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430071453570.png" /></p>
<p>译码器将MAR中信号转换为选择信号，选择自选线(比如上图有3位，对应8个地址，从0~7)，被选择的字选线得到一个高电平信号，这根线对应的存储字中的存储的数据一起通过数据线传送</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430071912303.png" style="zoom:50%;" /></p>
<p>控制电路用来控制MAR与MDR中电信号稳定才传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430072201789.png" style="zoom:50%;" /></p>
<p>芯片的选择控制与读写控制如上图</p>
<p>封装前后芯片组成如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430072531019.png" style="zoom:50%;" /></p>
<p><a
href="https://www.youtube.com/watch?v=7iP6daJ_EwA">视频讲解：存储芯片的封装和引脚数量的计算</a></p>
<p><a
href="https://www.youtube.com/watch?v=juOp0XLhOl0">视频讲解：存储芯片中的地址数量和存储字长的表示和计算</a></p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506110534863.png"
alt="芯片总容量计算" />
<figcaption aria-hidden="true">芯片总容量计算</figcaption>
</figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430073723378.png"
alt="存储单元1描述" />
<figcaption aria-hidden="true">存储单元1描述</figcaption>
</figure>
<p>第一个数字表示有多少个存储单元</p>
<p>第二个数字表示存储字长有多少</p>
<h1 id="半导体存储芯片的结构">半导体存储芯片的结构</h1>
<!--more-->
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/57f794b2ede60ee204ec064557c09c8.png" /></p>
<ul>
<li><strong>存储矩阵</strong>：由大量相同的位存储单元阵列构成</li>
<li><strong>译码驱动</strong>：将来自地址总线的地址信号翻译成对应存储单元的选通信号，
该信号在读写电路的配合下完成对被选中单元的读/写操作</li>
<li><strong>读写电路</strong>：包括读出放大器和写入电路，用来完成读/写操作</li>
<li><strong>地址线</strong>：决定CPU访问存储矩阵的哪里，<strong>单向</strong>输入，位数取决于芯片的容量</li>
<li><strong>数据线</strong>：进行数据的读写，<strong>双向</strong>读写，位数取决于芯片能够读/写的位数</li>
<li><strong>片选线</strong>：用于确定哪一个存储芯片被选中，可以表示为
<ul>
<li>CS‾CS：芯片选择，低电平有效</li>
<li>CE‾CE：芯片使能，低电平有效</li>
</ul></li>
<li>读写控制线：可以有一根，也可以有两根
<ul>
<li>一根
<ul>
<li>WE‾WE：低电平写有效，高电平读有效</li>
</ul></li>
<li>两根
<ul>
<li>OW‾OW：允许读，低电平有效</li>
<li>WE‾WE：允许写，低电平有效</li>
</ul></li>
</ul></li>
</ul>
<p>芯片的容量由地址线和数据线一起决定：</p>
<p>芯片的容量=2地址线根数×数据线根数芯片的容量=2地址线根数×数据线根数</p>
<h1 id="sram和dram的区别">SRAM和DRAM的区别</h1>
<h2 id="dram芯片">DRAM芯片</h2>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430142802775.png" style="zoom:50%;" /></p>
<p>写入：字选择线加5V，数据线加5V，电容内存储电荷，表示写入1，反之就是0</p>
<p>读出：字选择线加5V，如果此时电容有点，电容就放电，就表示输出1，反之就是0</p>
<p><a
href="https://www.youtube.com/watch?v=MsayKaswc6g">视频讲解</a></p>
<h2 id="sram芯片">SRAM芯片</h2>
<p>双稳态触发器</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430143603217.png" style="zoom:50%;" /></p>
<p>A高B低：1</p>
<p>A低B高：0</p>
<p>相应的读/写就是相应的2根数据线BL和BLX就是根据上面高低输出/输出，比如BL输出高电平，BLX输出低电平，那么就是1</p>
<p><a
href="https://www.youtube.com/watch?v=pJL39mmLPt4">视频讲解:SRAM</a></p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 21%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">特点</th>
<th style="text-align: center;">SRAM</th>
<th style="text-align: center;">DRAM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">存储信息（0、1）</td>
<td style="text-align: center;">触发器（双稳态）</td>
<td style="text-align: center;">电容（充放电）</td>
</tr>
<tr class="even">
<td style="text-align: center;">破坏性读出</td>
<td style="text-align: center;">非</td>
<td style="text-align: center;">是</td>
</tr>
<tr class="odd">
<td style="text-align: center;">需要刷新</td>
<td style="text-align: center;">不要</td>
<td style="text-align: center;">需要（电容上的电荷只能维持2ms）</td>
</tr>
<tr class="even">
<td style="text-align: center;">送行列地址（行地址，列地址）</td>
<td style="text-align: center;">同时传送</td>
<td style="text-align: center;">分两次送</td>
</tr>
<tr class="odd">
<td style="text-align: center;">运行速度</td>
<td style="text-align: center;">块</td>
<td style="text-align: center;">慢</td>
</tr>
<tr class="even">
<td style="text-align: center;">集成度</td>
<td style="text-align: center;">低</td>
<td style="text-align: center;">高</td>
</tr>
<tr class="odd">
<td style="text-align: center;">发热量</td>
<td style="text-align: center;">大</td>
<td style="text-align: center;">小</td>
</tr>
<tr class="even">
<td style="text-align: center;">存储成本</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">低</td>
</tr>
</tbody>
</table>
<p><a
href="https://www.youtube.com/watch?v=pJL39mmLPt4">视频讲解：SRAM和DRAM对比</a></p>
<h1 id="dram的刷新">DRAM的刷新</h1>
<h2 id="刷新的频率">刷新的频率：</h2>
<p>一般为2ms</p>
<h2 id="每次刷新多少存储单元">每次刷新多少存储单元：</h2>
<p>以行为单位，一次刷新一行</p>
<p>使用行列地址的目的：减少选通线</p>
<p>解释：什么叫行，为什么要拆成行</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240430152445001.png" style="zoom:50%;" /></p>
<p><font color = "yellow">原因：降低选通线的数量，比如如果地址线有8位，一个平面需要<span
class="math inline">\(2^8 =
256\)</span>根选通线，而展开成二维后需要<span class="math inline">\(2^4
+ 2^4 = 32\)</span>根选通线</font></p>
<h2 id="如何刷新">如何刷新</h2>
<p>通过硬件支持，读出一行的信息后重新写入，占用1个读/写周期</p>
<h2 id="何时刷新">何时刷新</h2>
<p>假设DRAM内部结构排列成 128X128 的形式，读/写周期0.5μs</p>
<ul>
<li><strong>分散刷新</strong>
<ul>
<li>每读写一次就刷新该行</li>
<li>前0.5μs用于读写、后0.5μs用于刷新</li>
<li>系统的存取周期变为1μs</li>
</ul></li>
<li><strong>集中刷新</strong>
<ul>
<li>2ms内集中安排时间刷新</li>
<li>例如最后128个周期（64μs）全部用于刷新128行</li>
<li>用于刷新的存储周期内无法访问存储器，称为<strong>访存死区</strong></li>
</ul></li>
<li><strong>异步刷新</strong>
<ul>
<li>将128次刷新平均分布在2ms内</li>
<li>每15.6μs会有一个0.5μs的<strong>死时间</strong></li>
</ul></li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=3fzfdsz-DNk">视频讲解：DRAM的刷新</a></p>
<h1 id="darm地址复用技术">DARM地址复用技术</h1>
<p>DRAM芯片容量较大，通常采用<strong>地址复用技术</strong>，即行地址和列地址分两次用同样的地址线输入</p>
<ul>
<li>地址线数量变为一半</li>
<li>选通线变为行选通和列选通线共计两根</li>
</ul>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240506104336977.png" /></p>
<p><a href="">视频讲解：DARM地址复用技术</a></p>
<h1 id="ram的读写周期">RAM的读写周期</h1>
<h2 id="sram的读周期">SRAM的读周期</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/162e0be361888a1e337e58c42f7ddc1.png" /></p>
<ul>
<li><span class="math inline">\(t_{CO}\)</span>
之前：等待地址线稳定</li>
<li><span class="math inline">\(t_{CO}\)</span>：片选保持时间</li>
<li>数据全部读出之后，在外部总线上稳定的出现，片选信号失效</li>
<li><span class="math inline">\(t_{A}\)</span>：读出时间</li>
<li><span class="math inline">\(t_{RC}\)</span> ：读周期</li>
</ul>
<p>当使用一根读写控制线时，写使能信号WE全程保持高电平。</p>
<p>这些时序参数描述了存储器操作时各种信号的作用和持续时间，确保正确的数据传输和存储器操作。</p>
<h2 id="sram的写周期">SRAM的写周期</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/26bf8dc373b2feb32df5eaf1af7fb19.png" /></p>
<p>过程原理与读类似，等待信号稳定。</p>
<h1 id="只读存储器rom">只读存储器（ROM）</h1>
<h2 id="rom的特点">ROM的特点</h2>
<ul>
<li>断电不丢失信息</li>
<li>只读</li>
</ul>
<h2 id="rom的分类">ROM的分类</h2>
<ul>
<li>掩膜式只读存储器（MROM）
<ul>
<li>出厂时写入</li>
</ul></li>
<li>一次可编程只读存储器（PROM）
<ul>
<li>通过专门设备一次性写入</li>
</ul></li>
<li>可擦除可编程只读存储器（EPROM）
<ul>
<li>修改次数有限</li>
<li>写入时间很长</li>
</ul></li>
<li>闪速存储器（Flash Memory）
<ul>
<li>如U盘</li>
</ul></li>
<li>固态硬盘（Solid State Drives）
<ul>
<li>控制端元+闪存芯片</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.3_主存储器与CPU的连接</title>
    <url>/posts/df1c2374.html</url>
    <content><![CDATA[<h2 id="主存连接原理">主存连接原理</h2>
<span id="more"></span>
<h3 id="主存简单模型">主存简单模型</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/b22791b744630498703ad51ca08a619.png" /></p>
<p>三个输入信号：读/写信号、要读写的数据、数据的主存地址</p>
<h3 id="连接原理">连接原理</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/6a3fec97c6d0d1f1aa0fe006b769e6c.png" /></p>
<p>三个总线：数据总线、地址总线、控制总线（读/写）</p>
<h3 id="主存的地址单元分配">主存的地址单元分配</h3>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/747950ef7f07cbf5549e0c5f212842b.jpg" style="zoom: 67%;" /></p>
<ul>
<li>存储单元的数量：总容量 ÷ 每个单元的容量</li>
<li>地址线的数量应该等于总容量的位数。根据图中所示，1KB等于2的10次方字节（1KB
= <span class="math inline">\(2^{10}\)</span>
B），因此有10根地址线。</li>
<li>如何存放一个字
<ul>
<li>字长为4B，实际上寻址时将四个存储单元看作一个</li>
<li>一组内有4个存储单元，后两位表示序号，前面表示所在组</li>
<li>每个存储单元存放两位十六进制数（8位二进制数）</li>
<li>共四个存储单元，也就是一个字</li>
</ul></li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=JVT9yXLECGE">视频讲解：寻址</a></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240526105712660.png" /></p>
<p><a href="">视频讲解</a></p>
<hr style = "border:2px solid yellow">
<h2 id="主存容量的扩展">主存容量的扩展</h2>
<h3 id="位扩展法">位扩展法</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f556c33ce71954c3de7f59502e725f7.png" /></p>
<ul>
<li><p>地址线、片选线和读写控制线<strong>并联</strong></p></li>
<li><p>数据线依次连接CPU数据线的一位</p></li>
</ul>
<p><a
href="https://www.youtube.com/watch?v=O9W6p6frY9E">视频讲解：位扩展</a></p>
<p>如上图中就将8片<span class="math inline">\(8K * 1位\)</span>
的储芯片扩展为了$8K $位</p>
<h3 id="字扩展法">字扩展法</h3>
<p><a
href="https://www.youtube.com/watch?v=htUgqiop9LY">视频讲解：字扩展</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/efe6c142bb12db18c2e7aceea4155b7.png" /></p>
<ul>
<li><p>数据线、读写控制线和地址线<strong>并联</strong></p></li>
<li><p>使用PU剩下的地址线连接片选线，选择当前读/写的芯片</p>
<ul>
<li><p>线选法：直接将地址线与片选线连接，一根地址线对应一根片选线</p></li>
<li><p>译码器片选法：使用译码器将连接CPU地址线与片选线</p></li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>线选法</th>
<th>译码器片选法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>n条线 → n个选片信号</td>
<td>n条线 → <span class="math inline">\(2^n\)</span>个选片信号</td>
</tr>
<tr class="even">
<td>电路简单</td>
<td>电路复杂</td>
</tr>
<tr class="odd">
<td>地址空间不连续（形如11、00的信号是无效的）</td>
<td>地址空间可连续可以增加逻辑设计</td>
</tr>
</tbody>
</table>
<h3 id="字位扩展">字位扩展</h3>
<p><a
href="https://www.youtube.com/watch?v=wvAH9hl4tkk">视频讲解：字位同时拓展</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/da523bbb75f333c121b384232099848.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240526110414799.png" /></p>
<hr style = "border:2px solid yellow">
<h2 id="补充编码器和ram读周期">补充：编码器和RAM读周期</h2>
<p><a
href="https://www.youtube.com/watch?v=0Zhze9Ocuao">视频讲解：编码器和RAM读周期</a></p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.5_磁盘存储器和固态硬盘</title>
    <url>/posts/23b2db03.html</url>
    <content><![CDATA[<h1 id="磁盘存储器">磁盘存储器</h1>
<span id="more"></span>
<h2 id="磁盘设备的组成">磁盘设备的组成</h2>
<p><a
href="https://www.youtube.com/watch?v=tSLGxtYlvK0">视频讲解：存储区域和硬盘存储器设计</a></p>
<h3 id="存储区域">存储区域</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/db3aaf1acc8ebd60a572155afe38e8a.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/8ea91f4563cfc2949d76c5130dc4f80.jpg" /></p>
<p>一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区(也称块)是磁盘读写的最小单位，也就是说磁盘按块存取。</p>
<h4 id="磁头数heads">磁头数(Heads)</h4>
<p>即记录面数，表示硬盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。
#### 柱面数(cylinders)
表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号(位置)的诸磁道构成一个圆柱面。
表示每一条磁道上有多少个扇区。</p>
<h4 id="扇区数">扇区数</h4>
<p>表示每一条磁道上有多少个扇区</p>
<h3 id="硬盘存储器">硬盘存储器</h3>
<p>硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。 #### 磁盘驱动器</p>
<p>核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器。
#### 磁盘控制器</p>
<p>是硬盘存储器和主机的接口，主流的标准有IDE、SCS1、SATA等 ##
磁盘的性能指标</p>
<h3 id="磁盘的容量">磁盘的容量</h3>
<p>一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。</p>
<p>非格式化容量是指磁记录表面可以利用的磁化单元总数。</p>
<p>格式化容量是指按照某种特定的记录格式所能存储信息的总量</p>
<h3 id="记录密度">记录密度</h3>
<p><a
href="https://www.youtube.com/watch?v=dJCTfv7fi8o">视频讲解：三种密度</a></p>
<p>记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</p>
<ol type="1">
<li><p>道密度是沿磁盘半径方向单位长度上的磁道数</p></li>
<li><p>位密度是磁道单位长度上能记录的二进制代码位数</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/95a41cedcd56b3d02eec8099d3dd840.jpg" /></p>
<ol start="3" type="1">
<li>面密度是位密度和道密度的乘积</li>
</ol>
<p>注意:磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240507161722601.png" /></p>
<h3 id="平均存取时间">平均存取时间:</h3>
<p>平均存取时间
=寻道时间(磁头移动到目的磁道)+旋转延迟时间(磁头定位到所在扇区)+传输时间(传输数据所花费的时间)</p>
<p><a href="">视频讲解:平均存取时间计算</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240507162853821.png" /></p>
<h3 id="数据传输率">数据传输率</h3>
<p>磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。</p>
<h2 id="磁盘阵列">磁盘阵列</h2>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513093628681.png" /></p>
<p><a
href="https://www.youtube.com/watch?v=BOXUVUkwY2s">视频讲解</a></p>
<h1 id="固态硬盘ssd">固态硬盘SSD</h1>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240513094653726.png" /></p>
<h2 id="结构">结构</h2>
<p><a
href="https://www.youtube.com/watch?v=Vm-uAqAIQkI">视频讲解：SSD的结构</a></p>
<h2 id="读写">读写</h2>
<p><a
href="https://www.youtube.com/watch?v=iKfc2aVebPE">视频讲解：SSD的读写</a></p>
<p><a
href="https://www.youtube.com/watch?v=lhvPdJS2QUs">视频讲解：SSD使用寿命计算</a></p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.4_双端口RAM和多模块存储器.md</title>
    <url>/posts/2846ab22.html</url>
    <content><![CDATA[<h2 id="双端口ram">双端口RAM</h2>
<span id="more"></span>
<p>拥有两个端口，可以同时访问不同的地址单元。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/347e86b6d8334261a2a0705fccb0f66.png" /></p>
<p>当连个端口访问同一个地址单元时：</p>
<ul>
<li>两个端口不同时对同一地址单元存取数据 ✔</li>
<li>两个端口同时对同一地址单元读出数据 ✔</li>
<li>两个端口同时对同一地址单元写入数据 ❌</li>
<li>两个端口同时对同一地址单元，一个写入数据，另一个读出数据 ❌</li>
</ul>
<p>可以通过<strong>忙信号</strong>解决这一问题，当有忙信号时，暂时关闭其中一个端口。</p>
<h2 id="多模块存储器">多模块存储器</h2>
<h3 id="单体多字存储器">单体多字存储器</h3>
<ul>
<li>每个存储单元内存储m个字</li>
<li>总线宽度为m个字</li>
<li>一次并行读/写m个字</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<ul>
<li>优点
<ul>
<li>提高了带宽，增加了读写速度</li>
</ul></li>
<li>缺点
<ul>
<li>指令和数据在主存内必须是<strong>连续存放</strong>的</li>
<li>对转移指令、不连续操作数据效果不明显</li>
</ul></li>
</ul>
<h3 id="多体并行存储器">多体并行存储器</h3>
<p><a
href="https://www.youtube.com/watch?v=MgZECMV4bG0">视频讲解：高位与低位区别</a></p>
<p><a
href="https://www.youtube.com/watch?v=Fr_msQP-VRQ">视频讲解：存储体数量设置</a></p>
<p>有多个存储模块，每个存储模块有相同的容量和存取速度；单独的读写控制器、地址寄存器和数据寄存器。</p>
<p>能并行工作，也能交叉工作</p>
<p><font color = "yellow">下面举例都是假设T = 4r,
其中r是存入时间，3r是恢复时间</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e37d87c88bb390a2d0e3fa3fb56fe8e.jpg" /></p>
<h4 id="高位交叉编制也称顺序存储">高位交叉编制（也称顺序存储）</h4>
<p><font color = "yellow">前2位作为区分是第几个存储体</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/686a25b1e34450f888ff1063bfdda32.png" /></p>
<p>连续访问时还是在一个模块内进行，实际上仅仅实现了<strong>扩容</strong>，<strong>不能提高访问速度</strong>。</p>
<p>高位交叉编制<strong>不满足</strong>程序的<strong>局部性原理</strong>。</p>
<p><font color = "yellow">编码是从列往下0,1,2……</font></p>
<h4 id="低位交叉编制也称交叉存储">低位交叉编制（也称交叉存储）</h4>
<p><font color = "yellow">后2位作为存储体编号</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7190903b6e5eae91c22299a472a3de0.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/14014a7880774276291db3acdd445f6.jpg" /></p>
<p>当连续访问时，在多个模块间切换，提高了吞吐效率。</p>
<p>低位交叉编制<strong>满足</strong>程序的<strong>局部性原理</strong>。</p>
<p><font color = "yellow">低位是按行从左往右0， 1， 2……</font></p>
<hr style = "border:2px solid yellow">
<p>举例：如何求带宽</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240507161200050.png" /></p>
<p>例：模块数 ( m = 4 )，存储周期为 ( T )，字长 ( w )，数据总线宽度为 (
W )，总线传输周期为 ( r )，连续存储 ( n ) 个字，求交叉存储器的带宽。</p>
<p>连续存储 ( n ) 个字耗时： <span class="math inline">\(T + (n-1)
\times (T + r)\)</span> 前提： <span class="math inline">\(W \geq m
\times r \times T\)</span></p>
<p>带宽： <span class="math inline">\(\frac{n \times W}{T + (n-1) \times
(T + r)}\)</span></p>
<p>当 ( n ) 较大时，带宽趋近于： <span
class="math inline">\(\frac{W}{r}\)</span></p>
<p>单个存储体的带宽： <span
class="math inline">\(\frac{W}{T}\)</span></p>
<hr style = "border:2px solid yellow">
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>3.6_高速缓冲存储器cache</title>
    <url>/posts/5fa3f876.html</url>
    <content><![CDATA[<h2 id="局部性原理">局部性原理</h2>
<span id="more"></span>
<p><strong>时间局部性</strong>：一条指令一旦被执行，不久的将来可能被再次执行</p>
<p><strong>空间局部性</strong>：一个存储单元呗访问，则其临近的存储单元也将被访问</p>
<h2 id="cache的工作原理">Cache的工作原理</h2>
<p>基于局部性原理，可以把CPU目前访问的地址周围的部分数据放到Cache中。</p>
<p>将主存与Cache分为同样大小的块（见操作系统“分页”相关内容），<strong>主存和Cache之间以块为单位进行数据交换</strong>。系统访问主存时，会将这一块的内容同时复制到Cache中。</p>
<h3 id="cache的性能分析">Cache的性能分析</h3>
<p><a
href="https://www.youtube.com/watch?v=mnDTv6nlCZU">视频讲解：cache的性能分析</a></p>
<p>命中率 <span class="math inline">\(H\)</span> 的定义是： <span
class="math inline">\(H =
\text{CPU欲访问的信息已在Cache中的比率}\)</span></p>
<p>缺失（未命中）率 <span class="math inline">\(M\)</span> 的表达式是：
<span class="math inline">\(M = 1 - H\)</span></p>
<ol type="1">
<li><p>先访问Cache，若Cache未命中再访问主存的情况下，Cache-主存系统的平均访问时间
$ t$ 为： <span class="math inline">\(t = H \cdot t_c + (1 - H) \cdot
(t_c + t_m)\)</span></p></li>
<li><p>同时访问Cache和主存，若Cache命中则立即停止访问主存的情况下，Cache-主存系统的平均访问时间
$ t$ 为： <span class="math inline">\(t = H \cdot t_c + (1 - H) \cdot
t_m\)</span></p></li>
</ol>
<p>其中，<span class="math inline">\(t_c\)</span>
表示访问一次Cache所需的时间，$ t_m$ 表示访问一次主存所需的时间，$ H$
表示Cache的命中率。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/68871fabc55bff3ba1cce3791a19516.jpg" /></p>
<h2 id="cache和主存的映射方式">Cache和主存的映射方式</h2>
<h3 id="前置知识关于cache与主存分块">前置知识：关于cache与主存分块</h3>
<p><a
href="https://www.youtube.com/watch?v=DGaeZY4GjhA">视频讲解：关于cache与主存分块</a>
<img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/528c22c45d886d33721c4bc04a332d0.jpg" /></p>
<p><font color = "yellow">地址空间：需要多少位才能表示整个范围，比如如果一共有<span
class="math inline">\(2^n\)</span>个字节，那么地址空间就有n位 </font></p>
<p>Cache需要设置有效位，表明此块是否有效；</p>
<p><font color = "yellow">Cache中设置标记，与主存块号相等，表示存储的主存块</font></p>
<p><strong>假设计算机的主存地址空间大小为256MB,
按字节编址，其数据Cache有8个Cache行，行长为64B。则：</strong></p>
<h3 id="全相联映射">全相联映射</h3>
<p>主存块可以存放在Cache的任何位置。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/673dcfa3edf0a07e7acc1adab4aa3a1.jpg" /></p>
<p><span class="math inline">\(256M = 2^{28}\)</span>，主存地址共 28
位。</p>
<p>Cache 行与主存块大小相等， <span class="math inline">\(64B =
2^6\)</span>，块内地址为 6 位。</p>
<p>主存共有块号为 22 位。</p>
<p>Cache 中有一位有效位，22 位标志位。</p>
<h4 id="访存过程">访存过程</h4>
<ol type="1">
<li>用所要访问的主存地址的前22位，对比Cache中所有块的标记；</li>
<li>若标记匹配且有效位=1，则Cache命中，访问相应块内地址的单元；</li>
<li>若未命中或有效位=0，则正常访问主存</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<ul>
<li>优点
<ul>
<li>Cache存储空间利用充分</li>
<li>命中率高</li>
</ul></li>
<li>缺点
<ul>
<li>查找标记最慢</li>
<li>有可能需要对比所有行的标记</li>
</ul></li>
</ul>
<h3 id="直接映射">直接映射</h3>
<p><a
href="https://www.youtube.com/watch?v=5QMX_ZtKtlI">视频讲解：直接映射</a></p>
<p>每个主存块只能放在特定的位置。</p>
<p>主存块在Cache中的位置=主存块号%Cache总块数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7be6eb0322d5389ab2f0a2accc31b84.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f298566bf606d9940b5490d5a610b98.jpg" /></p>
<ul>
<li>本例中有8个Cache块，对8取余的实质是<strong>取二进制的后三位</strong></li>
<li>Cache的序号即可反映主存块的后三位，因此标记中不再记录后三位，节省空间</li>
<li>主存块号可以依此细分为<strong>19位标记</strong>和<strong>3位行号</strong></li>
</ul>
<h4 id="访存过程-1">访存过程</h4>
<ol type="1">
<li>根据主存块号的后3位确定<strong>Cache行；</strong></li>
<li>若主存块号的前19位与Cache标记匹配，且有效位=1，则Cache命中，访问相应块内地址的单元；</li>
<li>若未命中或有效位=0，则正常访问主存</li>
</ol>
<h4 id="优缺点-1">优缺点</h4>
<ul>
<li>优点
<ul>
<li>对于任意一个地址，只需对比一个标记，速度最快</li>
</ul></li>
<li>缺点
<ul>
<li>Cache存储空间利用不充分</li>
<li>命中率低</li>
</ul></li>
</ul>
<h3 id="组相联映射">组相联映射</h3>
<p><a
href="https://www.youtube.com/watch?v=ntbpYJjlFJs">视频讲解：组相联映射</a></p>
<p>将Cache块分组，每个主存块只能存放到特定的分组中。当分组中有空位时，就将该主存块中的内容存入。</p>
<p>主存块在Cache中的位置=主存块号%Cache分组数主存块在Cache中的位置=主存块号%Cache分组数</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e79b4734e6bd5469453c17e7e2216bf.jpg" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7de5b501309eee16c3a408f215c7eff.png" /></p>
<ul>
<li>本例中分了4组，对4取余实际上是<strong>取二进制的后两位</strong></li>
<li>同理，不记录后两位，节省标志位空间</li>
<li>主存块号可以依此细分为<strong>20位标记</strong>和<strong>2位组号</strong></li>
</ul>
<h4 id="访存过程-2">访存过程</h4>
<ol type="1">
<li>根据主存块号的后2位确定所属分组号</li>
<li>若主存块号的前20 位与分组内的某个标记匹配且有效位=1，
则Cache命中，访问相应块内地址的单元；</li>
<li>若未命中或有效位=0，则正常访问主存</li>
</ol>
<h4 id="优缺点-2">优缺点</h4>
<p>两种方法的折中，效果最好</p>
<h2 id="cache替换算法">Cache替换算法</h2>
<p>Cache不会产生中断！</p>
<p>当Cache中存满时，需要用相应的算法替换掉已有的数据。</p>
<p>根据映射方式不同，存在不同的替换方式。其中<strong>直接映射不需要替换算法</strong>（是一对一的，直接顶替就行）。</p>
<h3 id="随机算法rand">随机算法（RAND）</h3>
<p><a
href="https://www.youtube.com/watch?v=EyBeGGFHHZg">视频讲解：随机算法</a></p>
<p>若Cache已满，则随机选择一块替换。</p>
<ul>
<li>优点
<ul>
<li>实现简单</li>
</ul></li>
<li>缺点
<ul>
<li>没有考虑局部性原理</li>
<li>命中率低</li>
</ul></li>
</ul>
<h3 id="先进先出算法fifo">先进先出算法（FIFO）</h3>
<p><a
href="https://www.youtube.com/watch?v=c7evkkEpOk8">视频讲解：先入先出</a></p>
<p>若Cache已满，则<strong>替换最先被调入Cache的块</strong>。</p>
<p>从硬件层面，可以在将主存块存入Cache块时按照Cache块序号<strong>顺序存入</strong>，则替换时也仅需要顺序替换即可替换最先存入的。</p>
<ul>
<li>优点
<ul>
<li>实现简单</li>
</ul></li>
<li>缺点
<ul>
<li>没有考虑到局部性原理</li>
<li>会出现<strong>抖动现象</strong>（块被频繁的换入换出）</li>
</ul></li>
</ul>
<h3 id="近期最少使用算法lru">近期最少使用算法（LRU）</h3>
<p><a
href="https://www.youtube.com/watch?v=DKAYXU5jA8c">视频讲解：近期最少使用算法</a></p>
<p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没被访问了。当Cache满后<strong>替换计数器最大的</strong>。</p>
<p>从题目的角度，仅需要向前数n个访问的块，则第n+1个块就是要替换的。（n为Cache块数）</p>
<h4 id="算法逻辑">算法逻辑</h4>
<ul>
<li>命中时
<ul>
<li>所命中的行的计数器清零</li>
<li><strong>计数器值比被命中的块的值低的块</strong>，计数器加1</li>
<li>其余不变</li>
</ul></li>
<li>未命中
<ul>
<li>还有空闲行时
<ul>
<li>新装入的行的计数器置0</li>
<li>其余非空闲行全加1</li>
</ul></li>
<li>无空闲行时
<ul>
<li>计数值最大的行的信息块被淘汰</li>
<li>新装行的块的计数器置0</li>
<li>其余全加1</li>
</ul></li>
</ul></li>
</ul>
<p>Cache块数为 <span
class="math inline">\(2^n\)</span>个，则计数器的位数仅需要n位。</p>
<ul>
<li>优点
<ul>
<li>遵循了局部性原理</li>
<li>Cache命中率高</li>
</ul></li>
<li>缺点
<ul>
<li>若被频繁访问的<strong>主存块数量&gt;Cache行的数量</strong>，则有可能发生<strong>抖动</strong></li>
</ul></li>
</ul>
<h3 id="最近不经常使用算法lfu">最近不经常使用算法（LFU）</h3>
<p><a
href="https://www.youtube.com/watch?v=rMpOA2pDXA0">视频讲解：最近不经常使用算法</a></p>
<p>为每一个Cache块设置一个计数器，用于记录<strong>每个Cache块被访问过几次</strong>。</p>
<p>每被访问一次，计数器+1当Cache满后<strong>替换计数器最小的</strong>。</p>
<ul>
<li>缺点
<ul>
<li>计数器可能需要很大的长度</li>
<li>曾经被经常访问的主存块在未来不一定会用到</li>
</ul></li>
</ul>
<p>实际运行时效率不如LRU。</p>
<h2 id="cache写策略">Cache写策略</h2>
<h3 id="写命中时">写命中时</h3>
<p><a
href="https://www.youtube.com/watch?v=PILja_eQkJ8">视频讲解：写命中的两种方法</a></p>
<h4 id="回写法">回写法</h4>
<p>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主
存，只有当此块<strong>被换出时</strong>才写回主存。</p>
<p>对每一个Cache行增加一个<strong>脏位</strong>，标记该行是否被修改过。只有被修改过的块才进行写回操作。</p>
<ul>
<li>优点
<ul>
<li>减少了访存次数</li>
</ul></li>
<li>缺点
<ul>
<li>存在数据不一致的隐患</li>
</ul></li>
</ul>
<h4 id="全写法">全写法</h4>
<p>当CPU对Cache写
命中时，必须把<strong>数据同时写入Cache和主存</strong>，一般使用写缓冲(write
buffer)。</p>
<p>写缓冲通过SRAM来实现。</p>
<ul>
<li>优点
<ul>
<li>能保证数据的一致性</li>
</ul></li>
<li>缺点
<ul>
<li>访存次数增加</li>
<li>速度变慢</li>
<li>当写操作较多时，写缓冲队列会饱和</li>
</ul></li>
</ul>
<h3 id="写不命中">写不命中</h3>
<p><a
href="https://www.youtube.com/watch?v=bwiTnJRmH5c">视频讲解：写不命中的两种处理方法</a></p>
<h4 id="写分配法">写分配法</h4>
<p>当CPU对Cache写不命中时，把主存中的块调入Cache，<strong>在Cache中修改</strong>。</p>
<p>通常<strong>搭配写回法使用</strong>。</p>
<h4 id="非写分配法">非写分配法</h4>
<p>当CPU对Cache写不命中时<strong>只写入主存</strong>，不调入Cache。只有读未命中时才调入Cache。</p>
<p><strong>搭配全写法使用</strong>。</p>
<h3 id="多级cache">多级Cache</h3>
<p>现代计算机采用多级Cache。其中</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/e6ab0457d0c39a7bd02a16e8a6c30ca.png" /></p>
<ul>
<li>越靠近CPU
<ul>
<li>容量越小</li>
<li>速度越快</li>
</ul></li>
<li>越远离CPU
<ul>
<li>容量越大</li>
<li>速度越慢</li>
</ul></li>
</ul>
<p>其中，各级Cache之间一般采用<strong>全写法+非写分配法</strong>传递，而Cache-主存之间<strong>采用写回法+写分配法</strong>。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章总线系统</title>
    <url>/posts/9717b4f8.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.1_进位计数制与相互转换</title>
    <url>/posts/10ea6e78.html</url>
    <content><![CDATA[<h3 id="进位计数法">进位计数法</h3>
<span id="more"></span>
<p><strong>基数</strong>：每个数位所要用到的不同符号的个数（二进制就是2个、8进制就是8个、十进制就是10个...）。</p>
<p>基数越大，<strong>位数</strong>越小，运算情况越多。</p>
<p>位权：依据进制所决定的一个常数（二级制就是2，十进制就是10...）</p>
<p>N位r进制的数所能表示的<strong>数字个数</strong>为：<span
class="math inline">\(r^N\)</span>个</p>
<h3 id="进制转换">进制转换</h3>
<h4 id="一任意进制----十进制">（一）、任意进制 --&gt; 十进制</h4>
<p>用相应位上的数乘以位权即可。</p>
<blockquote>
<p>二进制：101.1 --&gt; <span class="math inline">\(1 \times 2^2 + 0
\times 2^1 + 1 \times 2^0 + 1 \times 2^{-1} = 5.5\)</span></p>
<p>八进制：5.4 --&gt; <span class="math inline">\(5 \times 8^0 + 4
\times 8^{-1} = 5.5\)</span></p>
<p>十六进制：5.8 --&gt; <span class="math inline">\(5 \times 16^0 + 8
\times 16^{-1} = 5.5\)</span></p>
</blockquote>
<h4 id="二十进制----任意进制">（二）、十进制 --&gt; 任意进制</h4>
<p>例：将十进制123.6875转化为二进制</p>
<h4 id="除基取余法整数">除基取余法（整数）</h4>
<p>对整数部分的处理使用短除法，并从下向上，得1111011</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(7).png" /></p>
<h4 id="乘基取整法小数">乘基取整法（小数）</h4>
<p>小数部分采用乘基取整的思路，如下所示：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240415115021673.png" /></p>
<p>一般十进制<strong>无法精确化为</strong>二进制小数，取一定精度即可。</p>
<h4 id="二-2n-进制之间的转换">（二）、 <span
class="math inline">\(2^n\)</span> 进制之间的转换</h4>
<p>每n位一组，进行对应的转换即可。</p>
<p>例1：将3C2.68H转化为二进制</p>
<p>3C2.68H = 1111000010.01101B</p>
<p>例2：将1111000010.01101B转化为八进制</p>
<p>1111000010.01101B = (1702.32)8</p>
<h2 id="bcd码">BCD码</h2>
<p>BCD（Binary-Coded
Decimal），<strong>使用二进制表示的十进制数</strong>。即使用四位二进制数表示一位十进制数，使得十进制与二进制之间的转换得以快速进行。</p>
<h3 id="码">8421码</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">0011</td>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">0110</td>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">1001</td>
</tr>
</tbody>
</table>
<p><font color = "red">使用8421码进行运算时，若结果大于等于10，需要<strong>加6修正</strong>（加0110）</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dece78159862e668a33d5f2fa4d45e7.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="余三码">余三码</h3>
<p>将8421码的每一位加3（即加0011B）得到。</p>
<h3 id="码-1">2421码</h3>
<p>将最高位的权值改为2，特点是大于5的四位二进制码最高位是1，小于5的是0.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">0011</td>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1011</td>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">1101</td>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">1111</td>
</tr>
</tbody>
</table>
<h2 id="字符与字符串">字符与字符串</h2>
<h3 id="ascii码">ASCII码</h3>
<ul>
<li><font color = "red">32~126位称为可印刷字符</font></li>
<li><font color = "red">A-Z，a-z是连续的，但是Z和a之间不连续</font></li>
<li><font color = "red">以字节的形式存储</font></li>
</ul>
<hr style = "border:2px solid yellow">
<blockquote>
<p>例：已知'A'的ASCII码码值是65，H存放在某存储单元M中，求M中存放的值</p>
<p>65+(8-1)=72</p>
<p>72 = 0100 1000</p>
</blockquote>
<hr style = "border:2px solid yellow">
<h3 id="字符串">字符串</h3>
<p>字符串：IF A&gt;B THEN READ(C) ，每个存储单元存放4B</p>
<p><strong>大端模式</strong>：存储单元内<font color = "red"><strong>先存储高位字节</strong>、<strong>后存储低位字节</strong></font>的顺序</p>
<p><strong>大端方式是正常的</strong></p>
<table>
<thead>
<tr class="header">
<th>I</th>
<th>F</th>
<th>空格</th>
<th>A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;</td>
<td>B</td>
<td>空格</td>
<td>T</td>
</tr>
<tr class="even">
<td>H</td>
<td>E</td>
<td>N</td>
<td>空格</td>
</tr>
<tr class="odd">
<td>R</td>
<td>E</td>
<td>A</td>
<td>D</td>
</tr>
<tr class="even">
<td>(</td>
<td>C</td>
<td>)</td>
<td>空格</td>
</tr>
</tbody>
</table>
<p><strong>小端模式</strong>：存储单元内<strong>先存储低位字节</strong>、<strong>后存储高位字节</strong>的顺序</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>空格</th>
<th>F</th>
<th>I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T</td>
<td>空格</td>
<td>B</td>
<td>&gt;</td>
</tr>
<tr class="even">
<td>空格</td>
<td>N</td>
<td>E</td>
<td>H</td>
</tr>
<tr class="odd">
<td>D</td>
<td>A</td>
<td>E</td>
<td>R</td>
</tr>
<tr class="even">
<td>空格</td>
<td>)</td>
<td>C</td>
<td>(</td>
</tr>
</tbody>
</table>
<h3 id="汉字编码">汉字编码</h3>
<p>包括输入的<strong>输入编码</strong>，计算机内部处理的<strong>汉字内码</strong>和输出的<strong>汉字字形码</strong>三种。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image%20(8).png" /></p>
<h2 id="校验码">校验码</h2>
<p><strong>码距</strong>：任意两个合法码字之间不同的二进制的位数。</p>
<ul>
<li>码距大于等于2时，开始具有检错能力</li>
<li>码距越大，纠错、检错能力越强</li>
</ul>
<h3 id="奇偶校验码">奇偶校验码</h3>
<p>添加一个校验位，校验位的取值满足以下规定：</p>
<p>奇校验：这串序列1的个数如果为偶数则在前面加个1，使1的个数变成奇数，否则加0。<font color = "yellow">将1的个数凑成偶数</font></p>
<p>偶校验：这串序列1的个数如果为奇数则在前面加个1，使1的个数变成偶数，否则加0。<font color = "yellow">将1的个数凑成奇数</font></p>
<hr style = "border:2px solid yellow">
<p>举例： 1111 奇校验就是 11111 偶校验就是 01111 1110 奇校验就是 01110
偶校验就是 11110</p>
<p>特性是检测一位错，无法纠错。</p>
<hr style = "border:2px solid yellow">
<h3 id="海明校验码">海明校验码</h3>
<p><a
href="https://www.cnblogs.com/godoforange/p/12003676.html">参考博客</a></p>
<p><a
href="https://www.bilibili.com/video/BV1EJ4m1H7nz/?spm_id_from=333.999.0.0">视频讲解</a></p>
<h3 id="循环冗余校验码">循环冗余校验码</h3>
<p>循环冗余校验码包括K位数据位和R位校验位。</p>
<p>例：已知生成多项式<span class="math inline">\(G(x) = x^3 + x^2 +
1\)</span> ，信息码为101001，求对应的CRC码</p>
<h4
id="确定kr及生成多项式对应的二进制码">确定K、R及生成多项式对应的二进制码</h4>
<p>K = 7</p>
<p>R = 生成多项式的最高次幂 = 3</p>
<p>则，CRC码的位数 = K + R = 10</p>
<p>生成多项式的各次幂的系数就是对应的二进制码：1101（<em>没有x，故第二位为0</em>）</p>
<h4 id="移位">移位</h4>
<p>将信息码<strong>左移R位</strong>，低位补0</p>
<p>101001000</p>
<h4 id="模2相除">模2相除</h4>
<p>将左移后的信息码除以生成多项式的二进制码。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/37b6eeec26fec40b961c6fa1c197585.png" /></p>
<p><font color = "yellow">二进制除法是两两异或，不是相减！</font></p>
<p>最后的<strong>余数</strong>就是校验位</p>
<p>因此，CRC码 = 101001 001</p>
<p><a
href="https://www.bilibili.com/video/BV1G1421d7JA/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解</a></p>
<h4 id="检错">4、检错</h4>
<p>对于CRC码再次用生成多项式的二进制码进行<strong>模2除法</strong>，余数应为000。</p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.2_定点数的表示与运算</title>
    <url>/posts/e06682df.html</url>
    <content><![CDATA[<h2 id="定点数的表示">定点数的表示</h2>
<span id="more"></span>
<h3 id="无符号数和有符号数">无符号数和有符号数</h3>
<h4 id="无符号数"><strong>无符号数</strong>：</h4>
<p>整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的<strong>绝对值</strong>。</p>
<p>n位无符号数的表示范围是<span class="math inline">\(0 \sim2^n -
1\)</span></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/0aebb4140cbbd50e56019031b3e20ce.jpg" style="zoom: 50%;" /></p>
<h4 id="有符号数">有符号数</h4>
<ul>
<li><p><strong>真值</strong>：该数字的实际值，包含正负；</p></li>
<li><p><strong>机器数</strong>：用数字表示正负号的二进制数</p></li>
<li><p><strong>定点小数</strong>：<font color = "red">约定符号位后面就是小数点</font></p>
<ul>
<li>+0.75D = 0.11B</li>
<li>-0.75D =1.11B</li>
</ul></li>
<li><p><strong>定点整数</strong>：<font color = "red">约定小数点在数值的最后</font></p>
<ul>
<li>+3D = 011.B</li>
<li>-3D = 111.B</li>
</ul></li>
<li><p>定点整数和定点小数区别和联系</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3b93aab2a8038ff1a900ffe55c2852a.jpg" style="zoom: 50%;" /></p></li>
</ul>
<h3 id="原码补码反码移码">原码、补码、反码、移码</h3>
<h4 id="原码">原码</h4>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/848000f06f9bab43c0caf5c3442d2f1.jpg" style="zoom: 50%;" /></p>
<h4 id="补码">补码</h4>
<p><font color = "yellow">补码数值位不能解读为位权，而应该先转换为原码</font></p>
<p><font color = "red">补码的-128无法转换成原码</font></p>
<p>求一个数的相反数的补码的另类小技巧</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/fb6ab00f2f1d51ce4ff8cc08d4ccb56.jpg" /></p>
<p>关于补码正儿八经的解释</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240617112232369.png" /></p>
<p>整数方面，负数的补码的求法就是用二进制上比当前数二进制多1位，多出来的高位是1减去当前数的绝对值</p>
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/062bf6cf27f1979dcfdd84479aae9a2.jpg" style="zoom:50%;" /></p>
<h4 id="不同码之间相互转换">不同码之间相互转换</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421190235043.png" /></p>
<h2 id="定点数的运算">定点数的运算</h2>
<h3 id="定点数的移位运算">定点数的移位运算</h3>
<h4 id="算术移位">算术移位</h4>
<h5 id="原码-1">原码</h5>
<p><a
href="https://www.bilibili.com/video/BV1ju4m1F7LR/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">原码视频讲解</a></p>
<p>符号位保持不变，仅对数值位进行移位。</p>
<p>右移:高位补0，低位舍弃。若舍弃的位=0，则相当于-2;若舍弃的位0，则会丢失精度</p>
<p>左移:低位补0，高位舍弃。若舍弃的位=0，则相当于x2:若舍弃的位0，则会出现严重误差</p>
<p><a
href="https://www.bilibili.com/video/BV13J4m1H7JZ/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解为什么右移能实现除以2</a></p>
<h5 id="反码">反码</h5>
<p><font color = "yellow">正数与原码相同，负数补1</font></p>
<hr style = "border:2px solid yellow">
<p>举例： <img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421205101972.png" /></p>
<hr style = "border:2px solid yellow">
<h5 id="补码-1">补码</h5>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421212010461.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1GF4m1P7NR/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">补码的左右移视频讲解</a></p>
<p><font color = "yellow">正数与原码相同</font></p>
<p><font color = "yellow">负数右移，高位出现空位，高位与反码相同，所以补1</font></p>
<p><font color = "yellow">负数左移，低位出现空位，低位与原码相同，所以补0</font></p>
<h5
id="不同码算术移位的一个总结重要">不同码算术移位的一个总结（重要！！！）</h5>
<p><font color = "yellow">1. 如果是正数，无论什么码都补0</font></p>
<p><font color = "yellow">2.
如果是负数，原码都补0，与之相对的反码都补1，补码左移补0，右移补1</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240421210532352.png" /></p>
<p><a href="">视频讲解：如何通过移位实现乘法</a></p>
<h4 id="逻辑移位">逻辑移位</h4>
<p><font color = "red">都补0，区别算术移位和逻辑移位的理解，算术运算比逻辑运算复杂</font></p>
<p><a
href="https://www.bilibili.com/video/BV1tE421M7ff/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：逻辑移位在RGB颜色表示中的应用</a></p>
<h4 id="循环移位">循环移位</h4>
<p><a
href="https://www.bilibili.com/video/BV1hz421k7o6/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：循环移位</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/f4f2c08cbf25c629cf98b343c2420b9.png" /></p>
<h3 id="加减法">加减法</h3>
<p><font color  = "yellow">全部转换得到补码后相加，其中减法就是转换成相反数的的补码后再相加</font>（无论有符号数还是无符号数，都转成补码）</p>
<hr style = "border:2px solid yellow">
<p>举例：
<img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/1210195b519767f284585841a64be1c.jpg" style="zoom: 33%;" /></p>
<hr style = "border:2px solid yellow">
<h3 id="溢出的概念和判断方式">溢出的概念和判断方式</h3>
<ul>
<li>大于机器所能表示的最大正数称为<strong>上溢</strong>；</li>
<li>小于机器所能表示的最小负数称为<strong>下溢</strong>。</li>
<li>当两个符号<strong>相同</strong>的数<strong>相加</strong>或者两个符号<strong>相异</strong>的数<strong>相减</strong>时才会发生溢出。</li>
</ul>
<p>对溢出的判断有几种方式：</p>
<h4 id="采用一位符号位">采用一位符号位</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423055959832.png" /></p>
<h4
id="采用一位符号位根据数据位进位情况判断溢出">采用一位符号位根据数据位进位情况判断溢出</h4>
<p>即“模2补码”。</p>
<p>设符号位的进位 CS，最高数位的进位 C1，则当 CS 和 C1
不同时发生溢出。</p>
<h4 id="采用双符号位">采用双符号位</h4>
<p>即“模4补码”。</p>
<p>正数符号位为00，负数符号位为11。</p>
<p>记两个符号位分别为 S1 和 S2，则 V = S1 ⊕
S2，若V=0，无溢出；V=1，有溢出。</p>
<p>00：正数无溢出</p>
<p>01：正数有溢出</p>
<p>11：负数无溢出</p>
<p>10：负数有溢出</p>
<p>模4补码存储时仍然为一个符号位，因为正确的表示两位符号位必然是相同的</p>
<p>当送入ALU时，才将原来的符号位同时送入ALU的双符号位中</p>
<h3 id="定点数的乘法运算">定点数的乘法运算</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/c5e7a3ddf5eee94a722539bd7a34175.png" /></p>
<h4 id="原码一位乘法">原码一位乘法</h4>
<p><font color = "red">被乘数带符号位运算，乘数不需要</font></p>
<p><font color = "red">移位需要移动乘数的有效位数，最后以移位结束，将乘数全部移除</font></p>
<ul>
<li>符号位单独处理：乘数与被乘数异或</li>
<li>绝对值相乘
<ul>
<li>ACC存放乘积高位，MQ存放乘数、乘积低位，X存放被乘数</li>
<li>每次看MQ中最低位
<ul>
<li>为1，ACC加上被乘数</li>
<li>为0，ACC加上0</li>
</ul></li>
<li>每次运算后右移一位，高位补0</li>
<li>直到MQ仅剩原符号位，舍去不参与运算</li>
</ul></li>
<li>小数点位于ACC第一位（乘积符号位）后</li>
</ul>
<p><a
href="https://www.bilibili.com/video/BV1qE421K7BK/?spm_id_from=333.999.0.0">视频讲解：计算机原码一位乘法原理</a></p>
<p><a
href="https://www.bilibili.com/video/BV1Xz421679q/?spm_id_from=333.999.0.0">视频讲解：实操手工模拟计算机原码一位乘法运算</a></p>
<h4 id="补码一位乘法">补码一位乘法</h4>
<p><a
href="https://www.youtube.com/watch?v=SAFbPZ4H2dQ">视频讲解：计算机补码一位乘法原理</a></p>
<p>乘数增加了一个辅助位，原来表示数值的有n位，表示符号的有1位，现在增加了一个辅助位，变成n+2位。</p>
<p>被乘数和存储结果的也增加1位，所以用双符号位</p>
<p><font color = "red">1. 双符号位</font></p>
<p><font color = "red">2. 算术右移</font></p>
<p><font color = "red">3. 三种选择</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423233748320.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1sb421Y7Lw/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：实操手工模拟计算机补码一位乘法运算</a></p>
<h3 id="定点数除法运算">定点数除法运算</h3>
<h4 id="原码恢复余数法">原码恢复余数法</h4>
<p><a
href="https://www.youtube.com/watch?v=d3lWTapHFs4">视频讲解：原码恢复余数法</a></p>
<p><a
href="https://www.bilibili.com/video/BV1am421s74C/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：手工模拟原码恢复余数法</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423160942750.png" /></p>
<h4 id="原码加减交替法">原码加减交替法</h4>
<p><a
href="https://www.youtube.com/watch?v=5Hp2ZDtt-xs">视频讲解：理论讲解原码加减交替法</a></p>
<p><a
href="https://www.bilibili.com/video/BV1fZ421J7Sc/?spm_id_from=333.999.0.0">视频讲解：手工模拟原码加减交替法</a></p>
<p><font color = "red">原码除法两种方法在处理商1发现余数是0时采取操作的比较：</font></p>
<p><font color = "yellow">恢复余数法:当余数为负时商0，并+|除数|（为了恢复余数）再左移，再-|除数|，才能得到新余数和对应的商</font></p>
<p><font color = "yellow">加减交替法:当余数为负时商0，并左移，再+|除数|，就能得到新余数和对应的商</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240424173514275.png" /></p>
<h4 id="补码加减交替法">补码加减交替法</h4>
<p><a
href="https://www.youtube.com/watch?v=3fkI5H_MPN4">视频讲解</a></p>
<ol type="1">
<li>符号位参与运算</li>
<li>被除数/余数、除数采用双符号位</li>
<li>被除数和除数同号，则被除数减去除数;异号则被除数加上除数。</li>
<li>余数和除数同号，商1，余数左移一位减去除数;余数和除数异号，商0，余数左移一位加上除数。重复n次</li>
<li>商末尾恒为1</li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240428205123547.png" /></p>
<h2 id="整数型及类型转换">整数型及类型转换</h2>
<ul>
<li><p>长整数变为短整数：0x000286a1 --&gt; 0x86a1（截断高位）</p></li>
<li><p>短整数变为长整数：<strong>符号扩展</strong></p></li>
<li><p>有符号数变为无符号数：0xef1f（真值-3421） --&gt;
0xef1f（真值61215）<font color = "red">不改变数据内容，改变解释方式</font></p></li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.3_浮点数的表示和运算</title>
    <url>/posts/9b0b5055.html</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<span id="more"></span>
<h3 id="大端存储与小端存储">大端存储与小端存储</h3>
<p>实际有效字节</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240617104526525.png" /></p>
<p>大端存储</p>
<p>低地址存储最高有效字节，高地址存储最低有效字节</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240617104407487.png" /></p>
<p>小端存储</p>
<p>与大端相反，方便机器是因为机器从低往高读</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240617104512732.png" /></p>
<p><a
href="https://www.bilibili.com/video/BV1xC4113747/?spm_id_from=333.999.0.0">视频讲解：大端与小端</a></p>
<h3 id="边界对齐">边界对齐</h3>
<p><a
href="https://www.bilibili.com/video/BV1rF4m1P7mM/?spm_id_from=333.999.0.0">视频讲解：边界对齐</a></p>
<p>如何将字地址转换成与之对应的字节地址</p>
<p><font color = "yellow">已知字编号，对应的字节编号就是自编号逻辑左移2位</font></p>
<p><font color = 'yellow'>已知半字编号，对应的字节编号就是半字编号逻辑左移1位</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/5b5e6e4dc2fdfeefde9626c6676916b.jpg" /></p>
<h2 id="浮点数的表示">浮点数的表示</h2>
<h3 id="浮点数的表示-1">浮点数的表示</h3>
<p><a
href="https://www.bilibili.com/video/BV1st421j7RQ/?spm_id_from=333.999.0.0">视频讲解：浮点数表示</a></p>
<p>浮点数通常表示为：</p>
<p>$ N = r^E * M$</p>
<ul>
<li>r：阶码的底，通常为2</li>
<li>E：<strong>阶码</strong>，反映浮点数的表示范围和小数点的实际位置，用<strong>补码或移码</strong>表示</li>
<li>M：<strong>尾数</strong>，其位数反映了小数的精度，用<strong>原码或补码</strong>表示</li>
</ul>
<blockquote>
<p>例：阶码和尾数都用补码表示，求a、b的真值</p>
<ul>
<li>a = 0,01; 1.1001</li>
<li>b = 0,01; 0.01001</li>
</ul>
<p>a：</p>
<ul>
<li>阶码0,01对应真值+1</li>
<li>尾数1.1001(补码)对应真值(先转换成原码)-0.0111</li>
<li>故 a=-0.111(B)(上面二进制小数点右移1位) = <span
class="math inline">\(-\frac{7}{8}\)</span></li>
</ul>
<p>b：</p>
<ul>
<li>阶码对应真值+1</li>
<li>尾数0.01001对应真值+0.01001</li>
<li>故 b=0.1001=<span class="math inline">\(\frac{9}{16}\)</span></li>
</ul>
</blockquote>
<h3 id="浮点数的规格化">浮点数的规格化</h3>
<p><a
href="https://www.bilibili.com/video/BV11u4m1F7gQ/?spm_id_from=333.999.0.0">视频讲解：浮点数规格化</a></p>
<h4 id="规格化的种类">规格化的种类</h4>
<h5 id="左规">左规</h5>
<p>当浮点数运算的结果为非规格化时要进行规格化处理，将<font color = "red">尾数左移一位，阶码减1
( 基数为2时)</font>：</p>
<p>规定尾数的最高位必须是一个有效值。<font color = "yellow">个人理解，浮点数尾数还是定点小数，表示成0.*******（正数)或者1.******(表示负数)，所以符号位后，小数点下一位，也就是第二位不能是0</font></p>
<hr style = "border:2px solid yellow">
<p>举例：
<img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/06fd8146622a1827a81f5e657cea78f.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<h5 id="右规">右规</h5>
<p>当浮点数运算的结果尾数出现溢出(双符号位为01或10)时，将<font color = "red">尾数右移一位，阶码加1
(基数为2时)</font></p>
<blockquote>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422070143607.png" /></p>
</blockquote>
<h4 id="规格化数的特点">规格化数的特点</h4>
<h5 id="如何判断需要规格化">如何判断需要规格化</h5>
<p><font color = "yellow">1.
无论正数负数，原码尾数最高位(就是符号位下一位)必须是1</font></p>
<p><font color = "yellow">2.
补码尾数最高位（就是符号位下一位）必须和尾数符号相反，比如正数就是1，负数就是0</font></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/de3c63bb5369dbe0536bb24b31f925d.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<h5 id="规格化的小数所能表示范围">规格化的小数所能表示范围</h5>
<p>原码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074440544.png" /></p>
<p>补码</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074452583.png" /></p>
<p>上溢和下溢</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422074712134.png" /></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/92426731dcfb987b1187617cd2ad0c2.jpg" /></p>
<hr style = "border:2px solid yellow">
<h3 id="ieee754-标准">IEEE754 标准</h3>
<h4 id="移码的求法">移码的求法</h4>
<p><font color = "yellow">移码的求法：移码 = 真值 + 偏置值 </font></p>
<p>偏置值常见两种取法，一种取常数 <span class="math inline">\(2^{n -
1}\)</span>，等价于符号位取反</p>
<p>另一种是<span class="math inline">\(2^{n - 1} -
1，等价于加01111111（一个0和7个1）\)</span></p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240422083436691.png" /></p>
<hr style = "border:2px solid yellow">
<blockquote>
<p>注：<font color = "red">移码只能表示整数，不能表示小数，所以移码用来表示阶码，因为阶码一定是整数</font></p>
</blockquote>
<h4 id="ieee754标准下的浮点数表示">IEEE754标准下的浮点数表示</h4>
<p><a
href="https://www.bilibili.com/video/BV1Zm421x7UD/?spm_id_from=333.999.0.0">视频讲解：IEEE754标准下的移码</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423071008688.png" /></p>
<p>尾数前隐含一位1</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">数阶</th>
<th style="text-align: center;">阶码</th>
<th style="text-align: center;">尾数数值</th>
<th style="text-align: center;">总位数</th>
<th style="text-align: center;">偏置值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">短浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">7FH（127）</td>
</tr>
<tr class="even">
<td style="text-align: center;">长浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">3FFH（1023）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">临时浮点数</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">3FFFH</td>
</tr>
</tbody>
</table>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240423065106995.png" /></p>
<p>对于短浮点数而言，<strong>偏置值取127</strong>，此时阶码（移码）的表示范围为<strong>-126~127</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">真值</th>
<th style="text-align: center;">补码</th>
<th style="text-align: center;">移码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">-128</td>
<td style="text-align: center;">1000 0000</td>
<td style="text-align: center;">1111 1111</td>
</tr>
<tr class="even">
<td style="text-align: center;">-127</td>
<td style="text-align: center;">1000 0001</td>
<td style="text-align: center;">0000 0000</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-126</td>
<td style="text-align: center;">1000 0010</td>
<td style="text-align: center;">0000 0001</td>
</tr>
<tr class="even">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0000 0000</td>
<td style="text-align: center;">0111 1111</td>
</tr>
<tr class="even">
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
<td style="text-align: center;">……</td>
</tr>
<tr class="odd">
<td style="text-align: center;">127</td>
<td style="text-align: center;">0111 1111</td>
<td style="text-align: center;">1111 1110</td>
</tr>
</tbody>
</table>
<p>-128和-127的作用：</p>
<p>E=0且 M=0，则真值为0；</p>
<p>E=0且 E≠0 M≠0，为非规格化数，真值 = (-1)^S ×0.M×2^(-126)；</p>
<p>E=255且 E≠0 M≠0，真值为‘NaN’（非数值）；</p>
<p>E=255且 E=0 M=0，真值为正或负无穷。</p>
<hr style = "border:2px solid yellow">
<p>例1：十进制小数转单精度浮点数</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/af766190e0070c5504a7528d5b4c821.jpg" style="zoom:50%;" /></p>
<p>例2：单精度浮点数转十进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/60fc6faf0ce444809c6004dab570fc8.jpg" style="zoom:50%;" /></p>
<hr style = "border:2px solid yellow">
<h2 id="浮点数的运算">浮点数的运算</h2>
<p><a
href="https://www.youtube.com/watch?v=McazQToNWYs">视频讲解</a></p>
<h3 id="加减运算">加减运算</h3>
<p><strong>步骤</strong>：</p>
<ol type="1">
<li><p>对阶</p></li>
<li><p>尾数加减</p></li>
<li><p>规格化</p></li>
<li><p>舍入</p></li>
<li><p>判溢出</p></li>
</ol>
<blockquote>
<p>已知十进制数： <span class="math inline">\(X =
-\frac{5}{256}\)</span> <span class="math inline">\(Y =
+\frac{59}{1024}\)</span></p>
<p>按机器补码浮点运算规则计算 ( X - Y
)，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。
例子中的浮点数计算过程如下：</p>
<ol type="1">
<li>计算X和Y的浮点表示：</li>
</ol>
<p>X: 阶码: -101（补码为：1011，阶符取两位、阶码取三位：11011） 尾数:
-0.101（补码为1.011，数符取两位、尾数取九位：11.011000000）</p>
<p>Y: 阶码: -100（补码为1100，阶符取两位、阶码取三位：11100） 尾数:
+0.111011（补码为0.111011，数符取两位、尾数取九位：00.111011000）</p>
<ol start="2" type="1">
<li><p>对阶： 计算阶码差：ΔE = 11011 - 11100 = 11011 + 00100 = 11111
（11111为-1的补码） 所以 ΔE = -1 ，X的阶码比Y的阶码小1
阶码每加1，尾数右移一位，则有新的X：11100；11.101100000（右移之后前面补1）</p></li>
<li><p>尾数相加减： -Y: 11100；11.000101000
尾数相加，得：10.110001000</p></li>
<li><p>规格化：
尾数右移一位，阶码加1，得：X-Y=11101；11.011000100</p></li>
<li><p>舍入： 由于无舍入，不需要进行舍入操作。</p></li>
<li><p>判断溢出： 未发生溢出</p></li>
</ol>
<p>因此，结果真值为 <span class="math inline">\(2^{-3} \times
(-0.1001111)_2\)</span>。</p>
</blockquote>
<p><a
href="https://www.youtube.com/watch?v=McazQToNWYs">视频讲解</a></p>
<h3 id="强制类型转换">强制类型转换</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">16位机器</th>
<th style="text-align: center;">32位机器</th>
<th style="text-align: center;">64位机器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">char</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;">short</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="even">
<td style="text-align: center;">long</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">64</td>
</tr>
<tr class="odd">
<td style="text-align: center;">long long</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
</tr>
<tr class="even">
<td style="text-align: center;">float</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="odd">
<td style="text-align: center;">double</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">64</td>
</tr>
</tbody>
</table>
<p>char --&gt; int --&gt; long --&gt; double 以及 float --&gt;
double，不会损失精度。</p>
<p>对于32位系统：</p>
<ul>
<li><p>整数类型（int）表示整数，范围为 <span
class="math inline">\(-2^{31} \sim
2^{31}-1\)</span>，有效数字32位。</p></li>
<li><p>浮点数类型（float）表示整数及小数，范围为 <span
class="math inline">\(\pm [2^{-126} \sim 2^{127} \times
(2^{-2^{-23}})]\)</span>，有效数字为23位尾数加1位整数部分，共24位。</p></li>
</ul>
<p>在进行类型转换时：</p>
<ul>
<li><p><strong>int --&gt;
float</strong>：可能会损失精度，因为float类型的有效数字比int类型多。</p></li>
<li><p><strong>float --&gt;
int</strong>：可能会溢出（超出int表示范围），同时可能损失精度（小数部分被舍弃）。</p></li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>2.4_算数逻辑单元（ALU）</title>
    <url>/posts/cef77967.html</url>
    <content><![CDATA[<h1 id="算数逻辑单元alu">算数逻辑单元（ALU）</h1>
<span id="more"></span>
<p><a
href="https://www.bilibili.com/video/BV1pD421H7mr/?spm_id_from=333.999.0.0">视频讲解：ALU简单介绍</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7843cf0508bb476543d2c1c547f52cd.png" /></p>
<h2 id="串行加法器和并行加法器">串行加法器和并行加法器</h2>
<h3 id="一位全加器">一位全加器</h3>
<p><a
href="https://www.bilibili.com/video/BV1DE421L729/?spm_id_from=333.999.0.0">视频讲解：对于一位全加器的基本介绍</a></p>
<h3 id="并行加法器">并行加法器</h3>
<h4 id="串行进位的并行加法器">串行进位的并行加法器</h4>
<p>把n个全加器串接起来，就可进行两个n位数的相加。</p>
<h4 id="并行进位的并行加法器">并行进位的并行加法器</h4>
<p><a
href="https://www.bilibili.com/video/BV1uT421C7FB/?spm_id_from=333.999.0.0&amp;vd_source=a46136aa644c81e751b3b0cc0e17dbe1">视频讲解：并行进位的并行加法器的简单介绍</a></p>
<h2 id="补码加减法运算器">补码加/减法运算器</h2>
<h3 id="加法器原理">加法器原理</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/2495851f0916f05bab3abe06c9c3d2c.png" /></p>
<p>例1：A=1000，B=0111，Cin=0</p>
<p>则：F=1111，Cout=0</p>
<p>例2：A=1000，B=0111，Cin=1</p>
<p>则：F=0000，Cout=1</p>
<h3 id="补码加减器">补码加减器</h3>
<p><a
href="https://www.bilibili.com/video/BV1mm41127Qw/?spm_id_from=333.999.0.0">视频讲解：补码加减器的设计</a></p>
<p><strong>补码加减法原理</strong>：</p>
<p>X+Y：直接按位相加</p>
<p>X-Y：</p>
<ol type="1">
<li><p>Y全部按位取反，末位+1</p></li>
<li><p>减法变加法</p></li>
</ol>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/7af15bf708439501c0acf81000143b8.png" /></p>
<p><strong>Sub信号的作用</strong></p>
<ul>
<li><p>控制多路选择器的输出</p></li>
<li><p>若计算减法时，1同时输入到Cin，用作补码取反后的+1</p></li>
</ul>
<blockquote>
<p>例：4bit补码，X=-8，Y=7</p>
<p><span class="math inline">\(\text{X}*{补} = 1000\)</span>，<span
class="math inline">\(\text{Y}*{补} = 0111\)</span></p>
<p>X+Y：直接输出：1111B（补）=-1D</p>
<p>X-Y：1000+（1000+1）=0001B（补）（产生溢出）</p>
</blockquote>
<p><strong>这一电路同样适用于无符号数的加减法</strong>，原理完全一致，<font color = "red">但是判断溢出标准不同</font></p>
<p><font color = "yellow">计算机中是不会判断什么有符号无符号数，它设计出的硬件都是按0/1做运算，是人都结果做出了不同的解释</font></p>
<h2 id="标志位">标志位</h2>
<h3 id="有符号数">有符号数</h3>
<h4 id="of溢出标志位">OF：溢出标志位</h4>
<ul>
<li><p>最高位产生的进位与次高位产生的进位异或</p></li>
<li><p><strong>判断有符号数的溢出</strong>，<font color = "yellow">对无符号数没有意义</font></p></li>
</ul>
<h4 id="sf符号标志位">SF：符号标志位</h4>
<ul>
<li>取运算结果的最高位</li>
</ul>
<blockquote>
<p>例：4bit补码，X=-8，Y=7</p>
<p>X补=1000，Y补=0111</p>
<p>X+Y</p>
<p>直接输出：1111B（补）=-1D</p>
<p>OF=0 ⊕ 0=0：没有溢出</p>
<p>SF=1：结果是负数</p>
<p>X-Y</p>
<p>1000+(1000+1)=0001B</p>
<p>OF=1 ⊕ 0=1：产生了溢出</p>
<p>SF=0：结果是正数</p>
</blockquote>
<h3 id="无符号数">无符号数</h3>
<h4 id="zf零标志位">ZF：零标志位</h4>
<ul>
<li>运算结果全部为零</li>
</ul>
<h4 id="cf进位标志">CF：进位标志</h4>
<ul>
<li><p>最高位的进位信号与sub进行异或</p></li>
<li><p>为1代表发生了借位，产生溢出</p></li>
<li><p><strong>判断无符号数的溢出</strong></p></li>
</ul>
<blockquote>
<p>例：4bit原码，无符号数X=3，Y=4</p>
<p>X=0011B，Y=0100B</p>
<p>X+Y</p>
<p>直接输出：0111B（原）=7D</p>
<p>ZF：0</p>
<p>CF：0 ⊕ 0=0</p>
<p>X-Y</p>
<p>0011+(1011+1)=1111B（原）</p>
<p>ZF：0</p>
<p>CF：0 ⊕ 1=1（产生了借位溢出）</p>
</blockquote>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>4.1_指令格式</title>
    <url>/posts/48ef267a.html</url>
    <content><![CDATA[<p>指令是指示计算机执行某种操作的命令，
是计算机运行的<strong>最小功能单位</strong>。</p>
<p>一台计算机的所有指令的集合构成该机的指令系统，也称为<strong>指令集</strong>。</p>
<h2 id="指令的基本格式">指令的基本格式</h2>
<span id="more"></span>
<p>指令是一段有意义的二进制码，包括两个部分：操作码字段和地址码字段。</p>
<p><strong>操作码</strong>：指令要进行什么操作，具有何种功能</p>
<p><strong>地址码</strong>：被操作信息的地址</p>
<h3 id="按照地址码数量分类">按照地址码数量分类</h3>
<h4 id="零地址指令">零地址指令</h4>
<p><a
href="https://www.youtube.com/watch?v=sABYjdij14Q">视频讲解：零地址指令</a></p>
<ul>
<li>不需要操作数，如空操作、停机、关中断等指令</li>
<li>堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶</li>
</ul>
<h4 id="一地址指令">一地址指令</h4>
<p><a
href="https://www.youtube.com/watch?v=FwXUCOTrYjc">视频讲解：一地址指令</a></p>
<ul>
<li>只需要单操作数，如加1、减1、取反、求补等</li>
</ul>
<p>指令含义：<span class="math inline">\(\text{OP}(A_1) \rightarrow
A_1\)</span></p>
<p>完成一 条指令需要<strong>3次访存</strong>：取指→读A1→写A1</p>
<ul>
<li>需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）</li>
</ul>
<p>指令含义：<span class="math inline">\((\text{ACC}) \text{OP}(A_1)
\rightarrow \text{ACC}\)</span></p>
<p>完成一条指令需要<strong>2次访存</strong>：取指→读A1</p>
<blockquote>
<p>A1指某个主存地址</p>
<p>(A1)表示A1所指向的地址中的内容</p>
</blockquote>
<h4 id="二地址指令">二地址指令</h4>
<p>需要两个操作数的算术运算、逻辑运算相关指令</p>
<p>指令含义：<span class="math inline">\((A_1) \, \text{OP} \, (A_2)
\rightarrow A_1\)</span></p>
<p>完成一条指令需要<strong>访存4次</strong>：取指→读A1→读A2→写A1</p>
<h4 id="三地址指令">三地址指令</h4>
<p>需要两个操作数的算术运算、逻辑运算相关指令</p>
<p>指令含义：[ (A_1) , , (A_2) A_3 ]</p>
<p>完成一条指令需要<strong>访存4次</strong>：取指→读A1→读A2→写A3</p>
<p><a
href="https://www.youtube.com/watch?v=c3XrGulTgQE">视频讲解：二、三地址指令</a></p>
<h4 id="四地址指令">四地址指令</h4>
<p><a
href="https://www.youtube.com/watch?v=qHZHBvw4NZ8">视频讲解：四地址指令</a></p>
<p>与三地址指令相同，A4中存放下一条要执行的指令的地址。</p>
<blockquote>
<p>一般来说，程序执行完毕后，会将PC（程序计数器）+1</p>
<p>而四地址指令会将PC的值置为A4</p>
</blockquote>
<h3 id="按照指令长度分类">按照指令长度分类</h3>
<p><strong>指令字长</strong>：一条指令的总长度（可能会变）</p>
<p><strong>机器字长</strong>：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）</p>
<p><strong>存储字长</strong>：一个存储单元中的二进制代码位数（通常和MDR位数相同）</p>
<p><strong>半字长指令、单字长指令、双字长指令</strong>：指令长度是机器字长的多少倍。指令长度影响取指令的时间。</p>
<p><strong>定长指令字结构</strong>：指令系统中<strong>所有指令的长度都相等</strong></p>
<p><strong>变长指令字结构</strong>：指令系统中各种<strong>指令的长度不等</strong></p>
<h3 id="按照操作码长度分类">按照操作码长度分类</h3>
<p><strong>定长操作码</strong>：指令系统中所有指令的<strong>操作码长度都相同</strong></p>
<ul>
<li>译码电路设计简单</li>
<li>灵活性较差</li>
</ul>
<p><strong>可变长操作码</strong>：指令系统中各指令的<strong>操作码长度可变</strong></p>
<ul>
<li>译码电路设计复杂</li>
<li>灵活性高</li>
</ul>
<h3 id="按照操作类型分类">按照操作类型分类</h3>
<h4 id="数据传送类">数据传送类</h4>
<p>进行主存与CPU之间的数据传送</p>
<ul>
<li>LOAD：把存储器（源）中的数据放到寄存器（目标）中</li>
<li>STORE：把寄存器（源）中的数据放到存储器（目标）中</li>
</ul>
<h4 id="运算类">运算类</h4>
<ul>
<li>算数逻辑运算
<ul>
<li>算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算</li>
<li>逻辑：与、或、非、异或、位操作、位测试、位清除、位求反</li>
</ul></li>
<li>移位操作
<ul>
<li>算术移位、逻辑移位、循环移位（带进位和不带进位）</li>
</ul></li>
</ul>
<h4 id="程序控制类">程序控制类</h4>
<p>改变程序执行的顺序</p>
<ul>
<li>无条件转移：JMP</li>
<li>条件转移
<ul>
<li>JZ：结果为0</li>
<li>JO：结果溢出</li>
<li>JC：结果有进位</li>
</ul></li>
<li>调用和返回：CALL和RETURN</li>
<li>陷阱(Trap)与陷阱指令</li>
</ul>
<h4 id="输入输出操作">输入输出操作</h4>
<p>CPU寄存器与I/O端口之间的数据传送（端口即I/O接口中的寄存器）</p>
<h2 id="扩展操作码指令格式">扩展操作码指令格式</h2>
<p><a
href="https://www.youtube.com/watch?v=pzdWC4RSEYY">视频讲解：扩展操作码理论</a></p>
<p>扩展操作码指令格式采用<strong>定长指令字结构</strong>+<strong>可变长操作码结构</strong></p>
<p>n位操作码代表指令系统最大能够表达<span
class="math inline">\(2^n\)</span>条指令</p>
<h3 id="扩展操作码举例">扩展操作码举例</h3>
<p><a
href="https://www.youtube.com/watch?v=VwFrOmt3N24">视频讲解：扩展操作码设计举例</a></p>
<p>设指令字长为16位，每个地址码占4位</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/3405c076fc8e0b7096565b62224f5a1.png" /></p>
<ul>
<li>用全部为1标识地址数量，因此实际可用指令数量为<span
class="math inline">\(2^n - 1\)</span></li>
<li>地址长度为n，上一层留下m种状态，则协议层可以扩展出<span
class="math inline">\(m \times 2 ^ n\)</span>种状态</li>
</ul>
<p>例：指令字长为16位，设计一套有15条三地址指令、12条二地址指令、62条一地址指令、32条零地址指令的指令系统。</p>
<ul>
<li>地址长度：16bit/4=4bit</li>
<li>三地址指令
<ul>
<li>16-3*4 = 4bit 操作码</li>
<li>24−15=124−15=1，剩余1111</li>
</ul></li>
<li>二地址指令
<ul>
<li>头部必须为1111，16 - 4 - 2*4 = 4bit</li>
<li>24−12=424−12=4，剩余1100、1101、1110、1111，头两位全部为11</li>
</ul></li>
<li>一地址指令
<ul>
<li>头部必须为1111 11，16 - 6 - 4 = 6bit</li>
<li>26−62=126−62=1，剩余111110</li>
</ul></li>
<li>零地址指令
<ul>
<li>头部必须为1111 1111 111，16 - 11 = 5bit</li>
<li>25−32=025−32=0，分配完毕</li>
</ul></li>
<li>优点
<ul>
<li>在指令字长有限的情况下保证了比较丰富的指令种类</li>
</ul></li>
<li>缺点
<ul>
<li>增加了指令译码和分析的难度</li>
<li>使控制器设计复杂</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>4.2_指令的寻址方式</title>
    <url>/posts/3fba63fc.html</url>
    <content><![CDATA[<h2 id="指令寻址">指令寻址</h2>
<span id="more"></span>
<p>通过程序计数器（PC）来给出下一条要执行的指令的地址。</p>
<h3 id="顺序寻址">顺序寻址</h3>
<p>(PC)+"1"→PC</p>
<p>这里的+1并不是直接+1，而是<strong>取决于指令字长与存储字长</strong>。</p>
<p>例如：系统采用定长指令字结构，指令字长=存储字长=2B，主存按照字节（1B）编址，则实际上PC每次是+2</p>
<p>而若采用不定长指令字结构，则每次加的值取决于正在执行的指令的长度。</p>
<p><a
href="https://www.youtube.com/watch?v=NeZi9Nh5fVw">视频讲解：非定长顺序寻址</a></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240514153153240.png" /></p>
<h3 id="跳跃寻址">跳跃寻址</h3>
<p>即通过转移指令JMP直接修改PC的值，跳转到相应的指令。</p>
<h2 id="数据寻址">数据寻址</h2>
<h3 id="立即寻址">立即寻址</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240514161812377.png" /></p>
<p>指令中存放的不是地址，而是<strong>直接存放的操作数</strong>。</p>
<p>一般寻址特征表现为“#”，相应的操作数又被称为<strong>立即数</strong>，一般用补码表示。</p>
<ul>
<li>优点
<ul>
<li>仅需要一次访存</li>
<li>执行速度最快</li>
</ul></li>
<li>缺点
<ul>
<li>地址码的位数限制了立即数的范围</li>
</ul></li>
</ul>
<h3 id="直接寻址">直接寻址</h3>
<h4 id="存储器直接寻址">存储器直接寻址</h4>
<p><font color = "yellow"> 内存里面放的是地址，通过这个地址找到目标数据
S = (D)</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605103458605.png" /></p>
<h4 id="寄存器直接寻址">寄存器直接寻址</h4>
<p><font color = "yellow">寄存器里面是地址，通过这个地址找到目标数据, S
= (R)</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/dacfa71c700c07f0b6d6076ca20d387.png" /></p>
<h3 id="间接寻址">间接寻址</h3>
<h4 id="存储器间接寻址">存储器间接寻址</h4>
<p><font color = "yellow">内存里面放的是目的数据地址的地址，通过这个地址找到目的数据的地址，再通过目的数据的地址找到目的数据，S
= ((D))</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605103646529.png" /></p>
<h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p><font color = "yellow">寄存器里面放的是目的数据地址的地址，通过这个地址找到目的数据的地址，再通过目的数据的地址找到目的数据，S
= ((R))</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104111587.png" /></p>
<h4 id="堆栈寻址">堆栈寻址</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104128026.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104147513.png" /></p>
<h3 id="变址基址寻址及其变化">变址、基址寻址及其变化</h3>
<h4 id="变址寻址">变址寻址</h4>
<p><font color = "yellow">变址寻址中内存中是基准地址(不变量)，寄存器中是偏移量，两者之和作为地址，根据这个地址找到目的数据</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104234641.png" /></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104245730.png" /></p>
<h4 id="基址寻址">基址寻址</h4>
<p><font color = "yellow">基址寻址中内存中是偏移量，寄存器中是基址（不变量），两者之和作为地址，根据这个地址找到目的数据</font></p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104319715.png" /></p>
<blockquote>
<p>注：变址与基址的区别</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104359223.png" /></p>
</blockquote>
<h4 id="基址变址">基址+变址</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104420578.png" /></p>
<h4 id="相对寻址">相对寻址</h4>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104442446.png" /></p>
<h4 id="页面寻址">页面寻址</h4>
<h4 id="section"><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240605104507065.png" /></h4>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="操作码隐含说明不同寻址方式">操作码隐含说明不同寻址方式</h3>
<p>某机指令操作码最高两位</p>
<p>00：RR型指令，寄存器-寄存器寻址 01：RX型指令，寄存器-变址寻址
10：SI型指令，基址-立即寻址 11：SS型指令，基址-基址寻址</p>
<h3
id="指令中设置专门字段说明寻址方式">指令中设置专门字段说明寻址方式</h3>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240606093026459.png" /></p>
]]></content>
      <categories>
        <category>计组</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第一章_汇编语言基础练习题</title>
    <url>/posts/2327a50.html</url>
    <content><![CDATA[<h1 id="的组成">8086的组成</h1>
<span id="more"></span>
<h2 id="题1">题1：</h2>
<p>关于 8086/8088 微机系列,下列说法哪个是正确的( D )</p>
<p>A. 一个存储单元由 16 个二进制位组成,简称字。</p>
<p>B. 当存储一个字数据时,低字节放高地址位,高字节放低地址位。</p>
<p>C. 在内存中,可以无限分配段,且段的大小不受限制</p>
<p>D. 段与段之间可以邻接,也可以重叠。</p>
<p>解析：</p>
<p>A.
<strong>错误</strong>：8086/8088微处理器的<strong>存储单元是8位的，即一个字节，而不是16位</strong>。16位通常指的是数据总线宽度，即一次可以处理16位数据。</p>
<p>B. <strong>错误</strong>：低地址放低字节，高地址放高字节</p>
<p>C.
<strong>错误</strong>：在8086/8088微处理器的内存管理中，段的大小是有限制的。<strong>段的大小不能超过64KB，这是由于段寄存器（如CS、DS、ES、SS）是16位的，因此段内偏移量的最大值为0xFFFF</strong>，即64KB
- 1。</p>
<p>D.
<strong>正确</strong>：在8086/8088微处理器的内存模型中，<strong>段与段之间可以邻接，也可以重叠</strong>。这是因为段的基地址和偏移量是独立的，段的基地址由段寄存器确定，而偏移量则是由指令或数据操作指定的。因此，不同的段可以设置不同的基地址，并且段内的偏移量可以是任意的，从而允许段与段之间的邻接或重叠。</p>
<p>所以，正确答案是D。</p>
<h1 id="的寻址方式">8086的寻址方式</h1>
<h2 id="题1-1">题1</h2>
<p>下列指令中段默认为堆栈段的是( C )</p>
<p>A. MOV AX, [BX+SI+10] B. ADD AX,ES:[SI]</p>
<p>C. SUB BX, [BP][DI] D. MOV DX,[1000H]</p>
<p>A.
<code>MOV AX, [BX+SI+10]</code>：这是一个使用基址加变址加偏移的寻址方式，但没有指定段寄存器，因此它使用的是默认的数据段寄存器（DS）。</p>
<p>B.
<code>ADD AX, ES:[SI]</code>：这条指令明确指定了段寄存器ES，因此它使用的是额外段寄存器ES。</p>
<p>C.
<code>SUB BX, [BP][DI]</code>：这条指令使用了BP和DI寄存器，并且没有明确指定段寄存器。在8086/8088中，当使用BP寄存器作为基址寄存器时，如果没有指定段寄存器，那么默认使用的是堆栈段寄存器（SS）。</p>
<p>D.
<code>MOV DX, [1000H]</code>：这条指令使用的是立即数寻址方式，直接访问物理地址1000H，没有使用段寄存器。</p>
<h2 id="题2">题2</h2>
<p>MOV AX, ES:[1000H] 源操作数的寻址方式是（ A ）</p>
<p>A.立即寻址 B.寄存器寻址 C. 直接寻址 D.基址寻址</p>
<h2 id="题3bx和bp二选一">题3：BX和BP二选一</h2>
<p>MOV AX
,[BP+100H][SI]这种虽然同时出现BP(默认SS)和SI(默认DS)，但是以SS作为段地址</p>
<p>基址寄存器2个：BP和BX二选一</p>
<p>变址寄存器2个：SI和DI二选一</p>
<h2 id="题4">题4</h2>
<p>设 （DS）=2000H， （BX）=0200H， （SI）=0002H， （20200H）=12H，
（20201H）=FFH，（20202H）= 56H，（20203H）= 78H， （21200H）= 2AH，
（21201H）= 00H，（21202H）=B7H，（21203H）=65H，试说明下列各条指
令执行完后AX 寄存器中的内容是多少？ （1）MOV AX，0400H
（AX）=___________ （2）MOV AX，BX （AX）=___________ （3）MOV AX，[BX]
（AX）=___________ （4）MOV AX，[BX+1000H] （AX）=___________ （5）MOV
AX，[BX+SI] （AX）=___________</p>
<p>解析：</p>
<ol type="1">
<li><font color = "yellow">注意段地址</font></li>
<li><font color = "yellow">注意是传1个字节还是1个字</font></li>
</ol>
<ol type="1">
<li><p>0400H</p></li>
<li><p>0200H</p></li>
</ol>
<p>(3)、(4)、(5)有坑</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/a103b15867a55726948183c77d0a97b.jpg" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li><p>FF12H</p></li>
<li><p>002AH</p></li>
<li><p>7856H</p></li>
</ol>
<p>概念判断</p>
<ol type="1">
<li>汇编语言是用符号表示的面向机器的语言，因此它是机器语言。 （ ）</li>
</ol>
<p>错误</p>
<p>汇编语言是一种低级别的编程语言，它使用助记符（例如，<code>MOV</code>、<code>ADD</code>）来表示机器指令，这些指令直接对应于计算机的操作码。机器语言是计算机硬件直接能够理解和执行的二进制指令。</p>
<ol start="2" type="1">
<li>汇编语言是一种高级语言,其程序源代码必须编译成目标代码,程序才能执行。</li>
</ol>
<p>错误</p>
<p>这个说法是<strong>错误的</strong>。汇编语言实际上是一种<strong>低级别的编程语言</strong>，而不是高级语言。让我来解释一下：</p>
<ol type="1">
<li><strong>汇编语言</strong>：
<ul>
<li>汇编语言是一种<strong>符号化的</strong>机器语言。它使用助记符（例如，<code>MOV</code>、<code>ADD</code>）来表示机器指令，这些指令直接对应于计算机的操作码。</li>
<li>程序员编写的汇编程序源代码需要经过<strong>汇编器</strong>的处理，将其转换为机器码（目标代码）。这个过程称为<strong>汇编</strong>。</li>
<li>汇编语言程序不需要像高级语言那样进行完整的编译过程，因为它们已经接近于底层的机器指令。</li>
</ul></li>
<li><strong>高级语言</strong>：
<ul>
<li>高级语言（例如C、Java、Python）是相对于汇编语言的概念。它们更接近人类自然语言，具有更高的抽象级别。</li>
<li>高级语言的程序源代码需要经过<strong>编译器</strong>的处理，将其转换为机器码。这个过程称为<strong>编译</strong>。</li>
<li>高级语言程序的执行不需要直接生成机器码，而是通过解释器或虚拟机来执行。</li>
</ul></li>
</ol>
<p>因此，汇编语言不是高级语言，它不需要完整的编译过程，而是通过汇编器将源代码转换为机器码。高级语言的编译过程更复杂，需要将源代码转换为目标代码，然后再执行。</p>
<ol start="3" type="1">
<li>汇编语言是最快最有效的计算机语言,在自动控制、通信与接口中是必不可少的。
（ ）</li>
</ol>
<p>正确</p>
<ol start="4" type="1">
<li>汇编语言与机器低层关系不大,所以它具有很好的移植性。 ( )</li>
</ol>
<p>错误</p>
<p>虽然汇编语言相对于高级语言来说较低级，但它与机器的关系非常密切，因此移植性并不总是很好</p>
<ol start="5" type="1">
<li>将汇编语言源代码转换成机器目标代码的过程称为编译。 ( )</li>
</ol>
<p>错误</p>
<p><font color = "red">将汇编语言源代码转换成机器目标代码的过程称为<strong>汇编</strong>，而不是编译。</font>让我来解释一下：</p>
<ul>
<li><strong>编译</strong>：
<ul>
<li>编译是将高级语言（例如C、Java）源代码转换为机器目标代码的过程。</li>
<li>编译器将高级语言源代码分析、优化，并生成与目标平台（计算机体系结构和操作系统）兼容的目标代码。</li>
<li>目标代码可以直接在目标平台上执行，而不需要进一步的转换。</li>
</ul></li>
<li><strong>汇编</strong>：
<ul>
<li>汇编是将汇编语言源代码转换为机器目标代码的过程。</li>
<li>汇编器将汇编语言源代码翻译成机器码（操作码），这些指令直接对应于计算机硬件的操作。</li>
<li>汇编语言程序员编写的源代码需要经过汇编器处理，生成可执行的目标代码。</li>
</ul></li>
</ul>
<p>因此，编译是高级语言到目标代码的过程，而汇编是汇编语言到目标代码的过程。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第二章_8086指令系统练习题</title>
    <url>/posts/8f276d43.html</url>
    <content><![CDATA[<h1 id="指令影响标志位">指令影响标志位</h1>
<span id="more"></span>
<h2 id="题1">题1</h2>
<p>7、下列指令中,不影响PSW的指令是( A )。</p>
<p>A. MOV B. TEST C. SAL D. CLD</p>
<p>解析：</p>
<p>A.
<code>MOV</code>：数据传输指令，用于将数据从一个位置移动到另一个位置。<code>MOV</code>指令不影响标志寄存器中的任何标志位。</p>
<p>B.
<code>TEST</code>：逻辑测试指令，用于对两个操作数进行AND操作，但不存储结果。<code>TEST</code>会根据结果影响标志寄存器中的零标志(ZF)、符号标志(SF)、奇偶标志(PF)和辅助进位标志(AF)。</p>
<p>C.
<code>SAL</code>：算术左移指令，将操作数的位向左移动指定的位数。<code>SAL</code>指令会影响进位标志(CF)和符号标志(SF)，如果左移后的最高位发生了变化。</p>
<p>D.
<code>CLD</code>：清除方向标志指令，用于清除标志寄存器中的DF位（方向标志）。<code>CLD</code>指令直接影响了标志寄存器，因此会影响PSW。</p>
<h1 id="指令作用的考察">指令作用的考察</h1>
<h2 id="非压缩bcd码除法的调整">非压缩BCD码除法的调整</h2>
<p>除法调整指令AAD调整的是（ A ）</p>
<p>A. AX中的被除数 B. AL中的商数</p>
<p>C. AX中的除数 D. AL中的余数</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第五章_1_输入输出和中断程序设计练习题</title>
    <url>/posts/b09ccb65.html</url>
    <content><![CDATA[<h1 id="端口寻址">端口寻址</h1>
<span id="more"></span>
<h2 id="题1">题1</h2>
<p>端口寻址的输入/输出方式（ D ）</p>
<p>A．不使用专门的输入/输出指令 B．不占用内存单元</p>
<p>C．执行速度比存储器寻址方式慢 D．与内存单元统一编址</p>
<p>A.
<strong>不使用专门的输入/输出指令</strong>：这个选项是错误的。在大多数体系结构中，访问I/O端口通常需要使用专门的输入/输出指令，如<code>IN</code>和<code>OUT</code>指令。</p>
<p>B.
<strong>不占用内存单元</strong>：这个选项也是错误的。虽然端口寻址用于访问I/O设备，但它们通常是通过内存映射的方式来实现的，这意味着它们在内存地址空间中占有特定的地址。</p>
<p>C.
<strong>执行速度比存储器寻址方式慢</strong>：这个选项是错误的。<strong>端口寻址的执行速度通常与存储器寻址方式相当，甚至可能更快，因为它直接映射到硬件，避免了某些内存访问的开销</strong>。</p>
<p>D.
<strong>与内存单元统一编址</strong>：这个选项是正确的。在端口寻址中，I/O端口通常被映射到内存地址空间中，与内存单元共享相同的地址总线。这意味着，从CPU的角度来看，访问内存和访问I/O端口在寻址上是一致的。</p>
<h1 id="中断">中断</h1>
<h2 id="dma">DMA</h2>
<ol start="8" type="1">
<li><p>直接存储器存取方式由DMA控制器窃取CPU周期完成I/O设备与CPU之间的数据传送。</p>
<p>解析：错误。DMA请求的是总线的使用权，中断请求的是CPU的服务</p></li>
</ol>
<h2 id="中断类型">中断类型</h2>
<p>溢出中断是硬件中断中的不可屏蔽中断。</p>
<p>错误</p>
<p>解析：不可屏蔽中断（Non-Maskable Interrupt,
NMI）是一种特殊的硬件中断，它不能通过常规的中断屏蔽寄存器来禁用。NMI通常用于处理系统级的紧急情况，比如电源故障、系统时钟故障等，这些情况需要立即处理，不能被忽略或延迟。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章-串操作</title>
    <url>/posts/e5870eb0.html</url>
    <content><![CDATA[<h1 id="串操作特点">串操作特点</h1>
<span id="more"></span>
<ol type="1">
<li>串操作指令使用专用的寻址方式：源操作数地址由DS:[SI]提供，目的操作数由ES:[DI]提供。<br />
</li>
<li>串操作指令每次只对串中的一个字或一个字节单元进行操作，并自动修改SI和(或)DI，使其指向下一个字或字节单元。</li>
<li>当标志位DF=0时，SI和DI的修改为递增，即加2（字操作）或加1（字节操作）。当DF=1时，SI和DI的修改为递减，即减2或减1。</li>
</ol>
<h1 id="取串指令lods">取串指令LODS</h1>
<h2 id="指令格式">指令格式</h2>
<p>LODS 源串名字</p>
<h2 id="功能">功能</h2>
<p>将源串中的一个字或字节内容送入AX或AL中，并根据DF修改SI</p>
<p>由于源串是由SI指定，如果程序中在执行该指令时已经明确是字或字节，则可以用无操作数指令LODSB（字节操作）或LODSW（字操作）替代</p>
<h1 id="存串指令stos">存串指令STOS</h1>
<h2 id="指令格式-1">指令格式</h2>
<p>STOS 目的串</p>
<h2 id="功能-1">功能</h2>
<p>将AX或AL中的内容送入目的串中的一个字单元或字节单元，并根据DF修改DI。</p>
<p>同样，指令可以用无操作数指令STOSB或STOSW替代。该指令对标志无影响。</p>
<h1 id="串传送指令movs">串传送指令MOVS</h1>
<h2 id="指令格式-2">指令格式</h2>
<p>MOVS 目的串 源串</p>
<h2 id="功能-2">功能</h2>
<p>将由SI指向的源串的一个字或字节传送到DI所指向的目的串中。并根据DF修改SI和DI</p>
<p>同样，指令可以用无操作数指令MOVSB或MOVSW替代。指令对标志无影响</p>
<h1 id="串比较指令cmps">串比较指令CMPS</h1>
<h2 id="指令格式-3">指令格式</h2>
<p>CMPS 源串，目的串</p>
<h2 id="功能-3">功能</h2>
<p>将源串中的一个字节或字减去目的串中的一个字或字节，结果不回送。但将影响标志寄存器。同时，将根据DF修改SI和DI。</p>
<p>同样，指令可以用无操作数指令CMPSB或CMPSW替代</p>
<h1 id="串搜索指令scas">串搜索指令SCAS</h1>
<h2 id="指令格式-4">指令格式</h2>
<p>SCAS 目的串</p>
<h2 id="功能-4">功能</h2>
<p>在目的串中查找AX或AL指定的内容。</p>
<p>查找的方法：用AX或AL的内容减去目的串中的一个字或字节，相减的结果反映在标志寄存器中。每查找一次，将按照DF修改DI。</p>
<p>同样，指令可以用无操作数指令SCASB或SCASW替代。</p>
<h1 id="重复前缀rep">重复前缀REP</h1>
<h2 id="指令格式-5">指令格式</h2>
<p>REP</p>
<h2 id="功能-5">功能</h2>
<p>在前面各种串指令之前加</p>
<p>重复内容由CX控制</p>
<hr style = "border:2px solid yellow">
<p>举例：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240602201658342.png" /></p>
<hr style = "border:2px solid yellow">
<p>REPE/REPZ 重复执行串操作指令的条件是：（CX）≠0和ZF=1</p>
<p>REPNE/REPNZ 重复执行串操作指令的条件是： （CX）≠0和ZF=0</p>
<h1 id="字符串中查找指定字符">字符串中查找指定字符</h1>
<p>关键代码：REPNE SCASB
如果当前位置与AX相减使得ZF=1，说明两者相等，说明找到了，就要跳出REPNE</p>
<p>同时需要提前CLD将DF置为0，这样表示从前往后搜</p>
<h1 id="kmp算法">KMP算法</h1>
<h1 id="冒泡排序">冒泡排序</h1>
<h1 id="二分查找">二分查找</h1>
<p>为了便于移位，先将表长修改为<span
class="math inline">\(2^n\)</span></p>
<p>使用BX记录当前对分点，DX记录每次对分后表的长度，向上查就是将BX减去DX中记录的对分后表长，向下查就是加上DX中记录的对分后表长</p>
<p>因为CMP会修改标志，所以需要再CMP前用PUSHF暂存标志，之后用POPF恢复标志</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章_子程序设计</title>
    <url>/posts/dbfbb964.html</url>
    <content><![CDATA[<h1 id="调用与返回">调用与返回</h1>
<span id="more"></span>
<h2 id="调用">调用</h2>
<h3 id="段内调用">段内调用</h3>
<p>直接CALL子程序名/AX,BX等16位寄存器/一个字大小的单元</p>
<h3 id="段间调用">段间调用</h3>
<p>直接CALL子程序名/一个双字大小的单元</p>
<h2 id="返回">返回</h2>
<h3 id="段内返回">段内返回</h3>
<p>弹出送IP</p>
<h3 id="段间返回">段间返回</h3>
<p>弹出送CS和IP</p>
<h3 id="带弹出值的返回">带弹出值的返回</h3>
<p>汇编指令格式为：RET n<br />
其中n为一个立即数，长度为2字节。并且是一个偶数。</p>
<p>（1）从堆栈弹出1个字送IP（段内返回）或2个字送IP和CS； （2）执行
SP&lt;=(SP)+n 。将堆栈中已经用过的参数(n个字节)弹出舍去.</p>
<h2 id="参数的传递">参数的传递</h2>
<h3 id="堆栈的使用">堆栈的使用</h3>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/image-20240603021333291.png" style="zoom:50%;" /></p>
<ol type="1">
<li>在CALL的时候，就已经将返回的IP压入堆栈了，这个容易被忽视</li>
<li>堆栈中处理都是2个字节2个字节处理</li>
<li>要想跳跃访问堆栈只能用BP</li>
</ol>
<h3 id="地址表的使用">地址表的使用</h3>
<h1 id="代码转换">代码转换</h1>
<h2
id="ascii码与int类型数之间的相互转换">ASCII码与int类型数之间的相互转换</h2>
<h3 id="ascii的char转int">ASCII的char转int</h3>
<h3 id="int转ascii的char">int转ASCII的char</h3>
<ol type="1">
<li>16位无符号二进制数表示的十进制数范围为0—65535，需要分别求出万位、千位、百位、十位和个位的值。</li>
<li>从16位二进制数中能够减10000的次数就是万位的值，剩下的数再用1000去减，这样依次进行下去，直至个位。</li>
</ol>
<h2 id="二进制转十进制">二进制转十进制</h2>
<p>用10去除二进制数，所得余数为十进制数的个位。其商再除以10，所得余数为十位，如此反复，直到商为0。</p>
<h2 id="十六进制数与bcd码的转换">十六进制数与BCD码的转换</h2>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章_算术运算</title>
    <url>/posts/60c662a5.html</url>
    <content><![CDATA[<h1 id="十进制加减运算">十进制加减运算</h1>
<span id="more"></span>
<h2 id="bcd吗矫正">BCD吗矫正</h2>
<h3 id="非压缩型加法aaa">非压缩型加法AAA</h3>
<p>在AAA指令执行前，必须是使用ADD或ADC指令完成了加法，且结果是在AL中。AAA指令对AL中内容进行校正。</p>
<p>校正过程为：</p>
<p>当AL中的低4位&gt;9或者AF=1, 则AL&lt;=（AL）+6，
AH&lt;=（AH）+1，AL中高4位清0，AF和CF置1。</p>
<h3 id="压缩加法daa">压缩加法DAA</h3>
<p>在执行DAA指令前，必须是用ADD或ADC完成了加法操作，且加的结果放在AL中。</p>
<p>其校正过程为：</p>
<p>若AL中低4位&gt;9或AF=1，则 AL&lt;=(AL)+6, AF&lt;=1</p>
<p>若AL中高4位&gt;9或CF=1，则AL&lt;=(AL)+60H, CF&lt;=1</p>
<h3 id="非压缩减法aas">非压缩减法AAS</h3>
<p>执行AAS指令前，必须是用SUB或SBB完成了减法操作，且结果放在AL中。</p>
<p>若AL中低4位&gt;9或AF=1，则AL&lt;= (AL)-6 , AH&lt;=
(AH)-1,同时将AL中高4位清零，CF和AF置1。</p>
<h3 id="压缩减法das">压缩减法DAS</h3>
<p>执行DAS指令前，必须是用SUB或SBB完成了减法操作，且结果放在AL中。其校正过程为：</p>
<p>若AL中低4位&gt;9或AF=1，则AL &lt;=(AL)-6，AF置1；</p>
<p>若AL中高4位&gt;9或CF=1，则AL&lt;=(AL)-60H,CF置1。</p>
<h2 id="举例非压缩bcd码减法">举例：非压缩BCD码减法</h2>
<p>设计思想：</p>
<p>两个十进制一位数相减(SBB)并矫正(AAS)，然后利用LAHF暂存向高位借位（将CF保存到AH里），之后用SAHF恢复</p>
<h1 id="多精度数运算">多精度数运算</h1>
<h2 id="多精度变补">多精度变补</h2>
<p>循环将每一位的取反，最后加1</p>
<h2 id="位乘法">32位乘法</h2>
<p>比如如果一个乘数是第0位，另一个乘数是第1位，那么它们想乘的结果就应该放在第0(0
+ 1 = 1)位</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第三章_汇编语言程序格式练习题</title>
    <url>/posts/10df1a2e.html</url>
    <content><![CDATA[<h1 id="求数据段中数组长度">求数据段中数组长度</h1>
<span id="more"></span>
<p>20、设有下列指令序列:</p>
<p>DY1 DW 12H,34H,56H,78H,9AH</p>
<p>DY2 DW $-DY1</p>
<p>…</p>
<p>MOV CX,DY2</p>
<p>试问上述指令序列执行后，CX 的内容是( C )</p>
<p>A. 10H B. 04H C. 0AH D. 08H</p>
<p>解析：</p>
<p>因为数据段中定义的是DW，一个字等于两个字节，一共有5个字，$-DY1得到的偏移地址是10，即DY2的值是10</p>
<h1 id="获取数组首地址和首单元的区别">获取数组首地址和首单元的区别</h1>
<p>下面程序执行后，AL 的内容为ARRAY 数组中的最小数，请在空白处各填上
一条指令。 ARRAY DB 3，5，-3，-2，4，5，-8，6 ┇ MOV CX，7 MOV DI，0 MOV
AL，ARRAY A1： _____________ CMP AL, ARRAY[DI] JLE A2 MOV AL，ARRAY [DI]
A2： _____________</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AL, ARRAY</span><br></pre></td></tr></table></figure>
<p>上面在AL里面保存的是ARRAY中的第一个单元中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, OFFSET ARRAY</span><br></pre></td></tr></table></figure>
<p>上面里面保存的是ARRAY的第一个单元的偏移地址</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
  <entry>
    <title>第四章_子程序设计练习题</title>
    <url>/posts/e228f7fe.html</url>
    <content><![CDATA[<h1 id="堆栈操作中堆栈的变化">堆栈操作中堆栈的变化</h1>
<span id="more"></span>
<h2 id="题1">题1</h2>
<p>设（SP）=80H,（BX）=0FFH;（AX）=1    </p>
<p>PUSH BX    </p>
<p>ADD BX,AX    </p>
<p>XOR BX,AX    </p>
<p>PUSH BX    </p>
<p>POP CX </p>
<p>上述程序段运行后，（SP）＝( )，（CX）=( )。</p>
<p>解析：</p>
<p><font color = "red">低地址放低字节，高地址放高字节</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/bffe9204cebfd2fed6ec84e4f7749c1.jpg" style="zoom:50%;" /></p>
<h2 id="题2子程序中堆栈寻址">题2：子程序中堆栈寻址</h2>
<p>下面的程序通过子程序调用，将数组ARRAY 的COUNT 个元素求和，并
将结果送SUM 单元。请补充完整程序。（3 分） DATA SEGMENT SUM DW ? ARRAY
DW 10,20,30,40,50,60,70,80,90,100 COUNT EQU ($-ARRAY)/2 DATA ENDS STACK
SEGMENT PARA STACK 'Stack' DW 64 DUP (0) STACK ENDS CODE SEGMENT ASSUME
CS: CODE; DS: DATA; SS: STACK START: MOV AX, DATA MOV DS, AX MOV BX,
OFFSET SUM PUSH BX MOV BX, OFFSET ARRAY PUSH BX MOV BX, OFFSET COUNT
PUSH BX CALL SUMPRO ………</p>
<p>SUMPRO PROC FAR PUSH AX PUSH BX PUSH SI PUSH DI PUSH BP MOV BP, SP
MOV SI, [BP+ _____ ] ;得到ARRAY 的地址 MOV DI, [BP+ _____ ] ;得到COUNT
的地址 MOV CX, DI MOV DI, [BP+ _____ ] ;得到SUM 的地址 XOR AX, AX
NEXT:ADD AX, [SI] INC SI INC SI LOOP NEXT MOV [DI], AX ;送求和结果 POP
BP POP DI POP SI POP BX POP AX RET SUMPRO ENDP CODE ENDS END START</p>
<p>解析：</p>
<p><img src="https://cdn.jsdelivr.net/gh/pilotztb/myBlog_img@main/4f609d0d5cb9b011f8719c5d0441b18.jpg" style="zoom:50%;" /></p>
<p>在子程序中使用堆栈传参的时候往往首先需要通过压栈保护一些寄存器中的值，然后通过将BP与SP指向同一位置，通过BP加上偏移地址获得之前压入栈的参数</p>
]]></content>
      <categories>
        <category>汇编语言</category>
        <category>理论</category>
      </categories>
  </entry>
</search>
